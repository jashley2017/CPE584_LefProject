(layerDefinitions
 (techPurposes
 ;( purposeName  purposeNumber  Abbr.)
  ( seal 1)
  ( core 2)
  ( frame 3)
  ( waffleDrop 4)
  ( standardc 5)
  ( tmpdgn 6)
  ( tmpdgp 7)
  ( tmpmaxdgn 8)
  ( tmpmaxdgp 9)
  ( moduleCut 10)
  ( dieCut 11)
  ( frameRect 12)
  ( tmpbase 13)
  ( tmpcol 14)
  ( cut 15)
  ( res 16)
  ( esd 17)
  ( tmppnp 18)
  ( short 19)
  ( mask 20)
  ( maskAdd 21)
  ( maskDrop 22)
  ( diode 23)
  ( fuse 24)
  ( gate 25)
  ( hvnwell 26)
  ( hv 28)
  ( probe 29)
  ( extFab 30)
  ( option1 31)
  ( option2 32)
  ( option3 33)
  ( option4 34)
  ( option5 35)
  ( option6 36)
  ( option7 37)
  ( option8 38)
  ( precres 39)
  ( silicon 40)
  ( vlc 41)
  ( met3 42)
  ( met2 43)
  ( met1 44)
  ( li1 45)
  ( poly 46)
  ( injection 47)
  ( blockage 48)
  ( nodnw 49)
  ( deadZon 50)
  ( critCorner 51)
  ( critSid 52)
  ( substrateCut 53)
  ( opcDrop 54)
  ( artisan 55)
  ( techCd 56)
  ( term1 57)
  ( term2 58)
  ( term3 59)
  ( scr 60)
  ( port 61)
  ( port1 62)
  ( region 63)
  ( grid 64)
  ( ppath 65)
  ( ppath1 66)
  ( macro 67)
  ( nwellIsolation 68)
  ( waffleWindow 69)
  ( block 70)
  ( waffleAdd1 71)
  ( waffleAdd2 72)
  ( dualMemory 73)
  ( tcamMemory 74)
  ( extendedDrain 75)
  ( subcktDevice 76)
  ( pixel 77)
  ( capacitor 78)
  ( antif 79)
  ( lvdnw 80)
  ( photo 81)
  ( rotation 82)
  ( model 83)
  ( ipExempt 84)
  ( pitch 85)
  ( HighVt 86)
  ( lvNative 87)
  ( psa1 88)
  ( psa2 89)
  ( psa3 90)
  ( psa4 91)
  ( psa5 92)
  ( psa6 93)
  ( hole 94)
  ( select 95)
  ( dummy 96)
  ( mslits 97)
  ( opc 98)
  ( nodummy 99)
  ( drc 100)
  ( etest 101)
  ( vss 102)
  ( fc 103)
  ( fix 104)
  ( mim 105)
  ( nmim 106)
  ( pad 107)
  ( per 108)
  ( cvs 109)
  ( ext 110)
  ( ip 111)
  ( low_vt 112)
  ( cis_array 113)
  ( imagers 114)
  ( t3 115)
  ( logic 116)
  ( dio 117)
  ( cap 118)
  ( res1 119)
  ( bjt 120)
  ( efuseMark 121)
  ( slotBlock 122)
  ( fuseMark 123)
  ( umcIP 124)
  ( rfdiode 125)
  ( lowTapDensity 126)
  ( notCritSide 127)
 ) ; techPurposes

 (techLayers
 ;( layerName  layerNumber  Abbr.)
  ( prBoundary  235)
  ( hvnvtm  81)
  ( chvnvtm  86)
  ( pwell  1)
  ( pwelliso  122)
  ( nwell  0)
  ( dnwell  23)
  ( vhvi  88)
  ( diff  2)
  ( tap  3)
  ( psdm  31)
  ( nsdm  30)
  ( poly  4)
  ( ldntm  53)
  ( lvtn  25)
  ( hvtp  92)
  ( tunm  41)
  ( licon1  43)
  ( npc  115)
  ( li1  22)
  ( mcon  5)
  ( met1  6)
  ( via  7)
  ( met2  8)
  ( via2  9)
  ( met3  10)
  ( via3  12)
  ( met4  13)
  ( via4  14)
  ( met5  15)
  ( nsm  47)
  ( pad  11)
  ( pnp  101)
  ( npn  111)
  ( hvi  42)
  ( capacitor  103)
  ( ncm  96)
  ( cncm  90)
  ( pmm  76)
  ( cfom  52)
  ( fom  77)
  ( cnwm  109)
  ( cdnm  79)
  ( clvtnm  120)
  ( chvtpm  85)
  ( ctunm  91)
  ( conom  93)
  ( cnsdm  56)
  ( cpsdm  57)
  ( cntm  58)
  ( hvntm  36)
  ( chvntm  102)
  ( cldntm  126)
  ( clvom  89)
  ( cp1m  55)
  ( cli1m  83)
  ( clicm1  95)
  ( cmm1  60)
  ( cviam  61)
  ( cmm2  62)
  ( cviam2  63)
  ( cmm3  64)
  ( cnpc  116)
  ( cviam3  67)
  ( cnsm  37)
  ( cpdm  66)
  ( cpmm  97)
  ( cmm4  68)
  ( cviam4  69)
  ( cmm5  70)
  ( target  107)
  ( cctm1  59)
  ( overlap  99)
  ( areaid  110)
  ( prune  21)
  ( padCenter  45)
  ( blanking  123)
 ) ; techLayers

 (techLayerPurposePriorities
 ;( layerName Purpose)
  ( prBoundary boundary)
  ( hvnvtm drawing)
  ( chvnvtm mask)
  ( pwell pin)
  ( pwell label)
  ( pwell res)
  ( pwell cut)
  ( pwelliso pin)
  ( pwelliso label)
  ( nwell drawing)
  ( nwell net)
  ( nwell pin)
  ( nwell label)
  ( dnwell drawing)
  ( vhvi drawing)
  ( diff drawing)
  ( diff res)
  ( diff cut)
  ( diff pin)
  ( diff label)
  ( diff net)
  ( diff boundary)
  ( diff hv)
  ( tap drawing)
  ( tap pin)
  ( tap net)
  ( tap boundary)
  ( tap label)
  ( psdm drawing)
  ( nsdm drawing)
  ( poly drawing)
  ( poly pin)
  ( poly res)
  ( poly cut)
  ( poly gate)
  ( poly label)
  ( poly boundary)
  ( poly probe)
  ( poly short)
  ( poly net)
  ( poly model)
  ( ldntm drawing)
  ( lvtn drawing)
  ( hvtp drawing)
  ( tunm drawing)
  ( licon1 drawing)
  ( licon1 boundary)
  ( licon1 pin)
  ( licon1 net)
  ( npc drawing)
  ( li1 drawing)
  ( li1 pin)
  ( li1 res)
  ( li1 cut)
  ( li1 label)
  ( li1 net)
  ( li1 boundary)
  ( li1 blockage)
  ( li1 short)
  ( li1 probe)
  ( mcon drawing)
  ( mcon boundary)
  ( mcon pin)
  ( mcon net)
  ( met1 drawing)
  ( met1 res)
  ( met1 cut)
  ( met1 pin)
  ( met1 label)
  ( met1 net)
  ( met1 boundary)
  ( met1 blockage)
  ( met1 short)
  ( met1 probe)
  ( met1 option1)
  ( met1 option2)
  ( met1 option3)
  ( met1 option4)
  ( met1 option5)
  ( met1 option6)
  ( met1 option7)
  ( met1 option8)
  ( via drawing)
  ( via boundary)
  ( via net)
  ( via pin)
  ( met2 drawing)
  ( met2 res)
  ( met2 cut)
  ( met2 pin)
  ( met2 label)
  ( met2 net)
  ( met2 boundary)
  ( met2 blockage)
  ( met2 short)
  ( met2 probe)
  ( met2 option1)
  ( met2 option2)
  ( met2 option3)
  ( met2 option4)
  ( met2 option5)
  ( met2 option6)
  ( met2 option7)
  ( met2 option8)
  ( via2 drawing)
  ( via2 boundary)
  ( via2 pin)
  ( via2 net)
  ( met3 drawing)
  ( met3 res)
  ( met3 cut)
  ( met3 pin)
  ( met3 label)
  ( met3 net)
  ( met3 boundary)
  ( met3 blockage)
  ( met3 short)
  ( met3 fuse)
  ( met3 probe)
  ( met3 option1)
  ( met3 option2)
  ( met3 option3)
  ( met3 option4)
  ( met3 option5)
  ( met3 option6)
  ( met3 option7)
  ( met3 option8)
  ( via3 drawing)
  ( via3 boundary)
  ( via3 pin)
  ( via3 net)
  ( met4 drawing)
  ( met4 res)
  ( met4 cut)
  ( met4 pin)
  ( met4 label)
  ( met4 net)
  ( met4 boundary)
  ( met4 blockage)
  ( met4 short)
  ( met4 fuse)
  ( met4 probe)
  ( met4 option1)
  ( met4 option2)
  ( met4 option3)
  ( met4 option4)
  ( met4 option5)
  ( met4 option6)
  ( met4 option7)
  ( met4 option8)
  ( via4 drawing)
  ( via4 boundary)
  ( via4 pin)
  ( via4 net)
  ( met5 drawing)
  ( met5 res)
  ( met5 cut)
  ( met5 pin)
  ( met5 label)
  ( met5 net)
  ( met5 boundary)
  ( met5 blockage)
  ( met5 short)
  ( met5 fuse)
  ( met5 probe)
  ( met5 option1)
  ( met5 option2)
  ( met5 option3)
  ( met5 option4)
  ( met5 option5)
  ( met5 option6)
  ( met5 option7)
  ( met5 option8)
  ( nsm drawing)
  ( pad drawing)
  ( pad label)
  ( pad pin)
  ( pnp drawing)
  ( pnp label)
  ( npn drawing)
  ( npn label)
  ( hvi drawing)
  ( capacitor drawing)
  ( ncm drawing)
  ( cncm drawing)
  ( cncm mask)
  ( pmm drawing)
  ( cfom drawing)
  ( cfom mask)
  ( cfom maskAdd)
  ( cfom maskDrop)
  ( cfom waffleDrop)
  ( fom dummy)
  ( cnwm drawing)
  ( cnwm mask)
  ( cnwm maskAdd)
  ( cnwm maskDrop)
  ( cdnm drawing)
  ( cdnm mask)
  ( cdnm maskAdd)
  ( cdnm maskDrop)
  ( clvtnm drawing)
  ( clvtnm mask)
  ( clvtnm maskAdd)
  ( clvtnm maskDrop)
  ( chvtpm drawing)
  ( chvtpm mask)
  ( chvtpm maskAdd)
  ( chvtpm maskDrop)
  ( ctunm drawing)
  ( ctunm mask)
  ( ctunm maskAdd)
  ( ctunm maskDrop)
  ( conom drawing)
  ( conom mask)
  ( conom maskAdd)
  ( conom maskDrop)
  ( cnsdm drawing)
  ( cnsdm mask)
  ( cnsdm maskAdd)
  ( cnsdm maskDrop)
  ( cpsdm drawing)
  ( cpsdm mask)
  ( cpsdm maskAdd)
  ( cpsdm maskDrop)
  ( cntm drawing)
  ( cntm mask)
  ( cntm maskAdd)
  ( cntm maskDrop)
  ( hvntm drawing)
  ( chvntm drawing)
  ( chvntm mask)
  ( chvntm maskAdd)
  ( chvntm maskDrop)
  ( cldntm drawing)
  ( cldntm mask)
  ( clvom drawing)
  ( clvom mask)
  ( clvom maskAdd)
  ( clvom maskDrop)
  ( cp1m drawing)
  ( cp1m mask)
  ( cp1m maskAdd)
  ( cp1m waffleDrop)
  ( cp1m maskDrop)
  ( cli1m drawing)
  ( cli1m mask)
  ( cli1m maskAdd)
  ( cli1m maskDrop)
  ( clicm1 drawing)
  ( clicm1 mask)
  ( clicm1 maskAdd)
  ( clicm1 maskDrop)
  ( cmm1 drawing)
  ( cmm1 mask)
  ( cmm1 maskAdd)
  ( cmm1 maskDrop)
  ( cmm1 waffleDrop)
  ( cviam drawing)
  ( cviam mask)
  ( cviam maskAdd)
  ( cviam maskDrop)
  ( cmm2 drawing)
  ( cmm2 mask)
  ( cmm2 maskAdd)
  ( cmm2 maskDrop)
  ( cmm2 waffleDrop)
  ( cviam2 drawing)
  ( cviam2 mask)
  ( cviam2 maskAdd)
  ( cviam2 maskDrop)
  ( cmm3 drawing)
  ( cmm3 mask)
  ( cmm3 maskAdd)
  ( cmm3 maskDrop)
  ( cmm3 waffleDrop)
  ( cnpc drawing)
  ( cnpc mask)
  ( cnpc maskAdd)
  ( cnpc maskDrop)
  ( cviam3 drawing)
  ( cviam3 mask)
  ( cviam3 maskAdd)
  ( cviam3 maskDrop)
  ( cnsm mask)
  ( cpdm drawing)
  ( cpdm mask)
  ( cpdm maskAdd)
  ( cpdm maskDrop)
  ( cpmm drawing)
  ( cpmm mask)
  ( cpmm maskDrop)
  ( cmm4 mask)
  ( cmm4 maskAdd)
  ( cmm4 maskDrop)
  ( cmm4 waffleDrop)
  ( cviam4 drawing)
  ( cviam4 mask)
  ( cviam4 maskAdd)
  ( cviam4 maskDrop)
  ( cmm5 mask)
  ( target drawing)
  ( cctm1 drawing)
  ( cctm1 mask)
  ( cctm1 maskAdd)
  ( cctm1 maskDrop)
  ( overlap drawing)
  ( overlap boundary)
  ( areaid lowTapDensity)
  ( areaid notCritSide)
  ( areaid injection)
  ( areaid rfdiode)
  ( areaid seal)
  ( areaid core)
  ( areaid frame)
  ( areaid esd)
  ( areaid dieCut)
  ( areaid moduleCut)
  ( areaid frameRect)
  ( areaid substrateCut)
  ( areaid diode)
  ( areaid standardc)
  ( areaid deadZon)
  ( areaid critCorner)
  ( areaid critSid)
  ( areaid opcDrop)
  ( areaid waffleWindow)
  ( areaid extendedDrain)
  ( areaid lvdnw)
  ( areaid lvNative)
  ( areaid photo)
  ( areaid etest)
  ( areaid hvnwell)
  ( prune drawing)
  ( padCenter drawing)
  ( met1 psa1)
  ( met2 psa1)
  ( met3 psa1)
  ( met4 psa1)
  ( met5 psa1)
  ( met1 psa2)
  ( met2 psa2)
  ( met3 psa2)
  ( met4 psa2)
  ( met5 psa2)
  ( met1 psa3)
  ( met2 psa3)
  ( met3 psa3)
  ( met4 psa3)
  ( met5 psa3)
  ( met1 psa4)
  ( met2 psa4)
  ( met3 psa4)
  ( met4 psa4)
  ( met5 psa4)
  ( met1 psa5)
  ( met2 psa5)
  ( met3 psa5)
  ( met4 psa5)
  ( met5 psa5)
  ( met1 psa6)
  ( met2 psa6)
  ( met3 psa6)
  ( met4 psa6)
  ( met5 psa6)
  ( blanking drawing)
 ) ; techLayerPurposePriorities

 (techDisplays
 ;( layer  Purpose  Packet  Vis  Sel  chgLay  drag valid)
  ( prBoundary boundary prbdg t t t t t)
  ( hvnvtm drawing mvi t t t t t)
  ( chvnvtm mask cnwbtmmask t t t t t)
  ( pwell pin rpolyPin t t t t t)
  ( pwell label rpolyLabel t t t t t)
  ( pwell res rpolyRes t t t t t)
  ( pwell cut rpolyCut t t t t t)
  ( pwelliso pin elm  t t t t t)
  ( pwelliso label rpolyLabel t t t t t)
  ( nwell drawing nwell t t t t t)
  ( nwell net hilite1 t t t t t)
  ( nwell pin nwellPin t t t t t)
  ( nwell label nwellLabel t t t t t)
  ( dnwell drawing dnwell t t t t t)
  ( vhvi drawing VhviId t t t t t)
  ( diff drawing diff t t t t t)
  ( diff res diffRes t t t t t)
  ( diff cut diffCut t t t t t)
  ( diff pin diffPin t t t t nil)
  ( diff label diffLabel t t t t nil)
  ( diff net diffNet t t t t nil)
  ( diff boundary diffBnd t t t t nil)
  ( diff hv diffHv t t t t t)
  ( tap drawing tap t t t t t)
  ( tap pin tapPin t t t t nil)
  ( tap net tapNet t t t t nil)
  ( tap boundary tapBnd t t t t nil)
  ( tap label tapLabel t t t t nil)
  ( psdm drawing psdm t t t t t)
  ( nsdm drawing nsdm t t t t t)
  ( poly drawing poly t t t t t)
  ( poly pin polyPin t t t t t)
  ( poly res polyRes t t t t t)
  ( poly cut polyCut t t t t t)
  ( poly gate polyGate t t t t t)
  ( poly label polyLabel t t t t t)
  ( poly boundary polyBnd t t t t t)
  ( poly probe polyProbe t t t t t)
  ( poly short polyShort t t t t t)
  ( poly net polyNet t t t t t)
  ( poly model polyModel t t t t t)
  ( ldntm drawing met8 t t t t t)
  ( lvtn drawing lvtn t t t t t)
  ( hvtp drawing hvtp t t t t t)
  ( tunm drawing tunm t t t t t)
  ( licon1 drawing licon1 t t t t t)
  ( licon1 boundary licon1Bnd t t t t t)
  ( licon1 pin licon1Pin t t t t nil)
  ( licon1 net licon1Net t t t t t)
  ( npc drawing silm t t t t t)
  ( li1 drawing li1 t t t t t)
  ( li1 pin li1Pin t t t t t)
  ( li1 res li1Res t t t t nil)
  ( li1 cut li1Cut t t t t nil)
  ( li1 label li1Label t t t t t)
  ( li1 net li1Net t t t t t)
  ( li1 boundary li1Bnd t t t t t)
  ( li1 blockage li1Blkg t t t t t)
  ( li1 short li1Short t t t t t)
  ( li1 probe li1Probe t t t t t)
  ( mcon drawing mcon t t t t t)
  ( mcon boundary mconBnd t t t t t)
  ( mcon pin mconPin t t t t nil)
  ( mcon net mconNet t t t t t)
  ( met1 drawing met1 t t t t t)
  ( met1 res met1Res t t t t nil)
  ( met1 cut met1Cut t t t t nil)
  ( met1 pin met1Pin t t t t t)
  ( met1 label met1Label t t t t t)
  ( met1 net met1Net t t t t t)
  ( met1 boundary met1Bnd t t t t t)
  ( met1 blockage met1Blkg t t t t t)
  ( met1 short met1Short t t t t t)
  ( met1 probe met1Probe t t t t t)
  ( met1 option1 met1Metop1 t t t t nil)
  ( met1 option2 met1Metop2 t t t t nil)
  ( met1 option3 met1Metop3 t t t t nil)
  ( met1 option4 met1Metop4 t t t t nil)
  ( met1 option5 met1Metop5 t t t t nil)
  ( met1 option6 met1Metop6 t t t t nil)
  ( met1 option7 met1Metop7 t t t t nil)
  ( met1 option8 met1Metop8 t t t t nil)
  ( via drawing via t t t t t)
  ( via boundary viaBnd t t t t t)
  ( via net viaNet t t t t t)
  ( via pin viaPin t t t t nil)
  ( met2 drawing met2 t t t t t)
  ( met2 res met2Res t t t t nil)
  ( met2 cut met2Cut t t t t nil)
  ( met2 pin met2Pin t t t t t)
  ( met2 label met2Label t t t t t)
  ( met2 net met2Net t t t t t)
  ( met2 boundary met2Bnd t t t t t)
  ( met2 blockage met2Blkg t t t t t)
  ( met2 short met2Short t t t t t)
  ( met2 probe met2Probe t t t t t)
  ( met2 option1 met2Metop1 t t t t nil)
  ( met2 option2 met2Metop2 t t t t nil)
  ( met2 option3 met2Metop3 t t t t nil)
  ( met2 option4 met2Metop4 t t t t nil)
  ( met2 option5 met2Metop5 t t t t nil)
  ( met2 option6 met2Metop6 t t t t nil)
  ( met2 option7 met2Metop7 t t t t nil)
  ( met2 option8 met2Metop8 t t t t nil)
  ( via2 drawing via2 t t t t t)
  ( via2 boundary via2Bnd t t t t t)
  ( via2 pin via2Pin t t t t nil)
  ( via2 net via2Net t t t t t)
  ( met3 drawing met3 t t t t t)
  ( met3 res met3Res t t t t nil)
  ( met3 cut met3Cut t t t t nil)
  ( met3 pin met3Pin t t t t t)
  ( met3 label met3Label t t t t t)
  ( met3 net met3Net t t t t t)
  ( met3 boundary met3Bnd t t t t t)
  ( met3 blockage met3Blkg t t t t t)
  ( met3 short met3Short t t t t t)
  ( met3 fuse met3Fuse t t t t nil)
  ( met3 probe met3Probe t t t t t)
  ( met3 option1 met3Metop1 t t t t nil)
  ( met3 option2 met3Metop2 t t t t nil)
  ( met3 option3 met3Metop3 t t t t nil)
  ( met3 option4 met3Metop4 t t t t nil)
  ( met3 option5 met3Metop5 t t t t nil)
  ( met3 option6 met3Metop6 t t t t nil)
  ( met3 option7 met3Metop7 t t t t nil)
  ( met3 option8 met3Metop8 t t t t nil)
  ( via3 drawing via3 t t t t t)
  ( via3 boundary via3Bnd t t t t t)
  ( via3 pin via3Pin t t t t nil)
  ( via3 net via3Net t t t t t)
  ( met4 drawing met4 t t t t t)
  ( met4 res met4Res t t t t nil)
  ( met4 cut met4Cut t t t t nil)
  ( met4 pin met4Pin t t t t t)
  ( met4 label met4Label t t t t t)
  ( met4 net met4Net t t t t t)
  ( met4 boundary met4Bnd t t t t t)
  ( met4 blockage met4Blkg t t t t t)
  ( met4 short met4Short t t t t t)
  ( met4 fuse met4Fuse t t t t nil)
  ( met4 probe met4Probe t t t t t)
  ( met4 option1 met4Metop1 t t t t nil)
  ( met4 option2 met4Metop2 t t t t nil)
  ( met4 option3 met4Metop3 t t t t nil)
  ( met4 option4 met4Metop4 t t t t nil)
  ( met4 option5 met4Metop5 t t t t nil)
  ( met4 option6 met4Metop6 t t t t nil)
  ( met4 option7 met4Metop7 t t t t nil)
  ( met4 option8 met4Metop8 t t t t nil)
  ( via4 drawing via4 t t t t t)
  ( via4 boundary via4Bnd t t t t t)
  ( via4 pin via4Pin t t t t nil)
  ( via4 net via4Net t t t t t)
  ( met5 drawing met5 t t t t t)
  ( met5 res met5Res t t t t nil)
  ( met5 cut met5Cut t t t t nil)
  ( met5 pin met5Pin t t t t t)
  ( met5 label met5Label t t t t t)
  ( met5 net met5Net t t t t t)
  ( met5 boundary met5Bnd t t t t t)
  ( met5 blockage met5Blkg t t t t t)
  ( met5 short met5Short t t t t t)
  ( met5 fuse met5Fuse t t t t nil)
  ( met5 probe met5Probe t t t t t)
  ( met5 option1 met5Metop1 t t t t nil)
  ( met5 option2 met5Metop2 t t t t nil)
  ( met5 option3 met5Metop3 t t t t nil)
  ( met5 option4 met5Metop4 t t t t nil)
  ( met5 option5 met5Metop5 t t t t nil)
  ( met5 option6 met5Metop6 t t t t nil)
  ( met5 option7 met5Metop7 t t t t nil)
  ( met5 option8 met5Metop8 t t t t nil)
  ( nsm drawing met8 t t t t t)
  ( pad drawing pad t t t t t)
  ( pad label padLabel t t t t t)
  ( pad pin padPin t t t t t)
  ( pnp drawing pnp t t t t t)
  ( pnp label pnplabel t t t t t)
  ( npn drawing npn t t t t t)
  ( npn label npnlabel t t t t t)
  ( hvi drawing hvi t t t t t)
  ( capacitor drawing capacitor t t t t t)
  ( ncm drawing ncm t t t t t)
  ( cncm drawing cncm t nil t t t)
  ( cncm mask cncmmask t nil t t t)
  ( pmm drawing post2 t t t t t)
  ( cfom drawing cfom t t t t t)
  ( cfom mask cfommask t t t t t)
  ( cfom maskAdd cfommaskAdd t t t t t)
  ( cfom maskDrop cfommaskDrop t t t t t)
  ( cfom waffleDrop cfomwaffleDrop t t t t t)
  ( fom dummy cfom t t t t nil)
  ( cnwm drawing cnwm t t t t nil)
  ( cnwm mask cnwmmask t t t t t)
  ( cnwm maskAdd cnwmmaskAdd t t t t nil)
  ( cnwm maskDrop cnwmmaskDrop t t t t nil)
  ( cdnm drawing cdnm t t t t t)
  ( cdnm mask cdnmmask t t t t t)
  ( cdnm maskAdd cdnmmaskAdd t t t t t)
  ( cdnm maskDrop cdnmmaskDrop t t t t t)
  ( clvtnm drawing clvtnm t t t t nil)
  ( clvtnm mask clvtnmmask t t t t t)
  ( clvtnm maskAdd clvtnmmaskAdd t t t t nil)
  ( clvtnm maskDrop clvtnmmaskDrop t t t t nil)
  ( chvtpm drawing chvtpm t t t t nil)
  ( chvtpm mask chvtpmmask t t t t t)
  ( chvtpm maskAdd chvtpmmaskAdd t t t t nil)
  ( chvtpm maskDrop chvtpmmaskDrop t t t t nil)
  ( ctunm drawing ctunm t t t t t)
  ( ctunm mask ctunmmask t t t t t)
  ( ctunm maskAdd ctunmmaskAdd t t t t t)
  ( ctunm maskDrop ctunmmaskDrop t t t t t)
  ( conom drawing conom t t t t t)
  ( conom mask conommask t t t t t)
  ( conom maskAdd conommaskAdd t t t t t)
  ( conom maskDrop conommaskDrop t t t t t)
  ( cnsdm drawing cnsdm t t t t t)
  ( cnsdm mask cnsdmmask t t t t t)
  ( cnsdm maskAdd cnsdmmaskAdd t t t t t)
  ( cnsdm maskDrop cnsdmmaskDrop t t t t t)
  ( cpsdm drawing cpsdm t t t t t)
  ( cpsdm mask cpsdmmask t t t t t)
  ( cpsdm maskAdd cpsdmmaskAdd t t t t t)
  ( cpsdm maskDrop cpsdmmaskDrop t t t t t)
  ( cntm drawing cntm t t t t t)
  ( cntm mask cntmmask t t t t t)
  ( cntm maskAdd cntmmaskAdd t t t t nil)
  ( cntm maskDrop cntmmaskDrop t t t t nil)
  ( hvntm drawing hvntm t t t t t)
  ( chvntm drawing chvntm t t t t t)
  ( chvntm mask chvntmmask t t t t t)
  ( chvntm maskAdd chvntmmaskAdd t t t t nil)
  ( chvntm maskDrop chvntmmaskDrop t t t t nil)
  ( cldntm drawing cmm8 t t t t nil)
  ( cldntm mask cmm8mask t t t t t)
  ( clvom drawing clvom t t t t t)
  ( clvom mask clvommask t t t t t)
  ( clvom maskAdd clvommaskAdd t t t t nil)
  ( clvom maskDrop clvommaskDrop t t t t nil)
  ( cp1m drawing cp1m t t t t nil)
  ( cp1m mask cp1mmask t t t t t)
  ( cp1m maskAdd cp1mmaskAdd t t t t t)
  ( cp1m waffleDrop cp1mwaffleDrop t t t t t)
  ( cp1m maskDrop cp1mmaskDrop t t t t t)
  ( cli1m drawing cli1m t t t t nil)
  ( cli1m mask cli1mmask t t t t t)
  ( cli1m maskAdd cli1mmaskAdd t t t t t)
  ( cli1m maskDrop cli1mmaskDrop t t t t t)
  ( clicm1 drawing clicm1 t t t t nil)
  ( clicm1 mask clicm1mask t t t t t)
  ( clicm1 maskAdd clicm1maskAdd t t t t t)
  ( clicm1 maskDrop clicm1maskDrop t t t t t)
  ( cmm1 drawing cmm1 t t t t nil)
  ( cmm1 mask cmm1mask t t t t t)
  ( cmm1 maskAdd cmm1maskAdd t t t t nil)
  ( cmm1 maskDrop cmm1maskDrop t t t t nil)
  ( cmm1 waffleDrop cmm1waffleDrop t t t t t)
  ( cviam drawing cviam t t t t nil)
  ( cviam mask cviammask t t t t t)
  ( cviam maskAdd cviammaskAdd t t t t nil)
  ( cviam maskDrop cviammaskDrop t t t t nil)
  ( cmm2 drawing cmm2 t t t t nil)
  ( cmm2 mask cmm2mask t t t t t)
  ( cmm2 maskAdd cmm2maskAdd t t t t nil)
  ( cmm2 maskDrop cmm2maskDrop t t t t nil)
  ( cmm2 waffleDrop cmm2waffleDrop t t t t t)
  ( cviam2 drawing cviam2 t t t t nil)
  ( cviam2 mask cviam2mask t t t t t)
  ( cviam2 maskAdd cviam2maskAdd t t t t nil)
  ( cviam2 maskDrop cviam2maskDrop t t t t nil)
  ( cmm3 drawing cmm3 t t t t nil)
  ( cmm3 mask cmm3mask t t t t t)
  ( cmm3 maskAdd cmm3maskAdd t t t t nil)
  ( cmm3 maskDrop cmm3maskDrop t t t t nil)
  ( cmm3 waffleDrop cmm3waffleDrop t t t t t)
  ( cnpc drawing csilm t t t t t)
  ( cnpc mask csilmmask t t t t t)
  ( cnpc maskAdd csilmmaskAdd t t t t nil)
  ( cnpc maskDrop csilmmaskDrop t t t t nil)
  ( cviam3 drawing cviam3 t t t t nil)
  ( cviam3 mask cviam3mask t t t t t)
  ( cviam3 maskAdd cviam3maskAdd t t t t nil)
  ( cviam3 maskDrop cviam3maskDrop t t t t nil)
  ( cnsm mask cmm8 t t t t t)
  ( cpdm drawing cpdm t t t t nil)
  ( cpdm mask cpdmmask t t t t t)
  ( cpdm maskAdd cpdmmaskAdd t t t t nil)
  ( cpdm maskDrop cpdmmaskDrop t t t t nil)
  ( cpmm drawing ccim t t t t t)
  ( cpmm mask ccimmask t t t t t)
  ( cpmm maskDrop cpmmmaskDrop t t t t t)
  ( cmm4 mask cmm4mask t t t t t)
  ( cmm4 maskAdd cmm4maskAdd t t t t t)
  ( cmm4 maskDrop cmm4maskDrop t t t t t)
  ( cmm4 waffleDrop cmm4waffleDrop t t t t t)
  ( cviam4 drawing cviam4 t t t t nil)
  ( cviam4 mask cviam4mask t t t t t)
  ( cviam4 maskAdd cviam4maskAdd t t t t nil)
  ( cviam4 maskDrop cviam4maskDrop t t t t nil)
  ( cmm5 mask cmm5mask t t t t t)
  ( target drawing target t t t t t)
  ( cctm1 drawing cctm1 t t t t nil)
  ( cctm1 mask cctm1mask t t t t t)
  ( cctm1 maskAdd cctm1maskAdd t t t t nil)
  ( cctm1 maskDrop cctm1maskDrop t t t t nil)
  ( overlap drawing overlap t t t t t)
  ( overlap boundary overlapBnd t t t t t)
  ( areaid lowTapDensity areaidDualMemory t t t t t)
  ( areaid notCritSide areaidTcamMemory t t t t t)
  ( areaid injection per t t t t t)
  ( areaid rfdiode fix t t t t t)
  ( areaid seal areaidseal t t t t t)
  ( areaid core areaidcore t t t t t)
  ( areaid frame areaidframe t t t t t)
  ( areaid esd areaidesd t t t t t)
  ( areaid dieCut areaiddieCut t t t t t)
  ( areaid moduleCut areaidmoduleCut t t t t t)
  ( areaid frameRect areaidframeRect t t t t t)
  ( areaid substrateCut areaidsubstrateCut2 t t t t t)
  ( areaid diode areaidde t t t t t)
  ( areaid standardc areaidStandardc t t t t t)
  ( areaid deadZon areaiddn t t t t t)
  ( areaid critCorner areaidcr t t t t t)
  ( areaid critSid areaidcd t t t t t)
  ( areaid opcDrop areaidopcDrop t t t t t)
  ( areaid waffleWindow areaidWaffleWindow t t t t t)
  ( areaid extendedDrain areaidextendedDrain t t t t t)
  ( areaid lvdnw areaidlvdnw t t t t t)
  ( areaid lvNative areaidTcamMemory t t t t t)
  ( areaid photo areaidprobe t t t t t)
  ( areaid etest cmsm t t t t t)
  ( areaid hvnwell msm t t t t t)
  ( prune drawing prunedg t t t t t)
  ( padCenter drawing target t t t t t)
  ( met1 psa1 met1Psa1 t t t t t)
  ( met2 psa1 met2Psa1 t t t t t)
  ( met3 psa1 met3Psa1 t t t t t)
  ( met4 psa1 met4Psa1 t t t t t)
  ( met5 psa1 met5Psa1 t t t t t)
  ( met1 psa2 met1Psa2 t t t t t)
  ( met2 psa2 met2Psa2 t t t t t)
  ( met3 psa2 met3Psa2 t t t t t)
  ( met4 psa2 met4Psa2 t t t t t)
  ( met5 psa2 met5Psa2 t t t t t)
  ( met1 psa3 met1Psa3 t t t t t)
  ( met2 psa3 met2Psa3 t t t t t)
  ( met3 psa3 met3Psa3 t t t t t)
  ( met4 psa3 met4Psa3 t t t t t)
  ( met5 psa3 met5Psa3 t t t t t)
  ( met1 psa4 met1Psa4 t t t t t)
  ( met2 psa4 met2Psa4 t t t t t)
  ( met3 psa4 met3Psa4 t t t t t)
  ( met4 psa4 met4Psa4 t t t t t)
  ( met5 psa4 met5Psa4 t t t t t)
  ( met1 psa5 met1Psa5 t t t t t)
  ( met2 psa5 met2Psa5 t t t t t)
  ( met3 psa5 met3Psa5 t t t t t)
  ( met4 psa5 met4Psa5 t t t t t)
  ( met5 psa5 met5Psa5 t t t t t)
  ( met1 psa6 met1Psa6 t t t t t)
  ( met2 psa6 met2Psa6 t t t t t)
  ( met3 psa6 met3Psa6 t t t t t)
  ( met4 psa6 met4Psa6 t t t t t)
  ( met5 psa6 met5Psa6 t t t t t)
  ( blanking drawing post2 t t t t nil)
 ) ; techDisplay

) ; layerDefinitions
(layerRules

 (viaLayers
  ( ("poly" "drawing") ("licon1" "drawing") ("li1" "drawing"))
  ( ("diff" "drawing") ("licon1" "drawing") ("li1" "drawing"))
  ( ("tap" "drawing") ("licon1" "drawing") ("li1" "drawing"))
  ( ("met1" "drawing") ("via" "drawing") ("met2" "drawing"))
  ( ("met2" "drawing") ("via2" "drawing") ("met3" "drawing"))
  ( ("li1" "drawing") ("mcon" "drawing") ("met1" "drawing"))
  ( ("met4" "drawing") ("via4" "drawing") ("met5" "drawing"))
  ( ("met3" "drawing") ("via3" "drawing") ("met4" "drawing"))
 ) ; viaLayers

 (streamLayers
  ( ("cmm2" "maskDrop") 105 42 t)
  ( ("met1" "pin") 68 16 t)
  ( ("met4" "psa5") 71 92 t)
  ( ("met2" "cut") 69 14 t)
  ( ("met1" "option1") 68 32 t)
  ( ("text" "drawing") 83 44 t)
  ( ("poly" "probe") 66 25 t)
  ( ("licon1" "drawing") 66 44 t)
  ( ("met5" "psa6") 72 93 t)
  ( ("met5" "net") 72 23 t)
  ( ("met2" "blockage") 69 10 t)
  ( ("met3" "boundary") 70 4 t)
  ( ("areaid" "rfdiode") 81 125 t)
  ( ("cli1m" "maskDrop") 115 42 t)
  ( ("cfom" "maskAdd") 22 21 t)
  ( ("nwell" "net") 84 23 t)
  ( ("cpmm" "maskDrop") 94 22 t)
  ( ("cmm1" "maskAdd") 62 21 t)
  ( ("cnsdm" "maskDrop") 29 22 t)
  ( ("cviam3" "drawing") 112 20 t)
  ( ("poly" "gate") 66 9 t)
  ( ("met2" "probe") 69 25 t)
  ( ("met3" "label") 70 5 t)
  ( ("ctunm" "drawing") 96 20 t)
  ( ("chvntm" "maskAdd") 38 21 t)
  ( ("via3" "boundary") 70 60 t)
  ( ("poly" "cut") 66 14 t)
  ( ("met4" "fuse") 71 17 t)
  ( ("met4" "label") 71 5 t)
  ( ("marker" "warning") 83 7 t)
  ( ("chvntm" "mask") 39 0 t)
  ( ("met3" "fuse") 70 17 t)
  ( ("cfom" "mask") 23 0 t)
  ( ("cmm1" "mask") 36 0 t)
  ( ("nwell" "pin") 64 16 t)
  ( ("met2" "psa3") 69 90 t)
  ( ("nsdm" "drawing") 93 44 t)
  ( ("psdm" "drawing") 94 20 t)
  ( ("met2" "psa4") 69 91 t)
  ( ("met2" "option7") 69 38 t)
  ( ("met4" "boundary") 71 4 t)
  ( ("met5" "pin") 72 16 t)
  ( ("met5" "option1") 72 32 t)
  ( ("cmm4" "maskDrop") 112 42 t)
  ( ("pad" "pin") 76 16 t)
  ( ("hvi" "drawing") 75 20 t)
  ( ("areaid" "frameRect") 81 12 t)
  ( ("hvntm" "drawing") 125 20 t)
  ( ("met1" "psa6") 68 93 t)
  ( ("met3" "psa5") 70 92 t)
  ( ("met1" "net") 68 23 t)
  ( ("hvnvtm" "drawing") 63 20 t)
  ( ("areaid" "hvnwell") 81 63 t)
  ( ("nwell" "label") 64 5 t)
  ( ("met2" "res") 69 13 t)
  ( ("li1" "drawing") 67 20 t)
  ( ("cp1m" "waffleDrop") 33 24 t)
  ( ("tap" "drawing") 65 44 t)
  ( ("met4" "option1") 71 32 t)
  ( ("chvtpm" "drawing") 88 44 t)
  ( ("met3" "psa6") 70 93 t)
  ( ("met1" "psa5") 68 92 t)
  ( ("met3" "net") 70 23 t)
  ( ("cnsdm" "mask") 30 0 t)
  ( ("cp1m" "drawing") 33 44 t)
  ( ("met4" "pin") 71 16 t)
  ( ("met5" "boundary") 72 4 t)
  ( ("cpmm" "mask") 92 0 t)
  ( ("tunm" "drawing") 80 20 t)
  ( ("cli1m" "mask") 56 0 t)
  ( ("cmm4" "maskAdd") 112 43 t)
  ( ("pad" "label") 76 5 t)
  ( ("met5" "label") 72 5 t)
  ( ("cmm2" "mask") 41 0 t)
  ( ("areaid" "lvNative") 81 60 t)
  ( ("poly" "res") 66 13 t)
  ( ("via3" "net") 70 41 t)
  ( ("blanking" "drawing") 124 40 t)
  ( ("li1" "short") 67 15 t)
  ( ("areaid" "waffleWindow") 81 13 t)
  ( ("clvtnm" "drawing") 25 44 t)
  ( ("cmm2" "maskAdd") 105 43 t)
  ( ("poly" "model") 66 83 t)
  ( ("met5" "fuse") 72 17 t)
  ( ("via3" "pin") 70 48 t)
  ( ("met1" "label") 68 5 t)
  ( ("areaid" "frame") 81 3 t)
  ( ("cmm4" "mask") 51 0 t)
  ( ("cli1m" "maskAdd") 115 43 t)
  ( ("met3" "pin") 70 16 t)
  ( ("cnsdm" "maskAdd") 29 21 t)
  ( ("met4" "psa6") 71 93 t)
  ( ("met4" "net") 71 23 t)
  ( ("met3" "option1") 70 32 t)
  ( ("cfom" "maskDrop") 22 22 t)
  ( ("areaid" "standardc") 81 4 t)
  ( ("cmm1" "maskDrop") 62 22 t)
  ( ("met5" "psa5") 72 92 t)
  ( ("cnpc" "drawing") 44 20 t)
  ( ("chvntm" "maskDrop") 38 22 t)
  ( ("met1" "boundary") 68 4 t)
  ( ("cncm" "drawing") 96 44 t)
  ( ("pnp" "label") 82 59 t)
  ( ("padCenter" "drawing") 81 20 t)
  ( ("via4" "net") 71 41 t)
  ( ("lvtn" "drawing") 125 44 t)
  ( ("conom" "maskAdd") 87 43 t)
  ( ("poly" "net") 66 23 t)
  ( ("met5" "probe") 72 25 t)
  ( ("cctm1" "maskDrop") 101 42 t)
  ( ("cviam2" "maskAdd") 108 21 t)
  ( ("met1" "psa3") 68 90 t)
  ( ("met3" "res") 70 13 t)
  ( ("areaid" "lvdnw") 81 80 t)
  ( ("cpdm" "mask") 37 0 t)
  ( ("met5" "cut") 72 14 t)
  ( ("met1" "psa4") 68 91 t)
  ( ("met1" "option7") 68 38 t)
  ( ("cmm3" "drawing") 107 20 t)
  ( ("marker" "error") 83 6 t)
  ( ("areaid" "etest") 81 101 t)
  ( ("clicm1" "drawing") 106 44 t)
  ( ("met5" "blockage") 72 10 t)
  ( ("met2" "psa6") 69 93 t)
  ( ("cmm3" "waffleDrop") 107 24 t)
  ( ("met2" "net") 69 23 t)
  ( ("met1" "cut") 68 14 t)
  ( ("met2" "option1") 69 32 t)
  ( ("met5" "psa4") 72 91 t)
  ( ("met2" "pin") 69 16 t)
  ( ("met5" "option7") 72 38 t)
  ( ("cnwm" "maskDrop") 109 42 t)
  ( ("cviam" "drawing") 105 20 t)
  ( ("cpsdm" "maskDrop") 31 22 t)
  ( ("cpdm" "maskAdd") 104 43 t)
  ( ("overlap" "drawing") 90 20 t)
  ( ("met1" "blockage") 68 10 t)
  ( ("met4" "res") 71 13 t)
  ( ("cviam4" "maskDrop") 117 22 t)
  ( ("cviam2" "mask") 44 0 t)
  ( ("cntm" "drawing") 26 20 t)
  ( ("cnsm" "mask") 22 0 t)
  ( ("met1" "probe") 68 25 t)
  ( ("via4" "pin") 71 48 t)
  ( ("npn" "drawing") 82 20 t)
  ( ("via" "drawing") 68 44 t)
  ( ("conom" "mask") 88 0 t)
  ( ("poly" "pin") 66 16 t)
  ( ("met5" "psa3") 72 90 t)
  ( ("cpsdm" "maskAdd") 31 21 t)
  ( ("via2" "drawing") 69 44 t)
  ( ("via4" "boundary") 71 60 t)
  ( ("poly" "boundary") 66 4 t)
  ( ("met4" "psa3") 71 90 t)
  ( ("areaid" "core") 81 2 t)
  ( ("cnwm" "maskAdd") 109 43 t)
  ( ("met2" "label") 69 5 t)
  ( ("met3" "probe") 70 25 t)
  ( ("cviam4" "maskAdd") 117 21 t)
  ( ("cpdm" "maskDrop") 104 42 t)
  ( ("met3" "cut") 70 14 t)
  ( ("met5" "res") 72 13 t)
  ( ("poly" "label") 66 5 t)
  ( ("cctm1" "mask") 35 0 t)
  ( ("met4" "psa4") 71 91 t)
  ( ("areaid" "critSid") 81 52 t)
  ( ("met2" "boundary") 69 4 t)
  ( ("met4" "option7") 71 38 t)
  ( ("clvom" "drawing") 45 20 t)
  ( ("met3" "blockage") 70 10 t)
  ( ("cdnm" "drawing") 110 20 t)
  ( ("met1" "res") 68 13 t)
  ( ("met4" "blockage") 71 10 t)
  ( ("met3" "psa4") 70 91 t)
  ( ("conom" "maskDrop") 87 42 t)
  ( ("met3" "option7") 70 38 t)
  ( ("cviam2" "maskDrop") 108 22 t)
  ( ("diff" "drawing") 65 20 t)
  ( ("met2" "psa5") 69 92 t)
  ( ("met4" "cut") 71 14 t)
  ( ("cctm1" "maskAdd") 101 43 t)
  ( ("areaid" "extendedDrain") 81 57 t)
  ( ("cviam4" "mask") 58 0 t)
  ( ("met4" "probe") 71 25 t)
  ( ("areaid" "lowTapDensity") 81 14 t)
  ( ("areaid" "substrateCut") 81 53 t)
  ( ("cpsdm" "mask") 32 0 t)
  ( ("mcon" "drawing") 67 44 t)
  ( ("met3" "psa3") 70 90 t)
  ( ("cldntm" "drawing") 11 20 t)
  ( ("cnwm" "mask") 21 0 t)
  ( ("via" "boundary") 68 60 t)
  ( ("clvom" "maskDrop") 45 22 t)
  ( ("cmm5" "mask") 59 0 t)
  ( ("mcon" "net") 67 41 t)
  ( ("via2" "pin") 69 58 t)
  ( ("areaid" "moduleCut") 81 10 t)
  ( ("cntm" "maskAdd") 26 21 t)
  ( ("met2" "psa1") 69 88 t)
  ( ("met1" "option6") 68 37 t)
  ( ("areaid" "deadZon") 81 50 t)
  ( ("areaid" "diode") 81 23 t)
  ( ("cmm3" "mask") 34 0 t)
  ( ("met4" "option5") 71 36 t)
  ( ("overlap" "boundary") 90 4 t)
  ( ("npn" "label") 82 5 t)
  ( ("cpdm" "drawing") 104 44 t)
  ( ("diff" "hv") 65 8 t)
  ( ("diff" "net") 65 23 t)
  ( ("chvnvtm" "mask") 95 0 t)
  ( ("cviam" "maskAdd") 105 21 t)
  ( ("met5" "option2") 72 33 t)
  ( ("met1" "option8") 68 39 t)
  ( ("pwell" "cut") 64 14 t)
  ( ("clicm1" "mask") 43 0 t)
  ( ("areaid" "opcDrop") 81 54 t)
  ( ("cviam" "mask") 40 0 t)
  ( ("li1" "cut") 67 14 t)
  ( ("clicm1" "maskAdd") 106 43 t)
  ( ("cmm3" "maskAdd") 107 21 t)
  ( ("li1" "blockage") 67 10 t)
  ( ("met1" "option2") 68 33 t)
  ( ("met3" "option5") 70 36 t)
  ( ("met5" "option8") 72 39 t)
  ( ("diff" "pin") 65 16 t)
  ( ("met2" "option3") 69 34 t)
  ( ("met2" "option4") 69 35 t)
  ( ("ldntm" "drawing") 11 44 t)
  ( ("cviam2" "drawing") 108 20 t)
  ( ("conom" "drawing") 87 44 t)
  ( ("capacitor" "drawing") 82 64 t)
  ( ("mcon" "pin") 67 48 t)
  ( ("cdnm" "maskDrop") 110 22 t)
  ( ("li1" "probe") 67 25 t)
  ( ("dnwell" "drawing") 64 18 t)
  ( ("via2" "net") 69 41 t)
  ( ("met5" "option6") 72 37 t)
  ( ("cntm" "mask") 27 0 t)
  ( ("met2" "short") 69 15 t)
  ( ("mcon" "boundary") 67 60 t)
  ( ("clicm1" "maskDrop") 106 42 t)
  ( ("via" "net") 68 41 t)
  ( ("areaid" "injection") 81 17 t)
  ( ("met2" "psa2") 69 89 t)
  ( ("diff" "label") 65 6 t)
  ( ("met4" "option6") 71 37 t)
  ( ("prune" "drawing") 84 44 t)
  ( ("cmm3" "maskDrop") 107 22 t)
  ( ("fom" "dummy") 22 23 t)
  ( ("cctm1" "drawing") 101 44 t)
  ( ("diff" "boundary") 65 4 t)
  ( ("met4" "option8") 71 39 t)
  ( ("npc" "drawing") 95 20 t)
  ( ("met3" "option2") 70 33 t)
  ( ("met1" "option5") 68 36 t)
  ( ("poly" "short") 66 15 t)
  ( ("pwell" "res") 64 13 t)
  ( ("areaid" "notCritSide") 81 15 t)
  ( ("nsm" "drawing") 61 20 t)
  ( ("clvom" "mask") 46 0 t)
  ( ("cdnm" "maskAdd") 110 21 t)
  ( ("met4" "option2") 71 33 t)
  ( ("li1" "res") 67 13 t)
  ( ("cntm" "maskDrop") 26 22 t)
  ( ("met2" "drawing") 69 20 t)
  ( ("vhvi" "drawing") 74 21 t)
  ( ("clvom" "maskAdd") 45 21 t)
  ( ("cdnm" "mask") 48 0 t)
  ( ("met5" "option5") 72 36 t)
  ( ("met3" "option8") 70 39 t)
  ( ("cviam4" "drawing") 117 20 t)
  ( ("poly" "drawing") 66 20 t)
  ( ("pmm" "drawing") 85 44 t)
  ( ("cldntm" "mask") 11 0 t)
  ( ("cnwm" "drawing") 109 44 t)
  ( ("via" "pin") 68 58 t)
  ( ("hvtp" "drawing") 78 44 t)
  ( ("met3" "option6") 70 37 t)
  ( ("cpsdm" "drawing") 31 20 t)
  ( ("cviam" "maskDrop") 105 22 t)
  ( ("via2" "boundary") 69 60 t)
  ( ("via4" "drawing") 71 44 t)
  ( ("li1" "pin") 67 16 t)
  ( ("met2" "option2") 69 33 t)
  ( ("target" "drawing") 76 44 t)
  ( ("met1" "option3") 68 34 t)
  ( ("met4" "drawing") 71 20 t)
  ( ("tap" "pin") 65 48 t)
  ( ("diff" "cut") 65 14 t)
  ( ("cviam3" "mask") 50 0 t)
  ( ("met3" "psa2") 70 89 t)
  ( ("cp1m" "maskDrop") 33 42 t)
  ( ("met3" "short") 70 15 t)
  ( ("met1" "option4") 68 35 t)
  ( ("chvtpm" "maskDrop") 97 42 t)
  ( ("met5" "psa1") 72 88 t)
  ( ("ctunm" "mask") 20 0 t)
  ( ("ncm" "drawing") 92 44 t)
  ( ("cmm1" "waffleDrop") 62 24 t)
  ( ("via3" "drawing") 70 44 t)
  ( ("chvntm" "drawing") 38 20 t)
  ( ("met5" "option4") 72 35 t)
  ( ("cfom" "waffleDrop") 22 24 t)
  ( ("cnpc" "maskDrop") 44 42 t)
  ( ("ctunm" "maskAdd") 96 21 t)
  ( ("cviam3" "maskAdd") 112 21 t)
  ( ("met4" "short") 71 15 t)
  ( ("pwelliso" "label") 44 5 t)
  ( ("met4" "psa2") 71 89 t)
  ( ("areaid" "dieCut") 81 11 t)
  ( ("met1" "psa1") 68 88 t)
  ( ("cmm1" "drawing") 62 20 t)
  ( ("met2" "option6") 69 37 t)
  ( ("cfom" "drawing") 22 20 t)
  ( ("areaid" "seal") 81 1 t)
  ( ("met3" "drawing") 70 20 t)
  ( ("tap" "net") 65 41 t)
  ( ("clvtnm" "maskDrop") 25 42 t)
  ( ("li1" "net") 67 23 t)
  ( ("licon1" "boundary") 66 60 t)
  ( ("pwell" "pin") 122 16 t)
  ( ("met5" "option3") 72 34 t)
  ( ("met2" "option8") 69 39 t)
  ( ("pwelliso" "pin") 44 16 t)
  ( ("licon1" "pin") 66 58 t)
  ( ("met1" "drawing") 68 20 t)
  ( ("cnpc" "maskAdd") 44 43 t)
  ( ("ctunm" "maskDrop") 96 22 t)
  ( ("met4" "option3") 71 34 t)
  ( ("cpmm" "drawing") 91 44 t)
  ( ("cp1m" "mask") 28 0 t)
  ( ("cviam3" "maskDrop") 112 22 t)
  ( ("diff" "res") 65 13 t)
  ( ("chvtpm" "mask") 97 0 t)
  ( ("cnsdm" "drawing") 29 20 t)
  ( ("met5" "psa2") 72 89 t)
  ( ("cli1m" "drawing") 115 44 t)
  ( ("pnp" "drawing") 82 44 t)
  ( ("met5" "short") 72 15 t)
  ( ("cmm2" "waffleDrop") 105 52 t)
  ( ("pwell" "label") 64 59 t)
  ( ("met4" "option4") 71 35 t)
  ( ("met3" "psa1") 70 88 t)
  ( ("cmm2" "drawing") 105 44 t)
  ( ("clvtnm" "maskAdd") 25 43 t)
  ( ("met4" "psa1") 71 88 t)
  ( ("met1" "psa2") 68 89 t)
  ( ("met1" "short") 68 15 t)
  ( ("met3" "option4") 70 35 t)
  ( ("areaid" "esd") 81 19 t)
  ( ("areaid" "critCorner") 81 51 t)
  ( ("cmm4" "waffleDrop") 112 4 t)
  ( ("tap" "label") 65 5 t)
  ( ("clvtnm" "mask") 25 0 t)
  ( ("li1" "label") 67 5 t)
  ( ("areaid" "photo") 81 81 t)
  ( ("nwell" "drawing") 64 20 t)
  ( ("prBoundary" "boundary") 235 4 t)
  ( ("tap" "boundary") 65 60 t)
  ( ("pad" "drawing") 76 20 t)
  ( ("cp1m" "maskAdd") 33 43 t)
  ( ("met5" "drawing") 72 20 t)
  ( ("chvtpm" "maskAdd") 97 43 t)
  ( ("li1" "boundary") 67 4 t)
  ( ("licon1" "net") 66 41 t)
  ( ("met2" "option5") 69 36 t)
  ( ("cncm" "mask") 17 0 t)
  ( ("met3" "option3") 70 34 t)
  ( ("cnpc" "mask") 49 0 t)
 ) ; streamLayers

) ; layerRules

(physicalRules

 (orderedSpacingRules
   ( minEnclosure  ("met5" "drawing")  ("via4" "drawing")  0.310000 ) 
   ( minEnclosure  ("met4" "drawing")  ("via4" "drawing")  0.190000 ) 
   ( minEnclosure  ("met4" "drawing")  ("via3" "drawing")  0.065000 ) 
   ( minEnclosure  ("met3" "drawing")  ("via3" "drawing")  0.060000 ) 
   ( minEnclosure  ("met3" "drawing")  ("via2" "drawing")  0.065000 ) 
   ( minEnclosure  ("met2" "drawing")  ("via2" "drawing")  0.040000 ) 
   ( minEnclosure  ("met2" "drawing")  ("via" "drawing")  0.085000 ) 
   ( minEnclosure  ("met1" "drawing")  ("via" "drawing")  0.085000 ) 
   ( minEnclosure  ("met1" "drawing")  ("mcon" "drawing")  0.060000 ) 
   ( minEnclosure  ("nwell" "drawing")  ("capacitor" "drawing")  1.500000 ) 
   ( minEnclosure  ("li1" "drawing")  ("mcon" "drawing")  0.000000 ) 
   ( minEnclosure  ("npc" "drawing")  ("licon1" "drawing")  0.100000 ) 
   ( minEnclosure  ("poly" "drawing")  ("licon1" "drawing")  0.080000 ) 
   ( minEnclosure  ("tap" "drawing")  ("licon1" "drawing")  0.120000 ) 
   ( minEnclosure  ("diff" "drawing")  ("licon1" "drawing")  0.040000 ) 
   ( minEnclosure  ("li1" "drawing")  ("licon1" "drawing")  0.080000 ) 
   ( minEnclosure  ("nwell" "drawing")  ("tap" "drawing")  0.180000 ) 
   ( minEnclosure  ("nwell" "drawing")  ("diff" "drawing")  0.180000 ) 
   ( minEnclosure  ("dnwell" "drawing")  ("nwell" "drawing")  0.400000 ) 
 ) ; orderedSpacingRules

 (spacingRules
   ( minWidth  ("met5" "drawing")       0.800000 ) 
   ( minWidth  ("via4" "drawing")       0.800000 ) 
   ( minWidth  ("met4" "drawing")       0.300000 ) 
   ( minWidth  ("via3" "drawing")       0.200000 ) 
   ( minWidth  ("met3" "drawing")       0.300000 ) 
   ( minWidth  ("via2" "drawing")       0.200000 ) 
   ( minWidth  ("hvntm" "drawing")       0.380000 ) 
   ( minWidth  ("hvntm" "drawing")       0.700000 ) 
   ( minWidth  ("hvtp" "drawing")       0.380000 ) 
   ( minWidth  ("ncm" "drawing")       0.380000 ) 
   ( minWidth  ("nsm" "drawing")       3.000000 ) 
   ( minWidth  ("met2" "drawing")       0.140000 ) 
   ( minWidth  ("via" "drawing")       0.150000 ) 
   ( minWidth  ("met1" "drawing")       0.140000 ) 
   ( minWidth  ("capacitor" "drawing")       1.430000 ) 
   ( minWidth  ("mcon" "drawing")       0.170000 ) 
   ( minWidth  ("licon1" "drawing")       0.170000 ) 
   ( minWidth  ("poly" "drawing")       0.150000 ) 
   ( minWidth  ("hvi" "drawing")       0.600000 ) 
   ( minWidth  ("ldntm" "drawing")       0.700000 ) 
   ( minWidth  ("lvtn" "drawing")       0.380000 ) 
   ( minWidth  ("li1" "drawing")       0.170000 ) 
   ( minWidth  ("npc" "drawing")       0.270000 ) 
   ( minWidth  ("psdm" "drawing")       0.380000 ) 
   ( minWidth  ("nsdm" "drawing")       0.380000 ) 
   ( minWidth  ("tunm" "drawing")       0.410000 ) 
   ( minWidth  ("tap" "drawing")       0.150000 ) 
   ( minWidth  ("diff" "drawing")       0.150000 ) 
   ( minWidth  ("nwell" "drawing")       0.840000 ) 
   ( minWidth  ("dnwell" "drawing")       3.000000 ) 
   ( minSpacing  ("met5" "drawing")       0.800000 ) 
   ( minSpacing  ("via4" "drawing")       0.800000 ) 
   ( minSpacing  ("met4" "drawing")       0.300000 ) 
   ( minSpacing  ("via3" "drawing")       0.200000 ) 
   ( minSpacing  ("met3" "drawing")       0.300000 ) 
   ( minSpacing  ("via2" "drawing")       0.200000 ) 
   ( minSpacing  ("hvntm" "drawing")       0.380000 ) 
   ( minSpacing  ("hvntm" "drawing")       0.700000 ) 
   ( minSpacing  ("hvtp" "drawing")       0.380000 ) 
   ( minSpacing  ("ncm" "drawing")       0.380000 ) 
   ( minSpacing  ("nsm" "drawing")       4.000000 ) 
   ( minSpacing  ("met2" "drawing")       0.140000 ) 
   ( minSpacing  ("via" "drawing")       0.170000 ) 
   ( minSpacing  ("met1" "drawing")       0.140000 ) 
   ( minSpacing  ("mcon" "drawing")       0.190000 ) 
   ( minSpacing  ("licon1" "drawing")       0.170000 ) 
   ( minSpacing  ("poly" "drawing")  ("tap" "drawing")  0.055000 ) 
   ( minSpacing  ("poly" "drawing")  ("diff" "drawing")  0.075000 ) 
   ( minSpacing  ("poly" "drawing")       0.210000 ) 
   ( minSpacing  ("hvi" "drawing")  ("nwell" "drawing")  0.700000 ) 
   ( minSpacing  ("hvi" "drawing")       0.700000 ) 
   ( minSpacing  ("ldntm" "drawing")       0.700000 ) 
   ( minSpacing  ("lvtn" "drawing")  ("hvtp" "drawing")  0.380000 ) 
   ( minSpacing  ("lvtn" "drawing")       0.380000 ) 
   ( minSpacing  ("li1" "drawing")       0.170000 ) 
   ( minSpacing  ("npc" "drawing")       0.270000 ) 
   ( minSpacing  ("psdm" "drawing")       0.380000 ) 
   ( minSpacing  ("nsdm" "drawing")       0.380000 ) 
   ( minSpacing  ("tunm" "drawing")       0.500000 ) 
   ( minSpacing  ("tap" "drawing")  ("nwell" "drawing")  0.130000 ) 
   ( minSpacing  ("diff" "drawing")  ("nwell" "drawing")  0.340000 ) 
   ( minSpacing  ("diff" "drawing")  ("tap" "drawing")  0.270000 ) 
   ( minSpacing  ("tap" "drawing")       0.270000 ) 
   ( minSpacing  ("diff" "drawing")       0.270000 ) 
   ( minSpacing  ("nwell" "drawing")  ("dnwell" "drawing")  6.000000 ) 
   ( minSpacing  ("nwell" "drawing")       1.270000 ) 
   ( minSpacing  ("dnwell" "drawing")       9.500000 ) 
   ( sameNet  ("via3" "drawing")  ("via4" "drawing")  0.000000 ) 
   ( sameNet  ("via2" "drawing")  ("via3" "drawing")  0.000000 ) 
   ( sameNet  ("via" "drawing")  ("via3" "drawing")  0.000000 ) 
   ( sameNet  ("via" "drawing")  ("via2" "drawing")  0.000000 ) 
   ( sameNet  ("mcon" "drawing")  ("via3" "drawing")  0.000000 ) 
   ( sameNet  ("mcon" "drawing")  ("via2" "drawing")  0.000000 ) 
   ( sameNet  ("mcon" "drawing")  ("via" "drawing")  0.000000 ) 
   ( sameNet  ("met5" "drawing")  ("met5" "drawing")  0.800000 ) 
   ( sameNet  ("met4" "drawing")  ("met4" "drawing")  0.300000 ) 
   ( sameNet  ("via3" "drawing")  ("via3" "drawing")  0.200000 ) 
   ( sameNet  ("met3" "drawing")  ("met3" "drawing")  0.300000 ) 
   ( sameNet  ("via2" "drawing")  ("via2" "drawing")  0.200000 ) 
   ( sameNet  ("met2" "drawing")  ("met2" "drawing")  0.140000 ) 
   ( sameNet  ("via" "drawing")  ("via" "drawing")  0.170000 ) 
   ( sameNet  ("met1" "drawing")  ("met1" "drawing")  0.140000 ) 
   ( sameNet  ("mcon" "drawing")  ("mcon" "drawing")  0.190000 ) 
   ( offset  ("met5" "drawing")       0.955000 ) 
   ( offset  ("met4" "drawing")       0.305000 ) 
   ( offset  ("met3" "drawing")       0.305000 ) 
   ( offset  ("met2" "drawing")       0.185000 ) 
   ( offset  ("met1" "drawing")       0.185000 ) 
   ( minSpacingRange  ("met4" "drawing")  (" 0.400000 RANGE 3.005000  2000.00  "  " 0.400000 RANGE 3.005000  2000.00 INFLUENCE 0.400000  ")) 
   ( minSpacingRange  ("met3" "drawing")  (" 0.400000 RANGE 3.005000  2000.00  "  " 0.400000 RANGE 3.005000  2000.00 INFLUENCE 0.400000  ")) 
   ( minSpacingRange  ("met2" "drawing")  (" 0.280000 RANGE 3.005000  2000.00  "  " 0.280000 RANGE 3.005000  2000.00 INFLUENCE 0.280000  ")) 
   ( minSpacingRange  ("met1" "drawing")  (" 0.280000 RANGE 3.005000  2000.00  "  " 0.280000 RANGE 3.005000  2000.00 INFLUENCE 0.280000  ")) 
 ) ; spacingRules

 (mfgGridResolution  ( 0.005000 ) )

) ; physicalRules

(electricalRules

 (characterizationRules
   ( areaCap  met5  6.48e-06 ) 
   ( areaCap  met4  8.67e-06 ) 
   ( areaCap  met3  1.26e-05 ) 
   ( areaCap  met2  1.75e-05 ) 
   ( areaCap  met1  2.58e-05 ) 
   ( areaCap  li1  3.69e-05 ) 
   ( areaCap  poly  0.000106 ) 
   ( edgeCapacitance  met5  2.55e-12 ) 
   ( edgeCapacitance  met4  1.28e-12 ) 
   ( edgeCapacitance  met3  1.84e-12 ) 
   ( edgeCapacitance  met2  1.22e-12 ) 
   ( edgeCapacitance  met1  1.79e-12 ) 
   ( edgeCapacitance  li1  3.26e-12 ) 
   ( edgeCapacitance  poly  1.03e-11 ) 
   ( edgeCap  met5  2.55e-06 ) 
   ( edgeCap  met4  1.28e-06 ) 
   ( edgeCap  met3  1.84e-06 ) 
   ( edgeCap  met2  1.22e-06 ) 
   ( edgeCap  met1  1.79e-06 ) 
   ( edgeCap  li1  3.26e-06 ) 
   ( edgeCap  poly  1.03e-05 ) 
   ( sheetRes  met5  0.014 ) 
   ( sheetRes  met4  0.042 ) 
   ( sheetRes  met3  0.042 ) 
   ( sheetRes  met2  0.125 ) 
   ( sheetRes  met1  0.125 ) 
   ( sheetRes  li1  12.2 ) 
   ( sheetRes  nwell  1800 ) 
   ( sheetRes  poly  48.2 ) 
   ( sheetRes  diff  197 ) 
   ( sheetRes  diff  120 ) 
   ( thickness  met5  2 ) 
   ( thickness  met4  0.8 ) 
   ( thickness  met3  0.8 ) 
   ( thickness  met2  0.35 ) 
   ( thickness  met1  0.35 ) 
   ( thickness  li1  0.1 ) 
   ( thickness  poly  0.18 ) 
   ( currentden  via4  0.0072 ) 
   ( currentden  via3  0.0027 ) 
   ( currentden  via2  0.0027 ) 
   ( currentden  via  0.002025 ) 
   ( currentden  mcon  0.002295 ) 
   ( currentden  met5  0.01424 ) 
   ( currentden  met4  0.00204 ) 
   ( currentden  met3  0.00204 ) 
   ( currentden  met2  0.000392 ) 
   ( currentden  met1  0.000392 ) 
   ( currentden  via  0.002025 ) 
   ( currentden  mcon  0.002295 ) 
   ( currentden  met2  0.000392 ) 
   ( currentden  met1  0.000392 ) 
   ( defaultAntennaRule  "via4"  (6 _NA_ ((0 6) (0.0215 6) (0.0225 6.81) (1 42)) _NA_ _NA_ _NA_ _NA_ _NA_ _NA_ _NA_) ) 
   ( defaultAntennaRule  "via3"  (6 _NA_ ((0 6) (0.0215 6) (0.0225 6.81) (1 42)) _NA_ _NA_ _NA_ _NA_ _NA_ _NA_ _NA_) ) 
   ( defaultAntennaRule  "via2"  (6 _NA_ ((0 6) (0.0215 6) (0.0225 6.81) (1 42)) _NA_ _NA_ _NA_ _NA_ _NA_ _NA_ _NA_) ) 
   ( defaultAntennaRule  "via"  (6 _NA_ ((0 6) (0.0215 6) (0.0225 6.81) (1 42)) _NA_ _NA_ _NA_ _NA_ _NA_ _NA_ _NA_) ) 
   ( defaultAntennaRule  "mcon"  (3 _NA_ ((0 3) (0.0215 3) (0.0225 3.405) (1 21)) _NA_ _NA_ _NA_ _NA_ _NA_ _NA_ _NA_) ) 
   ( defaultAntennaRule  "met5"  (_NA_ 400 _NA_ ((0 400) (0.0215 400) (0.0225 2609.0) (1 3000)) _NA_ _NA_ _NA_ _NA_ _NA_ _NA_) ) 
   ( defaultAntennaRule  "met4"  (_NA_ 400 _NA_ ((0 400) (0.0215 400) (0.0225 2609.0) (1 3000)) _NA_ _NA_ _NA_ _NA_ _NA_ _NA_) ) 
   ( defaultAntennaRule  "met3"  (_NA_ 400 _NA_ ((0 400) (0.0215 400) (0.0225 2609.0) (1 3000)) _NA_ _NA_ _NA_ _NA_ _NA_ _NA_) ) 
   ( defaultAntennaRule  "met2"  (_NA_ 400 _NA_ ((0 400) (0.0215 400) (0.0225 2609.0) (1 3000)) _NA_ _NA_ _NA_ _NA_ _NA_ _NA_) ) 
   ( defaultAntennaRule  "met1"  (_NA_ 400 _NA_ ((0 400) (0.0215 400) (0.0225 2609.0) (1 3000)) _NA_ _NA_ _NA_ _NA_ _NA_ _NA_) ) 
   ( defaultAntennaRule  "li1"  (_NA_ 75 _NA_ ((0 75) (0.0215 75) (0.0225 85.125) (1 525)) _NA_ _NA_ _NA_ _NA_ _NA_ _NA_) ) 
 ) ; characterizationRules

 (orderedCharacterizationRules
   ( parallelCap  ("met5" "drawing")  ("diff" "drawing")  0.000193 ) 
   ( parallelCap  ("met4" "drawing")  ("diff" "drawing")  8.13e-05 ) 
   ( parallelCap  ("met3" "drawing")  ("diff" "drawing")  7.98e-05 ) 
   ( parallelCap  ("met2" "drawing")  ("diff" "drawing")  0.000106 ) 
   ( parallelCap  ("met1" "drawing")  ("diff" "drawing")  0.000106 ) 
   ( parallelCap  ("li1" "drawing")  ("diff" "drawing")  7.99e-05 ) 
   ( parallelCap  ("poly" "drawing")  ("diff" "drawing")  7.62e-05 ) 
 ) ; orderedCharacterizationRules

) ; electricalRules

;;; 
;;; $Id: rawTech.tf,v 1.1 2006/06/26 18:53:32 kuc Exp $
;;; 
;;; rawTech.tf
;;; 
;;; Copyright (c) 2006 by Cypress Semiconductor
;;; Cypress Kentucky CAD Center (KYCC)
;;; 
;;; Date  : Jun 23, 2006
;;; Author: Kungyen Chang (kuc) @ KYCC
;;; 
;;; Description:
;;;   This file contains devices common to all flows.
;;; 
;;; Revision History:
;;;   kuc 06/23/06  initial version
;;; 


(devices
 
 (tcCreateCDSDeviceClass)

;; Following chunk of code creates the partnum
;; cell and its individual character cells
;; for use in every flow

;;; 
;;; $Id: partNumCharClass.il,v 1.1 2006/06/26 18:51:52 kuc Exp $
;;; 
;;; partNumCharClass.il
;;; 
;;; Copyright (c) 2006 by Cypress Semiconductor
;;; Cypress Kentucky CAD Center (KYCC)
;;; 
;;; Date  : Jun 23, 2006
;;; Author: Kungyen Chang (kuc) @ KYCC
;;; 
;;; Description:
;;;   This class is a pcell for individual letters
;;;   in layout using the points for the shapes for
;;;   characters in partNumClassData.il
;;;
;;;   These individual cells are instantiated by
;;;   partNumClass
;;;   
;;; 
;;; Revision History:
;;;   kuc 06/26/06  initial version
;;; 

;;; 
;;; $Id: partNumClassData.il,v 1.1 2006/06/23 19:36:38 kuc Exp $
;;; 
;;; partNumClassData.il
;;; 
;;; Copyright (c) 2006 by Cypress Semiconductor
;;; Cypress Kentucky CAD Center (KYCC)
;;; 
;;; Date  : Jun 23, 2006
;;; Author: Kungyen Chang (kuc) @ KYCC
;;; 
;;; Description:
;;;   This file contains the data for points
;;;   for creating letters and numbers for
;;;   partNumClass.il
;;;
;;; Revision History:
;;;   kuc 06/23/06  initial version
;;; 


letterShapes = (makeTable "letterTable" nil)
letterShapes["A"] = (list 11.95:1.1 11.9:1.1 11.9:1.25 11.85:1.25 11.85:1.4 11.8:1.4 11.8:1.55 11.75:1.55 11.75:1.7 11.7:1.7 11.7:1.8 11.65:1.8 11.65:1.95 11.6:1.95 11.6:2.1 11.55:2.1 11.55:2.25 11.5:2.25 11.5:2.35 11.45:2.35 11.45:2.5 11.4:2.5 11.4:2.65 11.35:2.65 11.35:2.8 11.3:2.8 11.3:2.9 11.25:2.9 11.25:3.05 11.2:3.05 11.2:3.2 11.15:3.2 11.15:3.35 11.1:3.35 11.1:3.45 11.05:3.45 11.05:3.6 11:3.6 11:3.75 10.95:3.75 10.95:3.9 10.9:3.9 10.9:4 10.85:4 10.85:4.15 10.8:4.15 10.8:4.3 10.75:4.3 10.75:4.45 10.7:4.45 10.7:4.6 10.65:4.6 10.65:4.7 10.6:4.7 10.6:4.85 10.55:4.85 10.55:5 10.5:5 10.5:5.15 10.45:5.15 10.45:5.25 10.4:5.25 10.4:5.4 10.35:5.4 10.35:5.55 10.3:5.55 10.3:5.7 10.25:5.7 10.25:5.8 10.2:5.8 10.2:5.95 10.15:5.95 10.15:6.1 10.1:6.1 10.1:6.25 10.05:6.25 10.05:6.35 10:6.35 10:6.5 9.95:6.5 9.95:6.65 9.9:6.65 9.9:6.8 9.85:6.8 9.85:6.9 9.8:6.9 9.8:7.05 9.75:7.05 9.75:7.2 9.7:7.2 9.7:7.35 9.65:7.35 9.65:7.45 9.6:7.45 9.6:7.6 9.55:7.6 9.55:7.75 9.5:7.75 9.5:7.9 9.45:7.9 9.45:8.05 9.4:8.05 9.4:8.15 9.35:8.15 9.35:8.3 9.3:8.3 9.3:8.45 9.25:8.45 9.25:8.6 9.2:8.6 9.2:8.7 9.15:8.7 9.15:8.85 9.1:8.85 9.1:9 9.05:9 9.05:9.15 9:9.15 9:9.25 8.95:9.25 8.95:9.4 8.9:9.4 8.9:9.55 8.85:9.55 8.85:9.7 8.8:9.7 8.8:9.8 8.75:9.8 8.75:9.95 8.7:9.95 8.7:10.1 8.65:10.1 8.65:10.25 8.6:10.25 8.6:10.35 8.55:10.35 8.55:10.5 8.5:10.5 8.5:10.65 8.45:10.65 8.45:10.8 8.4:10.8 8.4:10.95 8.35:10.95 8.35:11.05 8.3:11.05 8.3:11.2 8.25:11.2 8.25:11.35 8.2:11.35 8.2:11.5 8.15:11.5 8.15:11.6 8.1:11.6 8.1:11.75 8.05:11.75 8.05:11.9 8:11.9 8:12.05 7.95:12.05 7.95:12.15 7.9:12.15 7.9:12.3 7.85:12.3 7.85:12.45 7.8:12.45 7.8:5.85 3.95:5.85 3.95:6.75 4:6.75 4:6.9 4.05:6.9 4.05:7 4.1:7 4.1:7.15 4.15:7.15 4.15:7.3 4.2:7.3 4.2:7.45 4.25:7.45 4.25:7.55 4.3:7.55 4.3:7.7 4.35:7.7 4.35:7.85 4.4:7.85 4.4:8 4.45:8 4.45:8.1 4.5:8.1 4.5:8.25 4.55:8.25 4.55:8.4 4.6:8.4 4.6:8.55 4.65:8.55 4.65:8.65 4.7:8.65 4.7:8.8 4.75:8.8 4.75:8.95 4.8:8.95 4.8:9.1 4.85:9.1 4.85:9.2 4.9:9.2 4.9:9.35 4.95:9.35 4.95:9.5 5:9.5 5:9.65 5.05:9.65 5.05:9.75 5.1:9.75 5.1:9.9 5.15:9.9 5.15:10.05 5.2:10.05 5.2:10.2 5.25:10.2 5.25:10.3 5.3:10.3 5.3:10.45 5.35:10.45 5.35:10.6 5.4:10.6 5.4:10.75 5.45:10.75 5.45:10.85 5.5:10.85 5.5:11 6.4:11 6.4:10.85 6.45:10.85 6.45:10.7 6.5:10.7 6.5:10.6 6.55:10.6 6.55:10.45 6.6:10.45 6.6:10.3 6.65:10.3 6.65:10.15 6.7:10.15 6.7:10 6.75:10 6.75:9.85 6.8:9.85 6.8:9.7 6.85:9.7 6.85:9.55 6.9:9.55 6.9:9.4 6.95:9.4 6.95:9.25 7:9.25 7:9.1 7.05:9.1 7.05:8.95 7.1:8.95 7.1:8.8 7.15:8.8 7.15:8.65 7.2:8.65 7.2:8.5 7.25:8.5 7.25:8.35 7.3:8.35 7.3:8.2 7.35:8.2 7.35:8.05 7.4:8.05 7.4:7.9 7.45:7.9 7.45:7.75 7.5:7.75 7.5:7.6 7.55:7.6 7.55:7.45 7.6:7.45 7.6:7.3 7.65:7.3 7.65:7.15 7.7:7.15 7.7:7 7.75:7 7.75:6.85 7.8:6.85 7.8:12.6 7.75:12.6 7.75:12.7 7.7:12.7 7.7:12.85 7.65:12.85 7.65:13 7.6:13 7.6:13.15 7.55:13.15 7.55:13.25 7.5:13.25 7.5:13.4 7.45:13.4 7.45:13.55 7.4:13.55 7.4:13.7 7.35:13.7 7.35:13.85 7.3:13.85 7.3:13.95 7.25:13.95 7.25:14.1 7.2:14.1 7.2:14.25 7.15:14.25 7.15:14.3 4.95:14.3 4.95:14.25 4.9:14.25 4.9:14.1 4.85:14.1 4.85:14 4.8:14 4.8:13.85 4.75:13.85 4.75:13.7 4.7:13.7 4.7:13.6 4.65:13.6 4.65:13.45 4.6:13.45 4.6:13.3 4.55:13.3 4.55:13.2 4.5:13.2 4.5:13.05 4.45:13.05 4.45:12.9 4.4:12.9 4.4:12.8 4.35:12.8 4.35:12.65 4.3:12.65 4.3:12.5 4.25:12.5 4.25:12.4 4.2:12.4 4.2:12.25 4.15:12.25 4.15:12.1 4.1:12.1 4.1:12 4.05:12 4.05:11.85 4:11.85 4:11.7 3.95:11.7 3.95:11.6 3.9:11.6 3.9:11.45 3.85:11.45 3.85:11.3 3.8:11.3 3.8:11.2 3.75:11.2 3.75:11.05 3.7:11.05 3.7:10.9 3.65:10.9 3.65:10.8 3.6:10.8 3.6:10.65 3.55:10.65 3.55:10.5 3.5:10.5 3.5:10.4 3.45:10.4 3.45:10.25 3.4:10.25 3.4:10.1 3.35:10.1 3.35:10 3.3:10 3.3:9.85 3.25:9.85 3.25:9.7 3.2:9.7 3.2:9.6 3.15:9.6 3.15:9.45 3.1:9.45 3.1:9.3 3.05:9.3 3.05:9.2 3:9.2 3:9.05 2.95:9.05 2.95:8.9 2.9:8.9 2.9:8.8 2.85:8.8 2.85:8.65 2.8:8.65 2.8:8.55 2.75:8.55 2.75:8.4 2.7:8.4 2.7:8.25 2.65:8.25 2.65:8.15 2.6:8.15 2.6:8 2.55:8 2.55:7.85 2.5:7.85 2.5:7.75 2.45:7.75 2.45:7.6 2.4:7.6 2.4:7.45 2.35:7.45 2.35:7.35 2.3:7.35 2.3:7.2 2.25:7.2 2.25:7.05 2.2:7.05 2.2:6.95 2.15:6.95 2.15:6.8 2.1:6.8 2.1:6.65 2.05:6.65 2.05:6.55 2:6.55 2:6.4 1.95:6.4 1.95:6.25 1.9:6.25 1.9:6.15 1.85:6.15 1.85:6 1.8:6 1.8:5.85 1.75:5.85 1.75:5.75 1.7:5.75 1.7:5.6 1.65:5.6 1.65:5.45 1.6:5.45 1.6:5.35 1.55:5.35 1.55:5.2 1.5:5.2 1.5:5.05 1.45:5.05 1.45:4.95 1.4:4.95 1.4:4.8 1.35:4.8 1.35:4.65 1.3:4.65 1.3:4.55 1.25:4.55 1.25:4.4 1.2:4.4 1.2:4.25 1.15:4.25 1.15:4.15 1.1:4.15 1.1:4 1.05:4 1.05:3.85 1:3.85 1:3.75 0.95:3.75 0.95:3.6 0.9:3.6 0.9:3.45 0.85:3.45 0.85:3.35 0.8:3.35 0.8:3.2 0.75:3.2 0.75:3.05 0.7:3.05 0.7:2.95 0.65:2.95 0.65:2.8 0.6:2.8 0.6:2.7 0.55:2.7 0.55:2.55 0.5:2.55 0.5:2.4 0.45:2.4 0.45:2.3 0.4:2.3 0.4:2.15 0.35:2.15 0.35:2 0.3:2 0.3:1.9 0.25:1.9 0.25:1.75 0.2:1.75 0.2:1.6 0.15:1.6 0.15:1.5 0.1:1.5 0.1:1.35 0.05:1.35 0.05:1.2 0:1.2 0:0 1.6:0 1.6:0.15 1.65:0.15 1.65:0.3 1.7:0.3 1.7:0.45 1.75:0.45 1.75:0.6 1.8:0.6 1.8:0.7 1.85:0.7 1.85:0.85 1.9:0.85 1.9:1 1.95:1 1.95:1.15 2:1.15 2:1.3 2.05:1.3 2.05:1.4 2.1:1.4 2.1:1.55 2.15:1.55 2.15:1.7 2.2:1.7 2.2:1.85 2.25:1.85 2.25:2 2.3:2 2.3:2.1 2.35:2.1 2.35:2.25 2.4:2.25 2.4:2.4 2.45:2.4 2.45:2.55 2.5:2.55 2.5:2.7 2.55:2.7 2.55:2.8 2.6:2.8 2.6:2.95 2.65:2.95 2.65:3.1 2.7:3.1 2.7:3.25 2.75:3.25 2.75:3.4 2.8:3.4 2.8:3.5 2.85:3.5 2.85:3.65 2.9:3.65 2.9:3.8 2.95:3.8 2.95:3.95 3:3.95 3:4.1 3.05:4.1 3.05:4.15 8.8:4.15 8.8:4.1 8.85:4.1 8.85:3.95 8.9:3.95 8.9:3.8 8.95:3.8 8.95:3.65 9:3.65 9:3.5 9.05:3.5 9.05:3.35 9.1:3.35 9.1:3.2 9.15:3.2 9.15:3.05 9.2:3.05 9.2:2.9 9.25:2.9 9.25:2.75 9.3:2.75 9.3:2.65 9.35:2.65 9.35:2.5 9.4:2.5 9.4:2.35 9.45:2.35 9.45:2.2 9.5:2.2 9.5:2.05 9.55:2.05 9.55:1.9 9.6:1.9 9.6:1.75 9.65:1.75 9.65:1.6 9.7:1.6 9.7:1.45 9.75:1.45 9.75:1.3 9.8:1.3 9.8:1.15 9.85:1.15 9.85:1 9.9:1 9.9:0.85 9.95:0.85 9.95:0.7 10:0.7 10:0.55 10.05:0.55 10.05:0.4 10.1:0.4 10.1:0.25 10.15:0.25 10.15:0.1 10.2:0.1 10.2:0 11.95:0)
letterShapes["B"] = (list 11:5 10.95:5 10.95:5.25 10.9:5.25 10.9:5.4 10.85:5.4 10.85:5.55 10.8:5.55 10.8:5.7 10.75:5.7 10.75:5.8 10.7:5.8 10.7:5.95 10.65:5.95 10.65:6.05 10.6:6.05 10.6:6.1 10.55:6.1 10.55:6.2 10.5:6.2 10.5:6.25 10.45:6.25 10.45:6.35 10.4:6.35 10.4:6.4 10.35:6.4 10.35:6.45 10.3:6.45 10.3:6.55 10.25:6.55 10.25:6.6 10.2:6.6 10.2:6.65 10.15:6.65 10.15:6.7 10.1:6.7 10.1:6.75 10.05:6.75 10.05:6.8 10:6.8 10:6.85 9.95:6.85 9.95:6.9 9.85:6.9 9.85:6.95 9.8:6.95 9.8:7 9.75:7 9.75:7.05 9.7:7.05 9.7:7.1 9.6:7.1 9.6:7.15 9.5:7.15 9.5:7.2 9.45:7.2 9.45:7.25 9.35:7.25 9.35:7.3 9.25:7.3 9.25:8.25 9.3:8.25 9.3:8.3 9.35:8.3 9.35:8.35 9.4:8.35 9.4:8.4 9.45:8.4 9.45:8.45 9.5:8.45 9.5:8.5 9.55:8.5 9.55:8.55 9.6:8.55 9.6:8.6 9.65:8.6 9.65:8.65 9.7:8.65 9.7:8.7 9.75:8.7 9.75:8.8 9.8:8.8 9.8:8.85 9.85:8.85 9.85:8.95 9.9:8.95 9.9:9.05 9.95:9.05 9.95:9.1 10:9.1 10:9.2 10.05:9.2 10.05:9.35 10.1:9.35 10.1:9.45 10.15:9.45 10.15:9.6 10.2:9.6 10.2:9.75 10.25:9.75 10.25:10 10.3:10 10.3:11.45 10.25:11.45 10.25:11.65 10.2:11.65 10.2:11.85 10.15:11.85 10.15:11.95 10.1:11.95 10.1:12.1 10.05:12.1 10.05:12.2 10:12.2 10:12.35 9.95:12.35 9.95:12.45 9.9:12.45 9.9:12.5 9.85:12.5 9.85:12.6 9.8:12.6 9.8:12.7 9.75:12.7 9.75:12.75 9.7:12.75 9.7:12.8 9.65:12.8 9.65:12.9 9.6:12.9 9.6:12.95 9.55:12.95 9.55:13 9.5:13 9.5:13.05 9.45:13.05 9.45:13.1 9.4:13.1 9.4:13.15 9.35:13.15 9.35:13.2 9.3:13.2 9.3:13.25 9.25:13.25 9.25:13.3 9.2:13.3 9.2:13.35 9.15:13.35 9.15:13.4 9.1:13.4 9.1:13.45 9.05:13.45 9.05:3.5 9:3.5 9:3.3 8.95:3.3 8.95:3.2 8.9:3.2 8.9:3.05 8.85:3.05 8.85:2.95 8.8:2.95 8.8:2.85 8.75:2.85 8.75:2.8 8.7:2.8 8.7:2.7 8.65:2.7 8.65:2.65 8.6:2.65 8.6:2.55 8.55:2.55 8.55:2.5 8.5:2.5 8.5:2.45 8.45:2.45 8.45:2.4 8.4:2.4 8.4:2.35 8.35:2.35 8.35:2.3 8.3:2.3 8.3:2.25 8.25:2.25 8.25:2.2 8.15:2.2 8.15:2.15 8.1:2.15 8.1:2.1 8:2.1 8:2.05 7.95:2.05 7.95:2 7.85:2 7.85:1.95 7.75:1.95 7.75:1.9 7.65:1.9 7.65:1.85 7.5:1.85 7.5:1.8 7.35:1.8 7.35:1.75 7.15:1.75 7.15:1.7 6.9:1.7 6.9:1.65 6.55:1.65 6.55:1.6 1.9:1.6 1.9:6.65 6.4:6.65 6.4:6.6 6.8:6.6 6.8:6.55 7.1:6.55 7.1:6.5 7.3:6.5 7.3:6.45 7.5:6.45 7.5:6.4 7.6:6.4 7.6:6.35 7.75:6.35 7.75:6.3 7.85:6.3 7.85:6.25 7.95:6.25 7.95:6.2 8.05:6.2 8.05:6.15 8.15:6.15 8.15:6.1 8.2:6.1 8.2:6.05 8.3:6.05 8.3:6 8.35:6 8.35:5.95 8.4:5.95 8.4:5.9 8.45:5.9 8.45:5.85 8.5:5.85 8.5:5.8 8.55:5.8 8.55:5.75 8.6:5.75 8.6:5.7 8.65:5.7 8.65:5.65 8.7:5.65 8.7:5.55 8.75:5.55 8.75:5.5 8.8:5.5 8.8:5.4 8.85:5.4 8.85:5.3 8.9:5.3 8.9:5.2 8.95:5.2 8.95:5.05 9:5.05 9:4.9 9.05:4.9 9.05:13.5 8.95:13.5 8.95:13.55 8.9:13.55 8.9:13.6 8.8:13.6 8.8:13.65 8.75:13.65 8.75:13.7 8.65:13.7 8.65:13.75 8.55:13.75 8.55:13.8 8.45:13.8 8.45:13.85 8.35:13.85 8.35:9.85 8.3:9.85 8.3:9.65 8.25:9.65 8.25:9.55 8.2:9.55 8.2:9.4 8.15:9.4 8.15:9.3 8.1:9.3 8.1:9.25 8.05:9.25 8.05:9.15 8:9.15 8:9.1 7.95:9.1 7.95:9.05 7.9:9.05 7.9:9 7.85:9 7.85:8.95 7.8:8.95 7.8:8.9 7.75:8.9 7.75:8.85 7.7:8.85 7.7:8.8 7.65:8.8 7.65:8.75 7.55:8.75 7.55:8.7 7.5:8.7 7.5:8.65 7.4:8.65 7.4:8.6 7.3:8.6 7.3:8.55 7.2:8.55 7.2:8.5 7.05:8.5 7.05:8.45 6.9:8.45 6.9:8.4 6.7:8.4 6.7:8.35 6.45:8.35 6.45:8.3 6.1:8.3 6.1:8.25 1.9:8.25 1.9:12.65 6.05:12.65 6.05:12.6 6.45:12.6 6.45:12.55 6.75:12.55 6.75:12.5 6.95:12.5 6.95:12.45 7.1:12.45 7.1:12.4 7.2:12.4 7.2:12.35 7.35:12.35 7.35:12.3 7.45:12.3 7.45:12.25 7.55:12.25 7.55:12.2 7.6:12.2 7.6:12.15 7.7:12.15 7.7:12.1 7.75:12.1 7.75:12.05 7.8:12.05 7.8:12 7.9:12 7.9:11.9 7.95:11.9 7.95:11.85 8:11.85 8:11.8 8.05:11.8 8.05:11.75 8.1:11.75 8.1:11.65 8.15:11.65 8.15:11.6 8.2:11.6 8.2:11.5 8.25:11.5 8.25:11.35 8.3:11.35 8.3:11.2 8.35:11.2 8.35:13.9 8.25:13.9 8.25:13.95 8.15:13.95 8.15:14 8:14 8:14.05 7.85:14.05 7.85:14.1 7.7:14.1 7.7:14.15 7.45:14.15 7.45:14.2 7.25:14.2 7.25:14.25 6.8:14.25 6.8:14.3 0:14.3 0:0 7.15:0 7.15:0.05 7.45:0.05 7.45:0.1 7.7:0.1 7.7:0.15 7.9:0.15 7.9:0.2 8.05:0.2 8.05:0.25 8.2:0.25 8.2:0.3 8.35:0.3 8.35:0.35 8.45:0.35 8.45:0.4 8.6:0.4 8.6:0.45 8.7:0.45 8.7:0.5 8.8:0.5 8.8:0.55 8.9:0.55 8.9:0.6 9:0.6 9:0.65 9.1:0.65 9.1:0.7 9.15:0.7 9.15:0.75 9.25:0.75 9.25:0.8 9.3:0.8 9.3:0.85 9.4:0.85 9.4:0.9 9.45:0.9 9.45:0.95 9.5:0.95 9.5:1 9.6:1 9.6:1.05 9.65:1.05 9.65:1.1 9.7:1.1 9.7:1.15 9.75:1.15 9.75:1.2 9.8:1.2 9.8:1.25 9.85:1.25 9.85:1.3 9.9:1.3 9.9:1.35 9.95:1.35 9.95:1.4 10:1.4 10:1.45 10.05:1.45 10.05:1.5 10.1:1.5 10.1:1.55 10.15:1.55 10.15:1.6 10.2:1.6 10.2:1.7 10.25:1.7 10.25:1.75 10.3:1.75 10.3:1.8 10.35:1.8 10.35:1.9 10.4:1.9 10.4:1.95 10.45:1.95 10.45:2.05 10.5:2.05 10.5:2.15 10.55:2.15 10.55:2.25 10.6:2.25 10.6:2.35 10.65:2.35 10.65:2.45 10.7:2.45 10.7:2.55 10.75:2.55 10.75:2.7 10.8:2.7 10.8:2.8 10.85:2.8 10.85:2.95 10.9:2.95 10.9:3.2 10.95:3.2 10.95:3.4 11:3.4)
letterShapes["C"] = (list 11.8:5.3 10.25:5.3 10.25:5.1 10.2:5.1 10.2:4.9 10.15:4.9 10.15:4.7 10.1:4.7 10.1:4.55 10.05:4.55 10.05:4.4 10:4.4 10:4.25 9.95:4.25 9.95:4.1 9.9:4.1 9.9:4 9.85:4 9.85:3.85 9.8:3.85 9.8:3.75 9.75:3.75 9.75:3.65 9.7:3.65 9.7:3.55 9.65:3.55 9.65:3.5 9.6:3.5 9.6:3.4 9.55:3.4 9.55:3.3 9.5:3.3 9.5:3.25 9.45:3.25 9.45:3.15 9.4:3.15 9.4:3.1 9.35:3.1 9.35:3 9.3:3 9.3:2.95 9.25:2.95 9.25:2.9 9.2:2.9 9.2:2.85 9.15:2.85 9.15:2.75 9.1:2.75 9.1:2.7 9.05:2.7 9.05:2.65 9:2.65 9:2.6 8.95:2.6 8.95:2.55 8.9:2.55 8.9:2.5 8.85:2.5 8.85:2.45 8.8:2.45 8.8:2.4 8.7:2.4 8.7:2.35 8.65:2.35 8.65:2.3 8.6:2.3 8.6:2.25 8.55:2.25 8.55:2.2 8.45:2.2 8.45:2.15 8.4:2.15 8.4:2.1 8.3:2.1 8.3:2.05 8.2:2.05 8.2:2 8.1:2 8.1:1.95 8.05:1.95 8.05:1.9 7.9:1.9 7.9:1.85 7.8:1.85 7.8:1.8 7.7:1.8 7.7:1.75 7.55:1.75 7.55:1.7 7.35:1.7 7.35:1.65 7.15:1.65 7.15:1.6 6.85:1.6 6.85:1.55 5.75:1.55 5.75:1.6 5.4:1.6 5.4:1.65 5.15:1.65 5.15:1.7 4.95:1.7 4.95:1.75 4.75:1.75 4.75:1.8 4.6:1.8 4.6:1.85 4.5:1.85 4.5:1.9 4.35:1.9 4.35:1.95 4.25:1.95 4.25:2 4.15:2 4.15:2.05 4.05:2.05 4.05:2.1 4:2.1 4:2.15 3.9:2.15 3.9:2.2 3.8:2.2 3.8:2.25 3.75:2.25 3.75:2.3 3.7:2.3 3.7:2.35 3.6:2.35 3.6:2.4 3.55:2.4 3.55:2.45 3.5:2.45 3.5:2.5 3.4:2.5 3.4:2.55 3.35:2.55 3.35:2.6 3.3:2.6 3.3:2.65 3.25:2.65 3.25:2.7 3.2:2.7 3.2:2.75 3.15:2.75 3.15:2.8 3.1:2.8 3.1:2.9 3.05:2.9 3.05:2.95 3:2.95 3:3 2.95:3 2.95:3.05 2.9:3.05 2.9:3.15 2.85:3.15 2.85:3.2 2.8:3.2 2.8:3.3 2.75:3.3 2.75:3.35 2.7:3.35 2.7:3.45 2.65:3.45 2.65:3.55 2.6:3.55 2.6:3.6 2.55:3.6 2.55:3.7 2.5:3.7 2.5:3.85 2.45:3.85 2.45:3.95 2.4:3.95 2.4:4.05 2.35:4.05 2.35:4.2 2.3:4.2 2.3:4.3 2.25:4.3 2.25:4.45 2.2:4.45 2.2:4.65 2.15:4.65 2.15:4.8 2.1:4.8 2.1:5 2.05:5 2.05:5.25 2:5.25 2:5.5 1.95:5.5 1.95:5.9 1.9:5.9 1.9:6.45 1.85:6.45 1.85:7.9 1.9:7.9 1.9:8.35 1.95:8.35 1.95:8.65 2:8.65 2:8.9 2.05:8.9 2.05:9.1 2.1:9.1 2.1:9.3 2.15:9.3 2.15:9.45 2.2:9.45 2.2:9.6 2.25:9.6 2.25:9.75 2.3:9.75 2.3:9.9 2.35:9.9 2.35:10 2.4:10 2.4:10.1 2.45:10.1 2.45:10.2 2.5:10.2 2.5:10.3 2.55:10.3 2.55:10.4 2.6:10.4 2.6:10.5 2.65:10.5 2.65:10.6 2.7:10.6 2.7:10.65 2.75:10.65 2.75:10.75 2.8:10.75 2.8:10.8 2.85:10.8 2.85:10.9 2.9:10.9 2.9:10.95 2.95:10.95 2.95:11 3:11 3:11.1 3.05:11.1 3.05:11.15 3.1:11.15 3.1:11.2 3.15:11.2 3.15:11.25 3.2:11.25 3.2:11.3 3.25:11.3 3.25:11.35 3.3:11.35 3.3:11.4 3.35:11.4 3.35:11.45 3.4:11.45 3.4:11.5 3.45:11.5 3.45:11.55 3.5:11.55 3.5:11.6 3.55:11.6 3.55:11.65 3.6:11.65 3.6:11.7 3.65:11.7 3.65:11.75 3.75:11.75 3.75:11.8 3.8:11.8 3.8:11.85 3.85:11.85 3.85:11.9 3.95:11.9 3.95:11.95 4.05:11.95 4.05:12 4.1:12 4.1:12.05 4.2:12.05 4.2:12.1 4.3:12.1 4.3:12.15 4.4:12.15 4.4:12.2 4.5:12.2 4.5:12.25 4.6:12.25 4.6:12.3 4.75:12.3 4.75:12.35 4.9:12.35 4.9:12.4 5.05:12.4 5.05:12.45 5.25:12.45 5.25:12.5 5.45:12.5 5.45:12.55 5.8:12.55 5.8:12.6 6.9:12.6 6.9:12.55 7.25:12.55 7.25:12.5 7.5:12.5 7.5:12.45 7.7:12.45 7.7:12.4 7.85:12.4 7.85:12.35 8:12.35 8:12.3 8.15:12.3 8.15:12.25 8.25:12.25 8.25:12.2 8.35:12.2 8.35:12.15 8.45:12.15 8.45:12.1 8.55:12.1 8.55:12.05 8.65:12.05 8.65:12 8.7:12 8.7:11.95 8.8:11.95 8.8:11.9 8.85:11.9 8.85:11.85 8.9:11.85 8.9:11.8 9:11.8 9:11.75 9.05:11.75 9.05:11.7 9.1:11.7 9.1:11.65 9.15:11.65 9.15:11.6 9.2:11.6 9.2:11.55 9.25:11.55 9.25:11.5 9.3:11.5 9.3:11.45 9.35:11.45 9.35:11.4 9.4:11.4 9.4:11.35 9.45:11.35 9.45:11.25 9.5:11.25 9.5:11.2 9.55:11.2 9.55:11.1 9.6:11.1 9.6:11.05 9.65:11.05 9.65:10.95 9.7:10.95 9.7:10.9 9.75:10.9 9.75:10.8 9.8:10.8 9.8:10.7 9.85:10.7 9.85:10.6 9.9:10.6 9.9:10.45 9.95:10.45 9.95:10.35 10:10.35 10:10.2 10.05:10.2 10.05:10 10.1:10 10.1:9.8 11.65:9.8 11.65:11 11.6:11 11.6:11.1 11.55:11.1 11.55:11.2 11.5:11.2 11.5:11.35 11.45:11.35 11.45:11.45 11.4:11.45 11.4:11.55 11.35:11.55 11.35:11.6 11.3:11.6 11.3:11.7 11.25:11.7 11.25:11.8 11.2:11.8 11.2:11.9 11.15:11.9 11.15:11.95 11.1:11.95 11.1:12 11.05:12 11.05:12.1 11:12.1 11:12.15 10.95:12.15 10.95:12.25 10.9:12.25 10.9:12.3 10.85:12.3 10.85:12.35 10.8:12.35 10.8:12.4 10.75:12.4 10.75:12.45 10.7:12.45 10.7:12.55 10.65:12.55 10.65:12.6 10.6:12.6 10.6:12.65 10.55:12.65 10.55:12.7 10.5:12.7 10.5:12.75 10.45:12.75 10.45:12.8 10.4:12.8 10.4:12.85 10.3:12.85 10.3:12.9 10.25:12.9 10.25:12.95 10.2:12.95 10.2:13 10.15:13 10.15:13.05 10.1:13.05 10.1:13.1 10:13.1 10:13.15 9.95:13.15 9.95:13.2 9.9:13.2 9.9:13.25 9.8:13.25 9.8:13.3 9.7:13.3 9.7:13.35 9.65:13.35 9.65:13.4 9.55:13.4 9.55:13.45 9.5:13.45 9.5:13.5 9.4:13.5 9.4:13.55 9.3:13.55 9.3:13.6 9.2:13.6 9.2:13.65 9.1:13.65 9.1:13.7 9:13.7 9:13.75 8.85:13.75 8.85:13.8 8.75:13.8 8.75:13.85 8.6:13.85 8.6:13.9 8.45:13.9 8.45:13.95 8.3:13.95 8.3:14 8.1:14 8.1:14.05 7.9:14.05 7.9:14.1 7.65:14.1 7.65:14.15 7.3:14.15 7.3:14.2 5.3:14.2 5.3:14.15 5:14.15 5:14.1 4.75:14.1 4.75:14.05 4.55:14.05 4.55:14 4.35:14 4.35:13.95 4.2:13.95 4.2:13.9 4.05:13.9 4.05:13.85 3.9:13.85 3.9:13.8 3.75:13.8 3.75:13.75 3.65:13.75 3.65:13.7 3.55:13.7 3.55:13.65 3.45:13.65 3.45:13.6 3.35:13.6 3.35:13.55 3.25:13.55 3.25:13.5 3.15:13.5 3.15:13.45 3.05:13.45 3.05:13.4 2.95:13.4 2.95:13.35 2.9:13.35 2.9:13.3 2.8:13.3 2.8:13.25 2.75:13.25 2.75:13.2 2.65:13.2 2.65:13.15 2.6:13.15 2.6:13.1 2.5:13.1 2.5:13.05 2.45:13.05 2.45:13 2.4:13 2.4:12.95 2.35:12.95 2.35:12.9 2.3:12.9 2.3:12.85 2.2:12.85 2.2:12.8 2.15:12.8 2.15:12.75 2.1:12.75 2.1:12.7 2.05:12.7 2.05:12.65 2:12.65 2:12.6 1.95:12.6 1.95:12.55 1.9:12.55 1.9:12.5 1.85:12.5 1.85:12.45 1.8:12.45 1.8:12.4 1.75:12.4 1.75:12.35 1.7:12.35 1.7:12.3 1.65:12.3 1.65:12.25 1.6:12.25 1.6:12.2 1.55:12.2 1.55:12.1 1.5:12.1 1.5:12.05 1.45:12.05 1.45:12 1.4:12 1.4:11.95 1.35:11.95 1.35:11.85 1.3:11.85 1.3:11.8 1.25:11.8 1.25:11.75 1.2:11.75 1.2:11.65 1.15:11.65 1.15:11.55 1.1:11.55 1.1:11.5 1.05:11.5 1.05:11.4 1:11.4 1:11.35 0.95:11.35 0.95:11.25 0.9:11.25 0.9:11.15 0.85:11.15 0.85:11.05 0.8:11.05 0.8:10.95 0.75:10.95 0.75:10.85 0.7:10.85 0.7:10.75 0.65:10.75 0.65:10.65 0.6:10.65 0.6:10.5 0.55:10.5 0.55:10.4 0.5:10.4 0.5:10.25 0.45:10.25 0.45:10.15 0.4:10.15 0.4:10 0.35:10 0.35:9.8 0.3:9.8 0.3:9.65 0.25:9.65 0.25:9.45 0.2:9.45 0.2:9.25 0.15:9.25 0.15:9 0.1:9 0.1:8.75 0.05:8.75 0.05:8.35 0:8.35 0:5.8 0.05:5.8 0.05:5.4 0.1:5.4 0.1:5.15 0.15:5.15 0.15:4.85 0.2:4.85 0.2:4.65 0.25:4.65 0.25:4.45 0.3:4.45 0.3:4.3 0.35:4.3 0.35:4.1 0.4:4.1 0.4:3.95 0.45:3.95 0.45:3.8 0.5:3.8 0.5:3.7 0.55:3.7 0.55:3.55 0.6:3.55 0.6:3.45 0.65:3.45 0.65:3.3 0.7:3.3 0.7:3.2 0.75:3.2 0.75:3.1 0.8:3.1 0.8:3 0.85:3 0.85:2.9 0.9:2.9 0.9:2.8 0.95:2.8 0.95:2.75 1:2.75 1:2.65 1.05:2.65 1.05:2.55 1.1:2.55 1.1:2.5 1.15:2.5 1.15:2.4 1.2:2.4 1.2:2.35 1.25:2.35 1.25:2.25 1.3:2.25 1.3:2.2 1.35:2.2 1.35:2.15 1.4:2.15 1.4:2.05 1.45:2.05 1.45:2 1.5:2 1.5:1.95 1.55:1.95 1.55:1.9 1.6:1.9 1.6:1.8 1.65:1.8 1.65:1.75 1.7:1.75 1.7:1.7 1.75:1.7 1.75:1.65 1.8:1.65 1.8:1.6 1.85:1.6 1.85:1.55 1.9:1.55 1.9:1.5 1.95:1.5 1.95:1.45 2:1.45 2:1.4 2.05:1.4 2.05:1.35 2.1:1.35 2.1:1.3 2.15:1.3 2.15:1.25 2.25:1.25 2.25:1.2 2.3:1.2 2.3:1.15 2.35:1.15 2.35:1.1 2.4:1.1 2.4:1.05 2.5:1.05 2.5:1 2.55:1 2.55:0.95 2.65:0.95 2.65:0.9 2.7:0.9 2.7:0.85 2.8:0.85 2.8:0.8 2.85:0.8 2.85:0.75 2.95:0.75 2.95:0.7 3.05:0.7 3.05:0.65 3.15:0.65 3.15:0.6 3.2:0.6 3.2:0.55 3.3:0.55 3.3:0.5 3.4:0.5 3.4:0.45 3.55:0.45 3.55:0.4 3.65:0.4 3.65:0.35 3.75:0.35 3.75:0.3 3.9:0.3 3.9:0.25 4.05:0.25 4.05:0.2 4.2:0.2 4.2:0.15 4.35:0.15 4.35:0.1 4.6:0.1 4.6:0.05 4.85:0.05 4.85:0 7.35:0 7.35:0.05 7.6:0.05 7.6:0.1 7.8:0.1 7.8:0.15 8:0.15 8:0.2 8.15:0.2 8.15:0.25 8.3:0.25 8.3:0.3 8.45:0.3 8.45:0.35 8.55:0.35 8.55:0.4 8.7:0.4 8.7:0.45 8.8:0.45 8.8:0.5 8.9:0.5 8.9:0.55 9:0.55 9:0.6 9.1:0.6 9.1:0.65 9.2:0.65 9.2:0.7 9.3:0.7 9.3:0.75 9.35:0.75 9.35:0.8 9.45:0.8 9.45:0.85 9.5:0.85 9.5:0.9 9.6:0.9 9.6:0.95 9.65:0.95 9.65:1 9.75:1 9.75:1.05 9.8:1.05 9.8:1.1 9.85:1.1 9.85:1.15 9.95:1.15 9.95:1.2 10:1.2 10:1.25 10.05:1.25 10.05:1.3 10.1:1.3 10.1:1.35 10.15:1.35 10.15:1.4 10.2:1.4 10.2:1.45 10.25:1.45 10.25:1.5 10.3:1.5 10.3:1.55 10.35:1.55 10.35:1.6 10.4:1.6 10.4:1.65 10.45:1.65 10.45:1.7 10.5:1.7 10.5:1.75 10.55:1.75 10.55:1.8 10.6:1.8 10.6:1.85 10.65:1.85 10.65:1.9 10.7:1.9 10.7:1.95 10.75:1.95 10.75:2.05 10.8:2.05 10.8:2.1 10.85:2.1 10.85:2.15 10.9:2.15 10.9:2.25 10.95:2.25 10.95:2.3 11:2.3 11:2.4 11.05:2.4 11.05:2.45 11.1:2.45 11.1:2.55 11.15:2.55 11.15:2.65 11.2:2.65 11.2:2.7 11.25:2.7 11.25:2.8 11.3:2.8 11.3:2.9 11.35:2.9 11.35:3 11.4:3 11.4:3.1 11.45:3.1 11.45:3.2 11.5:3.2 11.5:3.35 11.55:3.35 11.55:3.45 11.6:3.45 11.6:3.6 11.65:3.6 11.65:3.75 11.7:3.75 11.7:3.85 11.75:3.85 11.75:4.05 11.8:4.05)
letterShapes["D"] = (list 11.85:8.05 11.8:8.05 11.8:8.55 11.75:8.55 11.75:8.9 11.7:8.9 11.7:9.2 11.65:9.2 11.65:9.45 11.6:9.45 11.6:9.65 11.55:9.65 11.55:9.8 11.5:9.8 11.5:10 11.45:10 11.45:10.2 11.4:10.2 11.4:10.3 11.35:10.3 11.35:10.45 11.3:10.45 11.3:10.6 11.25:10.6 11.25:10.7 11.2:10.7 11.2:10.85 11.15:10.85 11.15:10.95 11.1:10.95 11.1:11.05 11.05:11.05 11.05:11.15 11:11.15 11:11.25 10.95:11.25 10.95:11.35 10.9:11.35 10.9:11.45 10.85:11.45 10.85:11.5 10.8:11.5 10.8:11.6 10.75:11.6 10.75:11.7 10.7:11.7 10.7:11.75 10.65:11.75 10.65:11.85 10.6:11.85 10.6:11.9 10.55:11.9 10.55:12 10.5:12 10.5:12.05 10.45:12.05 10.45:12.1 10.4:12.1 10.4:12.2 10.35:12.2 10.35:12.25 10.3:12.25 10.3:12.3 10.25:12.3 10.25:12.35 10.2:12.35 10.2:12.4 10.15:12.4 10.15:12.5 10.1:12.5 10.1:12.55 10.05:12.55 10.05:12.6 10:12.6 10:12.65 9.95:12.65 9.95:12.7 9.9:12.7 9.9:12.75 9.85:12.75 9.85:6.5 9.8:6.5 9.8:5.95 9.75:5.95 9.75:5.6 9.7:5.6 9.7:5.3 9.65:5.3 9.65:5.1 9.6:5.1 9.6:4.9 9.55:4.9 9.55:4.7 9.5:4.7 9.5:4.55 9.45:4.55 9.45:4.4 9.4:4.4 9.4:4.25 9.35:4.25 9.35:4.15 9.3:4.15 9.3:4.05 9.25:4.05 9.25:3.9 9.2:3.9 9.2:3.8 9.15:3.8 9.15:3.7 9.1:3.7 9.1:3.6 9.05:3.6 9.05:3.55 9:3.55 9:3.45 8.95:3.45 8.95:3.35 8.9:3.35 8.9:3.3 8.85:3.3 8.85:3.2 8.8:3.2 8.8:3.15 8.75:3.15 8.75:3.05 8.7:3.05 8.7:3 8.65:3 8.65:2.95 8.6:2.95 8.6:2.9 8.55:2.9 8.55:2.85 8.5:2.85 8.5:2.75 8.45:2.75 8.45:2.7 8.4:2.7 8.4:2.65 8.35:2.65 8.35:2.6 8.3:2.6 8.3:2.55 8.2:2.55 8.2:2.5 8.15:2.5 8.15:2.45 8.1:2.45 8.1:2.4 8.05:2.4 8.05:2.35 8:2.35 8:2.3 7.9:2.3 7.9:2.25 7.85:2.25 7.85:2.2 7.75:2.2 7.75:2.15 7.7:2.15 7.7:2.1 7.6:2.1 7.6:2.05 7.5:2.05 7.5:2 7.4:2 7.4:1.95 7.3:1.95 7.3:1.9 7.15:1.9 7.15:1.85 7.05:1.85 7.05:1.8 6.9:1.8 6.9:1.75 6.7:1.75 6.7:1.7 6.45:1.7 6.45:1.65 6.15:1.65 6.15:1.6 1.9:1.6 1.9:12.65 6.05:12.65 6.05:12.6 6.4:12.6 6.4:12.55 6.65:12.55 6.65:12.5 6.85:12.5 6.85:12.45 7:12.45 7:12.4 7.15:12.4 7.15:12.35 7.3:12.35 7.3:12.3 7.4:12.3 7.4:12.25 7.5:12.25 7.5:12.2 7.6:12.2 7.6:12.15 7.7:12.15 7.7:12.1 7.75:12.1 7.75:12.05 7.85:12.05 7.85:12 7.9:12 7.9:11.95 8:11.95 8:11.9 8.05:11.9 8.05:11.85 8.15:11.85 8.15:11.8 8.2:11.8 8.2:11.75 8.25:11.75 8.25:11.7 8.3:11.7 8.3:11.65 8.35:11.65 8.35:11.6 8.4:11.6 8.4:11.55 8.45:11.55 8.45:11.5 8.5:11.5 8.5:11.45 8.55:11.45 8.55:11.4 8.6:11.4 8.6:11.35 8.65:11.35 8.65:11.3 8.7:11.3 8.7:11.25 8.75:11.25 8.75:11.15 8.8:11.15 8.8:11.1 8.85:11.1 8.85:11.05 8.9:11.05 8.9:10.95 8.95:10.95 8.95:10.9 9:10.9 9:10.8 9.05:10.8 9.05:10.7 9.1:10.7 9.1:10.6 9.15:10.6 9.15:10.55 9.2:10.55 9.2:10.4 9.25:10.4 9.25:10.3 9.3:10.3 9.3:10.2 9.35:10.2 9.35:10.1 9.4:10.1 9.4:9.95 9.45:9.95 9.45:9.8 9.5:9.8 9.5:9.65 9.55:9.65 9.55:9.45 9.6:9.45 9.6:9.25 9.65:9.25 9.65:9.05 9.7:9.05 9.7:8.75 9.75:8.75 9.75:8.45 9.8:8.45 9.8:7.9 9.85:7.9 9.85:12.8 9.8:12.8 9.8:12.85 9.75:12.85 9.75:12.9 9.65:12.9 9.65:12.95 9.6:12.95 9.6:13 9.55:13 9.55:13.05 9.5:13.05 9.5:13.1 9.45:13.1 9.45:13.15 9.35:13.15 9.35:13.2 9.3:13.2 9.3:13.25 9.2:13.25 9.2:13.3 9.15:13.3 9.15:13.35 9.05:13.35 9.05:13.4 9:13.4 9:13.45 8.9:13.45 8.9:13.5 8.85:13.5 8.85:13.55 8.75:13.55 8.75:13.6 8.65:13.6 8.65:13.65 8.55:13.65 8.55:13.7 8.45:13.7 8.45:13.75 8.35:13.75 8.35:13.8 8.25:13.8 8.25:13.85 8.1:13.85 8.1:13.9 7.95:13.9 7.95:13.95 7.85:13.95 7.85:14 7.7:14 7.7:14.05 7.5:14.05 7.5:14.1 7.35:14.1 7.35:14.15 7.1:14.15 7.1:14.2 6.8:14.2 6.8:14.25 6.35:14.25 6.35:14.3 0:14.3 0:0 6.75:0 6.75:0.05 7.05:0.05 7.05:0.1 7.3:0.1 7.3:0.15 7.5:0.15 7.5:0.2 7.65:0.2 7.65:0.25 7.8:0.25 7.8:0.3 7.95:0.3 7.95:0.35 8.1:0.35 8.1:0.4 8.2:0.4 8.2:0.45 8.3:0.45 8.3:0.5 8.45:0.5 8.45:0.55 8.5:0.55 8.5:0.6 8.6:0.6 8.6:0.65 8.7:0.65 8.7:0.7 8.8:0.7 8.8:0.75 8.9:0.75 8.9:0.8 8.95:0.8 8.95:0.85 9.05:0.85 9.05:0.9 9.1:0.9 9.1:0.95 9.2:0.95 9.2:1 9.25:1 9.25:1.05 9.3:1.05 9.3:1.1 9.4:1.1 9.4:1.15 9.45:1.15 9.45:1.2 9.5:1.2 9.5:1.25 9.55:1.25 9.55:1.3 9.6:1.3 9.6:1.35 9.65:1.35 9.65:1.4 9.75:1.4 9.75:1.45 9.8:1.45 9.8:1.5 9.85:1.5 9.85:1.55 9.9:1.55 9.9:1.65 9.95:1.65 9.95:1.7 10:1.7 10:1.75 10.05:1.75 10.05:1.8 10.1:1.8 10.1:1.85 10.15:1.85 10.15:1.9 10.2:1.9 10.2:2 10.25:2 10.25:2.05 10.3:2.05 10.3:2.1 10.35:2.1 10.35:2.2 10.4:2.2 10.4:2.25 10.45:2.25 10.45:2.3 10.5:2.3 10.5:2.4 10.55:2.4 10.55:2.45 10.6:2.45 10.6:2.55 10.65:2.55 10.65:2.65 10.7:2.65 10.7:2.7 10.75:2.7 10.75:2.8 10.8:2.8 10.8:2.9 10.85:2.9 10.85:2.95 10.9:2.95 10.9:3.1 10.95:3.1 10.95:3.2 11:3.2 11:3.3 11.05:3.3 11.05:3.4 11.1:3.4 11.1:3.5 11.15:3.5 11.15:3.6 11.2:3.6 11.2:3.75 11.25:3.75 11.25:3.9 11.3:3.9 11.3:4.05 11.35:4.05 11.35:4.15 11.4:4.15 11.4:4.35 11.45:4.35 11.45:4.5 11.5:4.5 11.5:4.7 11.55:4.7 11.55:4.9 11.6:4.9 11.6:5.15 11.65:5.15 11.65:5.4 11.7:5.4 11.7:5.7 11.75:5.7 11.75:6.05 11.8:6.05 11.8:6.6 11.85:6.6)
letterShapes["E"] = (list 10.55:1.65 1.9:1.65 1.9:6.5 9.75:6.5 9.75:8.2 1.9:8.2 1.9:12.6 10.4:12.6 10.4:14.3 0:14.3 0:0 10.55:0)
letterShapes["F"] = (list 9.9:14.3 0:14.3 0:0 1.9:0 1.9:6.5 8.95:6.5 8.95:8.2 1.9:8.2 1.9:12.6 9.9:12.6)
letterShapes["G"] = (list 13.05:7.95 6.75:7.95 6.75:6.3 11.2:6.3 11.2:5.2 11.15:5.2 11.15:4.9 11.1:4.9 11.1:4.65 11.05:4.65 11.05:4.5 11:4.5 11:4.35 10.95:4.35 10.95:4.2 10.9:4.2 10.9:4.05 10.85:4.05 10.85:3.95 10.8:3.95 10.8:3.85 10.75:3.85 10.75:3.75 10.7:3.75 10.7:3.65 10.65:3.65 10.65:3.6 10.6:3.6 10.6:3.5 10.55:3.5 10.55:3.4 10.5:3.4 10.5:3.35 10.45:3.35 10.45:3.3 10.4:3.3 10.4:3.2 10.35:3.2 10.35:3.15 10.3:3.15 10.3:3.1 10.25:3.1 10.25:3.05 10.2:3.05 10.2:3 10.15:3 10.15:2.9 10.1:2.9 10.1:2.85 10:2.85 10:2.8 9.95:2.8 9.95:2.75 9.9:2.75 9.9:2.7 9.85:2.7 9.85:2.65 9.8:2.65 9.8:2.6 9.75:2.6 9.75:2.55 9.7:2.55 9.7:2.5 9.6:2.5 9.6:2.45 9.55:2.45 9.55:2.4 9.5:2.4 9.5:2.35 9.4:2.35 9.4:2.3 9.35:2.3 9.35:2.25 9.25:2.25 9.25:2.2 9.15:2.2 9.15:2.15 9.1:2.15 9.1:2.1 9:2.1 9:2.05 8.9:2.05 8.9:2 8.75:2 8.75:1.95 8.65:1.95 8.65:1.9 8.5:1.9 8.5:1.85 8.35:1.85 8.35:1.8 8.2:1.8 8.2:1.75 8:1.75 8:1.7 7.75:1.7 7.75:1.65 7.35:1.65 7.35:1.6 6.15:1.6 6.15:1.65 5.75:1.65 5.75:1.7 5.45:1.7 5.45:1.75 5.25:1.75 5.25:1.8 5.1:1.8 5.1:1.85 4.95:1.85 4.95:1.9 4.8:1.9 4.8:1.95 4.7:1.95 4.7:2 4.55:2 4.55:2.05 4.45:2.05 4.45:2.1 4.35:2.1 4.35:2.15 4.25:2.15 4.25:2.2 4.2:2.2 4.2:2.25 4.1:2.25 4.1:2.3 4:2.3 4:2.35 3.95:2.35 3.95:2.4 3.85:2.4 3.85:2.45 3.8:2.45 3.8:2.5 3.75:2.5 3.75:2.55 3.7:2.55 3.7:2.6 3.6:2.6 3.6:2.65 3.55:2.65 3.55:2.7 3.5:2.7 3.5:2.75 3.45:2.75 3.45:2.8 3.4:2.8 3.4:2.85 3.35:2.85 3.35:2.9 3.3:2.9 3.3:2.95 3.25:2.95 3.25:3 3.2:3 3.2:3.1 3.15:3.1 3.15:3.15 3.1:3.15 3.1:3.2 3.05:3.2 3.05:3.3 3:3.3 3:3.35 2.95:3.35 2.95:3.45 2.9:3.45 2.9:3.5 2.85:3.5 2.85:3.6 2.8:3.6 2.8:3.7 2.75:3.7 2.75:3.75 2.7:3.75 2.7:3.85 2.65:3.85 2.65:3.95 2.6:3.95 2.6:4.05 2.55:4.05 2.55:4.2 2.5:4.2 2.5:4.3 2.45:4.3 2.45:4.45 2.4:4.45 2.4:4.55 2.35:4.55 2.35:4.7 2.3:4.7 2.3:4.9 2.25:4.9 2.25:5.1 2.2:5.1 2.2:5.25 2.15:5.25 2.15:5.5 2.1:5.5 2.1:5.8 2.05:5.8 2.05:6.15 2:6.15 2:6.75 1.95:6.75 1.95:8.15 2:8.15 2:8.6 2.05:8.6 2.05:8.95 2.1:8.95 2.1:9.2 2.15:9.2 2.15:9.45 2.2:9.45 2.2:9.65 2.25:9.65 2.25:9.8 2.3:9.8 2.3:10 2.35:10 2.35:10.1 2.4:10.1 2.4:10.25 2.45:10.25 2.45:10.35 2.5:10.35 2.5:10.5 2.55:10.5 2.55:10.6 2.6:10.6 2.6:10.7 2.65:10.7 2.65:10.8 2.7:10.8 2.7:10.9 2.75:10.9 2.75:11 2.8:11 2.8:11.1 2.85:11.1 2.85:11.15 2.9:11.15 2.9:11.25 2.95:11.25 2.95:11.3 3:11.3 3:11.4 3.05:11.4 3.05:11.45 3.1:11.45 3.1:11.55 3.15:11.55 3.15:11.6 3.2:11.6 3.2:11.65 3.25:11.65 3.25:11.7 3.3:11.7 3.3:11.8 3.35:11.8 3.35:11.85 3.4:11.85 3.4:11.9 3.45:11.9 3.45:11.95 3.5:11.95 3.5:12 3.55:12 3.55:12.05 3.6:12.05 3.6:12.1 3.65:12.1 3.65:12.15 3.7:12.15 3.7:12.2 3.75:12.2 3.75:12.25 3.8:12.25 3.8:12.3 3.9:12.3 3.9:12.35 3.95:12.35 3.95:12.4 4:12.4 4:12.45 4.05:12.45 4.05:12.5 4.15:12.5 4.15:12.55 4.2:12.55 4.2:12.6 4.3:12.6 4.3:12.65 4.35:12.65 4.35:12.7 4.45:12.7 4.45:12.75 4.55:12.75 4.55:12.8 4.65:12.8 4.65:12.85 4.75:12.85 4.75:12.9 4.85:12.9 4.85:12.95 4.95:12.95 4.95:13 5.1:13 5.1:13.05 5.25:13.05 5.25:13.1 5.4:13.1 5.4:13.15 5.6:13.15 5.6:13.2 5.85:13.2 5.85:13.25 6.15:13.25 6.15:13.3 7.25:13.3 7.25:13.25 7.65:13.25 7.65:13.2 7.9:13.2 7.9:13.15 8.15:13.15 8.15:13.1 8.3:13.1 8.3:13.05 8.45:13.05 8.45:13 8.6:13 8.6:12.95 8.75:12.95 8.75:12.9 8.85:12.9 8.85:12.85 8.95:12.85 8.95:12.8 9.05:12.8 9.05:12.75 9.15:12.75 9.15:12.7 9.25:12.7 9.25:12.65 9.3:12.65 9.3:12.6 9.4:12.6 9.4:12.55 9.5:12.55 9.5:12.5 9.55:12.5 9.55:12.45 9.6:12.45 9.6:12.4 9.7:12.4 9.7:12.35 9.75:12.35 9.75:12.3 9.8:12.3 9.8:12.25 9.85:12.25 9.85:12.2 9.9:12.2 9.9:12.15 9.95:12.15 9.95:12.1 10:12.1 10:12.05 10.05:12.05 10.05:12 10.1:12 10.1:11.95 10.15:11.95 10.15:11.9 10.2:11.9 10.2:11.8 10.25:11.8 10.25:11.75 10.3:11.75 10.3:11.7 10.35:11.7 10.35:11.6 10.4:11.6 10.4:11.55 10.45:11.55 10.45:11.45 10.5:11.45 10.5:11.35 10.55:11.35 10.55:11.25 10.6:11.25 10.6:11.15 10.65:11.15 10.65:11.05 10.7:11.05 10.7:10.95 10.75:10.95 10.75:10.8 10.8:10.8 10.8:10.7 10.85:10.7 10.85:10.5 10.9:10.5 10.9:10.35 10.95:10.35 10.95:10.25 12.55:10.25 12.55:11.45 12.5:11.45 12.5:11.55 12.45:11.55 12.45:11.7 12.4:11.7 12.4:11.8 12.35:11.8 12.35:11.9 12.3:11.9 12.3:12 12.25:12 12.25:12.1 12.2:12.1 12.2:12.2 12.15:12.2 12.15:12.25 12.1:12.25 12.1:12.35 12.05:12.35 12.05:12.45 12:12.45 12:12.5 11.95:12.5 11.95:12.55 11.9:12.55 11.9:12.65 11.85:12.65 11.85:12.7 11.8:12.7 11.8:12.8 11.75:12.8 11.75:12.85 11.7:12.85 11.7:12.9 11.65:12.9 11.65:12.95 11.6:12.95 11.6:13 11.55:13 11.55:13.05 11.5:13.05 11.5:13.1 11.45:13.1 11.45:13.2 11.4:13.2 11.4:13.25 11.3:13.25 11.3:13.3 11.25:13.3 11.25:13.35 11.2:13.35 11.2:13.4 11.15:13.4 11.15:13.45 11.1:13.45 11.1:13.5 11.05:13.5 11.05:13.55 11:13.55 11:13.6 10.9:13.6 10.9:13.65 10.85:13.65 10.85:13.7 10.8:13.7 10.8:13.75 10.7:13.75 10.7:13.8 10.65:13.8 10.65:13.85 10.6:13.85 10.6:13.9 10.5:13.9 10.5:13.95 10.4:13.95 10.4:14 10.35:14 10.35:14.05 10.25:14.05 10.25:14.1 10.2:14.1 10.2:14.15 10.1:14.15 10.1:14.2 10:14.2 10:14.25 9.9:14.25 9.9:14.3 9.8:14.3 9.8:14.35 9.7:14.35 9.7:14.4 9.55:14.4 9.55:14.45 9.45:14.45 9.45:14.5 9.35:14.5 9.35:14.55 9.2:14.55 9.2:14.6 9.05:14.6 9.05:14.65 8.9:14.65 8.9:14.7 8.75:14.7 8.75:14.75 8.55:14.75 8.55:14.8 8.35:14.8 8.35:14.85 8.05:14.85 8.05:14.9 7.8:14.9 7.8:14.95 7.3:14.95 7.3:15 6.15:15 6.15:14.95 5.7:14.95 5.7:14.9 5.35:14.9 5.35:14.85 5.1:14.85 5.1:14.8 4.9:14.8 4.9:14.75 4.75:14.75 4.75:14.7 4.55:14.7 4.55:14.65 4.4:14.65 4.4:14.6 4.3:14.6 4.3:14.55 4.15:14.55 4.15:14.5 4.05:14.5 4.05:14.45 3.9:14.45 3.9:14.4 3.8:14.4 3.8:14.35 3.7:14.35 3.7:14.3 3.6:14.3 3.6:14.25 3.5:14.25 3.5:14.2 3.4:14.2 3.4:14.15 3.35:14.15 3.35:14.1 3.25:14.1 3.25:14.05 3.15:14.05 3.15:14 3.1:14 3.1:13.95 3:13.95 3:13.9 2.95:13.9 2.95:13.85 2.9:13.85 2.9:13.8 2.8:13.8 2.8:13.75 2.75:13.75 2.75:13.7 2.7:13.7 2.7:13.65 2.6:13.65 2.6:13.6 2.55:13.6 2.55:13.55 2.5:13.55 2.5:13.5 2.45:13.5 2.45:13.45 2.4:13.45 2.4:13.4 2.35:13.4 2.35:13.35 2.25:13.35 2.25:13.3 2.2:13.3 2.2:13.25 2.15:13.25 2.15:13.2 2.1:13.2 2.1:13.15 2.05:13.15 2.05:13.1 2:13.1 2:13.05 1.95:13.05 1.95:13 1.9:13 1.9:12.9 1.85:12.9 1.85:12.85 1.8:12.85 1.8:12.8 1.75:12.8 1.75:12.75 1.7:12.75 1.7:12.7 1.65:12.7 1.65:12.65 1.6:12.65 1.6:12.55 1.55:12.55 1.55:12.5 1.5:12.5 1.5:12.45 1.45:12.45 1.45:12.35 1.4:12.35 1.4:12.3 1.35:12.3 1.35:12.2 1.3:12.2 1.3:12.15 1.25:12.15 1.25:12.1 1.2:12.1 1.2:12 1.15:12 1.15:11.9 1.1:11.9 1.1:11.8 1.05:11.8 1.05:11.75 1:11.75 1:11.65 0.95:11.65 0.95:11.55 0.9:11.55 0.9:11.5 0.85:11.5 0.85:11.35 0.8:11.35 0.8:11.25 0.75:11.25 0.75:11.15 0.7:11.15 0.7:11.05 0.65:11.05 0.65:10.95 0.6:10.95 0.6:10.8 0.55:10.8 0.55:10.7 0.5:10.7 0.5:10.55 0.45:10.55 0.45:10.4 0.4:10.4 0.4:10.25 0.35:10.25 0.35:10.1 0.3:10.1 0.3:9.9 0.25:9.9 0.25:9.75 0.2:9.75 0.2:9.55 0.15:9.55 0.15:9.3 0.1:9.3 0.1:9.05 0.05:9.05 0.05:8.7 0:8.7 0:6 0.05:6 0.05:5.6 0.1:5.6 0.1:5.35 0.15:5.35 0.15:5.1 0.2:5.1 0.2:4.9 0.25:4.9 0.25:4.7 0.3:4.7 0.3:4.55 0.35:4.55 0.35:4.4 0.4:4.4 0.4:4.25 0.45:4.25 0.45:4.1 0.5:4.1 0.5:4 0.55:4 0.55:3.85 0.6:3.85 0.6:3.75 0.65:3.75 0.65:3.65 0.7:3.65 0.7:3.55 0.75:3.55 0.75:3.45 0.8:3.45 0.8:3.35 0.85:3.35 0.85:3.25 0.9:3.25 0.9:3.15 0.95:3.15 0.95:3.1 1:3.1 1:3 1.05:3 1.05:2.9 1.1:2.9 1.1:2.85 1.15:2.85 1.15:2.75 1.2:2.75 1.2:2.7 1.25:2.7 1.25:2.65 1.3:2.65 1.3:2.55 1.35:2.55 1.35:2.5 1.4:2.5 1.4:2.4 1.45:2.4 1.45:2.35 1.5:2.35 1.5:2.3 1.55:2.3 1.55:2.25 1.6:2.25 1.6:2.2 1.65:2.2 1.65:2.1 1.7:2.1 1.7:2.05 1.75:2.05 1.75:2 1.8:2 1.8:1.95 1.85:1.95 1.85:1.9 1.9:1.9 1.9:1.85 1.95:1.85 1.95:1.8 2:1.8 2:1.75 2.05:1.75 2.05:1.7 2.1:1.7 2.1:1.65 2.15:1.65 2.15:1.6 2.2:1.6 2.2:1.55 2.25:1.55 2.25:1.5 2.3:1.5 2.3:1.45 2.35:1.45 2.35:1.4 2.4:1.4 2.4:1.35 2.45:1.35 2.45:1.3 2.5:1.3 2.5:1.25 2.6:1.25 2.6:1.2 2.65:1.2 2.65:1.15 2.7:1.15 2.7:1.1 2.75:1.1 2.75:1.05 2.85:1.05 2.85:1 2.9:1 2.9:0.95 3:0.95 3:0.9 3.05:0.9 3.05:0.85 3.15:0.85 3.15:0.8 3.2:0.8 3.2:0.75 3.3:0.75 3.3:0.7 3.4:0.7 3.4:0.65 3.5:0.65 3.5:0.6 3.6:0.6 3.6:0.55 3.7:0.55 3.7:0.5 3.8:0.5 3.8:0.45 3.9:0.45 3.9:0.4 4.05:0.4 4.05:0.35 4.2:0.35 4.2:0.3 4.3:0.3 4.3:0.25 4.5:0.25 4.5:0.2 4.65:0.2 4.65:0.15 4.9:0.15 4.9:0.1 5.15:0.1 5.15:0.05 5.45:0.05 5.45:0 7.6:0 7.6:0.05 7.85:0.05 7.85:0.1 8.1:0.1 8.1:0.15 8.3:0.15 8.3:0.2 8.5:0.2 8.5:0.25 8.65:0.25 8.65:0.3 8.8:0.3 8.8:0.35 8.9:0.35 8.9:0.4 9.05:0.4 9.05:0.45 9.15:0.45 9.15:0.5 9.3:0.5 9.3:0.55 9.4:0.55 9.4:0.6 9.5:0.6 9.5:0.65 9.6:0.65 9.6:0.7 9.65:0.7 9.65:0.75 9.75:0.75 9.75:0.8 9.85:0.8 9.85:0.85 9.95:0.85 9.95:0.9 10:0.9 10:0.95 10.1:0.95 10.1:1 10.15:1 10.15:1.05 10.25:1.05 10.25:1.1 10.3:1.1 10.3:1.15 10.35:1.15 10.35:1.2 10.45:1.2 10.45:1.25 10.5:1.25 10.5:1.3 10.55:1.3 10.55:1.35 10.6:1.35 10.6:1.4 10.65:1.4 10.65:1.45 11.55:1.45 11.55:1.25 11.6:1.25 11.6:1.05 11.65:1.05 11.65:0.85 11.7:0.85 11.7:0.6 11.75:0.6 11.75:0.4 11.8:0.4 11.8:0.3 13.05:0.3)
letterShapes["H"] = (list 11.3:14.3 9.35:14.3 9.35:8.35 1.9:8.35 1.9:14.3 0:14.3 0:0 1.9:0 1.9:6.65 9.35:6.65 9.35:0 11.3:0)
letterShapes["I"] = (list 0:0 0:14.3 1.9:14.3 1.9:0)
letterShapes["J"] = (list 8.15:14.65 6.2:14.65 6.2:3.55 6.15:3.55 6.15:3.2 6.1:3.2 6.1:3 6.05:3 6.05:2.85 6:2.85 6:2.75 5.95:2.75 5.95:2.65 5.9:2.65 5.9:2.55 5.85:2.55 5.85:2.45 5.8:2.45 5.8:2.4 5.75:2.4 5.75:2.3 5.7:2.3 5.7:2.25 5.65:2.25 5.65:2.2 5.6:2.2 5.6:2.15 5.55:2.15 5.55:2.1 5.5:2.1 5.5:2.05 5.45:2.05 5.45:2 5.35:2 5.35:1.95 5.3:1.95 5.3:1.9 5.2:1.9 5.2:1.85 5.1:1.85 5.1:1.8 5:1.8 5:1.75 4.85:1.75 4.85:1.7 4.65:1.7 4.65:1.65 3.2:1.65 3.2:1.7 3:1.7 3:1.75 2.85:1.75 2.85:1.8 2.75:1.8 2.75:1.85 2.65:1.85 2.65:1.9 2.6:1.9 2.6:1.95 2.5:1.95 2.5:2 2.45:2 2.45:2.05 2.4:2.05 2.4:2.1 2.35:2.1 2.35:2.15 2.3:2.15 2.3:2.2 2.25:2.2 2.25:2.25 2.2:2.25 2.2:2.3 2.15:2.3 2.15:2.35 2.1:2.35 2.1:2.45 2.05:2.45 2.05:2.55 2:2.55 2:2.65 1.95:2.65 1.95:2.8 1.9:2.8 1.9:2.95 1.85:2.95 1.85:3.15 1.8:3.15 1.8:3.45 1.75:3.45 1.75:4.95 0:4.95 0:2.75 0.05:2.75 0.05:2.55 0.1:2.55 0.1:2.35 0.15:2.35 0.15:2.25 0.2:2.25 0.2:2.1 0.25:2.1 0.25:2 0.3:2 0.3:1.85 0.35:1.85 0.35:1.75 0.4:1.75 0.4:1.7 0.45:1.7 0.45:1.6 0.5:1.6 0.5:1.5 0.55:1.5 0.55:1.45 0.6:1.45 0.6:1.4 0.65:1.4 0.65:1.3 0.7:1.3 0.7:1.25 0.75:1.25 0.75:1.2 0.8:1.2 0.8:1.15 0.85:1.15 0.85:1.1 0.9:1.1 0.9:1 0.95:1 0.95:0.95 1.05:0.95 1.05:0.9 1.1:0.9 1.1:0.85 1.15:0.85 1.15:0.8 1.2:0.8 1.2:0.75 1.25:0.75 1.25:0.7 1.35:0.7 1.35:0.65 1.4:0.65 1.4:0.6 1.5:0.6 1.5:0.55 1.55:0.55 1.55:0.5 1.65:0.5 1.65:0.45 1.75:0.45 1.75:0.4 1.85:0.4 1.85:0.35 1.95:0.35 1.95:0.3 2.1:0.3 2.1:0.25 2.25:0.25 2.25:0.2 2.35:0.2 2.35:0.15 2.55:0.15 2.55:0.1 2.75:0.1 2.75:0.05 3.05:0.05 3.05:0 4.95:0 4.95:0.05 5.2:0.05 5.2:0.1 5.4:0.1 5.4:0.15 5.55:0.15 5.55:0.2 5.7:0.2 5.7:0.25 5.85:0.25 5.85:0.3 6:0.3 6:0.35 6.1:0.35 6.1:0.4 6.2:0.4 6.2:0.45 6.3:0.45 6.3:0.5 6.35:0.5 6.35:0.55 6.45:0.55 6.45:0.6 6.55:0.6 6.55:0.65 6.6:0.65 6.6:0.7 6.7:0.7 6.7:0.75 6.75:0.75 6.75:0.8 6.8:0.8 6.8:0.85 6.85:0.85 6.85:0.9 6.9:0.9 6.9:0.95 7:0.95 7:1 7.05:1 7.05:1.05 7.1:1.05 7.1:1.1 7.15:1.1 7.15:1.2 7.2:1.2 7.2:1.25 7.25:1.25 7.25:1.3 7.3:1.3 7.3:1.35 7.35:1.35 7.35:1.4 7.4:1.4 7.4:1.5 7.45:1.5 7.45:1.55 7.5:1.55 7.5:1.65 7.55:1.65 7.55:1.7 7.6:1.7 7.6:1.8 7.65:1.8 7.65:1.95 7.7:1.95 7.7:2.05 7.75:2.05 7.75:2.15 7.8:2.15 7.8:2.25 7.85:2.25 7.85:2.4 7.9:2.4 7.9:2.55 7.95:2.55 7.95:2.75 8:2.75 8:2.95 8.05:2.95 8.05:3.25 8.1:3.25 8.1:3.7 8.15:3.7)
letterShapes["K"] = (list 10.9:1.1 10.85:1.1 10.85:1.15 10.8:1.15 10.8:1.25 10.75:1.25 10.75:1.3 10.7:1.3 10.7:1.35 10.65:1.35 10.65:1.45 10.6:1.45 10.6:1.5 10.55:1.5 10.55:1.6 10.5:1.6 10.5:1.65 10.45:1.65 10.45:1.7 10.4:1.7 10.4:1.8 10.35:1.8 10.35:1.85 10.3:1.85 10.3:1.95 10.25:1.95 10.25:2 10.2:2 10.2:2.05 10.15:2.05 10.15:2.15 10.1:2.15 10.1:2.2 10.05:2.2 10.05:2.25 10:2.25 10:2.35 9.95:2.35 9.95:2.4 9.9:2.4 9.9:2.5 9.85:2.5 9.85:2.55 9.8:2.55 9.8:2.6 9.75:2.6 9.75:2.7 9.7:2.7 9.7:2.75 9.65:2.75 9.65:2.85 9.6:2.85 9.6:2.9 9.55:2.9 9.55:2.95 9.5:2.95 9.5:3.05 9.45:3.05 9.45:3.1 9.4:3.1 9.4:3.2 9.35:3.2 9.35:3.25 9.3:3.25 9.3:3.3 9.25:3.3 9.25:3.4 9.2:3.4 9.2:3.45 9.15:3.45 9.15:3.55 9.1:3.55 9.1:3.6 9.05:3.6 9.05:3.65 9:3.65 9:3.75 8.95:3.75 8.95:3.8 8.9:3.8 8.9:3.9 8.85:3.9 8.85:3.95 8.8:3.95 8.8:4 8.75:4 8.75:4.1 8.7:4.1 8.7:4.15 8.65:4.15 8.65:4.2 8.6:4.2 8.6:4.3 8.55:4.3 8.55:4.35 8.5:4.35 8.5:4.45 8.45:4.45 8.45:4.5 8.4:4.5 8.4:4.55 8.35:4.55 8.35:4.65 8.3:4.65 8.3:4.7 8.25:4.7 8.25:4.8 8.2:4.8 8.2:4.85 8.15:4.85 8.15:4.9 8.1:4.9 8.1:5 8.05:5 8.05:5.05 8:5.05 8:5.15 7.95:5.15 7.95:5.2 7.9:5.2 7.9:5.25 7.85:5.25 7.85:5.35 7.8:5.35 7.8:5.4 7.75:5.4 7.75:5.5 7.7:5.5 7.7:5.55 7.65:5.55 7.65:5.6 7.6:5.6 7.6:5.7 7.55:5.7 7.55:5.75 7.5:5.75 7.5:5.8 7.45:5.8 7.45:5.9 7.4:5.9 7.4:5.95 7.35:5.95 7.35:6.05 7.3:6.05 7.3:6.1 7.25:6.1 7.25:6.15 7.2:6.15 7.2:6.25 7.15:6.25 7.15:6.3 7.1:6.3 7.1:6.4 7.05:6.4 7.05:6.45 7:6.45 7:6.5 6.95:6.5 6.95:6.6 6.9:6.6 6.9:6.65 6.85:6.65 6.85:6.75 6.8:6.75 6.8:6.8 6.75:6.8 6.75:6.85 6.7:6.85 6.7:6.95 6.65:6.95 6.65:7 6.6:7 6.6:7.1 6.55:7.1 6.55:7.15 6.5:7.15 6.5:7.2 6.45:7.2 6.45:7.3 6.4:7.3 6.4:7.35 6.35:7.35 6.35:7.4 6.3:7.4 6.3:7.5 6.25:7.5 6.25:7.55 6.2:7.55 6.2:7.65 6.15:7.65 6.15:7.7 6.1:7.7 6.1:7.75 6.05:7.75 6.05:7.85 6:7.85 6:7.9 5.95:7.9 5.95:8.9 6:8.9 6:8.95 6.05:8.95 6.05:9 6.1:9 6.1:9.05 6.15:9.05 6.15:9.1 6.2:9.1 6.2:9.15 6.25:9.15 6.25:9.2 6.3:9.2 6.3:9.25 6.35:9.25 6.35:9.3 6.4:9.3 6.4:9.35 6.45:9.35 6.45:9.4 6.5:9.4 6.5:9.45 6.55:9.45 6.55:9.5 6.6:9.5 6.6:9.55 6.65:9.55 6.65:9.6 6.7:9.6 6.7:9.65 6.75:9.65 6.75:9.7 6.8:9.7 6.8:9.75 6.85:9.75 6.85:9.8 6.9:9.8 6.9:9.85 7:9.85 7:9.9 7.05:9.9 7.05:9.95 7.1:9.95 7.1:10 7.15:10 7.15:10.05 7.2:10.05 7.2:10.1 7.25:10.1 7.25:10.15 7.3:10.15 7.3:10.2 7.35:10.2 7.35:10.25 7.4:10.25 7.4:10.3 7.45:10.3 7.45:10.35 7.5:10.35 7.5:10.4 7.55:10.4 7.55:10.45 7.6:10.45 7.6:10.5 7.65:10.5 7.65:10.55 7.7:10.55 7.7:10.6 7.75:10.6 7.75:10.65 7.8:10.65 7.8:10.7 7.85:10.7 7.85:10.75 7.9:10.75 7.9:10.8 7.95:10.8 7.95:10.85 8:10.85 8:10.9 8.05:10.9 8.05:10.95 8.1:10.95 8.1:11 8.15:11 8.15:11.05 8.2:11.05 8.2:11.1 8.25:11.1 8.25:11.15 8.3:11.15 8.3:11.2 8.35:11.2 8.35:11.25 8.4:11.25 8.4:11.3 8.45:11.3 8.45:11.35 8.5:11.35 8.5:11.4 8.55:11.4 8.55:11.45 8.6:11.45 8.6:11.5 8.7:11.5 8.7:11.55 8.75:11.55 8.75:11.6 8.8:11.6 8.8:11.65 8.85:11.65 8.85:11.7 8.9:11.7 8.9:11.75 8.95:11.75 8.95:11.8 9:11.8 9:11.85 9.05:11.85 9.05:11.9 9.1:11.9 9.1:11.95 9.15:11.95 9.15:12 9.2:12 9.2:12.05 9.25:12.05 9.25:12.1 9.3:12.1 9.3:12.15 9.35:12.15 9.35:12.2 9.4:12.2 9.4:12.25 9.45:12.25 9.45:12.3 9.5:12.3 9.5:12.35 9.55:12.35 9.55:12.4 9.6:12.4 9.6:12.45 9.65:12.45 9.65:12.5 9.7:12.5 9.7:12.55 9.75:12.55 9.75:12.6 9.8:12.6 9.8:12.65 9.85:12.65 9.85:12.7 9.9:12.7 9.9:12.75 9.95:12.75 9.95:12.8 10:12.8 10:12.85 10.05:12.85 10.05:12.9 10.1:12.9 10.1:12.95 10.15:12.95 10.15:13 10.2:13 10.2:13.05 10.25:13.05 10.25:13.1 10.3:13.1 10.3:13.15 10.4:13.15 10.4:14.3 8.85:14.3 8.85:14.25 8.8:14.25 8.8:14.2 8.75:14.2 8.75:14.15 8.7:14.15 8.7:14.1 8.65:14.1 8.65:14.05 8.6:14.05 8.6:14 8.55:14 8.55:13.95 8.5:13.95 8.5:13.9 8.45:13.9 8.45:13.85 8.4:13.85 8.4:13.8 8.35:13.8 8.35:13.75 8.3:13.75 8.3:13.7 8.25:13.7 8.25:13.65 8.2:13.65 8.2:13.6 8.15:13.6 8.15:13.55 8.1:13.55 8.1:13.5 8.05:13.5 8.05:13.45 8:13.45 8:13.4 7.95:13.4 7.95:13.35 7.9:13.35 7.9:13.3 7.85:13.3 7.85:13.25 7.8:13.25 7.8:13.2 7.75:13.2 7.75:13.15 7.7:13.15 7.7:13.1 7.65:13.1 7.65:13.05 7.6:13.05 7.6:13 7.55:13 7.55:12.95 7.5:12.95 7.5:12.9 7.45:12.9 7.45:12.85 7.4:12.85 7.4:12.8 7.35:12.8 7.35:12.75 7.3:12.75 7.3:12.7 7.25:12.7 7.25:12.65 7.2:12.65 7.2:12.6 7.15:12.6 7.15:12.55 7.1:12.55 7.1:12.5 7.05:12.5 7.05:12.45 7:12.45 7:12.4 6.95:12.4 6.95:12.35 6.9:12.35 6.9:12.3 6.85:12.3 6.85:12.25 6.8:12.25 6.8:12.2 6.75:12.2 6.75:12.15 6.7:12.15 6.7:12.1 6.65:12.1 6.65:12.05 6.6:12.05 6.6:12 6.55:12 6.55:11.95 6.5:11.95 6.5:11.9 6.45:11.9 6.45:11.85 6.4:11.85 6.4:11.8 6.35:11.8 6.35:11.75 6.3:11.75 6.3:11.7 6.25:11.7 6.25:11.65 6.2:11.65 6.2:11.6 6.15:11.6 6.15:11.55 6.1:11.55 6.1:11.5 6.05:11.5 6.05:11.45 6:11.45 6:11.4 5.95:11.4 5.95:11.35 5.9:11.35 5.9:11.3 5.85:11.3 5.85:11.25 5.8:11.25 5.8:11.2 5.75:11.2 5.75:11.15 5.7:11.15 5.7:11.1 5.65:11.1 5.65:11.05 5.6:11.05 5.6:11 5.55:11 5.55:10.95 5.5:10.95 5.5:10.9 5.45:10.9 5.45:10.85 5.4:10.85 5.4:10.8 5.35:10.8 5.35:10.75 5.3:10.75 5.3:10.7 5.25:10.7 5.25:10.65 5.2:10.65 5.2:10.6 5.15:10.6 5.15:10.55 5.1:10.55 5.1:10.5 5.05:10.5 5.05:10.45 5:10.45 5:10.4 4.95:10.4 4.95:10.35 4.9:10.35 4.9:10.3 4.85:10.3 4.85:10.25 4.8:10.25 4.8:10.2 4.75:10.2 4.75:10.15 4.7:10.15 4.7:10.1 4.65:10.1 4.65:10.05 4.6:10.05 4.6:10 4.55:10 4.55:9.95 4.5:9.95 4.5:9.9 4.45:9.9 4.45:9.85 4.4:9.85 4.4:9.8 4.35:9.8 4.35:9.75 4.3:9.75 4.3:9.7 4.25:9.7 4.25:9.65 4.2:9.65 4.2:9.6 4.15:9.6 4.15:9.55 4.1:9.55 4.1:9.5 4.05:9.5 4.05:9.45 4:9.45 4:9.4 3.95:9.4 3.95:9.35 3.9:9.35 3.9:9.3 3.85:9.3 3.85:9.25 3.8:9.25 3.8:9.2 3.75:9.2 3.75:9.15 3.7:9.15 3.7:9.1 3.65:9.1 3.65:9.05 3.6:9.05 3.6:9 3.55:9 3.55:8.95 3.5:8.95 3.5:8.9 3.45:8.9 3.45:8.85 3.4:8.85 3.4:8.8 3.35:8.8 3.35:8.75 3.3:8.75 3.3:8.7 3.25:8.7 3.25:8.65 3.2:8.65 3.2:8.6 3.15:8.6 3.15:8.55 3.1:8.55 3.1:8.5 3.05:8.5 3.05:8.45 3:8.45 3:8.4 2.95:8.4 2.95:8.35 2.9:8.35 2.9:8.3 2.85:8.3 2.85:8.25 2.8:8.25 2.8:8.2 1.9:8.2 1.9:14.3 0:14.3 0:0 1.9:0 1.9:5 1.95:5 1.95:5.05 2:5.05 2:5.1 2.05:5.1 2.05:5.15 2.1:5.15 2.1:5.2 2.15:5.2 2.15:5.25 2.2:5.25 2.2:5.3 2.25:5.3 2.25:5.35 2.3:5.35 2.3:5.4 2.35:5.4 2.35:5.45 2.4:5.45 2.4:5.5 2.45:5.5 2.45:5.55 2.5:5.55 2.5:5.6 2.6:5.6 2.6:5.65 2.65:5.65 2.65:5.7 2.7:5.7 2.7:5.75 2.75:5.75 2.75:5.8 2.8:5.8 2.8:5.85 2.85:5.85 2.85:5.9 2.9:5.9 2.9:5.95 2.95:5.95 2.95:6 3:6 3:6.05 3.05:6.05 3.05:6.1 3.1:6.1 3.1:6.15 3.15:6.15 3.15:6.2 3.2:6.2 3.2:6.25 3.25:6.25 3.25:6.3 3.3:6.3 3.3:6.35 3.35:6.35 3.35:6.4 3.4:6.4 3.4:6.45 3.45:6.45 3.45:6.5 3.5:6.5 3.5:6.55 3.55:6.55 3.55:6.6 3.6:6.6 3.6:6.65 4.5:6.65 4.5:6.6 4.55:6.6 4.55:6.55 4.6:6.55 4.6:6.45 4.65:6.45 4.65:6.4 4.7:6.4 4.7:6.3 4.75:6.3 4.75:6.25 4.8:6.25 4.8:6.2 4.85:6.2 4.85:6.1 4.9:6.1 4.9:6.05 4.95:6.05 4.95:5.95 5:5.95 5:5.9 5.05:5.9 5.05:5.8 5.1:5.8 5.1:5.75 5.15:5.75 5.15:5.7 5.2:5.7 5.2:5.6 5.25:5.6 5.25:5.55 5.3:5.55 5.3:5.45 5.35:5.45 5.35:5.4 5.4:5.4 5.4:5.3 5.45:5.3 5.45:5.25 5.5:5.25 5.5:5.15 5.55:5.15 5.55:5.1 5.6:5.1 5.6:5.05 5.65:5.05 5.65:4.95 5.7:4.95 5.7:4.9 5.75:4.9 5.75:4.8 5.8:4.8 5.8:4.75 5.85:4.75 5.85:4.65 5.9:4.65 5.9:4.6 5.95:4.6 5.95:4.55 6:4.55 6:4.45 6.05:4.45 6.05:4.4 6.1:4.4 6.1:4.3 6.15:4.3 6.15:4.25 6.2:4.25 6.2:4.15 6.25:4.15 6.25:4.1 6.3:4.1 6.3:4.05 6.35:4.05 6.35:3.95 6.4:3.95 6.4:3.9 6.45:3.9 6.45:3.8 6.5:3.8 6.5:3.75 6.55:3.75 6.55:3.65 6.6:3.65 6.6:3.6 6.65:3.6 6.65:3.55 6.7:3.55 6.7:3.45 6.75:3.45 6.75:3.4 6.8:3.4 6.8:3.3 6.85:3.3 6.85:3.25 6.9:3.25 6.9:3.15 6.95:3.15 6.95:3.1 7:3.1 7:3.05 7.05:3.05 7.05:2.95 7.1:2.95 7.1:2.9 7.15:2.9 7.15:2.8 7.2:2.8 7.2:2.75 7.25:2.75 7.25:2.65 7.3:2.65 7.3:2.6 7.35:2.6 7.35:2.55 7.4:2.55 7.4:2.45 7.45:2.45 7.45:2.4 7.5:2.4 7.5:2.3 7.55:2.3 7.55:2.25 7.6:2.25 7.6:2.15 7.65:2.15 7.65:2.1 7.7:2.1 7.7:2.05 7.75:2.05 7.75:1.95 7.8:1.95 7.8:1.9 7.85:1.9 7.85:1.8 7.9:1.8 7.9:1.75 7.95:1.75 7.95:1.65 8:1.65 8:1.6 8.05:1.6 8.05:1.5 8.1:1.5 8.1:1.45 8.15:1.45 8.15:1.4 8.2:1.4 8.2:1.3 8.25:1.3 8.25:1.25 8.3:1.25 8.3:1.15 8.35:1.15 8.35:1.1 8.4:1.1 8.4:1 8.45:1 8.45:0.95 8.5:0.95 8.5:0.9 8.55:0.9 8.55:0.8 8.6:0.8 8.6:0.75 8.65:0.75 8.65:0.65 8.7:0.65 8.7:0.6 8.75:0.6 8.75:0.5 8.8:0.5 8.8:0.45 8.85:0.45 8.85:0.4 8.9:0.4 8.9:0.3 8.95:0.3 8.95:0.25 9:0.25 9:0.15 9.05:0.15 9.05:0.1 9.1:0.1 9.1:0 10.9:0)
letterShapes["L"] = (list 9.2:1.65 1.9:1.65 1.9:14.3 0:14.3 0:0 9.2:0)
letterShapes["M"] = (list 13.75:14.3 10.95:14.3 10.95:14.15 10.9:14.15 10.9:14 10.85:14 10.85:13.85 10.8:13.85 10.8:13.7 10.75:13.7 10.75:13.55 10.7:13.55 10.7:13.4 10.65:13.4 10.65:13.25 10.6:13.25 10.6:13.1 10.55:13.1 10.55:12.95 10.5:12.95 10.5:12.8 10.45:12.8 10.45:12.65 10.4:12.65 10.4:12.5 10.35:12.5 10.35:12.35 10.3:12.35 10.3:12.2 10.25:12.2 10.25:12.05 10.2:12.05 10.2:11.9 10.15:11.9 10.15:11.75 10.1:11.75 10.1:11.65 10.05:11.65 10.05:11.5 10:11.5 10:11.35 9.95:11.35 9.95:11.2 9.9:11.2 9.9:11.05 9.85:11.05 9.85:10.9 9.8:10.9 9.8:10.75 9.75:10.75 9.75:10.6 9.7:10.6 9.7:10.45 9.65:10.45 9.65:10.3 9.6:10.3 9.6:10.15 9.55:10.15 9.55:10 9.5:10 9.5:9.85 9.45:9.85 9.45:9.7 9.4:9.7 9.4:9.55 9.35:9.55 9.35:9.4 9.3:9.4 9.3:9.25 9.25:9.25 9.25:9.1 9.2:9.1 9.2:8.95 9.15:8.95 9.15:8.8 9.1:8.8 9.1:8.65 9.05:8.65 9.05:8.5 9:8.5 9:8.35 8.95:8.35 8.95:8.2 8.9:8.2 8.9:8.05 8.85:8.05 8.85:7.9 8.8:7.9 8.8:7.75 8.75:7.75 8.75:7.6 8.7:7.6 8.7:7.45 8.65:7.45 8.65:7.3 8.6:7.3 8.6:7.15 8.55:7.15 8.55:7 8.5:7 8.5:6.85 8.45:6.85 8.45:6.7 8.4:6.7 8.4:6.55 8.35:6.55 8.35:6.4 8.3:6.4 8.3:6.25 8.25:6.25 8.25:6.1 8.2:6.1 8.2:5.95 8.15:5.95 8.15:5.8 8.1:5.8 8.1:5.7 8.05:5.7 8.05:5.55 8:5.55 8:5.4 7.95:5.4 7.95:5.25 7.9:5.25 7.9:5.1 7.85:5.1 7.85:4.95 7.8:4.95 7.8:4.8 7.75:4.8 7.75:4.65 7.7:4.65 7.7:4.5 7.65:4.5 7.65:4.35 7.6:4.35 7.6:4.2 7.55:4.2 7.55:4.05 7.5:4.05 7.5:3.9 7.45:3.9 7.45:3.75 7.4:3.75 7.4:3.6 7.35:3.6 7.35:3.45 7.3:3.45 7.3:3.4 6.4:3.4 6.4:3.55 6.35:3.55 6.35:3.7 6.3:3.7 6.3:3.85 6.25:3.85 6.25:4 6.2:4 6.2:4.15 6.15:4.15 6.15:4.3 6.1:4.3 6.1:4.45 6.05:4.45 6.05:4.6 6:4.6 6:4.75 5.95:4.75 5.95:4.9 5.9:4.9 5.9:5.05 5.85:5.05 5.85:5.2 5.8:5.2 5.8:5.35 5.75:5.35 5.75:5.5 5.7:5.5 5.7:5.65 5.65:5.65 5.65:5.8 5.6:5.8 5.6:5.9 5.55:5.9 5.55:6.05 5.5:6.05 5.5:6.2 5.45:6.2 5.45:6.35 5.4:6.35 5.4:6.5 5.35:6.5 5.35:6.65 5.3:6.65 5.3:6.8 5.25:6.8 5.25:6.95 5.2:6.95 5.2:7.1 5.15:7.1 5.15:7.25 5.1:7.25 5.1:7.4 5.05:7.4 5.05:7.55 5:7.55 5:7.7 4.95:7.7 4.95:7.85 4.9:7.85 4.9:8 4.85:8 4.85:8.15 4.8:8.15 4.8:8.3 4.75:8.3 4.75:8.45 4.7:8.45 4.7:8.6 4.65:8.6 4.65:8.75 4.6:8.75 4.6:8.9 4.55:8.9 4.55:9.05 4.5:9.05 4.5:9.2 4.45:9.2 4.45:9.35 4.4:9.35 4.4:9.5 4.35:9.5 4.35:9.65 4.3:9.65 4.3:9.75 4.25:9.75 4.25:9.9 4.2:9.9 4.2:10.05 4.15:10.05 4.15:10.2 4.1:10.2 4.1:10.35 4.05:10.35 4.05:10.5 4:10.5 4:10.65 3.95:10.65 3.95:10.8 3.9:10.8 3.9:10.95 3.85:10.95 3.85:11.1 3.8:11.1 3.8:11.25 3.75:11.25 3.75:11.4 3.7:11.4 3.7:11.55 3.65:11.55 3.65:11.7 3.6:11.7 3.6:11.85 3.55:11.85 3.55:12 3.5:12 3.5:12.15 3.45:12.15 3.45:12.3 3.4:12.3 3.4:12.45 3.35:12.45 3.35:12.6 3.3:12.6 3.3:12.75 3.25:12.75 3.25:12.9 3.2:12.9 3.2:13.05 3.15:13.05 3.15:13.2 3.1:13.2 3.1:13.35 3.05:13.35 3.05:13.45 3:13.45 3:13.6 2.95:13.6 2.95:13.75 2.9:13.75 2.9:13.9 2.85:13.9 2.85:14.05 2.8:14.05 2.8:14.2 2.75:14.2 2.75:14.3 0:14.3 0:0 1.85:0 1.85:9.35 2.75:9.35 2.75:9.2 2.8:9.2 2.8:9.05 2.85:9.05 2.85:8.9 2.9:8.9 2.9:8.75 2.95:8.75 2.95:8.6 3:8.6 3:8.45 3.05:8.45 3.05:8.3 3.1:8.3 3.1:8.15 3.15:8.15 3.15:8 3.2:8 3.2:7.9 3.25:7.9 3.25:7.75 3.3:7.75 3.3:7.6 3.35:7.6 3.35:7.45 3.4:7.45 3.4:7.3 3.45:7.3 3.45:7.15 3.5:7.15 3.5:7 3.55:7 3.55:6.85 3.6:6.85 3.6:6.7 3.65:6.7 3.65:6.55 3.7:6.55 3.7:6.4 3.75:6.4 3.75:6.25 3.8:6.25 3.8:6.1 3.85:6.1 3.85:5.95 3.9:5.95 3.9:5.8 3.95:5.8 3.95:5.65 4:5.65 4:5.5 4.05:5.5 4.05:5.35 4.1:5.35 4.1:5.2 4.15:5.2 4.15:5.05 4.2:5.05 4.2:4.9 4.25:4.9 4.25:4.75 4.3:4.75 4.3:4.6 4.35:4.6 4.35:4.45 4.4:4.45 4.4:4.3 4.45:4.3 4.45:4.15 4.5:4.15 4.5:4 4.55:4 4.55:3.85 4.6:3.85 4.6:3.7 4.65:3.7 4.65:3.55 4.7:3.55 4.7:3.4 4.75:3.4 4.75:3.25 4.8:3.25 4.8:3.1 4.85:3.1 4.85:2.95 4.9:2.95 4.9:2.8 4.95:2.8 4.95:2.65 5:2.65 5:2.5 5.05:2.5 5.05:2.35 5.1:2.35 5.1:2.2 5.15:2.2 5.15:2.05 5.2:2.05 5.2:1.95 5.25:1.95 5.25:1.8 5.3:1.8 5.3:1.65 5.35:1.65 5.35:1.5 5.4:1.5 5.4:1.35 5.45:1.35 5.45:1.2 5.5:1.2 5.5:1.05 5.55:1.05 5.55:0.9 5.6:0.9 5.6:0.75 5.65:0.75 5.65:0.6 5.7:0.6 5.7:0.45 5.75:0.45 5.75:0.3 5.8:0.3 5.8:0.15 5.85:0.15 5.85:0 7.85:0 7.85:0.15 7.9:0.15 7.9:0.3 7.95:0.3 7.95:0.45 8:0.45 8:0.6 8.05:0.6 8.05:0.75 8.1:0.75 8.1:0.9 8.15:0.9 8.15:1.05 8.2:1.05 8.2:1.2 8.25:1.2 8.25:1.35 8.3:1.35 8.3:1.5 8.35:1.5 8.35:1.65 8.4:1.65 8.4:1.8 8.45:1.8 8.45:1.95 8.5:1.95 8.5:2.1 8.55:2.1 8.55:2.25 8.6:2.25 8.6:2.4 8.65:2.4 8.65:2.5 8.7:2.5 8.7:2.65 8.75:2.65 8.75:2.8 8.8:2.8 8.8:2.95 8.85:2.95 8.85:3.1 8.9:3.1 8.9:3.25 8.95:3.25 8.95:3.4 9:3.4 9:3.55 9.05:3.55 9.05:3.7 9.1:3.7 9.1:3.85 9.15:3.85 9.15:4 9.2:4 9.2:4.15 9.25:4.15 9.25:4.3 9.3:4.3 9.3:4.45 9.35:4.45 9.35:4.6 9.4:4.6 9.4:4.75 9.45:4.75 9.45:4.9 9.5:4.9 9.5:5.05 9.55:5.05 9.55:5.2 9.6:5.2 9.6:5.35 9.65:5.35 9.65:5.5 9.7:5.5 9.7:5.65 9.75:5.65 9.75:5.8 9.8:5.8 9.8:5.95 9.85:5.95 9.85:6.1 9.9:6.1 9.9:6.25 9.95:6.25 9.95:6.4 10:6.4 10:6.55 10.05:6.55 10.05:6.7 10.1:6.7 10.1:6.85 10.15:6.85 10.15:7 10.2:7 10.2:7.15 10.25:7.15 10.25:7.3 10.3:7.3 10.3:7.45 10.35:7.45 10.35:7.6 10.4:7.6 10.4:7.75 10.45:7.75 10.45:7.9 10.5:7.9 10.5:8.05 10.55:8.05 10.55:8.2 10.6:8.2 10.6:8.35 10.65:8.35 10.65:8.5 10.7:8.5 10.7:8.65 10.75:8.65 10.75:8.8 10.8:8.8 10.8:8.95 10.85:8.95 10.85:9.1 10.9:9.1 10.9:9.25 10.95:9.25 10.95:9.4 11.85:9.4 11.85:0 13.75:0)
letterShapes["N"] = (list 11.4:14.3 9.5:14.3 9.5:4.05 8.6:4.05 8.6:4.15 8.55:4.15 8.55:4.2 8.5:4.2 8.5:4.3 8.45:4.3 8.45:4.4 8.4:4.4 8.4:4.45 8.35:4.45 8.35:4.55 8.3:4.55 8.3:4.6 8.25:4.6 8.25:4.7 8.2:4.7 8.2:4.8 8.15:4.8 8.15:4.85 8.1:4.85 8.1:4.95 8.05:4.95 8.05:5 8:5 8:5.1 7.95:5.1 7.95:5.2 7.9:5.2 7.9:5.25 7.85:5.25 7.85:5.35 7.8:5.35 7.8:5.4 7.75:5.4 7.75:5.5 7.7:5.5 7.7:5.6 7.65:5.6 7.65:5.65 7.6:5.65 7.6:5.75 7.55:5.75 7.55:5.85 7.5:5.85 7.5:5.9 7.45:5.9 7.45:6 7.4:6 7.4:6.05 7.35:6.05 7.35:6.15 7.3:6.15 7.3:6.25 7.25:6.25 7.25:6.3 7.2:6.3 7.2:6.4 7.15:6.4 7.15:6.45 7.1:6.45 7.1:6.55 7.05:6.55 7.05:6.65 7:6.65 7:6.7 6.95:6.7 6.95:6.8 6.9:6.8 6.9:6.85 6.85:6.85 6.85:6.95 6.8:6.95 6.8:7.05 6.75:7.05 6.75:7.1 6.7:7.1 6.7:7.2 6.65:7.2 6.65:7.3 6.6:7.3 6.6:7.35 6.55:7.35 6.55:7.45 6.5:7.45 6.5:7.5 6.45:7.5 6.45:7.6 6.4:7.6 6.4:7.7 6.35:7.7 6.35:7.75 6.3:7.75 6.3:7.85 6.25:7.85 6.25:7.9 6.2:7.9 6.2:8 6.15:8 6.15:8.1 6.1:8.1 6.1:8.15 6.05:8.15 6.05:8.25 6:8.25 6:8.3 5.95:8.3 5.95:8.4 5.9:8.4 5.9:8.5 5.85:8.5 5.85:8.55 5.8:8.55 5.8:8.65 5.75:8.65 5.75:8.75 5.7:8.75 5.7:8.8 5.65:8.8 5.65:8.9 5.6:8.9 5.6:8.95 5.55:8.95 5.55:9.05 5.5:9.05 5.5:9.15 5.45:9.15 5.45:9.2 5.4:9.2 5.4:9.3 5.35:9.3 5.35:9.35 5.3:9.35 5.3:9.45 5.25:9.45 5.25:9.55 5.2:9.55 5.2:9.6 5.15:9.6 5.15:9.7 5.1:9.7 5.1:9.75 5.05:9.75 5.05:9.85 5:9.85 5:9.95 4.95:9.95 4.95:10 4.9:10 4.9:10.1 4.85:10.1 4.85:10.2 4.8:10.2 4.8:10.25 4.75:10.25 4.75:10.35 4.7:10.35 4.7:10.4 4.65:10.4 4.65:10.5 4.6:10.5 4.6:10.6 4.55:10.6 4.55:10.65 4.5:10.65 4.5:10.75 4.45:10.75 4.45:10.8 4.4:10.8 4.4:10.9 4.35:10.9 4.35:11 4.3:11 4.3:11.05 4.25:11.05 4.25:11.15 4.2:11.15 4.2:11.2 4.15:11.2 4.15:11.3 4.1:11.3 4.1:11.4 4.05:11.4 4.05:11.45 4:11.45 4:11.55 3.95:11.55 3.95:11.65 3.9:11.65 3.9:11.7 3.85:11.7 3.85:11.8 3.8:11.8 3.8:11.85 3.75:11.85 3.75:11.95 3.7:11.95 3.7:12.05 3.65:12.05 3.65:12.1 3.6:12.1 3.6:12.2 3.55:12.2 3.55:12.25 3.5:12.25 3.5:12.35 3.45:12.35 3.45:12.45 3.4:12.45 3.4:12.5 3.35:12.5 3.35:12.6 3.3:12.6 3.3:12.65 3.25:12.65 3.25:12.75 3.2:12.75 3.2:12.85 3.15:12.85 3.15:12.9 3.1:12.9 3.1:13 3.05:13 3.05:13.1 3:13.1 3:13.15 2.95:13.15 2.95:13.25 2.9:13.25 2.9:13.3 2.85:13.3 2.85:13.4 2.8:13.4 2.8:13.5 2.75:13.5 2.75:13.55 2.7:13.55 2.7:13.65 2.65:13.65 2.65:13.7 2.6:13.7 2.6:13.8 2.55:13.8 2.55:13.9 2.5:13.9 2.5:13.95 2.45:13.95 2.45:14.05 2.4:14.05 2.4:14.15 2.35:14.15 2.35:14.2 2.3:14.2 2.3:14.3 0:14.3 0:0 1.85:0 1.85:10.2 2.75:10.2 2.75:10.15 2.8:10.15 2.8:10.05 2.85:10.05 2.85:10 2.9:10 2.9:9.9 2.95:9.9 2.95:9.8 3:9.8 3:9.75 3.05:9.75 3.05:9.65 3.1:9.65 3.1:9.6 3.15:9.6 3.15:9.5 3.2:9.5 3.2:9.45 3.25:9.45 3.25:9.35 3.3:9.35 3.3:9.25 3.35:9.25 3.35:9.2 3.4:9.2 3.4:9.1 3.45:9.1 3.45:9.05 3.5:9.05 3.5:8.95 3.55:8.95 3.55:8.85 3.6:8.85 3.6:8.8 3.65:8.8 3.65:8.7 3.7:8.7 3.7:8.65 3.75:8.65 3.75:8.55 3.8:8.55 3.8:8.5 3.85:8.5 3.85:8.4 3.9:8.4 3.9:8.3 3.95:8.3 3.95:8.25 4:8.25 4:8.15 4.05:8.15 4.05:8.1 4.1:8.1 4.1:8 4.15:8 4.15:7.9 4.2:7.9 4.2:7.85 4.25:7.85 4.25:7.75 4.3:7.75 4.3:7.7 4.35:7.7 4.35:7.6 4.4:7.6 4.4:7.5 4.45:7.5 4.45:7.45 4.5:7.45 4.5:7.35 4.55:7.35 4.55:7.3 4.6:7.3 4.6:7.2 4.65:7.2 4.65:7.15 4.7:7.15 4.7:7.05 4.75:7.05 4.75:6.95 4.8:6.95 4.8:6.9 4.85:6.9 4.85:6.8 4.9:6.8 4.9:6.75 4.95:6.75 4.95:6.65 5:6.65 5:6.55 5.05:6.55 5.05:6.5 5.1:6.5 5.1:6.4 5.15:6.4 5.15:6.35 5.2:6.35 5.2:6.25 5.25:6.25 5.25:6.2 5.3:6.2 5.3:6.1 5.35:6.1 5.35:6 5.4:6 5.4:5.95 5.45:5.95 5.45:5.85 5.5:5.85 5.5:5.8 5.55:5.8 5.55:5.7 5.6:5.7 5.6:5.6 5.65:5.6 5.65:5.55 5.7:5.55 5.7:5.45 5.75:5.45 5.75:5.4 5.8:5.4 5.8:5.3 5.85:5.3 5.85:5.25 5.9:5.25 5.9:5.15 5.95:5.15 5.95:5.05 6:5.05 6:5 6.05:5 6.05:4.9 6.1:4.9 6.1:4.85 6.15:4.85 6.15:4.75 6.2:4.75 6.2:4.65 6.25:4.65 6.25:4.6 6.3:4.6 6.3:4.5 6.35:4.5 6.35:4.45 6.4:4.45 6.4:4.35 6.45:4.35 6.45:4.3 6.5:4.3 6.5:4.2 6.55:4.2 6.55:4.1 6.6:4.1 6.6:4.05 6.65:4.05 6.65:3.95 6.7:3.95 6.7:3.9 6.75:3.9 6.75:3.8 6.8:3.8 6.8:3.7 6.85:3.7 6.85:3.65 6.9:3.65 6.9:3.55 6.95:3.55 6.95:3.5 7:3.5 7:3.4 7.05:3.4 7.05:3.3 7.1:3.3 7.1:3.25 7.15:3.25 7.15:3.15 7.2:3.15 7.2:3.1 7.25:3.1 7.25:3 7.3:3 7.3:2.95 7.35:2.95 7.35:2.85 7.4:2.85 7.4:2.75 7.45:2.75 7.45:2.7 7.5:2.7 7.5:2.6 7.55:2.6 7.55:2.55 7.6:2.55 7.6:2.45 7.65:2.45 7.65:2.35 7.7:2.35 7.7:2.3 7.75:2.3 7.75:2.2 7.8:2.2 7.8:2.15 7.85:2.15 7.85:2.05 7.9:2.05 7.9:2 7.95:2 7.95:1.9 8:1.9 8:1.8 8.05:1.8 8.05:1.75 8.1:1.75 8.1:1.65 8.15:1.65 8.15:1.6 8.2:1.6 8.2:1.5 8.25:1.5 8.25:1.4 8.3:1.4 8.3:1.35 8.35:1.35 8.35:1.25 8.4:1.25 8.4:1.2 8.45:1.2 8.45:1.1 8.5:1.1 8.5:1.05 8.55:1.05 8.55:0.95 8.6:0.95 8.6:0.85 8.65:0.85 8.65:0.8 8.7:0.8 8.7:0.7 8.75:0.7 8.75:0.65 8.8:0.65 8.8:0.55 8.85:0.55 8.85:0.45 8.9:0.45 8.9:0.4 8.95:0.4 8.95:0.3 9:0.3 9:0.25 9.05:0.25 9.05:0.15 9.1:0.15 9.1:0.1 9.15:0.1 9.15:0 11.4:0)
letterShapes["O"] = (list 13.95:8.1 13.9:8.1 13.9:8.6 13.85:8.6 13.85:8.95 13.8:8.95 13.8:9.25 13.75:9.25 13.75:9.5 13.7:9.5 13.7:9.7 13.65:9.7 13.65:9.9 13.6:9.9 13.6:10.05 13.55:10.05 13.55:10.2 13.5:10.2 13.5:10.35 13.45:10.35 13.45:10.55 13.4:10.55 13.4:10.65 13.35:10.65 13.35:10.8 13.3:10.8 13.3:10.9 13.25:10.9 13.25:11.05 13.2:11.05 13.2:11.15 13.15:11.15 13.15:11.25 13.1:11.25 13.1:11.35 13.05:11.35 13.05:11.45 13:11.45 13:11.55 12.95:11.55 12.95:11.65 12.9:11.65 12.9:11.75 12.85:11.75 12.85:11.85 12.8:11.85 12.8:11.9 12.75:11.9 12.75:12 12.7:12 12.7:12.1 12.65:12.1 12.65:12.15 12.6:12.15 12.6:12.25 12.55:12.25 12.55:12.3 12.5:12.3 12.5:12.4 12.45:12.4 12.45:12.45 12.4:12.45 12.4:12.5 12.35:12.5 12.35:12.55 12.3:12.55 12.3:12.65 12.25:12.65 12.25:12.7 12.2:12.7 12.2:12.75 12.15:12.75 12.15:12.8 12.1:12.8 12.1:12.9 12.05:12.9 12.05:12.95 12:12.95 12:13 11.95:13 11.95:6.85 11.9:6.85 11.9:6.35 11.85:6.35 11.85:6.05 11.8:6.05 11.8:5.8 11.75:5.8 11.75:5.55 11.7:5.55 11.7:5.4 11.65:5.4 11.65:5.2 11.6:5.2 11.6:5.05 11.55:5.05 11.55:4.9 11.5:4.9 11.5:4.8 11.45:4.8 11.45:4.65 11.4:4.65 11.4:4.55 11.35:4.55 11.35:4.45 11.3:4.45 11.3:4.35 11.25:4.35 11.25:4.2 11.2:4.2 11.2:4.1 11.15:4.1 11.15:4.05 11.1:4.05 11.1:3.95 11.05:3.95 11.05:3.85 11:3.85 11:3.8 10.95:3.8 10.95:3.7 10.9:3.7 10.9:3.65 10.85:3.65 10.85:3.55 10.8:3.55 10.8:3.5 10.75:3.5 10.75:3.45 10.7:3.45 10.7:3.35 10.65:3.35 10.65:3.3 10.6:3.3 10.6:3.25 10.55:3.25 10.55:3.2 10.5:3.2 10.5:3.15 10.45:3.15 10.45:3.1 10.4:3.1 10.4:3.05 10.35:3.05 10.35:3 10.3:3 10.3:2.95 10.25:2.95 10.25:2.9 10.2:2.9 10.2:2.85 10.15:2.85 10.15:2.8 10.1:2.8 10.1:2.75 10.05:2.75 10.05:2.7 10:2.7 10:2.65 9.95:2.65 9.95:2.6 9.85:2.6 9.85:2.55 9.8:2.55 9.8:2.5 9.7:2.5 9.7:2.45 9.65:2.45 9.65:2.4 9.55:2.4 9.55:2.35 9.5:2.35 9.5:2.3 9.4:2.3 9.4:2.25 9.3:2.25 9.3:2.2 9.2:2.2 9.2:2.15 9.1:2.15 9.1:2.1 9:2.1 9:2.05 8.9:2.05 8.9:2 8.75:2 8.75:1.95 8.65:1.95 8.65:1.9 8.5:1.9 8.5:1.85 8.3:1.85 8.3:1.8 8.1:1.8 8.1:1.75 7.8:1.75 7.8:1.7 7.45:1.7 7.45:1.65 6.45:1.65 6.45:1.7 6.1:1.7 6.1:1.75 5.8:1.75 5.8:1.8 5.6:1.8 5.6:1.85 5.4:1.85 5.4:1.9 5.25:1.9 5.25:1.95 5.15:1.95 5.15:2 5:2 5:2.05 4.9:2.05 4.9:2.1 4.8:2.1 4.8:2.15 4.7:2.15 4.7:2.2 4.6:2.2 4.6:2.25 4.5:2.25 4.5:2.3 4.4:2.3 4.4:2.35 4.35:2.35 4.35:2.4 4.25:2.4 4.25:2.45 4.2:2.45 4.2:2.5 4.1:2.5 4.1:2.55 4.05:2.55 4.05:2.6 3.95:2.6 3.95:2.65 3.9:2.65 3.9:2.7 3.85:2.7 3.85:2.75 3.8:2.75 3.8:2.8 3.75:2.8 3.75:2.85 3.7:2.85 3.7:2.9 3.65:2.9 3.65:2.95 3.6:2.95 3.6:3 3.55:3 3.55:3.05 3.5:3.05 3.5:3.1 3.45:3.1 3.45:3.15 3.4:3.15 3.4:3.2 3.35:3.2 3.35:3.25 3.3:3.25 3.3:3.3 3.25:3.3 3.25:3.35 3.2:3.35 3.2:3.45 3.15:3.45 3.15:3.5 3.1:3.5 3.1:3.55 3.05:3.55 3.05:3.65 3:3.65 3:3.7 2.95:3.7 2.95:3.8 2.9:3.8 2.9:3.85 2.85:3.85 2.85:3.95 2.8:3.95 2.8:4.05 2.75:4.05 2.75:4.1 2.7:4.1 2.7:4.2 2.65:4.2 2.65:4.35 2.6:4.35 2.6:4.45 2.55:4.45 2.55:4.55 2.5:4.55 2.5:4.65 2.45:4.65 2.45:4.8 2.4:4.8 2.4:4.9 2.35:4.9 2.35:5.05 2.3:5.05 2.3:5.2 2.25:5.2 2.25:5.4 2.2:5.4 2.2:5.55 2.15:5.55 2.15:5.8 2.1:5.8 2.1:6.05 2.05:6.05 2.05:6.35 2:6.35 2:6.8 1.95:6.8 1.95:8.15 2:8.15 2:8.6 2.05:8.6 2.05:8.9 2.1:8.9 2.1:9.15 2.15:9.15 2.15:9.4 2.2:9.4 2.2:9.55 2.25:9.55 2.25:9.75 2.3:9.75 2.3:9.9 2.35:9.9 2.35:10.05 2.4:10.05 2.4:10.15 2.45:10.15 2.45:10.3 2.5:10.3 2.5:10.4 2.55:10.4 2.55:10.5 2.6:10.5 2.6:10.6 2.65:10.6 2.65:10.75 2.7:10.75 2.7:10.85 2.75:10.85 2.75:10.9 2.8:10.9 2.8:11 2.85:11 2.85:11.1 2.9:11.1 2.9:11.15 2.95:11.15 2.95:11.25 3:11.25 3:11.3 3.05:11.3 3.05:11.4 3.1:11.4 3.1:11.45 3.15:11.45 3.15:11.5 3.2:11.5 3.2:11.6 3.25:11.6 3.25:11.65 3.3:11.65 3.3:11.7 3.35:11.7 3.35:11.75 3.4:11.75 3.4:11.8 3.45:11.8 3.45:11.85 3.5:11.85 3.5:11.9 3.55:11.9 3.55:11.95 3.6:11.95 3.6:12 3.65:12 3.65:12.05 3.7:12.05 3.7:12.1 3.75:12.1 3.75:12.15 3.8:12.15 3.8:12.2 3.85:12.2 3.85:12.25 3.9:12.25 3.9:12.3 3.95:12.3 3.95:12.35 4.05:12.35 4.05:12.4 4.1:12.4 4.1:12.45 4.2:12.45 4.2:12.5 4.25:12.5 4.25:12.55 4.35:12.55 4.35:12.6 4.4:12.6 4.4:12.65 4.5:12.65 4.5:12.7 4.6:12.7 4.6:12.75 4.7:12.75 4.7:12.8 4.8:12.8 4.8:12.85 4.9:12.85 4.9:12.9 5:12.9 5:12.95 5.15:12.95 5.15:13 5.25:13 5.25:13.05 5.4:13.05 5.4:13.1 5.6:13.1 5.6:13.15 5.8:13.15 5.8:13.2 6.1:13.2 6.1:13.25 6.45:13.25 6.45:13.3 7.45:13.3 7.45:13.25 7.8:13.25 7.8:13.2 8.1:13.2 8.1:13.15 8.3:13.15 8.3:13.1 8.5:13.1 8.5:13.05 8.65:13.05 8.65:13 8.75:13 8.75:12.95 8.9:12.95 8.9:12.9 9:12.9 9:12.85 9.1:12.85 9.1:12.8 9.2:12.8 9.2:12.75 9.3:12.75 9.3:12.7 9.4:12.7 9.4:12.65 9.5:12.65 9.5:12.6 9.55:12.6 9.55:12.55 9.65:12.55 9.65:12.5 9.7:12.5 9.7:12.45 9.8:12.45 9.8:12.4 9.85:12.4 9.85:12.35 9.95:12.35 9.95:12.3 10:12.3 10:12.25 10.05:12.25 10.05:12.2 10.1:12.2 10.1:12.15 10.15:12.15 10.15:12.1 10.2:12.1 10.2:12.05 10.25:12.05 10.25:12 10.3:12 10.3:11.95 10.35:11.95 10.35:11.9 10.4:11.9 10.4:11.85 10.45:11.85 10.45:11.8 10.5:11.8 10.5:11.75 10.55:11.75 10.55:11.7 10.6:11.7 10.6:11.65 10.65:11.65 10.65:11.6 10.7:11.6 10.7:11.5 10.75:11.5 10.75:11.45 10.8:11.45 10.8:11.4 10.85:11.4 10.85:11.3 10.9:11.3 10.9:11.25 10.95:11.25 10.95:11.15 11:11.15 11:11.05 11.05:11.05 11.05:11 11.1:11 11.1:10.9 11.15:10.9 11.15:10.8 11.2:10.8 11.2:10.75 11.25:10.75 11.25:10.6 11.3:10.6 11.3:10.5 11.35:10.5 11.35:10.4 11.4:10.4 11.4:10.3 11.45:10.3 11.45:10.15 11.5:10.15 11.5:10.05 11.55:10.05 11.55:9.9 11.6:9.9 11.6:9.75 11.65:9.75 11.65:9.55 11.7:9.55 11.7:9.4 11.75:9.4 11.75:9.15 11.8:9.15 11.8:8.9 11.85:8.9 11.85:8.6 11.9:8.6 11.9:8.1 11.95:8.1 11.95:13.05 11.9:13.05 11.9:13.1 11.85:13.1 11.85:13.15 11.8:13.15 11.8:13.2 11.75:13.2 11.75:13.25 11.7:13.25 11.7:13.3 11.65:13.3 11.65:13.35 11.6:13.35 11.6:13.4 11.55:13.4 11.55:13.45 11.45:13.45 11.45:13.5 11.4:13.5 11.4:13.55 11.35:13.55 11.35:13.6 11.3:13.6 11.3:13.65 11.25:13.65 11.25:13.7 11.15:13.7 11.15:13.75 11.1:13.75 11.1:13.8 11:13.8 11:13.85 10.95:13.85 10.95:13.9 10.85:13.9 10.85:13.95 10.8:13.95 10.8:14 10.7:14 10.7:14.05 10.65:14.05 10.65:14.1 10.55:14.1 10.55:14.15 10.45:14.15 10.45:14.2 10.35:14.2 10.35:14.25 10.25:14.25 10.25:14.3 10.15:14.3 10.15:14.35 10.05:14.35 10.05:14.4 9.95:14.4 9.95:14.45 9.85:14.45 9.85:14.5 9.7:14.5 9.7:14.55 9.55:14.55 9.55:14.6 9.4:14.6 9.4:14.65 9.25:14.65 9.25:14.7 9.1:14.7 9.1:14.75 8.9:14.75 8.9:14.8 8.7:14.8 8.7:14.85 8.4:14.85 8.4:14.9 8.1:14.9 8.1:14.95 7.6:14.95 7.6:15 6.3:15 6.3:14.95 5.8:14.95 5.8:14.9 5.45:14.9 5.45:14.85 5.2:14.85 5.2:14.8 5:14.8 5:14.75 4.8:14.75 4.8:14.7 4.65:14.7 4.65:14.65 4.5:14.65 4.5:14.6 4.35:14.6 4.35:14.55 4.2:14.55 4.2:14.5 4.05:14.5 4.05:14.45 3.95:14.45 3.95:14.4 3.85:14.4 3.85:14.35 3.75:14.35 3.75:14.3 3.65:14.3 3.65:14.25 3.55:14.25 3.55:14.2 3.45:14.2 3.45:14.15 3.35:14.15 3.35:14.1 3.25:14.1 3.25:14.05 3.2:14.05 3.2:14 3.1:14 3.1:13.95 3.05:13.95 3.05:13.9 2.95:13.9 2.95:13.85 2.9:13.85 2.9:13.8 2.8:13.8 2.8:13.75 2.75:13.75 2.75:13.7 2.65:13.7 2.65:13.65 2.6:13.65 2.6:13.6 2.55:13.6 2.55:13.55 2.5:13.55 2.5:13.5 2.45:13.5 2.45:13.45 2.35:13.45 2.35:13.4 2.3:13.4 2.3:13.35 2.25:13.35 2.25:13.3 2.2:13.3 2.2:13.25 2.15:13.25 2.15:13.2 2.1:13.2 2.1:13.15 2.05:13.15 2.05:13.1 2:13.1 2:13.05 1.95:13.05 1.95:13 1.9:13 1.9:12.95 1.85:12.95 1.85:12.9 1.8:12.9 1.8:12.8 1.75:12.8 1.75:12.75 1.7:12.75 1.7:12.7 1.65:12.7 1.65:12.65 1.6:12.65 1.6:12.55 1.55:12.55 1.55:12.5 1.5:12.5 1.5:12.45 1.45:12.45 1.45:12.4 1.4:12.4 1.4:12.3 1.35:12.3 1.35:12.25 1.3:12.25 1.3:12.15 1.25:12.15 1.25:12.1 1.2:12.1 1.2:12 1.15:12 1.15:11.9 1.1:11.9 1.1:11.85 1.05:11.85 1.05:11.75 1:11.75 1:11.65 0.95:11.65 0.95:11.55 0.9:11.55 0.9:11.45 0.85:11.45 0.85:11.35 0.8:11.35 0.8:11.25 0.75:11.25 0.75:11.15 0.7:11.15 0.7:11.05 0.65:11.05 0.65:10.9 0.6:10.9 0.6:10.8 0.55:10.8 0.55:10.65 0.5:10.65 0.5:10.55 0.45:10.55 0.45:10.4 0.4:10.4 0.4:10.2 0.35:10.2 0.35:10.05 0.3:10.05 0.3:9.9 0.25:9.9 0.25:9.7 0.2:9.7 0.2:9.5 0.15:9.5 0.15:9.25 0.1:9.25 0.1:8.95 0.05:8.95 0.05:8.65 0:8.65 0:6.3 0.05:6.3 0.05:6 0.1:6 0.1:5.7 0.15:5.7 0.15:5.45 0.2:5.45 0.2:5.25 0.25:5.25 0.25:5.05 0.3:5.05 0.3:4.9 0.35:4.9 0.35:4.75 0.4:4.75 0.4:4.55 0.45:4.55 0.45:4.4 0.5:4.4 0.5:4.3 0.55:4.3 0.55:4.15 0.6:4.15 0.6:4.05 0.65:4.05 0.65:3.9 0.7:3.9 0.7:3.8 0.75:3.8 0.75:3.7 0.8:3.7 0.8:3.6 0.85:3.6 0.85:3.5 0.9:3.5 0.9:3.4 0.95:3.4 0.95:3.3 1:3.3 1:3.2 1.05:3.2 1.05:3.1 1.1:3.1 1.1:3.05 1.15:3.05 1.15:2.95 1.2:2.95 1.2:2.85 1.25:2.85 1.25:2.8 1.3:2.8 1.3:2.7 1.35:2.7 1.35:2.65 1.4:2.65 1.4:2.55 1.45:2.55 1.45:2.5 1.5:2.5 1.5:2.45 1.55:2.45 1.55:2.4 1.6:2.4 1.6:2.3 1.65:2.3 1.65:2.25 1.7:2.25 1.7:2.2 1.75:2.2 1.75:2.15 1.8:2.15 1.8:2.05 1.85:2.05 1.85:2 1.9:2 1.9:1.95 1.95:1.95 1.95:1.9 2:1.9 2:1.85 2.05:1.85 2.05:1.8 2.1:1.8 2.1:1.75 2.15:1.75 2.15:1.7 2.2:1.7 2.2:1.65 2.25:1.65 2.25:1.6 2.3:1.6 2.3:1.55 2.35:1.55 2.35:1.5 2.45:1.5 2.45:1.45 2.5:1.45 2.5:1.4 2.55:1.4 2.55:1.35 2.6:1.35 2.6:1.3 2.65:1.3 2.65:1.25 2.75:1.25 2.75:1.2 2.8:1.2 2.8:1.15 2.9:1.15 2.9:1.1 2.95:1.1 2.95:1.05 3:1.05 3:1 3.1:1 3.1:0.95 3.2:0.95 3.2:0.9 3.25:0.9 3.25:0.85 3.35:0.85 3.35:0.8 3.45:0.8 3.45:0.75 3.55:0.75 3.55:0.7 3.65:0.7 3.65:0.65 3.75:0.65 3.75:0.6 3.85:0.6 3.85:0.55 3.95:0.55 3.95:0.5 4.05:0.5 4.05:0.45 4.2:0.45 4.2:0.4 4.35:0.4 4.35:0.35 4.5:0.35 4.5:0.3 4.65:0.3 4.65:0.25 4.8:0.25 4.8:0.2 5:0.2 5:0.15 5.2:0.15 5.2:0.1 5.45:0.1 5.45:0.05 5.8:0.05 5.8:0 8.1:0 8.1:0.05 8.45:0.05 8.45:0.1 8.7:0.1 8.7:0.15 8.9:0.15 8.9:0.2 9.1:0.2 9.1:0.25 9.25:0.25 9.25:0.3 9.4:0.3 9.4:0.35 9.55:0.35 9.55:0.4 9.7:0.4 9.7:0.45 9.85:0.45 9.85:0.5 9.95:0.5 9.95:0.55 10.05:0.55 10.05:0.6 10.15:0.6 10.15:0.65 10.25:0.65 10.25:0.7 10.35:0.7 10.35:0.75 10.45:0.75 10.45:0.8 10.55:0.8 10.55:0.85 10.65:0.85 10.65:0.9 10.7:0.9 10.7:0.95 10.8:0.95 10.8:1 10.85:1 10.85:1.05 10.95:1.05 10.95:1.1 11:1.1 11:1.15 11.1:1.15 11.1:1.2 11.15:1.2 11.15:1.25 11.25:1.25 11.25:1.3 11.3:1.3 11.3:1.35 11.35:1.35 11.35:1.4 11.4:1.4 11.4:1.45 11.45:1.45 11.45:1.5 11.55:1.5 11.55:1.55 11.6:1.55 11.6:1.6 11.65:1.6 11.65:1.65 11.7:1.65 11.7:1.7 11.75:1.7 11.75:1.75 11.8:1.75 11.8:1.8 11.85:1.8 11.85:1.85 11.9:1.85 11.9:1.9 11.95:1.9 11.95:1.95 12:1.95 12:2 12.05:2 12.05:2.05 12.1:2.05 12.1:2.15 12.15:2.15 12.15:2.2 12.2:2.2 12.2:2.25 12.25:2.25 12.25:2.3 12.3:2.3 12.3:2.4 12.35:2.4 12.35:2.45 12.4:2.45 12.4:2.5 12.45:2.5 12.45:2.55 12.5:2.55 12.5:2.65 12.55:2.65 12.55:2.7 12.6:2.7 12.6:2.8 12.65:2.8 12.65:2.85 12.7:2.85 12.7:2.95 12.75:2.95 12.75:3.05 12.8:3.05 12.8:3.1 12.85:3.1 12.85:3.2 12.9:3.2 12.9:3.3 12.95:3.3 12.95:3.4 13:3.4 13:3.5 13.05:3.5 13.05:3.6 13.1:3.6 13.1:3.7 13.15:3.7 13.15:3.8 13.2:3.8 13.2:3.9 13.25:3.9 13.25:4.05 13.3:4.05 13.3:4.15 13.35:4.15 13.35:4.3 13.4:4.3 13.4:4.4 13.45:4.4 13.45:4.55 13.5:4.55 13.5:4.75 13.55:4.75 13.55:4.9 13.6:4.9 13.6:5.05 13.65:5.05 13.65:5.25 13.7:5.25 13.7:5.45 13.75:5.45 13.75:5.7 13.8:5.7 13.8:6 13.85:6 13.85:6.35 13.9:6.35 13.9:6.85 13.95:6.85)
letterShapes["P"] = (list 10.65:11.1 10.6:11.1 10.6:11.3 10.55:11.3 10.55:11.55 10.5:11.55 10.5:11.7 10.45:11.7 10.45:11.8 10.4:11.8 10.4:11.95 10.35:11.95 10.35:12.05 10.3:12.05 10.3:12.15 10.25:12.15 10.25:12.25 10.2:12.25 10.2:12.35 10.15:12.35 10.15:12.45 10.1:12.45 10.1:12.5 10.05:12.5 10.05:12.6 10:12.6 10:12.65 9.95:12.65 9.95:12.75 9.9:12.75 9.9:12.8 9.85:12.8 9.85:12.85 9.8:12.85 9.8:12.95 9.75:12.95 9.75:13 9.7:13 9.7:13.05 9.65:13.05 9.65:13.1 9.6:13.1 9.6:13.15 9.55:13.15 9.55:13.2 9.5:13.2 9.5:13.25 9.45:13.25 9.45:13.3 9.35:13.3 9.35:13.35 9.3:13.35 9.3:13.4 9.25:13.4 9.25:13.45 9.2:13.45 9.2:13.5 9.1:13.5 9.1:13.55 9.05:13.55 9.05:13.6 8.95:13.6 8.95:13.65 8.9:13.65 8.9:13.7 8.8:13.7 8.8:13.75 8.7:13.75 8.7:13.8 8.65:13.8 8.65:9.5 8.6:9.5 8.6:9.25 8.55:9.25 8.55:9.1 8.5:9.1 8.5:9 8.45:9 8.45:8.9 8.4:8.9 8.4:8.8 8.35:8.8 8.35:8.7 8.3:8.7 8.3:8.65 8.25:8.65 8.25:8.55 8.2:8.55 8.2:8.5 8.15:8.5 8.15:8.45 8.1:8.45 8.1:8.4 8.05:8.4 8.05:8.35 8:8.35 8:8.3 7.95:8.3 7.95:8.25 7.9:8.25 7.9:8.2 7.85:8.2 7.85:8.15 7.75:8.15 7.75:8.1 7.7:8.1 7.7:8.05 7.6:8.05 7.6:8 7.5:8 7.5:7.95 7.4:7.95 7.4:7.9 7.25:7.9 7.25:7.85 7.1:7.85 7.1:7.8 6.95:7.8 6.95:7.75 6.7:7.75 6.7:7.7 6.3:7.7 6.3:7.65 1.9:7.65 1.9:12.65 6.4:12.65 6.4:12.6 6.75:12.6 6.75:12.55 7:12.55 7:12.5 7.15:12.5 7.15:12.45 7.3:12.45 7.3:12.4 7.45:12.4 7.45:12.35 7.55:12.35 7.55:12.3 7.65:12.3 7.65:12.25 7.75:12.25 7.75:12.2 7.8:12.2 7.8:12.15 7.9:12.15 7.9:12.1 7.95:12.1 7.95:12.05 8:12.05 8:12 8.05:12 8.05:11.95 8.1:11.95 8.1:11.9 8.15:11.9 8.15:11.85 8.2:11.85 8.2:11.8 8.25:11.8 8.25:11.75 8.3:11.75 8.3:11.65 8.35:11.65 8.35:11.6 8.4:11.6 8.4:11.5 8.45:11.5 8.45:11.4 8.5:11.4 8.5:11.25 8.55:11.25 8.55:11.15 8.6:11.15 8.6:10.95 8.65:10.95 8.65:13.8 8.6:13.8 8.6:13.85 8.5:13.85 8.5:13.9 8.4:13.9 8.4:13.95 8.25:13.95 8.25:14 8.15:14 8.15:14.05 8:14.05 8:14.1 7.8:14.1 7.8:14.15 7.6:14.15 7.6:14.2 7.35:14.2 7.35:14.25 6.95:14.25 6.95:14.3 0:14.3 0:0 1.9:0 1.9:6 7:6 7:6.05 7.35:6.05 7.35:6.1 7.6:6.1 7.6:6.15 7.8:6.15 7.8:6.2 8:6.2 8:6.25 8.15:6.25 8.15:6.3 8.25:6.3 8.25:6.35 8.4:6.35 8.4:6.4 8.5:6.4 8.5:6.45 8.6:6.45 8.6:6.5 8.7:6.5 8.7:6.55 8.8:6.55 8.8:6.6 8.85:6.6 8.85:6.65 8.95:6.65 8.95:6.7 9:6.7 9:6.75 9.1:6.75 9.1:6.8 9.15:6.8 9.15:6.85 9.2:6.85 9.2:6.9 9.3:6.9 9.3:6.95 9.35:6.95 9.35:7 9.4:7 9.4:7.05 9.45:7.05 9.45:7.1 9.5:7.1 9.5:7.15 9.55:7.15 9.55:7.2 9.6:7.2 9.6:7.25 9.65:7.25 9.65:7.3 9.7:7.3 9.7:7.35 9.75:7.35 9.75:7.45 9.8:7.45 9.8:7.5 9.85:7.5 9.85:7.55 9.9:7.55 9.9:7.65 9.95:7.65 9.95:7.7 10:7.7 10:7.8 10.05:7.8 10.05:7.85 10.1:7.85 10.1:7.95 10.15:7.95 10.15:8.05 10.2:8.05 10.2:8.15 10.25:8.15 10.25:8.25 10.3:8.25 10.3:8.35 10.35:8.35 10.35:8.5 10.4:8.5 10.4:8.6 10.45:8.6 10.45:8.75 10.5:8.75 10.5:8.95 10.55:8.95 10.55:9.15 10.6:9.15 10.6:9.4 10.65:9.4)
letterShapes["Q"] = (list 13.95:8.1 13.9:8.1 13.9:8.6 13.85:8.6 13.85:8.95 13.8:8.95 13.8:9.25 13.75:9.25 13.75:9.45 13.7:9.45 13.7:9.7 13.65:9.7 13.65:9.9 13.6:9.9 13.6:10.05 13.55:10.05 13.55:10.2 13.5:10.2 13.5:10.35 13.45:10.35 13.45:10.55 13.4:10.55 13.4:10.65 13.35:10.65 13.35:10.8 13.3:10.8 13.3:10.9 13.25:10.9 13.25:11.05 13.2:11.05 13.2:11.15 13.15:11.15 13.15:11.25 13.1:11.25 13.1:11.35 13.05:11.35 13.05:11.45 13:11.45 13:11.55 12.95:11.55 12.95:11.65 12.9:11.65 12.9:11.75 12.85:11.75 12.85:11.85 12.8:11.85 12.8:11.9 12.75:11.9 12.75:12 12.7:12 12.7:12.1 12.65:12.1 12.65:12.15 12.6:12.15 12.6:12.25 12.55:12.25 12.55:12.3 12.5:12.3 12.5:12.35 12.45:12.35 12.45:12.45 12.4:12.45 12.4:12.5 12.35:12.5 12.35:12.55 12.3:12.55 12.3:12.65 12.25:12.65 12.25:12.7 12.2:12.7 12.2:12.75 12.15:12.75 12.15:12.8 12.1:12.8 12.1:12.9 12.05:12.9 12.05:12.95 12:12.95 12:13 11.95:13 11.95:6.85 11.9:6.85 11.9:6.4 11.85:6.4 11.85:6.05 11.8:6.05 11.8:5.8 11.75:5.8 11.75:5.55 11.7:5.55 11.7:5.4 11.65:5.4 11.65:5.25 11.6:5.25 11.6:5.05 11.55:5.05 11.55:4.9 11.5:4.9 11.5:4.8 11.45:4.8 11.45:4.65 11.4:4.65 11.4:4.55 11.35:4.55 11.35:4.45 11.3:4.45 11.3:4.35 11.25:4.35 11.25:4.25 11.2:4.25 11.2:4.15 11.15:4.15 11.15:4.05 11.1:4.05 11.1:3.95 11.05:3.95 11.05:3.9 11:3.9 11:3.8 10.95:3.8 10.95:3.75 10.9:3.75 10.9:3.65 10.85:3.65 10.85:3.6 10.8:3.6 10.8:3.5 10.75:3.5 10.75:3.45 9.8:3.45 9.8:3.5 9.75:3.5 9.75:3.55 9.7:3.55 9.7:3.6 9.65:3.6 9.65:3.65 9.55:3.65 9.55:3.7 9.5:3.7 9.5:3.75 9.45:3.75 9.45:3.8 8.3:3.8 8.3:1.8 8.1:1.8 8.1:1.75 7.8:1.75 7.8:1.7 7.5:1.7 7.5:1.65 6.45:1.65 6.45:1.7 6.1:1.7 6.1:1.75 5.8:1.75 5.8:1.8 5.6:1.8 5.6:1.85 5.4:1.85 5.4:1.9 5.25:1.9 5.25:1.95 5.15:1.95 5.15:2 5:2 5:2.05 4.9:2.05 4.9:2.1 4.8:2.1 4.8:2.15 4.7:2.15 4.7:2.2 4.6:2.2 4.6:2.25 4.5:2.25 4.5:2.3 4.4:2.3 4.4:2.35 4.35:2.35 4.35:2.4 4.25:2.4 4.25:2.45 4.2:2.45 4.2:2.5 4.1:2.5 4.1:2.55 4.05:2.55 4.05:2.6 3.95:2.6 3.95:2.65 3.9:2.65 3.9:2.7 3.85:2.7 3.85:2.75 3.8:2.75 3.8:2.8 3.75:2.8 3.75:2.85 3.7:2.85 3.7:2.9 3.65:2.9 3.65:2.95 3.6:2.95 3.6:3 3.55:3 3.55:3.05 3.5:3.05 3.5:3.1 3.45:3.1 3.45:3.15 3.4:3.15 3.4:3.2 3.35:3.2 3.35:3.25 3.3:3.25 3.3:3.3 3.25:3.3 3.25:3.35 3.2:3.35 3.2:3.45 3.15:3.45 3.15:3.5 3.1:3.5 3.1:3.55 3.05:3.55 3.05:3.65 3:3.65 3:3.7 2.95:3.7 2.95:3.8 2.9:3.8 2.9:3.85 2.85:3.85 2.85:3.95 2.8:3.95 2.8:4.05 2.75:4.05 2.75:4.1 2.7:4.1 2.7:4.2 2.65:4.2 2.65:4.35 2.6:4.35 2.6:4.45 2.55:4.45 2.55:4.55 2.5:4.55 2.5:4.65 2.45:4.65 2.45:4.8 2.4:4.8 2.4:4.9 2.35:4.9 2.35:5.05 2.3:5.05 2.3:5.2 2.25:5.2 2.25:5.4 2.2:5.4 2.2:5.55 2.15:5.55 2.15:5.8 2.1:5.8 2.1:6.05 2.05:6.05 2.05:6.35 2:6.35 2:6.8 1.95:6.8 1.95:8.15 2:8.15 2:8.6 2.05:8.6 2.05:8.9 2.1:8.9 2.1:9.15 2.15:9.15 2.15:9.4 2.2:9.4 2.2:9.55 2.25:9.55 2.25:9.75 2.3:9.75 2.3:9.9 2.35:9.9 2.35:10.05 2.4:10.05 2.4:10.15 2.45:10.15 2.45:10.3 2.5:10.3 2.5:10.4 2.55:10.4 2.55:10.5 2.6:10.5 2.6:10.6 2.65:10.6 2.65:10.75 2.7:10.75 2.7:10.85 2.75:10.85 2.75:10.9 2.8:10.9 2.8:11 2.85:11 2.85:11.1 2.9:11.1 2.9:11.15 2.95:11.15 2.95:11.25 3:11.25 3:11.3 3.05:11.3 3.05:11.4 3.1:11.4 3.1:11.45 3.15:11.45 3.15:11.5 3.2:11.5 3.2:11.6 3.25:11.6 3.25:11.65 3.3:11.65 3.3:11.7 3.35:11.7 3.35:11.75 3.4:11.75 3.4:11.8 3.45:11.8 3.45:11.85 3.5:11.85 3.5:11.9 3.55:11.9 3.55:11.95 3.6:11.95 3.6:12 3.65:12 3.65:12.05 3.7:12.05 3.7:12.1 3.75:12.1 3.75:12.15 3.8:12.15 3.8:12.2 3.85:12.2 3.85:12.25 3.9:12.25 3.9:12.3 3.95:12.3 3.95:12.35 4.05:12.35 4.05:12.4 4.1:12.4 4.1:12.45 4.2:12.45 4.2:12.5 4.25:12.5 4.25:12.55 4.35:12.55 4.35:12.6 4.4:12.6 4.4:12.65 4.5:12.65 4.5:12.7 4.6:12.7 4.6:12.75 4.7:12.75 4.7:12.8 4.8:12.8 4.8:12.85 4.9:12.85 4.9:12.9 5:12.9 5:12.95 5.15:12.95 5.15:13 5.25:13 5.25:13.05 5.4:13.05 5.4:13.1 5.6:13.1 5.6:13.15 5.8:13.15 5.8:13.2 6.1:13.2 6.1:13.25 6.45:13.25 6.45:13.3 7.45:13.3 7.45:13.25 7.8:13.25 7.8:13.2 8.1:13.2 8.1:13.15 8.3:13.15 8.3:13.1 8.5:13.1 8.5:13.05 8.65:13.05 8.65:13 8.75:13 8.75:12.95 8.9:12.95 8.9:12.9 9:12.9 9:12.85 9.1:12.85 9.1:12.8 9.2:12.8 9.2:12.75 9.3:12.75 9.3:12.7 9.4:12.7 9.4:12.65 9.5:12.65 9.5:12.6 9.55:12.6 9.55:12.55 9.65:12.55 9.65:12.5 9.7:12.5 9.7:12.45 9.8:12.45 9.8:12.4 9.85:12.4 9.85:12.35 9.95:12.35 9.95:12.3 10:12.3 10:12.25 10.05:12.25 10.05:12.2 10.1:12.2 10.1:12.15 10.15:12.15 10.15:12.1 10.2:12.1 10.2:12.05 10.25:12.05 10.25:12 10.3:12 10.3:11.95 10.35:11.95 10.35:11.9 10.4:11.9 10.4:11.85 10.45:11.85 10.45:11.8 10.5:11.8 10.5:11.75 10.55:11.75 10.55:11.7 10.6:11.7 10.6:11.65 10.65:11.65 10.65:11.6 10.7:11.6 10.7:11.5 10.75:11.5 10.75:11.45 10.8:11.45 10.8:11.4 10.85:11.4 10.85:11.3 10.9:11.3 10.9:11.25 10.95:11.25 10.95:11.15 11:11.15 11:11.05 11.05:11.05 11.05:11 11.1:11 11.1:10.9 11.15:10.9 11.15:10.8 11.2:10.8 11.2:10.75 11.25:10.75 11.25:10.6 11.3:10.6 11.3:10.5 11.35:10.5 11.35:10.4 11.4:10.4 11.4:10.3 11.45:10.3 11.45:10.15 11.5:10.15 11.5:10.05 11.55:10.05 11.55:9.9 11.6:9.9 11.6:9.75 11.65:9.75 11.65:9.55 11.7:9.55 11.7:9.4 11.75:9.4 11.75:9.15 11.8:9.15 11.8:8.9 11.85:8.9 11.85:8.6 11.9:8.6 11.9:8.1 11.95:8.1 11.95:13.05 11.9:13.05 11.9:13.1 11.85:13.1 11.85:13.15 11.8:13.15 11.8:13.2 11.75:13.2 11.75:13.25 11.7:13.25 11.7:13.3 11.65:13.3 11.65:13.35 11.6:13.35 11.6:13.4 11.55:13.4 11.55:13.45 11.45:13.45 11.45:13.5 11.4:13.5 11.4:13.55 11.35:13.55 11.35:13.6 11.3:13.6 11.3:13.65 11.25:13.65 11.25:13.7 11.15:13.7 11.15:13.75 11.1:13.75 11.1:13.8 11:13.8 11:13.85 10.95:13.85 10.95:13.9 10.85:13.9 10.85:13.95 10.8:13.95 10.8:14 10.7:14 10.7:14.05 10.65:14.05 10.65:14.1 10.55:14.1 10.55:14.15 10.45:14.15 10.45:14.2 10.35:14.2 10.35:14.25 10.25:14.25 10.25:14.3 10.15:14.3 10.15:14.35 10.05:14.35 10.05:14.4 9.95:14.4 9.95:14.45 9.85:14.45 9.85:14.5 9.7:14.5 9.7:14.55 9.55:14.55 9.55:14.6 9.4:14.6 9.4:14.65 9.25:14.65 9.25:14.7 9.1:14.7 9.1:14.75 8.9:14.75 8.9:14.8 8.7:14.8 8.7:14.85 8.4:14.85 8.4:14.9 8.1:14.9 8.1:14.95 7.6:14.95 7.6:15 6.3:15 6.3:14.95 5.8:14.95 5.8:14.9 5.45:14.9 5.45:14.85 5.2:14.85 5.2:14.8 5:14.8 5:14.75 4.8:14.75 4.8:14.7 4.65:14.7 4.65:14.65 4.5:14.65 4.5:14.6 4.35:14.6 4.35:14.55 4.2:14.55 4.2:14.5 4.05:14.5 4.05:14.45 3.95:14.45 3.95:14.4 3.85:14.4 3.85:14.35 3.75:14.35 3.75:14.3 3.65:14.3 3.65:14.25 3.55:14.25 3.55:14.2 3.45:14.2 3.45:14.15 3.35:14.15 3.35:14.1 3.25:14.1 3.25:14.05 3.2:14.05 3.2:14 3.1:14 3.1:13.95 3.05:13.95 3.05:13.9 2.95:13.9 2.95:13.85 2.9:13.85 2.9:13.8 2.8:13.8 2.8:13.75 2.75:13.75 2.75:13.7 2.65:13.7 2.65:13.65 2.6:13.65 2.6:13.6 2.55:13.6 2.55:13.55 2.5:13.55 2.5:13.5 2.45:13.5 2.45:13.45 2.35:13.45 2.35:13.4 2.3:13.4 2.3:13.35 2.25:13.35 2.25:13.3 2.2:13.3 2.2:13.25 2.15:13.25 2.15:13.2 2.1:13.2 2.1:13.15 2.05:13.15 2.05:13.1 2:13.1 2:13.05 1.95:13.05 1.95:13 1.9:13 1.9:12.95 1.85:12.95 1.85:12.9 1.8:12.9 1.8:12.8 1.75:12.8 1.75:12.75 1.7:12.75 1.7:12.7 1.65:12.7 1.65:12.65 1.6:12.65 1.6:12.55 1.55:12.55 1.55:12.5 1.5:12.5 1.5:12.45 1.45:12.45 1.45:12.35 1.4:12.35 1.4:12.3 1.35:12.3 1.35:12.25 1.3:12.25 1.3:12.15 1.25:12.15 1.25:12.1 1.2:12.1 1.2:12 1.15:12 1.15:11.9 1.1:11.9 1.1:11.85 1.05:11.85 1.05:11.75 1:11.75 1:11.65 0.95:11.65 0.95:11.55 0.9:11.55 0.9:11.45 0.85:11.45 0.85:11.35 0.8:11.35 0.8:11.25 0.75:11.25 0.75:11.15 0.7:11.15 0.7:11.05 0.65:11.05 0.65:10.9 0.6:10.9 0.6:10.8 0.55:10.8 0.55:10.65 0.5:10.65 0.5:10.55 0.45:10.55 0.45:10.4 0.4:10.4 0.4:10.2 0.35:10.2 0.35:10.05 0.3:10.05 0.3:9.9 0.25:9.9 0.25:9.7 0.2:9.7 0.2:9.5 0.15:9.5 0.15:9.25 0.1:9.25 0.1:8.95 0.05:8.95 0.05:8.65 0:8.65 0:6.3 0.05:6.3 0.05:6 0.1:6 0.1:5.7 0.15:5.7 0.15:5.45 0.2:5.45 0.2:5.25 0.25:5.25 0.25:5.05 0.3:5.05 0.3:4.9 0.35:4.9 0.35:4.75 0.4:4.75 0.4:4.55 0.45:4.55 0.45:4.4 0.5:4.4 0.5:4.3 0.55:4.3 0.55:4.15 0.6:4.15 0.6:4.05 0.65:4.05 0.65:3.9 0.7:3.9 0.7:3.8 0.75:3.8 0.75:3.7 0.8:3.7 0.8:3.6 0.85:3.6 0.85:3.5 0.9:3.5 0.9:3.4 0.95:3.4 0.95:3.3 1:3.3 1:3.2 1.05:3.2 1.05:3.1 1.1:3.1 1.1:3.05 1.15:3.05 1.15:2.95 1.2:2.95 1.2:2.85 1.25:2.85 1.25:2.8 1.3:2.8 1.3:2.7 1.35:2.7 1.35:2.65 1.4:2.65 1.4:2.55 1.45:2.55 1.45:2.5 1.5:2.5 1.5:2.45 1.55:2.45 1.55:2.4 1.6:2.4 1.6:2.3 1.65:2.3 1.65:2.25 1.7:2.25 1.7:2.2 1.75:2.2 1.75:2.15 1.8:2.15 1.8:2.05 1.85:2.05 1.85:2 1.9:2 1.9:1.95 1.95:1.95 1.95:1.9 2:1.9 2:1.85 2.05:1.85 2.05:1.8 2.1:1.8 2.1:1.75 2.15:1.75 2.15:1.7 2.2:1.7 2.2:1.65 2.25:1.65 2.25:1.6 2.3:1.6 2.3:1.55 2.35:1.55 2.35:1.5 2.45:1.5 2.45:1.45 2.5:1.45 2.5:1.4 2.55:1.4 2.55:1.35 2.6:1.35 2.6:1.3 2.65:1.3 2.65:1.25 2.75:1.25 2.75:1.2 2.8:1.2 2.8:1.15 2.9:1.15 2.9:1.1 2.95:1.1 2.95:1.05 3:1.05 3:1 3.1:1 3.1:0.95 3.2:0.95 3.2:0.9 3.25:0.9 3.25:0.85 3.35:0.85 3.35:0.8 3.45:0.8 3.45:0.75 3.55:0.75 3.55:0.7 3.65:0.7 3.65:0.65 3.75:0.65 3.75:0.6 3.85:0.6 3.85:0.55 3.95:0.55 3.95:0.5 4.05:0.5 4.05:0.45 4.2:0.45 4.2:0.4 4.35:0.4 4.35:0.35 4.5:0.35 4.5:0.3 4.65:0.3 4.65:0.25 4.8:0.25 4.8:0.2 5:0.2 5:0.15 5.2:0.15 5.2:0.1 5.45:0.1 5.45:0.05 5.8:0.05 5.8:0 8.1:0 8.1:0.05 8.4:0.05 8.4:0.1 8.7:0.1 8.7:0.15 8.9:0.15 8.9:0.2 9.1:0.2 9.1:0.25 9.25:0.25 9.25:0.3 9.45:0.3 9.45:0.35 9.55:0.35 9.55:0.4 9.7:0.4 9.7:0.45 9.8:0.45 9.8:0.5 9.95:0.5 9.95:0.55 10.05:0.55 10.05:0.6 11.05:0.6 11.05:0.55 11.15:0.55 11.15:0.5 12.3:0.5 12.3:2.4 12.35:2.4 12.35:2.45 12.4:2.45 12.4:2.5 12.45:2.5 12.45:2.6 12.5:2.6 12.5:2.65 12.55:2.65 12.55:2.75 12.6:2.75 12.6:2.8 12.65:2.8 12.65:2.9 12.7:2.9 12.7:2.95 12.75:2.95 12.75:3.05 12.8:3.05 12.8:3.1 12.85:3.1 12.85:3.2 12.9:3.2 12.9:3.3 12.95:3.3 12.95:3.4 13:3.4 13:3.5 13.05:3.5 13.05:3.6 13.1:3.6 13.1:3.7 13.15:3.7 13.15:3.8 13.2:3.8 13.2:3.9 13.25:3.9 13.25:4.05 13.3:4.05 13.3:4.15 13.35:4.15 13.35:4.3 13.4:4.3 13.4:4.4 13.45:4.4 13.45:4.55 13.5:4.55 13.5:4.7 13.55:4.7 13.55:4.85 13.6:4.85 13.6:5.05 13.65:5.05 13.65:5.25 13.7:5.25 13.7:5.45 13.75:5.45 13.75:5.7 13.8:5.7 13.8:5.95 13.85:5.95 13.85:6.3 13.9:6.3 13.9:6.85 13.95:6.85)
letterShapes["R"] = (list 11.25:11.3 11.2:11.3 11.2:11.55 11.15:11.55 11.15:11.7 11.1:11.7 11.1:11.9 11.05:11.9 11.05:12 11:12 11:12.15 10.95:12.15 10.95:12.25 10.9:12.25 10.9:12.35 10.85:12.35 10.85:12.45 10.8:12.45 10.8:12.55 10.75:12.55 10.75:12.6 10.7:12.6 10.7:12.7 10.65:12.7 10.65:12.75 10.6:12.75 10.6:12.8 10.55:12.8 10.55:12.9 10.5:12.9 10.5:12.95 10.45:12.95 10.45:13 10.4:13 10.4:13.05 10.35:13.05 10.35:13.1 10.3:13.1 10.3:13.15 10.25:13.15 10.25:13.2 10.2:13.2 10.2:13.25 10.15:13.25 10.15:13.3 10.05:13.3 10.05:13.35 10:13.35 10:13.4 9.95:13.4 9.95:13.45 9.85:13.45 9.85:13.5 9.8:13.5 9.8:13.55 9.7:13.55 9.7:13.6 9.65:13.6 9.65:13.65 9.55:13.65 9.55:13.7 9.45:13.7 9.45:13.75 9.35:13.75 9.35:13.8 9.3:13.8 9.3:9.8 9.25:9.8 9.25:9.5 9.2:9.5 9.2:9.3 9.15:9.3 9.15:9.15 9.1:9.15 9.1:9.05 9.05:9.05 9.05:8.9 9:8.9 9:8.85 8.95:8.85 8.95:8.75 8.9:8.75 8.9:8.7 8.85:8.7 8.85:8.6 8.8:8.6 8.8:8.55 8.75:8.55 8.75:8.5 8.7:8.5 8.7:8.45 8.65:8.45 8.65:8.4 8.6:8.4 8.6:8.35 8.55:8.35 8.55:8.3 8.5:8.3 8.5:8.25 8.4:8.25 8.4:8.2 8.35:8.2 8.35:8.15 8.25:8.15 8.25:8.1 8.15:8.1 8.15:8.05 8.05:8.05 8.05:8 7.95:8 7.95:7.95 7.75:7.95 7.75:7.9 7.6:7.9 7.6:7.85 7.35:7.85 7.35:7.8 6.95:7.8 6.95:7.75 1.9:7.75 1.9:12.65 7.2:12.65 7.2:12.6 7.6:12.6 7.6:12.55 7.8:12.55 7.8:12.5 7.95:12.5 7.95:12.45 8.1:12.45 8.1:12.4 8.2:12.4 8.2:12.35 8.3:12.35 8.3:12.3 8.4:12.3 8.4:12.25 8.45:12.25 8.45:12.2 8.5:12.2 8.5:12.15 8.6:12.15 8.6:12.1 8.65:12.1 8.65:12.05 8.7:12.05 8.7:12 8.75:12 8.75:11.95 8.8:11.95 8.8:11.85 8.85:11.85 8.85:11.8 8.9:11.8 8.9:11.75 8.95:11.75 8.95:11.65 9:11.65 9:11.55 9.05:11.55 9.05:11.45 9.1:11.45 9.1:11.35 9.15:11.35 9.15:11.2 9.2:11.2 9.2:11 9.25:11 9.25:10.7 9.3:10.7 9.3:13.8 9.25:13.8 9.25:13.85 9.15:13.85 9.15:13.9 9:13.9 9:13.95 8.85:13.95 8.85:14 8.7:14 8.7:14.05 8.5:14.05 8.5:14.1 8.3:14.1 8.3:14.15 8.05:14.15 8.05:14.2 7.75:14.2 7.75:14.25 7.25:14.25 7.25:14.3 0:14.3 0:0 1.9:0 1.9:6.1 7.05:6.1 7.05:6.05 7.4:6.05 7.4:6 7.65:6 7.65:5.95 7.8:5.95 7.8:5.9 7.95:5.9 7.95:5.85 8.05:5.85 8.05:5.8 8.15:5.8 8.15:5.75 8.25:5.75 8.25:5.7 8.3:5.7 8.3:5.65 8.4:5.65 8.4:5.6 8.45:5.6 8.45:5.55 8.5:5.55 8.5:5.5 8.55:5.5 8.55:5.45 8.6:5.45 8.6:5.4 8.65:5.4 8.65:5.35 8.7:5.35 8.7:5.3 8.75:5.3 8.75:5.2 8.8:5.2 8.8:5.15 8.85:5.15 8.85:5.05 8.9:5.05 8.9:4.95 8.95:4.95 8.95:4.8 9:4.8 9:4.65 9.05:4.65 9.05:4.45 9.1:4.45 9.1:4.15 9.15:4.15 9.15:2.7 9.2:2.7 9.2:1.8 9.25:1.8 9.25:1.2 9.3:1.2 9.3:0.8 9.35:0.8 9.35:0.45 9.4:0.45 9.4:0.2 9.45:0.2 9.45:0 11.2:0 11.2:1.35 11.15:1.35 11.15:2.35 11.1:2.35 11.1:3.45 11.05:3.45 11.05:4.45 11:4.45 11:4.95 10.95:4.95 10.95:5.2 10.9:5.2 10.9:5.4 10.85:5.4 10.85:5.6 10.8:5.6 10.8:5.7 10.75:5.7 10.75:5.85 10.7:5.85 10.7:5.95 10.65:5.95 10.65:6 10.6:6 10.6:6.1 10.55:6.1 10.55:6.15 10.5:6.15 10.5:6.25 10.45:6.25 10.45:6.3 10.4:6.3 10.4:6.35 10.35:6.35 10.35:6.4 10.3:6.4 10.3:6.45 10.25:6.45 10.25:6.5 10.2:6.5 10.2:6.55 10.1:6.55 10.1:6.6 10.05:6.6 10.05:7.5 10.1:7.5 10.1:7.55 10.15:7.55 10.15:7.6 10.2:7.6 10.2:7.65 10.25:7.65 10.25:7.7 10.3:7.7 10.3:7.75 10.35:7.75 10.35:7.8 10.4:7.8 10.4:7.85 10.45:7.85 10.45:7.9 10.5:7.9 10.5:7.95 10.55:7.95 10.55:8.05 10.6:8.05 10.6:8.1 10.65:8.1 10.65:8.15 10.7:8.15 10.7:8.25 10.75:8.25 10.75:8.3 10.8:8.3 10.8:8.4 10.85:8.4 10.85:8.5 10.9:8.5 10.9:8.6 10.95:8.6 10.95:8.7 11:8.7 11:8.8 11.05:8.8 11.05:8.95 11.1:8.95 11.1:9.1 11.15:9.1 11.15:9.3 11.2:9.3 11.2:9.55 11.25:9.55)
letterShapes["S"] = (list 11.2:5.1 11.15:5.1 11.15:5.3 11.1:5.3 11.1:5.5 11.05:5.5 11.05:5.65 11:5.65 11:5.8 10.95:5.8 10.95:5.95 10.9:5.95 10.9:6.05 10.85:6.05 10.85:6.15 10.8:6.15 10.8:6.25 10.75:6.25 10.75:6.3 10.7:6.3 10.7:6.4 10.65:6.4 10.65:6.45 10.6:6.45 10.6:6.55 10.55:6.55 10.55:6.6 10.5:6.6 10.5:6.65 10.45:6.65 10.45:6.75 10.4:6.75 10.4:6.8 10.35:6.8 10.35:6.85 10.3:6.85 10.3:6.9 10.25:6.9 10.25:6.95 10.2:6.95 10.2:7 10.15:7 10.15:7.05 10.1:7.05 10.1:7.1 10.05:7.1 10.05:7.15 9.95:7.15 9.95:7.2 9.9:7.2 9.9:7.25 9.85:7.25 9.85:7.3 9.75:7.3 9.75:7.35 9.7:7.35 9.7:7.4 9.6:7.4 9.6:7.45 9.55:7.45 9.55:7.5 9.45:7.5 9.45:7.55 9.35:7.55 9.35:7.6 9.3:7.6 9.3:7.65 9.15:7.65 9.15:7.7 9.05:7.7 9.05:7.75 8.95:7.75 8.95:7.8 8.85:7.8 8.85:7.85 8.7:7.85 8.7:7.9 8.55:7.9 8.55:7.95 8.4:7.95 8.4:8 8.25:8 8.25:8.05 8.05:8.05 8.05:8.1 7.85:8.1 7.85:8.15 7.6:8.15 7.6:8.2 7.4:8.2 7.4:8.25 7.2:8.25 7.2:8.3 6.95:8.3 6.95:8.35 6.75:8.35 6.75:8.4 6.55:8.4 6.55:8.45 6.3:8.45 6.3:8.5 6.1:8.5 6.1:8.55 5.9:8.55 5.9:8.6 5.65:8.6 5.65:8.65 5.45:8.65 5.45:8.7 5.2:8.7 5.2:8.75 5:8.75 5:8.8 4.8:8.8 4.8:8.85 4.55:8.85 4.55:8.9 4.35:8.9 4.35:8.95 4.15:8.95 4.15:9 3.9:9 3.9:9.05 3.75:9.05 3.75:9.1 3.55:9.1 3.55:9.15 3.4:9.15 3.4:9.2 3.3:9.2 3.3:9.25 3.2:9.25 3.2:9.3 3.1:9.3 3.1:9.35 3:9.35 3:9.4 2.9:9.4 2.9:9.45 2.85:9.45 2.85:9.5 2.75:9.5 2.75:9.55 2.7:9.55 2.7:9.6 2.65:9.6 2.65:9.65 2.6:9.65 2.6:9.7 2.55:9.7 2.55:9.75 2.5:9.75 2.5:9.85 2.45:9.85 2.45:9.9 2.4:9.9 2.4:10 2.35:10 2.35:10.1 2.3:10.1 2.3:10.25 2.25:10.25 2.25:11.5 2.3:11.5 2.3:11.7 2.35:11.7 2.35:11.8 2.4:11.8 2.4:11.95 2.45:11.95 2.45:12.05 2.5:12.05 2.5:12.15 2.55:12.15 2.55:12.2 2.6:12.2 2.6:12.25 2.65:12.25 2.65:12.35 2.7:12.35 2.7:12.4 2.75:12.4 2.75:12.45 2.8:12.45 2.8:12.5 2.85:12.5 2.85:12.55 2.9:12.55 2.9:12.6 2.95:12.6 2.95:12.65 3:12.65 3:12.7 3.1:12.7 3.1:12.75 3.15:12.75 3.15:12.8 3.25:12.8 3.25:12.85 3.3:12.85 3.3:12.9 3.4:12.9 3.4:12.95 3.5:12.95 3.5:13 3.65:13 3.65:13.05 3.75:13.05 3.75:13.1 3.9:13.1 3.9:13.15 4.05:13.15 4.05:13.2 4.25:13.2 4.25:13.25 4.55:13.25 4.55:13.3 4.95:13.3 4.95:13.35 6:13.35 6:13.3 6.4:13.3 6.4:13.25 6.6:13.25 6.6:13.2 6.8:13.2 6.8:13.15 7:13.15 7:13.1 7.15:13.1 7.15:13.05 7.25:13.05 7.25:13 7.4:13 7.4:12.95 7.5:12.95 7.5:12.9 7.6:12.9 7.6:12.85 7.65:12.85 7.65:12.8 7.75:12.8 7.75:12.75 7.85:12.75 7.85:12.7 7.9:12.7 7.9:12.65 7.95:12.65 7.95:12.6 8.05:12.6 8.05:12.55 8.1:12.55 8.1:12.5 8.15:12.5 8.15:12.45 8.2:12.45 8.2:12.4 8.25:12.4 8.25:12.35 8.3:12.35 8.3:12.3 8.35:12.3 8.35:12.25 8.4:12.25 8.4:12.2 8.45:12.2 8.45:12.15 8.5:12.15 8.5:12.05 8.55:12.05 8.55:12 8.6:12 8.6:11.9 8.65:11.9 8.65:11.85 8.7:11.85 8.7:11.75 8.75:11.75 8.75:11.65 8.8:11.65 8.8:11.5 8.85:11.5 8.85:11.4 8.9:11.4 8.9:11.25 8.95:11.25 8.95:11 9:11 9:10.7 9.05:10.7 9.05:10.45 10.7:10.45 10.7:11.7 10.65:11.7 10.65:11.9 10.6:11.9 10.6:12.05 10.55:12.05 10.55:12.2 10.5:12.2 10.5:12.3 10.45:12.3 10.45:12.45 10.4:12.45 10.4:12.55 10.35:12.55 10.35:12.65 10.3:12.65 10.3:12.75 10.25:12.75 10.25:12.85 10.2:12.85 10.2:12.95 10.15:12.95 10.15:13 10.1:13 10.1:13.05 10.05:13.05 10.05:13.15 10:13.15 10:13.2 9.95:13.2 9.95:13.3 9.9:13.3 9.9:13.35 9.85:13.35 9.85:13.4 9.8:13.4 9.8:13.45 9.75:13.45 9.75:13.5 9.7:13.5 9.7:13.55 9.65:13.55 9.65:13.6 9.6:13.6 9.6:13.65 9.55:13.65 9.55:13.7 9.5:13.7 9.5:13.75 9.45:13.75 9.45:13.8 9.4:13.8 9.4:13.85 9.35:13.85 9.35:13.9 9.25:13.9 9.25:13.95 9.2:13.95 9.2:14 9.15:14 9.15:14.05 9.05:14.05 9.05:14.1 9:14.1 9:14.15 8.9:14.15 8.9:14.2 8.8:14.2 8.8:14.25 8.75:14.25 8.75:14.3 8.65:14.3 8.65:14.35 8.55:14.35 8.55:14.4 8.45:14.4 8.45:14.45 8.3:14.45 8.3:14.5 8.2:14.5 8.2:14.55 8.05:14.55 8.05:14.6 7.9:14.6 7.9:14.65 7.75:14.65 7.75:14.7 7.6:14.7 7.6:14.75 7.4:14.75 7.4:14.8 7.15:14.8 7.15:14.85 6.9:14.85 6.9:14.9 6.55:14.9 6.55:14.95 6:14.95 6:15 4.65:15 4.65:14.95 4.25:14.95 4.25:14.9 3.95:14.9 3.95:14.85 3.7:14.85 3.7:14.8 3.5:14.8 3.5:14.75 3.35:14.75 3.35:14.7 3.15:14.7 3.15:14.65 3:14.65 3:14.6 2.9:14.6 2.9:14.55 2.8:14.55 2.8:14.5 2.7:14.5 2.7:14.45 2.55:14.45 2.55:14.4 2.5:14.4 2.5:14.35 2.4:14.35 2.4:14.3 2.3:14.3 2.3:14.25 2.2:14.25 2.2:14.2 2.15:14.2 2.15:14.15 2.05:14.15 2.05:14.1 2:14.1 2:14.05 1.95:14.05 1.95:14 1.85:14 1.85:13.95 1.8:13.95 1.8:13.9 1.75:13.9 1.75:13.85 1.7:13.85 1.7:13.8 1.65:13.8 1.65:13.75 1.6:13.75 1.6:13.7 1.55:13.7 1.55:13.65 1.45:13.65 1.45:13.55 1.4:13.55 1.4:13.5 1.35:13.5 1.35:13.45 1.3:13.45 1.3:13.4 1.25:13.4 1.25:13.35 1.2:13.35 1.2:13.3 1.15:13.3 1.15:13.2 1.1:13.2 1.1:13.15 1.05:13.15 1.05:13.05 1:13.05 1:13 0.95:13 0.95:12.9 0.9:12.9 0.9:12.8 0.85:12.8 0.85:12.75 0.8:12.75 0.8:12.65 0.75:12.65 0.75:12.55 0.7:12.55 0.7:12.4 0.65:12.4 0.65:12.3 0.6:12.3 0.6:12.15 0.55:12.15 0.55:12 0.5:12 0.5:11.85 0.45:11.85 0.45:11.65 0.4:11.65 0.4:11.4 0.35:11.4 0.35:9.85 0.4:9.85 0.4:9.65 0.45:9.65 0.45:9.45 0.5:9.45 0.5:9.3 0.55:9.3 0.55:9.2 0.6:9.2 0.6:9.1 0.65:9.1 0.65:9 0.7:9 0.7:8.9 0.75:8.9 0.75:8.85 0.8:8.85 0.8:8.75 0.85:8.75 0.85:8.7 0.9:8.7 0.9:8.6 0.95:8.6 0.95:8.55 1:8.55 1:8.5 1.05:8.5 1.05:8.45 1.1:8.45 1.1:8.4 1.15:8.4 1.15:8.35 1.2:8.35 1.2:8.3 1.25:8.3 1.25:8.25 1.3:8.25 1.3:8.2 1.35:8.2 1.35:8.15 1.4:8.15 1.4:8.1 1.45:8.1 1.45:8.05 1.5:8.05 1.5:8 1.6:8 1.6:7.95 1.65:7.95 1.65:7.9 1.75:7.9 1.75:7.85 1.8:7.85 1.8:7.8 1.9:7.8 1.9:7.75 2:7.75 2:7.7 2.1:7.7 2.1:7.65 2.2:7.65 2.2:7.6 2.3:7.6 2.3:7.55 2.4:7.55 2.4:7.5 2.5:7.5 2.5:7.45 2.65:7.45 2.65:7.4 2.8:7.4 2.8:7.35 2.95:7.35 2.95:7.3 3.15:7.3 3.15:7.25 3.35:7.25 3.35:7.2 3.55:7.2 3.55:7.15 3.8:7.15 3.8:7.1 4:7.1 4:7.05 4.2:7.05 4.2:7 4.45:7 4.45:6.95 4.65:6.95 4.65:6.9 4.85:6.9 4.85:6.85 5.1:6.85 5.1:6.8 5.3:6.8 5.3:6.75 5.5:6.75 5.5:6.7 5.75:6.7 5.75:6.65 5.95:6.65 5.95:6.6 6.15:6.6 6.15:6.55 6.4:6.55 6.4:6.5 6.6:6.5 6.6:6.45 6.8:6.45 6.8:6.4 6.95:6.4 6.95:6.35 7.15:6.35 7.15:6.3 7.3:6.3 7.3:6.25 7.45:6.25 7.45:6.2 7.6:6.2 7.6:6.15 7.75:6.15 7.75:6.1 7.9:6.1 7.9:6.05 8:6.05 8:6 8.1:6 8.1:5.95 8.25:5.95 8.25:5.9 8.35:5.9 8.35:5.85 8.4:5.85 8.4:5.8 8.5:5.8 8.5:5.75 8.55:5.75 8.55:5.7 8.65:5.7 8.65:5.65 8.7:5.65 8.7:5.6 8.75:5.6 8.75:5.55 8.8:5.55 8.8:5.5 8.9:5.5 8.9:5.4 8.95:5.4 8.95:5.35 9:5.35 9:5.3 9.05:5.3 9.05:5.2 9.1:5.2 9.1:5.15 9.15:5.15 9.15:5.05 9.2:5.05 9.2:4.9 9.25:4.9 9.25:4.75 9.3:4.75 9.3:3.4 9.25:3.4 9.25:3.25 9.2:3.25 9.2:3.15 9.15:3.15 9.15:3 9.1:3 9.1:2.95 9.05:2.95 9.05:2.85 9:2.85 9:2.8 8.95:2.8 8.95:2.7 8.9:2.7 8.9:2.65 8.85:2.65 8.85:2.6 8.8:2.6 8.8:2.55 8.75:2.55 8.75:2.5 8.7:2.5 8.7:2.45 8.65:2.45 8.65:2.4 8.55:2.4 8.55:2.35 8.5:2.35 8.5:2.3 8.45:2.3 8.45:2.25 8.35:2.25 8.35:2.2 8.25:2.2 8.25:2.15 8.2:2.15 8.2:2.1 8.1:2.1 8.1:2.05 8:2.05 8:2 7.85:2 7.85:1.95 7.75:1.95 7.75:1.9 7.55:1.9 7.55:1.85 7.4:1.85 7.4:1.8 7.2:1.8 7.2:1.75 7:1.75 7:1.7 6.7:1.7 6.7:1.65 6.25:1.65 6.25:1.6 5.05:1.6 5.05:1.65 4.65:1.65 4.65:1.7 4.35:1.7 4.35:1.75 4.15:1.75 4.15:1.8 3.95:1.8 3.95:1.85 3.8:1.85 3.8:1.9 3.7:1.9 3.7:1.95 3.55:1.95 3.55:2 3.45:2 3.45:2.05 3.35:2.05 3.35:2.1 3.25:2.1 3.25:2.15 3.15:2.15 3.15:2.2 3.05:2.2 3.05:2.25 3:2.25 3:2.3 2.9:2.3 2.9:2.35 2.85:2.35 2.85:2.4 2.8:2.4 2.8:2.45 2.7:2.45 2.7:2.5 2.65:2.5 2.65:2.55 2.6:2.55 2.6:2.6 2.55:2.6 2.55:2.65 2.5:2.65 2.5:2.7 2.45:2.7 2.45:2.75 2.4:2.75 2.4:2.8 2.35:2.8 2.35:2.85 2.3:2.85 2.3:2.9 2.25:2.9 2.25:3 2.2:3 2.2:3.05 2.15:3.05 2.15:3.15 2.1:3.15 2.1:3.2 2.05:3.2 2.05:3.3 2:3.3 2:3.4 1.95:3.4 1.95:3.5 1.9:3.5 1.9:3.65 1.85:3.65 1.85:3.8 1.8:3.8 1.8:3.95 1.75:3.95 1.75:4.15 1.7:4.15 1.7:4.5 1.65:4.5 1.65:4.95 0:4.95 0:3.35 0.05:3.35 0.05:3.2 0.1:3.2 0.1:3.05 0.15:3.05 0.15:2.9 0.2:2.9 0.2:2.8 0.25:2.8 0.25:2.65 0.3:2.65 0.3:2.55 0.35:2.55 0.35:2.45 0.4:2.45 0.4:2.4 0.45:2.4 0.45:2.3 0.5:2.3 0.5:2.2 0.55:2.2 0.55:2.15 0.6:2.15 0.6:2.05 0.65:2.05 0.65:2 0.7:2 0.7:1.95 0.75:1.95 0.75:1.85 0.8:1.85 0.8:1.8 0.85:1.8 0.85:1.75 0.9:1.75 0.9:1.7 0.95:1.7 0.95:1.65 1:1.65 1:1.6 1.05:1.6 1.05:1.55 1.1:1.55 1.1:1.5 1.15:1.5 1.15:1.45 1.2:1.45 1.2:1.4 1.25:1.4 1.25:1.35 1.3:1.35 1.3:1.3 1.35:1.3 1.35:1.25 1.4:1.25 1.4:1.2 1.45:1.2 1.45:1.15 1.5:1.15 1.5:1.1 1.6:1.1 1.6:1.05 1.65:1.05 1.65:1 1.7:1 1.7:0.95 1.8:0.95 1.8:0.9 1.85:0.9 1.85:0.85 1.9:0.85 1.9:0.8 2:0.8 2:0.75 2.1:0.75 2.1:0.7 2.15:0.7 2.15:0.65 2.25:0.65 2.25:0.6 2.35:0.6 2.35:0.55 2.45:0.55 2.45:0.5 2.55:0.5 2.55:0.45 2.7:0.45 2.7:0.4 2.8:0.4 2.8:0.35 2.95:0.35 2.95:0.3 3.1:0.3 3.1:0.25 3.3:0.25 3.3:0.2 3.5:0.2 3.5:0.15 3.7:0.15 3.7:0.1 3.95:0.1 3.95:0.05 4.3:0.05 4.3:0 6.8:0 6.8:0.05 7.15:0.05 7.15:0.1 7.4:0.1 7.4:0.15 7.65:0.15 7.65:0.2 7.85:0.2 7.85:0.25 8.05:0.25 8.05:0.3 8.2:0.3 8.2:0.35 8.35:0.35 8.35:0.4 8.5:0.4 8.5:0.45 8.6:0.45 8.6:0.5 8.7:0.5 8.7:0.55 8.85:0.55 8.85:0.6 8.95:0.6 8.95:0.65 9.05:0.65 9.05:0.7 9.15:0.7 9.15:0.75 9.25:0.75 9.25:0.8 9.35:0.8 9.35:0.85 9.4:0.85 9.4:0.9 9.5:0.9 9.5:0.95 9.55:0.95 9.55:1 9.65:1 9.65:1.05 9.7:1.05 9.7:1.1 9.75:1.1 9.75:1.15 9.85:1.15 9.85:1.2 9.9:1.2 9.9:1.25 9.95:1.25 9.95:1.3 10:1.3 10:1.35 10.05:1.35 10.05:1.4 10.1:1.4 10.1:1.45 10.15:1.45 10.15:1.5 10.2:1.5 10.2:1.55 10.25:1.55 10.25:1.6 10.3:1.6 10.3:1.65 10.35:1.65 10.35:1.7 10.4:1.7 10.4:1.75 10.45:1.75 10.45:1.8 10.5:1.8 10.5:1.9 10.55:1.9 10.55:1.95 10.6:1.95 10.6:2.05 10.65:2.05 10.65:2.1 10.7:2.1 10.7:2.2 10.75:2.2 10.75:2.3 10.8:2.3 10.8:2.4 10.85:2.4 10.85:2.5 10.9:2.5 10.9:2.6 10.95:2.6 10.95:2.7 11:2.7 11:2.85 11.05:2.85 11.05:3 11.1:3 11.1:3.2 11.15:3.2 11.15:3.45 11.2:3.45)
letterShapes["T"] = (list 11.6:14.3 0:14.3 0:12.6 4.8:12.6 4.8:0 6.75:0 6.75:12.6 11.6:12.6)
letterShapes["U"] = (list 11.3:14.65 9.35:14.65 9.35:5 9.3:5 9.3:4.6 9.25:4.6 9.25:4.35 9.2:4.35 9.2:4.15 9.15:4.15 9.15:3.95 9.1:3.95 9.1:3.85 9.05:3.85 9.05:3.7 9:3.7 9:3.6 8.95:3.6 8.95:3.5 8.9:3.5 8.9:3.4 8.85:3.4 8.85:3.3 8.8:3.3 8.8:3.2 8.75:3.2 8.75:3.1 8.7:3.1 8.7:3.05 8.65:3.05 8.65:2.95 8.6:2.95 8.6:2.9 8.55:2.9 8.55:2.85 8.5:2.85 8.5:2.8 8.45:2.8 8.45:2.75 8.4:2.75 8.4:2.7 8.35:2.7 8.35:2.65 8.3:2.65 8.3:2.6 8.25:2.6 8.25:2.55 8.2:2.55 8.2:2.5 8.15:2.5 8.15:2.45 8.1:2.45 8.1:2.4 8:2.4 8:2.35 7.95:2.35 7.95:2.3 7.9:2.3 7.9:2.25 7.8:2.25 7.8:2.2 7.7:2.2 7.7:2.15 7.65:2.15 7.65:2.1 7.55:2.1 7.55:2.05 7.45:2.05 7.45:2 7.3:2 7.3:1.95 7.2:1.95 7.2:1.9 7.05:1.9 7.05:1.85 6.9:1.85 6.9:1.8 6.7:1.8 6.7:1.75 6.45:1.75 6.45:1.7 6.05:1.7 6.05:1.65 5.05:1.65 5.05:1.7 4.7:1.7 4.7:1.75 4.45:1.75 4.45:1.8 4.25:1.8 4.25:1.85 4.1:1.85 4.1:1.9 4:1.9 4:1.95 3.85:1.95 3.85:2 3.75:2 3.75:2.05 3.65:2.05 3.65:2.1 3.55:2.1 3.55:2.15 3.5:2.15 3.5:2.2 3.4:2.2 3.4:2.25 3.3:2.25 3.3:2.3 3.25:2.3 3.25:2.35 3.2:2.35 3.2:2.4 3.15:2.4 3.15:2.45 3.05:2.45 3.05:2.5 3:2.5 3:2.55 2.95:2.55 2.95:2.6 2.9:2.6 2.9:2.65 2.85:2.65 2.85:2.7 2.8:2.7 2.8:2.75 2.75:2.75 2.75:2.85 2.7:2.85 2.7:2.9 2.65:2.9 2.65:2.95 2.6:2.95 2.6:3 2.55:3 2.55:3.1 2.5:3.1 2.5:3.2 2.45:3.2 2.45:3.25 2.4:3.25 2.4:3.35 2.35:3.35 2.35:3.45 2.3:3.45 2.3:3.55 2.25:3.55 2.25:3.7 2.2:3.7 2.2:3.85 2.15:3.85 2.15:3.95 2.1:3.95 2.1:4.15 2.05:4.15 2.05:4.35 2:4.35 2:4.6 1.95:4.6 1.95:5 1.9:5 1.9:14.65 0:14.65 0:4.15 0.05:4.15 0.05:3.9 0.1:3.9 0.1:3.65 0.15:3.65 0.15:3.5 0.2:3.5 0.2:3.3 0.25:3.3 0.25:3.15 0.3:3.15 0.3:3.05 0.35:3.05 0.35:2.9 0.4:2.9 0.4:2.8 0.45:2.8 0.45:2.7 0.5:2.7 0.5:2.6 0.55:2.6 0.55:2.5 0.6:2.5 0.6:2.4 0.65:2.4 0.65:2.3 0.7:2.3 0.7:2.2 0.75:2.2 0.75:2.15 0.8:2.15 0.8:2.1 0.85:2.1 0.85:2 0.9:2 0.9:1.95 0.95:1.95 0.95:1.85 1:1.85 1:1.8 1.05:1.8 1.05:1.75 1.1:1.75 1.1:1.7 1.15:1.7 1.15:1.65 1.2:1.65 1.2:1.55 1.25:1.55 1.25:1.5 1.3:1.5 1.3:1.45 1.35:1.45 1.35:1.4 1.4:1.4 1.4:1.35 1.45:1.35 1.45:1.3 1.5:1.3 1.5:1.25 1.6:1.25 1.6:1.2 1.65:1.2 1.65:1.15 1.7:1.15 1.7:1.1 1.75:1.1 1.75:1.05 1.85:1.05 1.85:1 1.9:1 1.9:0.95 1.95:0.95 1.95:0.9 2.05:0.9 2.05:0.85 2.1:0.85 2.1:0.8 2.2:0.8 2.2:0.75 2.3:0.75 2.3:0.7 2.35:0.7 2.35:0.65 2.45:0.65 2.45:0.6 2.55:0.6 2.55:0.55 2.65:0.55 2.65:0.5 2.75:0.5 2.75:0.45 2.9:0.45 2.9:0.4 3:0.4 3:0.35 3.15:0.35 3.15:0.3 3.3:0.3 3.3:0.25 3.45:0.25 3.45:0.2 3.65:0.2 3.65:0.15 3.85:0.15 3.85:0.1 4.1:0.1 4.1:0.05 4.4:0.05 4.4:0 6.6:0 6.6:0.05 6.95:0.05 6.95:0.1 7.15:0.1 7.15:0.15 7.4:0.15 7.4:0.2 7.6:0.2 7.6:0.25 7.75:0.25 7.75:0.3 7.9:0.3 7.9:0.35 8.05:0.35 8.05:0.4 8.15:0.4 8.15:0.45 8.3:0.45 8.3:0.5 8.4:0.5 8.4:0.55 8.5:0.55 8.5:0.6 8.6:0.6 8.6:0.65 8.7:0.65 8.7:0.7 8.8:0.7 8.8:0.75 8.9:0.75 8.9:0.8 8.95:0.8 8.95:0.85 9.05:0.85 9.05:0.9 9.15:0.9 9.15:0.95 9.2:0.95 9.2:1 9.25:1 9.25:1.05 9.35:1.05 9.35:1.1 9.4:1.1 9.4:1.15 9.45:1.15 9.45:1.2 9.55:1.2 9.55:1.25 9.6:1.25 9.6:1.3 9.65:1.3 9.65:1.35 9.7:1.35 9.7:1.4 9.75:1.4 9.75:1.45 9.8:1.45 9.8:1.5 9.85:1.5 9.85:1.55 9.9:1.55 9.9:1.6 9.95:1.6 9.95:1.65 10:1.65 10:1.7 10.05:1.7 10.05:1.75 10.1:1.75 10.1:1.85 10.15:1.85 10.15:1.9 10.2:1.9 10.2:1.95 10.25:1.95 10.25:2 10.3:2 10.3:2.1 10.35:2.1 10.35:2.15 10.4:2.15 10.4:2.25 10.45:2.25 10.45:2.3 10.5:2.3 10.5:2.4 10.55:2.4 10.55:2.5 10.6:2.5 10.6:2.55 10.65:2.55 10.65:2.65 10.7:2.65 10.7:2.75 10.75:2.75 10.75:2.85 10.8:2.85 10.8:3 10.85:3 10.85:3.1 10.9:3.1 10.9:3.2 10.95:3.2 10.95:3.35 11:3.35 11:3.5 11.05:3.5 11.05:3.7 11.1:3.7 11.1:3.9 11.15:3.9 11.15:4.1 11.2:4.1 11.2:4.4 11.25:4.4 11.25:4.85 11.3:4.85)
letterShapes["V"] = (list 11.7:14.3 9.9:14.3 9.9:14.2 9.85:14.2 9.85:14.05 9.8:14.05 9.8:13.9 9.75:13.9 9.75:13.75 9.7:13.75 9.7:13.55 9.65:13.55 9.65:13.4 9.6:13.4 9.6:13.25 9.55:13.25 9.55:13.1 9.5:13.1 9.5:12.95 9.45:12.95 9.45:12.8 9.4:12.8 9.4:12.65 9.35:12.65 9.35:12.5 9.3:12.5 9.3:12.35 9.25:12.35 9.25:12.2 9.2:12.2 9.2:12.05 9.15:12.05 9.15:11.9 9.1:11.9 9.1:11.75 9.05:11.75 9.05:11.6 9:11.6 9:11.45 8.95:11.45 8.95:11.3 8.9:11.3 8.9:11.15 8.85:11.15 8.85:11 8.8:11 8.8:10.85 8.75:10.85 8.75:10.7 8.7:10.7 8.7:10.55 8.65:10.55 8.65:10.4 8.6:10.4 8.6:10.25 8.55:10.25 8.55:10.1 8.5:10.1 8.5:9.95 8.45:9.95 8.45:9.8 8.4:9.8 8.4:9.65 8.35:9.65 8.35:9.5 8.3:9.5 8.3:9.35 8.25:9.35 8.25:9.2 8.2:9.2 8.2:9.05 8.15:9.05 8.15:8.9 8.1:8.9 8.1:8.75 8.05:8.75 8.05:8.6 8:8.6 8:8.45 7.95:8.45 7.95:8.3 7.9:8.3 7.9:8.15 7.85:8.15 7.85:8 7.8:8 7.8:7.85 7.75:7.85 7.75:7.7 7.7:7.7 7.7:7.55 7.65:7.55 7.65:7.4 7.6:7.4 7.6:7.25 7.55:7.25 7.55:7.1 7.5:7.1 7.5:6.95 7.45:6.95 7.45:6.8 7.4:6.8 7.4:6.65 7.35:6.65 7.35:6.5 7.3:6.5 7.3:6.35 7.25:6.35 7.25:6.2 7.2:6.2 7.2:6.05 7.15:6.05 7.15:5.9 7.1:5.9 7.1:5.75 7.05:5.75 7.05:5.6 7:5.6 7:5.45 6.95:5.45 6.95:5.3 6.9:5.3 6.9:5.15 6.85:5.15 6.85:5 6.8:5 6.8:4.85 6.75:4.85 6.75:4.65 6.7:4.65 6.7:4.5 6.65:4.5 6.65:4.35 6.6:4.35 6.6:4.2 6.55:4.2 6.55:4.05 6.5:4.05 6.5:3.9 6.45:3.9 6.45:3.75 6.4:3.75 6.4:3.6 6.35:3.6 6.35:3.45 6.3:3.45 6.3:3.3 5.4:3.3 5.4:3.35 5.35:3.35 5.35:3.5 5.3:3.5 5.3:3.65 5.25:3.65 5.25:3.8 5.2:3.8 5.2:3.95 5.15:3.95 5.15:4.1 5.1:4.1 5.1:4.25 5.05:4.25 5.05:4.4 5:4.4 5:4.55 4.95:4.55 4.95:4.7 4.9:4.7 4.9:4.85 4.85:4.85 4.85:5 4.8:5 4.8:5.15 4.75:5.15 4.75:5.3 4.7:5.3 4.7:5.45 4.65:5.45 4.65:5.6 4.6:5.6 4.6:5.75 4.55:5.75 4.55:5.9 4.5:5.9 4.5:6.05 4.45:6.05 4.45:6.2 4.4:6.2 4.4:6.35 4.35:6.35 4.35:6.5 4.3:6.5 4.3:6.65 4.25:6.65 4.25:6.8 4.2:6.8 4.2:6.95 4.15:6.95 4.15:7.1 4.1:7.1 4.1:7.25 4.05:7.25 4.05:7.4 4:7.4 4:7.55 3.95:7.55 3.95:7.7 3.9:7.7 3.9:7.85 3.85:7.85 3.85:8 3.8:8 3.8:8.15 3.75:8.15 3.75:8.3 3.7:8.3 3.7:8.45 3.65:8.45 3.65:8.6 3.6:8.6 3.6:8.75 3.55:8.75 3.55:8.9 3.5:8.9 3.5:9.05 3.45:9.05 3.45:9.2 3.4:9.2 3.4:9.35 3.35:9.35 3.35:9.5 3.3:9.5 3.3:9.65 3.25:9.65 3.25:9.8 3.2:9.8 3.2:9.95 3.15:9.95 3.15:10.1 3.1:10.1 3.1:10.25 3.05:10.25 3.05:10.4 3:10.4 3:10.55 2.95:10.55 2.95:10.7 2.9:10.7 2.9:10.85 2.85:10.85 2.85:11 2.8:11 2.8:11.15 2.75:11.15 2.75:11.3 2.7:11.3 2.7:11.45 2.65:11.45 2.65:11.6 2.6:11.6 2.6:11.75 2.55:11.75 2.55:11.9 2.5:11.9 2.5:12.05 2.45:12.05 2.45:12.2 2.4:12.2 2.4:12.35 2.35:12.35 2.35:12.5 2.3:12.5 2.3:12.65 2.25:12.65 2.25:12.8 2.2:12.8 2.2:12.95 2.15:12.95 2.15:13.05 2.1:13.05 2.1:13.2 2.05:13.2 2.05:13.35 2:13.35 2:13.5 1.95:13.5 1.95:13.65 1.9:13.65 1.9:13.8 1.85:13.8 1.85:13.95 1.8:13.95 1.8:14.1 1.75:14.1 1.75:14.25 1.7:14.25 1.7:14.3 0:14.3 0:13 0.05:13 0.05:12.9 0.1:12.9 0.1:12.75 0.15:12.75 0.15:12.6 0.2:12.6 0.2:12.45 0.25:12.45 0.25:12.35 0.3:12.35 0.3:12.2 0.35:12.2 0.35:12.05 0.4:12.05 0.4:11.9 0.45:11.9 0.45:11.8 0.5:11.8 0.5:11.65 0.55:11.65 0.55:11.5 0.6:11.5 0.6:11.35 0.65:11.35 0.65:11.25 0.7:11.25 0.7:11.1 0.75:11.1 0.75:10.95 0.8:10.95 0.8:10.8 0.85:10.8 0.85:10.7 0.9:10.7 0.9:10.55 0.95:10.55 0.95:10.4 1:10.4 1:10.25 1.05:10.25 1.05:10.15 1.1:10.15 1.1:10 1.15:10 1.15:9.85 1.2:9.85 1.2:9.75 1.25:9.75 1.25:9.6 1.3:9.6 1.3:9.45 1.35:9.45 1.35:9.3 1.4:9.3 1.4:9.2 1.45:9.2 1.45:9.05 1.5:9.05 1.5:8.9 1.55:8.9 1.55:8.75 1.6:8.75 1.6:8.65 1.65:8.65 1.65:8.5 1.7:8.5 1.7:8.35 1.75:8.35 1.75:8.2 1.8:8.2 1.8:8.1 1.85:8.1 1.85:7.95 1.9:7.95 1.9:7.8 1.95:7.8 1.95:7.65 2:7.65 2:7.55 2.05:7.55 2.05:7.4 2.1:7.4 2.1:7.25 2.15:7.25 2.15:7.1 2.2:7.1 2.2:7 2.25:7 2.25:6.85 2.3:6.85 2.3:6.7 2.35:6.7 2.35:6.6 2.4:6.6 2.4:6.45 2.45:6.45 2.45:6.3 2.5:6.3 2.5:6.15 2.55:6.15 2.55:6.05 2.6:6.05 2.6:5.9 2.65:5.9 2.65:5.75 2.7:5.75 2.7:5.6 2.75:5.6 2.75:5.5 2.8:5.5 2.8:5.35 2.85:5.35 2.85:5.2 2.9:5.2 2.9:5.05 2.95:5.05 2.95:4.95 3:4.95 3:4.8 3.05:4.8 3.05:4.65 3.1:4.65 3.1:4.5 3.15:4.5 3.15:4.4 3.2:4.4 3.2:4.25 3.25:4.25 3.25:4.1 3.3:4.1 3.3:4 3.35:4 3.35:3.85 3.4:3.85 3.4:3.7 3.45:3.7 3.45:3.55 3.5:3.55 3.5:3.45 3.55:3.45 3.55:3.3 3.6:3.3 3.6:3.15 3.65:3.15 3.65:3 3.7:3 3.7:2.9 3.75:2.9 3.75:2.75 3.8:2.75 3.8:2.6 3.85:2.6 3.85:2.45 3.9:2.45 3.9:2.35 3.95:2.35 3.95:2.2 4:2.2 4:2.05 4.05:2.05 4.05:1.9 4.1:1.9 4.1:1.8 4.15:1.8 4.15:1.65 4.2:1.65 4.2:1.5 4.25:1.5 4.25:1.35 4.3:1.35 4.3:1.25 4.35:1.25 4.35:1.1 4.4:1.1 4.4:0.95 4.45:0.95 4.45:0.85 4.5:0.85 4.5:0.7 4.55:0.7 4.55:0.55 4.6:0.55 4.6:0.4 4.65:0.4 4.65:0.3 4.7:0.3 4.7:0.15 4.75:0.15 4.75:0 6.9:0 6.9:0.15 6.95:0.15 6.95:0.3 7:0.3 7:0.4 7.05:0.4 7.05:0.55 7.1:0.55 7.1:0.7 7.15:0.7 7.15:0.85 7.2:0.85 7.2:0.95 7.25:0.95 7.25:1.1 7.3:1.1 7.3:1.25 7.35:1.25 7.35:1.35 7.4:1.35 7.4:1.5 7.45:1.5 7.45:1.65 7.5:1.65 7.5:1.8 7.55:1.8 7.55:1.9 7.6:1.9 7.6:2.05 7.65:2.05 7.65:2.2 7.7:2.2 7.7:2.35 7.75:2.35 7.75:2.45 7.8:2.45 7.8:2.6 7.85:2.6 7.85:2.75 7.9:2.75 7.9:2.9 7.95:2.9 7.95:3 8:3 8:3.15 8.05:3.15 8.05:3.3 8.1:3.3 8.1:3.45 8.15:3.45 8.15:3.55 8.2:3.55 8.2:3.7 8.25:3.7 8.25:3.85 8.3:3.85 8.3:4 8.35:4 8.35:4.1 8.4:4.1 8.4:4.25 8.45:4.25 8.45:4.4 8.5:4.4 8.5:4.5 8.55:4.5 8.55:4.65 8.6:4.65 8.6:4.8 8.65:4.8 8.65:4.95 8.7:4.95 8.7:5.05 8.75:5.05 8.75:5.2 8.8:5.2 8.8:5.35 8.85:5.35 8.85:5.5 8.9:5.5 8.9:5.6 8.95:5.6 8.95:5.75 9:5.75 9:5.9 9.05:5.9 9.05:6.05 9.1:6.05 9.1:6.15 9.15:6.15 9.15:6.3 9.2:6.3 9.2:6.45 9.25:6.45 9.25:6.6 9.3:6.6 9.3:6.7 9.35:6.7 9.35:6.85 9.4:6.85 9.4:7 9.45:7 9.45:7.1 9.5:7.1 9.5:7.25 9.55:7.25 9.55:7.4 9.6:7.4 9.6:7.55 9.65:7.55 9.65:7.65 9.7:7.65 9.7:7.8 9.75:7.8 9.75:7.95 9.8:7.95 9.8:8.1 9.85:8.1 9.85:8.2 9.9:8.2 9.9:8.35 9.95:8.35 9.95:8.5 10:8.5 10:8.65 10.05:8.65 10.05:8.75 10.1:8.75 10.1:8.9 10.15:8.9 10.15:9.05 10.2:9.05 10.2:9.2 10.25:9.2 10.25:9.3 10.3:9.3 10.3:9.45 10.35:9.45 10.35:9.6 10.4:9.6 10.4:9.75 10.45:9.75 10.45:9.85 10.5:9.85 10.5:10 10.55:10 10.55:10.15 10.6:10.15 10.6:10.25 10.65:10.25 10.65:10.4 10.7:10.4 10.7:10.55 10.75:10.55 10.75:10.7 10.8:10.7 10.8:10.8 10.85:10.8 10.85:10.95 10.9:10.95 10.9:11.1 10.95:11.1 10.95:11.25 11:11.25 11:11.35 11.05:11.35 11.05:11.5 11.1:11.5 11.1:11.65 11.15:11.65 11.15:11.8 11.2:11.8 11.2:11.9 11.25:11.9 11.25:12.05 11.3:12.05 11.3:12.2 11.35:12.2 11.35:12.35 11.4:12.35 11.4:12.45 11.45:12.45 11.45:12.6 11.5:12.6 11.5:12.75 11.55:12.75 11.55:12.85 11.6:12.85 11.6:13 11.65:13 11.65:13.15 11.7:13.15)
letterShapes["W"] = (list 17.6:14.3 15.75:14.3 15.75:14.15 15.7:14.15 15.7:13.95 15.65:13.95 15.65:13.75 15.6:13.75 15.6:13.5 15.55:13.5 15.55:13.3 15.5:13.3 15.5:13.1 15.45:13.1 15.45:12.85 15.4:12.85 15.4:12.65 15.35:12.65 15.35:12.45 15.3:12.45 15.3:12.2 15.25:12.2 15.25:12 15.2:12 15.2:11.8 15.15:11.8 15.15:11.55 15.1:11.55 15.1:11.35 15.05:11.35 15.05:11.15 15:11.15 15:10.9 14.95:10.9 14.95:10.7 14.9:10.7 14.9:10.45 14.85:10.45 14.85:10.25 14.8:10.25 14.8:10.05 14.75:10.05 14.75:9.8 14.7:9.8 14.7:9.6 14.65:9.6 14.65:9.4 14.6:9.4 14.6:9.15 14.55:9.15 14.55:8.95 14.5:8.95 14.5:8.75 14.45:8.75 14.45:8.5 14.4:8.5 14.4:8.3 14.35:8.3 14.35:8.1 14.3:8.1 14.3:7.85 14.25:7.85 14.25:7.65 14.2:7.65 14.2:7.45 14.15:7.45 14.15:7.2 14.1:7.2 14.1:7 14.05:7 14.05:6.8 14:6.8 14:6.55 13.95:6.55 13.95:6.35 13.9:6.35 13.9:6.1 13.85:6.1 13.85:5.9 13.8:5.9 13.8:5.7 13.75:5.7 13.75:5.45 13.7:5.45 13.7:5.25 13.65:5.25 13.65:5.05 13.6:5.05 13.6:4.8 13.55:4.8 13.55:4.6 13.5:4.6 13.5:4.4 13.45:4.4 13.45:4.3 12.55:4.3 12.55:4.5 12.5:4.5 12.5:4.65 12.45:4.65 12.45:4.85 12.4:4.85 12.4:5.05 12.35:5.05 12.35:5.2 12.3:5.2 12.3:5.4 12.25:5.4 12.25:5.6 12.2:5.6 12.2:5.75 12.15:5.75 12.15:5.95 12.1:5.95 12.1:6.1 12.05:6.1 12.05:6.3 12:6.3 12:6.5 11.95:6.5 11.95:6.65 11.9:6.65 11.9:6.85 11.85:6.85 11.85:7 11.8:7 11.8:7.2 11.75:7.2 11.75:7.4 11.7:7.4 11.7:7.55 11.65:7.55 11.65:7.75 11.6:7.75 11.6:7.95 11.55:7.95 11.55:8.1 11.5:8.1 11.5:8.3 11.45:8.3 11.45:8.45 11.4:8.45 11.4:8.65 11.35:8.65 11.35:8.85 11.3:8.85 11.3:9 11.25:9 11.25:9.2 11.2:9.2 11.2:9.4 11.15:9.4 11.15:9.55 11.1:9.55 11.1:9.75 11.05:9.75 11.05:9.9 11:9.9 11:10.1 10.95:10.1 10.95:10.3 10.9:10.3 10.9:10.45 10.85:10.45 10.85:10.65 10.8:10.65 10.8:10.85 10.75:10.85 10.75:11 10.7:11 10.7:11.2 10.65:11.2 10.65:11.35 10.6:11.35 10.6:11.55 10.55:11.55 10.55:11.75 10.5:11.75 10.5:11.9 10.45:11.9 10.45:12.1 10.4:12.1 10.4:12.25 10.35:12.25 10.35:12.45 10.3:12.45 10.3:12.65 10.25:12.65 10.25:12.8 10.2:12.8 10.2:13 10.15:13 10.15:13.2 10.1:13.2 10.1:13.35 10.05:13.35 10.05:13.55 10:13.55 10:13.7 9.95:13.7 9.95:13.9 9.9:13.9 9.9:14.1 9.85:14.1 9.85:14.25 9.8:14.25 9.8:14.3 7.7:14.3 7.7:14.25 7.65:14.25 7.65:14.05 7.6:14.05 7.6:13.85 7.55:13.85 7.55:13.7 7.5:13.7 7.5:13.5 7.45:13.5 7.45:13.3 7.4:13.3 7.4:13.15 7.35:13.15 7.35:12.95 7.3:12.95 7.3:12.8 7.25:12.8 7.25:12.6 7.2:12.6 7.2:12.4 7.15:12.4 7.15:12.25 7.1:12.25 7.1:12.05 7.05:12.05 7.05:11.9 7:11.9 7:11.7 6.95:11.7 6.95:11.5 6.9:11.5 6.9:11.35 6.85:11.35 6.85:11.15 6.8:11.15 6.8:10.95 6.75:10.95 6.75:10.8 6.7:10.8 6.7:10.6 6.65:10.6 6.65:10.45 6.6:10.45 6.6:10.25 6.55:10.25 6.55:10.05 6.5:10.05 6.5:9.9 6.45:9.9 6.45:9.7 6.4:9.7 6.4:9.5 6.35:9.5 6.35:9.35 6.3:9.35 6.3:9.15 6.25:9.15 6.25:9 6.2:9 6.2:8.8 6.15:8.8 6.15:8.6 6.1:8.6 6.1:8.45 6.05:8.45 6.05:8.25 6:8.25 6:8.1 5.95:8.1 5.95:7.9 5.9:7.9 5.9:7.7 5.85:7.7 5.85:7.55 5.8:7.55 5.8:7.35 5.75:7.35 5.75:7.15 5.7:7.15 5.7:7 5.65:7 5.65:6.8 5.6:6.8 5.6:6.65 5.55:6.65 5.55:6.45 5.5:6.45 5.5:6.25 5.45:6.25 5.45:6.1 5.4:6.1 5.4:5.9 5.35:5.9 5.35:5.7 5.3:5.7 5.3:5.55 5.25:5.55 5.25:5.35 5.2:5.35 5.2:5.2 5.15:5.2 5.15:5 5.1:5 5.1:4.8 5.05:4.8 5.05:4.65 5:4.65 5:4.45 4.95:4.45 4.95:4.25 4.05:4.25 4.05:4.45 4:4.45 4:4.65 3.95:4.65 3.95:4.85 3.9:4.85 3.9:5.1 3.85:5.1 3.85:5.3 3.8:5.3 3.8:5.5 3.75:5.5 3.75:5.75 3.7:5.75 3.7:5.95 3.65:5.95 3.65:6.15 3.6:6.15 3.6:6.4 3.55:6.4 3.55:6.6 3.5:6.6 3.5:6.8 3.45:6.8 3.45:7.05 3.4:7.05 3.4:7.25 3.35:7.25 3.35:7.45 3.3:7.45 3.3:7.7 3.25:7.7 3.25:7.9 3.2:7.9 3.2:8.1 3.15:8.1 3.15:8.35 3.1:8.35 3.1:8.55 3.05:8.55 3.05:8.8 3:8.8 3:9 2.95:9 2.95:9.2 2.9:9.2 2.9:9.45 2.85:9.45 2.85:9.65 2.8:9.65 2.8:9.85 2.75:9.85 2.75:10.1 2.7:10.1 2.7:10.3 2.65:10.3 2.65:10.5 2.6:10.5 2.6:10.75 2.55:10.75 2.55:10.95 2.5:10.95 2.5:11.15 2.45:11.15 2.45:11.4 2.4:11.4 2.4:11.6 2.35:11.6 2.35:11.8 2.3:11.8 2.3:12.05 2.25:12.05 2.25:12.25 2.2:12.25 2.2:12.45 2.15:12.45 2.15:12.7 2.1:12.7 2.1:12.9 2.05:12.9 2.05:13.1 2:13.1 2:13.35 1.95:13.35 1.95:13.55 1.9:13.55 1.9:13.8 1.85:13.8 1.85:14 1.8:14 1.8:14.2 1.75:14.2 1.75:14.3 0:14.3 0:12.9 0.05:12.9 0.05:12.7 0.1:12.7 0.1:12.5 0.15:12.5 0.15:12.3 0.2:12.3 0.2:12.1 0.25:12.1 0.25:11.9 0.3:11.9 0.3:11.75 0.35:11.75 0.35:11.55 0.4:11.55 0.4:11.35 0.45:11.35 0.45:11.15 0.5:11.15 0.5:10.95 0.55:10.95 0.55:10.75 0.6:10.75 0.6:10.6 0.65:10.6 0.65:10.4 0.7:10.4 0.7:10.2 0.75:10.2 0.75:10 0.8:10 0.8:9.8 0.85:9.8 0.85:9.6 0.9:9.6 0.9:9.45 0.95:9.45 0.95:9.25 1:9.25 1:9.05 1.05:9.05 1.05:8.85 1.1:8.85 1.1:8.65 1.15:8.65 1.15:8.45 1.2:8.45 1.2:8.3 1.25:8.3 1.25:8.1 1.3:8.1 1.3:7.9 1.35:7.9 1.35:7.7 1.4:7.7 1.4:7.5 1.45:7.5 1.45:7.3 1.5:7.3 1.5:7.15 1.55:7.15 1.55:6.95 1.6:6.95 1.6:6.75 1.65:6.75 1.65:6.55 1.7:6.55 1.7:6.35 1.75:6.35 1.75:6.15 1.8:6.15 1.8:6 1.85:6 1.85:5.8 1.9:5.8 1.9:5.6 1.95:5.6 1.95:5.4 2:5.4 2:5.2 2.05:5.2 2.05:5 2.1:5 2.1:4.8 2.15:4.8 2.15:4.65 2.2:4.65 2.2:4.45 2.25:4.45 2.25:4.25 2.3:4.25 2.3:4.05 2.35:4.05 2.35:3.85 2.4:3.85 2.4:3.65 2.45:3.65 2.45:3.5 2.5:3.5 2.5:3.3 2.55:3.3 2.55:3.1 2.6:3.1 2.6:2.9 2.65:2.9 2.65:2.7 2.7:2.7 2.7:2.5 2.75:2.5 2.75:2.35 2.8:2.35 2.8:2.15 2.85:2.15 2.85:1.95 2.9:1.95 2.9:1.75 2.95:1.75 2.95:1.55 3:1.55 3:1.35 3.05:1.35 3.05:1.2 3.1:1.2 3.1:1 3.15:1 3.15:0.8 3.2:0.8 3.2:0.6 3.25:0.6 3.25:0.4 3.3:0.4 3.3:0.2 3.35:0.2 3.35:0.05 3.4:0.05 3.4:0 5.45:0 5.45:0.1 5.5:0.1 5.5:0.3 5.55:0.3 5.55:0.45 5.6:0.45 5.6:0.65 5.65:0.65 5.65:0.8 5.7:0.8 5.7:1 5.75:1 5.75:1.15 5.8:1.15 5.8:1.35 5.85:1.35 5.85:1.55 5.9:1.55 5.9:1.7 5.95:1.7 5.95:1.9 6:1.9 6:2.05 6.05:2.05 6.05:2.25 6.1:2.25 6.1:2.45 6.15:2.45 6.15:2.6 6.2:2.6 6.2:2.8 6.25:2.8 6.25:2.95 6.3:2.95 6.3:3.15 6.35:3.15 6.35:3.3 6.4:3.3 6.4:3.5 6.45:3.5 6.45:3.7 6.5:3.7 6.5:3.85 6.55:3.85 6.55:4.05 6.6:4.05 6.6:4.2 6.65:4.2 6.65:4.4 6.7:4.4 6.7:4.6 6.75:4.6 6.75:4.75 6.8:4.75 6.8:4.95 6.85:4.95 6.85:5.1 6.9:5.1 6.9:5.3 6.95:5.3 6.95:5.45 7:5.45 7:5.65 7.05:5.65 7.05:5.85 7.1:5.85 7.1:6 7.15:6 7.15:6.2 7.2:6.2 7.2:6.35 7.25:6.35 7.25:6.55 7.3:6.55 7.3:6.75 7.35:6.75 7.35:6.9 7.4:6.9 7.4:7.1 7.45:7.1 7.45:7.25 7.5:7.25 7.5:7.45 7.55:7.45 7.55:7.6 7.6:7.6 7.6:7.8 7.65:7.8 7.65:8 7.7:8 7.7:8.15 7.75:8.15 7.75:8.35 7.8:8.35 7.8:8.5 7.85:8.5 7.85:8.7 7.9:8.7 7.9:8.9 7.95:8.9 7.95:9.05 8:9.05 8:9.25 8.05:9.25 8.05:9.4 8.1:9.4 8.1:9.6 8.15:9.6 8.15:9.75 8.2:9.75 8.2:9.95 8.25:9.95 8.25:10.15 8.3:10.15 8.3:10.3 9.25:10.3 9.25:10.1 9.3:10.1 9.3:9.95 9.35:9.95 9.35:9.75 9.4:9.75 9.4:9.55 9.45:9.55 9.45:9.4 9.5:9.4 9.5:9.2 9.55:9.2 9.55:9 9.6:9 9.6:8.85 9.65:8.85 9.65:8.65 9.7:8.65 9.7:8.5 9.75:8.5 9.75:8.3 9.8:8.3 9.8:8.1 9.85:8.1 9.85:7.95 9.9:7.95 9.9:7.75 9.95:7.75 9.95:7.55 10:7.55 10:7.4 10.05:7.4 10.05:7.2 10.1:7.2 10.1:7.05 10.15:7.05 10.15:6.85 10.2:6.85 10.2:6.65 10.25:6.65 10.25:6.5 10.3:6.5 10.3:6.3 10.35:6.3 10.35:6.1 10.4:6.1 10.4:5.95 10.45:5.95 10.45:5.75 10.5:5.75 10.5:5.6 10.55:5.6 10.55:5.4 10.6:5.4 10.6:5.2 10.65:5.2 10.65:5.05 10.7:5.05 10.7:4.85 10.75:4.85 10.75:4.65 10.8:4.65 10.8:4.5 10.85:4.5 10.85:4.3 10.9:4.3 10.9:4.15 10.95:4.15 10.95:3.95 11:3.95 11:3.75 11.05:3.75 11.05:3.6 11.1:3.6 11.1:3.4 11.15:3.4 11.15:3.2 11.2:3.2 11.2:3.05 11.25:3.05 11.25:2.85 11.3:2.85 11.3:2.65 11.35:2.65 11.35:2.5 11.4:2.5 11.4:2.3 11.45:2.3 11.45:2.15 11.5:2.15 11.5:1.95 11.55:1.95 11.55:1.75 11.6:1.75 11.6:1.6 11.65:1.6 11.65:1.4 11.7:1.4 11.7:1.2 11.75:1.2 11.75:1.05 11.8:1.05 11.8:0.85 11.85:0.85 11.85:0.7 11.9:0.7 11.9:0.5 11.95:0.5 11.95:0.3 12:0.3 12:0.15 12.05:0.15 12.05:0 14.15:0 14.15:0.2 14.2:0.2 14.2:0.35 14.25:0.35 14.25:0.55 14.3:0.55 14.3:0.75 14.35:0.75 14.35:0.95 14.4:0.95 14.4:1.15 14.45:1.15 14.45:1.3 14.5:1.3 14.5:1.5 14.55:1.5 14.55:1.7 14.6:1.7 14.6:1.9 14.65:1.9 14.65:2.1 14.7:2.1 14.7:2.25 14.75:2.25 14.75:2.45 14.8:2.45 14.8:2.65 14.85:2.65 14.85:2.85 14.9:2.85 14.9:3.05 14.95:3.05 14.95:3.2 15:3.2 15:3.4 15.05:3.4 15.05:3.6 15.1:3.6 15.1:3.8 15.15:3.8 15.15:4 15.2:4 15.2:4.15 15.25:4.15 15.25:4.35 15.3:4.35 15.3:4.55 15.35:4.55 15.35:4.75 15.4:4.75 15.4:4.95 15.45:4.95 15.45:5.1 15.5:5.1 15.5:5.3 15.55:5.3 15.55:5.5 15.6:5.5 15.6:5.7 15.65:5.7 15.65:5.85 15.7:5.85 15.7:6.05 15.75:6.05 15.75:6.25 15.8:6.25 15.8:6.45 15.85:6.45 15.85:6.65 15.9:6.65 15.9:6.8 15.95:6.8 15.95:7 16:7 16:7.2 16.05:7.2 16.05:7.4 16.1:7.4 16.1:7.6 16.15:7.6 16.15:7.75 16.2:7.75 16.2:7.95 16.25:7.95 16.25:8.15 16.3:8.15 16.3:8.35 16.35:8.35 16.35:8.55 16.4:8.55 16.4:8.7 16.45:8.7 16.45:8.9 16.5:8.9 16.5:9.1 16.55:9.1 16.55:9.3 16.6:9.3 16.6:9.5 16.65:9.5 16.65:9.65 16.7:9.65 16.7:9.85 16.75:9.85 16.75:10.05 16.8:10.05 16.8:10.25 16.85:10.25 16.85:10.45 16.9:10.45 16.9:10.6 16.95:10.6 16.95:10.8 17:10.8 17:11 17.05:11 17.05:11.2 17.1:11.2 17.1:11.4 17.15:11.4 17.15:11.55 17.2:11.55 17.2:11.75 17.25:11.75 17.25:11.95 17.3:11.95 17.3:12.15 17.35:12.15 17.35:12.35 17.4:12.35 17.4:12.5 17.45:12.5 17.45:12.7 17.5:12.7 17.5:12.9 17.55:12.9 17.55:13.1 17.6:13.1)
letterShapes["X"] = (list 10.95:1.15 10.9:1.15 10.9:1.2 10.85:1.2 10.85:1.3 10.8:1.3 10.8:1.35 10.75:1.35 10.75:1.45 10.7:1.45 10.7:1.5 10.65:1.5 10.65:1.6 10.6:1.6 10.6:1.65 10.55:1.65 10.55:1.75 10.5:1.75 10.5:1.8 10.45:1.8 10.45:1.85 10.4:1.85 10.4:1.95 10.35:1.95 10.35:2 10.3:2 10.3:2.1 10.25:2.1 10.25:2.15 10.2:2.15 10.2:2.25 10.15:2.25 10.15:2.3 10.1:2.3 10.1:2.4 10.05:2.4 10.05:2.45 10:2.45 10:2.55 9.95:2.55 9.95:2.6 9.9:2.6 9.9:2.65 9.85:2.65 9.85:2.75 9.8:2.75 9.8:2.8 9.75:2.8 9.75:2.9 9.7:2.9 9.7:2.95 9.65:2.95 9.65:3.05 9.6:3.05 9.6:3.1 9.55:3.1 9.55:3.2 9.5:3.2 9.5:3.25 9.45:3.25 9.45:3.35 9.4:3.35 9.4:3.4 9.35:3.4 9.35:3.45 9.3:3.45 9.3:3.55 9.25:3.55 9.25:3.6 9.2:3.6 9.2:3.7 9.15:3.7 9.15:3.75 9.1:3.75 9.1:3.85 9.05:3.85 9.05:3.9 9:3.9 9:4 8.95:4 8.95:4.05 8.9:4.05 8.9:4.15 8.85:4.15 8.85:4.2 8.8:4.2 8.8:4.3 8.75:4.3 8.75:4.35 8.7:4.35 8.7:4.4 8.65:4.4 8.65:4.5 8.6:4.5 8.6:4.55 8.55:4.55 8.55:4.65 8.5:4.65 8.5:4.7 8.45:4.7 8.45:4.8 8.4:4.8 8.4:4.85 8.35:4.85 8.35:4.95 8.3:4.95 8.3:5 8.25:5 8.25:5.1 8.2:5.1 8.2:5.15 8.15:5.15 8.15:5.2 8.1:5.2 8.1:5.3 8.05:5.3 8.05:5.35 8:5.35 8:5.45 7.95:5.45 7.95:5.5 7.9:5.5 7.9:5.6 7.85:5.6 7.85:5.65 7.8:5.65 7.8:5.75 7.75:5.75 7.75:5.8 7.7:5.8 7.7:5.9 7.65:5.9 7.65:5.95 7.6:5.95 7.6:6 7.55:6 7.55:6.1 7.5:6.1 7.5:6.15 7.45:6.15 7.45:6.25 7.4:6.25 7.4:6.3 7.35:6.3 7.35:6.4 7.3:6.4 7.3:6.45 7.25:6.45 7.25:6.55 7.2:6.55 7.2:6.6 7.15:6.6 7.15:6.7 7.1:6.7 7.1:6.75 7.05:6.75 7.05:6.8 7:6.8 7:7.75 7.05:7.75 7.05:7.85 7.1:7.85 7.1:7.9 7.15:7.9 7.15:8 7.2:8 7.2:8.05 7.25:8.05 7.25:8.15 7.3:8.15 7.3:8.2 7.35:8.2 7.35:8.25 7.4:8.25 7.4:8.35 7.45:8.35 7.45:8.4 7.5:8.4 7.5:8.5 7.55:8.5 7.55:8.55 7.6:8.55 7.6:8.65 7.65:8.65 7.65:8.7 7.7:8.7 7.7:8.8 7.75:8.8 7.75:8.85 7.8:8.85 7.8:8.95 7.85:8.95 7.85:9 7.9:9 7.9:9.05 7.95:9.05 7.95:9.15 8:9.15 8:9.2 8.05:9.2 8.05:9.3 8.1:9.3 8.1:9.35 8.15:9.35 8.15:9.45 8.2:9.45 8.2:9.5 8.25:9.5 8.25:9.6 8.3:9.6 8.3:9.65 8.35:9.65 8.35:9.75 8.4:9.75 8.4:9.8 8.45:9.8 8.45:9.85 8.5:9.85 8.5:9.95 8.55:9.95 8.55:10 8.6:10 8.6:10.1 8.65:10.1 8.65:10.15 8.7:10.15 8.7:10.25 8.75:10.25 8.75:10.3 8.8:10.3 8.8:10.4 8.85:10.4 8.85:10.45 8.9:10.45 8.9:10.5 8.95:10.5 8.95:10.6 9:10.6 9:10.65 9.05:10.65 9.05:10.75 9.1:10.75 9.1:10.8 9.15:10.8 9.15:10.9 9.2:10.9 9.2:10.95 9.25:10.95 9.25:11.05 9.3:11.05 9.3:11.1 9.35:11.1 9.35:11.2 9.4:11.2 9.4:11.25 9.45:11.25 9.45:11.3 9.5:11.3 9.5:11.4 9.55:11.4 9.55:11.45 9.6:11.45 9.6:11.55 9.65:11.55 9.65:11.6 9.7:11.6 9.7:11.7 9.75:11.7 9.75:11.75 9.8:11.75 9.8:11.85 9.85:11.85 9.85:11.9 9.9:11.9 9.9:12 9.95:12 9.95:12.05 10:12.05 10:12.1 10.05:12.1 10.05:12.2 10.1:12.2 10.1:12.25 10.15:12.25 10.15:12.35 10.2:12.35 10.2:12.4 10.25:12.4 10.25:12.5 10.3:12.5 10.3:12.55 10.35:12.55 10.35:12.65 10.4:12.65 10.4:12.7 10.45:12.7 10.45:12.75 10.5:12.75 10.5:12.85 10.55:12.85 10.55:12.9 10.6:12.9 10.6:13 10.65:13 10.65:13.05 10.7:13.05 10.7:13.15 10.75:13.15 10.75:14.3 9.2:14.3 9.2:14.25 9.15:14.25 9.15:14.2 9.1:14.2 9.1:14.1 9.05:14.1 9.05:14.05 9:14.05 9:13.95 8.95:13.95 8.95:13.9 8.9:13.9 8.9:13.8 8.85:13.8 8.85:13.75 8.8:13.75 8.8:13.65 8.75:13.65 8.75:13.6 8.7:13.6 8.7:13.5 8.65:13.5 8.65:13.45 8.6:13.45 8.6:13.35 8.55:13.35 8.55:13.3 8.5:13.3 8.5:13.2 8.45:13.2 8.45:13.1 8.4:13.1 8.4:13.05 8.35:13.05 8.35:12.95 8.3:12.95 8.3:12.9 8.25:12.9 8.25:12.8 8.2:12.8 8.2:12.75 8.15:12.75 8.15:12.65 8.1:12.65 8.1:12.6 8.05:12.6 8.05:12.5 8:12.5 8:12.45 7.95:12.45 7.95:12.35 7.9:12.35 7.9:12.3 7.85:12.3 7.85:12.2 7.8:12.2 7.8:12.15 7.75:12.15 7.75:12.05 7.7:12.05 7.7:12 7.65:12 7.65:11.9 7.6:11.9 7.6:11.85 7.55:11.85 7.55:11.75 7.5:11.75 7.5:11.7 7.45:11.7 7.45:11.6 7.4:11.6 7.4:11.55 7.35:11.55 7.35:11.45 7.3:11.45 7.3:11.4 7.25:11.4 7.25:11.3 7.2:11.3 7.2:11.25 7.15:11.25 7.15:11.15 7.1:11.15 7.1:11.1 7.05:11.1 7.05:11 7:11 7:10.95 6.95:10.95 6.95:10.85 6.9:10.85 6.9:10.8 6.85:10.8 6.85:10.7 6.8:10.7 6.8:10.65 6.75:10.65 6.75:10.55 6.7:10.55 6.7:10.5 6.65:10.5 6.65:10.4 6.6:10.4 6.6:10.35 6.55:10.35 6.55:10.25 6.5:10.25 6.5:10.2 6.45:10.2 6.45:10.1 6.4:10.1 6.4:10.05 6.35:10.05 6.35:9.95 6.3:9.95 6.3:9.9 6.25:9.9 6.25:9.8 6.2:9.8 6.2:9.75 6.15:9.75 6.15:9.65 6.1:9.65 6.1:9.55 6.05:9.55 6.05:9.5 6:9.5 6:9.45 5.1:9.45 5.1:9.55 5.05:9.55 5.05:9.6 5:9.6 5:9.7 4.95:9.7 4.95:9.75 4.9:9.75 4.9:9.85 4.85:9.85 4.85:9.9 4.8:9.9 4.8:10 4.75:10 4.75:10.05 4.7:10.05 4.7:10.15 4.65:10.15 4.65:10.2 4.6:10.2 4.6:10.3 4.55:10.3 4.55:10.35 4.5:10.35 4.5:10.45 4.45:10.45 4.45:10.5 4.4:10.5 4.4:10.6 4.35:10.6 4.35:10.65 4.3:10.65 4.3:10.75 4.25:10.75 4.25:10.8 4.2:10.8 4.2:10.9 4.15:10.9 4.15:10.95 4.1:10.95 4.1:11.05 4.05:11.05 4.05:11.1 4:11.1 4:11.2 3.95:11.2 3.95:11.25 3.9:11.25 3.9:11.35 3.85:11.35 3.85:11.4 3.8:11.4 3.8:11.5 3.75:11.5 3.75:11.55 3.7:11.55 3.7:11.65 3.65:11.65 3.65:11.7 3.6:11.7 3.6:11.8 3.55:11.8 3.55:11.85 3.5:11.85 3.5:11.95 3.45:11.95 3.45:12 3.4:12 3.4:12.1 3.35:12.1 3.35:12.15 3.3:12.15 3.3:12.25 3.25:12.25 3.25:12.3 3.2:12.3 3.2:12.4 3.15:12.4 3.15:12.5 3.1:12.5 3.1:12.55 3.05:12.55 3.05:12.65 3:12.65 3:12.7 2.95:12.7 2.95:12.8 2.9:12.8 2.9:12.85 2.85:12.85 2.85:12.95 2.8:12.95 2.8:13 2.75:13 2.75:13.1 2.7:13.1 2.7:13.15 2.65:13.15 2.65:13.25 2.6:13.25 2.6:13.3 2.55:13.3 2.55:13.4 2.5:13.4 2.5:13.45 2.45:13.45 2.45:13.55 2.4:13.55 2.4:13.6 2.35:13.6 2.35:13.7 2.3:13.7 2.3:13.75 2.25:13.75 2.25:13.85 2.2:13.85 2.2:13.9 2.15:13.9 2.15:14 2.1:14 2.1:14.05 2.05:14.05 2.05:14.15 2:14.15 2:14.2 1.95:14.2 1.95:14.3 0.25:14.3 0.25:13.15 0.3:13.15 0.3:13.05 0.35:13.05 0.35:13 0.4:13 0.4:12.9 0.45:12.9 0.45:12.85 0.5:12.85 0.5:12.8 0.55:12.8 0.55:12.7 0.6:12.7 0.6:12.65 0.65:12.65 0.65:12.55 0.7:12.55 0.7:12.5 0.75:12.5 0.75:12.4 0.8:12.4 0.8:12.35 0.85:12.35 0.85:12.25 0.9:12.25 0.9:12.2 0.95:12.2 0.95:12.1 1:12.1 1:12.05 1.05:12.05 1.05:12 1.1:12 1.1:11.9 1.15:11.9 1.15:11.85 1.2:11.85 1.2:11.75 1.25:11.75 1.25:11.7 1.3:11.7 1.3:11.6 1.35:11.6 1.35:11.55 1.4:11.55 1.4:11.45 1.45:11.45 1.45:11.4 1.5:11.4 1.5:11.3 1.55:11.3 1.55:11.25 1.6:11.25 1.6:11.2 1.65:11.2 1.65:11.1 1.7:11.1 1.7:11.05 1.75:11.05 1.75:10.95 1.8:10.95 1.8:10.9 1.85:10.9 1.85:10.8 1.9:10.8 1.9:10.75 1.95:10.75 1.95:10.65 2:10.65 2:10.6 2.05:10.6 2.05:10.5 2.1:10.5 2.1:10.45 2.15:10.45 2.15:10.4 2.2:10.4 2.2:10.3 2.25:10.3 2.25:10.25 2.3:10.25 2.3:10.15 2.35:10.15 2.35:10.1 2.4:10.1 2.4:10 2.45:10 2.45:9.95 2.5:9.95 2.5:9.85 2.55:9.85 2.55:9.8 2.6:9.8 2.6:9.75 2.65:9.75 2.65:9.65 2.7:9.65 2.7:9.6 2.75:9.6 2.75:9.5 2.8:9.5 2.8:9.45 2.85:9.45 2.85:9.35 2.9:9.35 2.9:9.3 2.95:9.3 2.95:9.2 3:9.2 3:9.15 3.05:9.15 3.05:9.05 3.1:9.05 3.1:9 3.15:9 3.15:8.95 3.2:8.95 3.2:8.85 3.25:8.85 3.25:8.8 3.3:8.8 3.3:8.7 3.35:8.7 3.35:8.65 3.4:8.65 3.4:8.55 3.45:8.55 3.45:8.5 3.5:8.5 3.5:8.4 3.55:8.4 3.55:8.35 3.6:8.35 3.6:8.25 3.65:8.25 3.65:8.2 3.7:8.2 3.7:8.15 3.75:8.15 3.75:8.05 3.8:8.05 3.8:8 3.85:8 3.85:7.9 3.9:7.9 3.9:7.85 3.95:7.85 3.95:7.75 4:7.75 4:6.85 3.95:6.85 3.95:6.75 3.9:6.75 3.9:6.7 3.85:6.7 3.85:6.6 3.8:6.6 3.8:6.55 3.75:6.55 3.75:6.5 3.7:6.5 3.7:6.4 3.65:6.4 3.65:6.35 3.6:6.35 3.6:6.25 3.55:6.25 3.55:6.2 3.5:6.2 3.5:6.1 3.45:6.1 3.45:6.05 3.4:6.05 3.4:6 3.35:6 3.35:5.9 3.3:5.9 3.3:5.85 3.25:5.85 3.25:5.75 3.2:5.75 3.2:5.7 3.15:5.7 3.15:5.6 3.1:5.6 3.1:5.55 3.05:5.55 3.05:5.5 3:5.5 3:5.4 2.95:5.4 2.95:5.35 2.9:5.35 2.9:5.25 2.85:5.25 2.85:5.2 2.8:5.2 2.8:5.1 2.75:5.1 2.75:5.05 2.7:5.05 2.7:5 2.65:5 2.65:4.9 2.6:4.9 2.6:4.85 2.55:4.85 2.55:4.75 2.5:4.75 2.5:4.7 2.45:4.7 2.45:4.6 2.4:4.6 2.4:4.55 2.35:4.55 2.35:4.5 2.3:4.5 2.3:4.4 2.25:4.4 2.25:4.35 2.2:4.35 2.2:4.25 2.15:4.25 2.15:4.2 2.1:4.2 2.1:4.1 2.05:4.1 2.05:4.05 2:4.05 2:4 1.95:4 1.95:3.9 1.9:3.9 1.9:3.85 1.85:3.85 1.85:3.75 1.8:3.75 1.8:3.7 1.75:3.7 1.75:3.6 1.7:3.6 1.7:3.55 1.65:3.55 1.65:3.5 1.6:3.5 1.6:3.4 1.55:3.4 1.55:3.35 1.5:3.35 1.5:3.25 1.45:3.25 1.45:3.2 1.4:3.2 1.4:3.1 1.35:3.1 1.35:3.05 1.3:3.05 1.3:3 1.25:3 1.25:2.9 1.2:2.9 1.2:2.85 1.15:2.85 1.15:2.75 1.1:2.75 1.1:2.7 1.05:2.7 1.05:2.6 1:2.6 1:2.55 0.95:2.55 0.95:2.5 0.9:2.5 0.9:2.4 0.85:2.4 0.85:2.35 0.8:2.35 0.8:2.25 0.75:2.25 0.75:2.2 0.7:2.2 0.7:2.1 0.65:2.1 0.65:2.05 0.6:2.05 0.6:2 0.55:2 0.55:1.9 0.5:1.9 0.5:1.85 0.45:1.85 0.45:1.75 0.4:1.75 0.4:1.7 0.35:1.7 0.35:1.6 0.3:1.6 0.3:1.55 0.25:1.55 0.25:1.5 0.2:1.5 0.2:1.4 0.15:1.4 0.15:1.35 0.1:1.35 0.1:1.25 0.05:1.25 0.05:1.2 0:1.2 0:0 1.55:0 1.55:0.05 1.6:0.05 1.6:0.15 1.65:0.15 1.65:0.2 1.7:0.2 1.7:0.3 1.75:0.3 1.75:0.35 1.8:0.35 1.8:0.45 1.85:0.45 1.85:0.5 1.9:0.5 1.9:0.6 1.95:0.6 1.95:0.65 2:0.65 2:0.75 2.05:0.75 2.05:0.8 2.1:0.8 2.1:0.9 2.15:0.9 2.15:0.95 2.2:0.95 2.2:1.05 2.25:1.05 2.25:1.1 2.3:1.1 2.3:1.15 2.35:1.15 2.35:1.25 2.4:1.25 2.4:1.3 2.45:1.3 2.45:1.4 2.5:1.4 2.5:1.45 2.55:1.45 2.55:1.55 2.6:1.55 2.6:1.6 2.65:1.6 2.65:1.7 2.7:1.7 2.7:1.75 2.75:1.75 2.75:1.85 2.8:1.85 2.8:1.9 2.85:1.9 2.85:2 2.9:2 2.9:2.05 2.95:2.05 2.95:2.15 3:2.15 3:2.2 3.05:2.2 3.05:2.3 3.1:2.3 3.1:2.35 3.15:2.35 3.15:2.45 3.2:2.45 3.2:2.5 3.25:2.5 3.25:2.6 3.3:2.6 3.3:2.65 3.35:2.65 3.35:2.7 3.4:2.7 3.4:2.8 3.45:2.8 3.45:2.85 3.5:2.85 3.5:2.95 3.55:2.95 3.55:3 3.6:3 3.6:3.1 3.65:3.1 3.65:3.15 3.7:3.15 3.7:3.25 3.75:3.25 3.75:3.3 3.8:3.3 3.8:3.4 3.85:3.4 3.85:3.45 3.9:3.45 3.9:3.55 3.95:3.55 3.95:3.6 4:3.6 4:3.7 4.05:3.7 4.05:3.75 4.1:3.75 4.1:3.85 4.15:3.85 4.15:3.9 4.2:3.9 4.2:4 4.25:4 4.25:4.05 4.3:4.05 4.3:4.15 4.35:4.15 4.35:4.2 4.4:4.2 4.4:4.3 4.45:4.3 4.45:4.35 4.5:4.35 4.5:4.4 4.55:4.4 4.55:4.5 4.6:4.5 4.6:4.55 4.65:4.55 4.65:4.65 4.7:4.65 4.7:4.7 4.75:4.7 4.75:4.8 4.8:4.8 4.8:4.85 4.85:4.85 4.85:4.95 4.9:4.95 4.9:5 4.95:5 4.95:5.1 5:5.1 5:5.15 5.95:5.15 5.95:5.1 6:5.1 6:5 6.05:5 6.05:4.95 6.1:4.95 6.1:4.85 6.15:4.85 6.15:4.8 6.2:4.8 6.2:4.7 6.25:4.7 6.25:4.6 6.3:4.6 6.3:4.55 6.35:4.55 6.35:4.45 6.4:4.45 6.4:4.4 6.45:4.4 6.45:4.3 6.5:4.3 6.5:4.25 6.55:4.25 6.55:4.15 6.6:4.15 6.6:4.1 6.65:4.1 6.65:4 6.7:4 6.7:3.95 6.75:3.95 6.75:3.85 6.8:3.85 6.8:3.8 6.85:3.8 6.85:3.7 6.9:3.7 6.9:3.65 6.95:3.65 6.95:3.55 7:3.55 7:3.5 7.05:3.5 7.05:3.4 7.1:3.4 7.1:3.35 7.15:3.35 7.15:3.25 7.2:3.25 7.2:3.2 7.25:3.2 7.25:3.1 7.3:3.1 7.3:3 7.35:3 7.35:2.95 7.4:2.95 7.4:2.85 7.45:2.85 7.45:2.8 7.5:2.8 7.5:2.7 7.55:2.7 7.55:2.65 7.6:2.65 7.6:2.55 7.65:2.55 7.65:2.5 7.7:2.5 7.7:2.4 7.75:2.4 7.75:2.35 7.8:2.35 7.8:2.25 7.85:2.25 7.85:2.2 7.9:2.2 7.9:2.1 7.95:2.1 7.95:2.05 8:2.05 8:1.95 8.05:1.95 8.05:1.9 8.1:1.9 8.1:1.8 8.15:1.8 8.15:1.75 8.2:1.75 8.2:1.65 8.25:1.65 8.25:1.6 8.3:1.6 8.3:1.5 8.35:1.5 8.35:1.45 8.4:1.45 8.4:1.35 8.45:1.35 8.45:1.25 8.5:1.25 8.5:1.2 8.55:1.2 8.55:1.1 8.6:1.1 8.6:1.05 8.65:1.05 8.65:0.95 8.7:0.95 8.7:0.9 8.75:0.9 8.75:0.8 8.8:0.8 8.8:0.75 8.85:0.75 8.85:0.65 8.9:0.65 8.9:0.6 8.95:0.6 8.95:0.5 9:0.5 9:0.45 9.05:0.45 9.05:0.35 9.1:0.35 9.1:0.3 9.15:0.3 9.15:0.2 9.2:0.2 9.2:0.15 9.25:0.15 9.25:0.05 9.3:0.05 9.3:0 10.95:0)
letterShapes["Y"] = (list 11.3:14.3 9.7:14.3 9.7:14.2 9.65:14.2 9.65:14.1 9.6:14.1 9.6:14.05 9.55:14.05 9.55:13.95 9.5:13.95 9.5:13.85 9.45:13.85 9.45:13.8 9.4:13.8 9.4:13.7 9.35:13.7 9.35:13.6 9.3:13.6 9.3:13.55 9.25:13.55 9.25:13.45 9.2:13.45 9.2:13.35 9.15:13.35 9.15:13.3 9.1:13.3 9.1:13.2 9.05:13.2 9.05:13.1 9:13.1 9:13.05 8.95:13.05 8.95:12.95 8.9:12.95 8.9:12.85 8.85:12.85 8.85:12.75 8.8:12.75 8.8:12.7 8.75:12.7 8.75:12.6 8.7:12.6 8.7:12.5 8.65:12.5 8.65:12.45 8.6:12.45 8.6:12.35 8.55:12.35 8.55:12.25 8.5:12.25 8.5:12.2 8.45:12.2 8.45:12.1 8.4:12.1 8.4:12 8.35:12 8.35:11.95 8.3:11.95 8.3:11.85 8.25:11.85 8.25:11.75 8.2:11.75 8.2:11.7 8.15:11.7 8.15:11.6 8.1:11.6 8.1:11.5 8.05:11.5 8.05:11.45 8:11.45 8:11.35 7.95:11.35 7.95:11.25 7.9:11.25 7.9:11.2 7.85:11.2 7.85:11.1 7.8:11.1 7.8:11 7.75:11 7.75:10.95 7.7:10.95 7.7:10.85 7.65:10.85 7.65:10.75 7.6:10.75 7.6:10.7 7.55:10.7 7.55:10.6 7.5:10.6 7.5:10.5 7.45:10.5 7.45:10.45 7.4:10.45 7.4:10.35 7.35:10.35 7.35:10.25 7.3:10.25 7.3:10.2 7.25:10.2 7.25:10.1 7.2:10.1 7.2:10 7.15:10 7.15:9.95 7.1:9.95 7.1:9.85 7.05:9.85 7.05:9.75 7:9.75 7:9.65 6.95:9.65 6.95:9.6 6.9:9.6 6.9:9.5 6.85:9.5 6.85:9.4 6.8:9.4 6.8:9.35 6.75:9.35 6.75:9.25 6.7:9.25 6.7:9.15 6.65:9.15 6.65:9.1 6.6:9.1 6.6:9 6.55:9 6.55:8.9 6.5:8.9 6.5:8.85 6.45:8.85 6.45:8.75 6.4:8.75 6.4:8.65 6.35:8.65 6.35:8.6 6.3:8.6 6.3:8.5 6.25:8.5 6.25:8.4 6.2:8.4 6.2:8.35 6.15:8.35 6.15:8.25 6.1:8.25 6.1:8.15 5.15:8.15 5.15:8.2 5.1:8.2 5.1:8.3 5.05:8.3 5.05:8.4 5:8.4 5:8.45 4.95:8.45 4.95:8.55 4.9:8.55 4.9:8.65 4.85:8.65 4.85:8.7 4.8:8.7 4.8:8.8 4.75:8.8 4.75:8.9 4.7:8.9 4.7:8.95 4.65:8.95 4.65:9.05 4.6:9.05 4.6:9.15 4.55:9.15 4.55:9.2 4.5:9.2 4.5:9.3 4.45:9.3 4.45:9.4 4.4:9.4 4.4:9.45 4.35:9.45 4.35:9.55 4.3:9.55 4.3:9.65 4.25:9.65 4.25:9.7 4.2:9.7 4.2:9.8 4.15:9.8 4.15:9.9 4.1:9.9 4.1:10 4.05:10 4.05:10.05 4:10.05 4:10.15 3.95:10.15 3.95:10.25 3.9:10.25 3.9:10.3 3.85:10.3 3.85:10.4 3.8:10.4 3.8:10.5 3.75:10.5 3.75:10.55 3.7:10.55 3.7:10.65 3.65:10.65 3.65:10.75 3.6:10.75 3.6:10.8 3.55:10.8 3.55:10.9 3.5:10.9 3.5:11 3.45:11 3.45:11.05 3.4:11.05 3.4:11.15 3.35:11.15 3.35:11.25 3.3:11.25 3.3:11.3 3.25:11.3 3.25:11.4 3.2:11.4 3.2:11.5 3.15:11.5 3.15:11.55 3.1:11.55 3.1:11.65 3.05:11.65 3.05:11.75 3:11.75 3:11.8 2.95:11.8 2.95:11.9 2.9:11.9 2.9:12 2.85:12 2.85:12.05 2.8:12.05 2.8:12.15 2.75:12.15 2.75:12.25 2.7:12.25 2.7:12.3 2.65:12.3 2.65:12.4 2.6:12.4 2.6:12.5 2.55:12.5 2.55:12.55 2.5:12.55 2.5:12.65 2.45:12.65 2.45:12.75 2.4:12.75 2.4:12.8 2.35:12.8 2.35:12.9 2.3:12.9 2.3:13 2.25:13 2.25:13.1 2.2:13.1 2.2:13.15 2.15:13.15 2.15:13.25 2.1:13.25 2.1:13.35 2.05:13.35 2.05:13.4 2:13.4 2:13.5 1.95:13.5 1.95:13.6 1.9:13.6 1.9:13.65 1.85:13.65 1.85:13.75 1.8:13.75 1.8:13.85 1.75:13.85 1.75:13.9 1.7:13.9 1.7:14 1.65:14 1.65:14.1 1.6:14.1 1.6:14.15 1.55:14.15 1.55:14.25 1.5:14.25 1.5:14.3 0:14.3 0:13.05 0.05:13.05 0.05:12.95 0.1:12.95 0.1:12.9 0.15:12.9 0.15:12.8 0.2:12.8 0.2:12.75 0.25:12.75 0.25:12.65 0.3:12.65 0.3:12.55 0.35:12.55 0.35:12.5 0.4:12.5 0.4:12.4 0.45:12.4 0.45:12.35 0.5:12.35 0.5:12.25 0.55:12.25 0.55:12.2 0.6:12.2 0.6:12.1 0.65:12.1 0.65:12 0.7:12 0.7:11.95 0.75:11.95 0.75:11.85 0.8:11.85 0.8:11.8 0.85:11.8 0.85:11.7 0.9:11.7 0.9:11.6 0.95:11.6 0.95:11.55 1:11.55 1:11.45 1.05:11.45 1.05:11.4 1.1:11.4 1.1:11.3 1.15:11.3 1.15:11.25 1.2:11.25 1.2:11.15 1.25:11.15 1.25:11.05 1.3:11.05 1.3:11 1.35:11 1.35:10.9 1.4:10.9 1.4:10.85 1.45:10.85 1.45:10.75 1.5:10.75 1.5:10.65 1.55:10.65 1.55:10.6 1.6:10.6 1.6:10.5 1.65:10.5 1.65:10.45 1.7:10.45 1.7:10.35 1.75:10.35 1.75:10.3 1.8:10.3 1.8:10.2 1.85:10.2 1.85:10.1 1.9:10.1 1.9:10.05 1.95:10.05 1.95:9.95 2:9.95 2:9.9 2.05:9.9 2.05:9.8 2.1:9.8 2.1:9.7 2.15:9.7 2.15:9.65 2.2:9.65 2.2:9.55 2.25:9.55 2.25:9.5 2.3:9.5 2.3:9.4 2.35:9.4 2.35:9.35 2.4:9.35 2.4:9.25 2.45:9.25 2.45:9.15 2.5:9.15 2.5:9.1 2.55:9.1 2.55:9 2.6:9 2.6:8.95 2.65:8.95 2.65:8.85 2.7:8.85 2.7:8.75 2.75:8.75 2.75:8.7 2.8:8.7 2.8:8.6 2.85:8.6 2.85:8.55 2.9:8.55 2.9:8.45 2.95:8.45 2.95:8.4 3:8.4 3:8.3 3.05:8.3 3.05:8.2 3.1:8.2 3.1:8.15 3.15:8.15 3.15:8.05 3.2:8.05 3.2:8 3.25:8 3.25:7.9 3.3:7.9 3.3:7.8 3.35:7.8 3.35:7.75 3.4:7.75 3.4:7.65 3.45:7.65 3.45:7.6 3.5:7.6 3.5:7.5 3.55:7.5 3.55:7.4 3.6:7.4 3.6:7.35 3.65:7.35 3.65:7.25 3.7:7.25 3.7:7.2 3.75:7.2 3.75:7.1 3.8:7.1 3.8:7.05 3.85:7.05 3.85:6.95 3.9:6.95 3.9:6.85 3.95:6.85 3.95:6.8 4:6.8 4:6.7 4.05:6.7 4.05:6.65 4.1:6.65 4.1:6.55 4.15:6.55 4.15:6.45 4.2:6.45 4.2:6.4 4.25:6.4 4.25:6.3 4.3:6.3 4.3:6.25 4.35:6.25 4.35:6.15 4.4:6.15 4.4:6.1 4.45:6.1 4.45:6 4.5:6 4.5:5.9 4.55:5.9 4.55:5.85 4.6:5.85 4.6:5.75 4.65:5.75 4.65:0 6.6:0 6.6:5.75 6.65:5.75 6.65:5.85 6.7:5.85 6.7:5.9 6.75:5.9 6.75:6 6.8:6 6.8:6.1 6.85:6.1 6.85:6.15 6.9:6.15 6.9:6.25 6.95:6.25 6.95:6.3 7:6.3 7:6.4 7.05:6.4 7.05:6.45 7.1:6.45 7.1:6.55 7.15:6.55 7.15:6.65 7.2:6.65 7.2:6.7 7.25:6.7 7.25:6.8 7.3:6.8 7.3:6.85 7.35:6.85 7.35:6.95 7.4:6.95 7.4:7.05 7.45:7.05 7.45:7.1 7.5:7.1 7.5:7.2 7.55:7.2 7.55:7.25 7.6:7.25 7.6:7.35 7.65:7.35 7.65:7.4 7.7:7.4 7.7:7.5 7.75:7.5 7.75:7.6 7.8:7.6 7.8:7.65 7.85:7.65 7.85:7.75 7.9:7.75 7.9:7.8 7.95:7.8 7.95:7.9 8:7.9 8:8 8.05:8 8.05:8.05 8.1:8.05 8.1:8.15 8.15:8.15 8.15:8.2 8.2:8.2 8.2:8.3 8.25:8.3 8.25:8.35 8.3:8.35 8.3:8.45 8.35:8.45 8.35:8.55 8.4:8.55 8.4:8.6 8.45:8.6 8.45:8.7 8.5:8.7 8.5:8.75 8.55:8.75 8.55:8.85 8.6:8.85 8.6:8.95 8.65:8.95 8.65:9 8.7:9 8.7:9.1 8.75:9.1 8.75:9.15 8.8:9.15 8.8:9.25 8.85:9.25 8.85:9.35 8.9:9.35 8.9:9.4 8.95:9.4 8.95:9.5 9:9.5 9:9.55 9.05:9.55 9.05:9.65 9.1:9.65 9.1:9.7 9.15:9.7 9.15:9.8 9.2:9.8 9.2:9.9 9.25:9.9 9.25:9.95 9.3:9.95 9.3:10.05 9.35:10.05 9.35:10.1 9.4:10.1 9.4:10.2 9.45:10.2 9.45:10.3 9.5:10.3 9.5:10.35 9.55:10.35 9.55:10.45 9.6:10.45 9.6:10.5 9.65:10.5 9.65:10.6 9.7:10.6 9.7:10.65 9.75:10.65 9.75:10.75 9.8:10.75 9.8:10.85 9.85:10.85 9.85:10.9 9.9:10.9 9.9:11 9.95:11 9.95:11.05 10:11.05 10:11.15 10.05:11.15 10.05:11.25 10.1:11.25 10.1:11.3 10.15:11.3 10.15:11.4 10.2:11.4 10.2:11.45 10.25:11.45 10.25:11.55 10.3:11.55 10.3:11.6 10.35:11.6 10.35:11.7 10.4:11.7 10.4:11.8 10.45:11.8 10.45:11.85 10.5:11.85 10.5:11.95 10.55:11.95 10.55:12 10.6:12 10.6:12.1 10.65:12.1 10.65:12.2 10.7:12.2 10.7:12.25 10.75:12.25 10.75:12.35 10.8:12.35 10.8:12.4 10.85:12.4 10.85:12.5 10.9:12.5 10.9:12.55 10.95:12.55 10.95:12.65 11:12.65 11:12.75 11.05:12.75 11.05:12.8 11.1:12.8 11.1:12.9 11.15:12.9 11.15:12.95 11.2:12.95 11.2:13.05 11.25:13.05 11.25:13.15 11.3:13.15)
letterShapes["Z"] = (list 11.25:1.65 3.1:1.65 3.1:2.55 3.15:2.55 3.15:2.6 3.2:2.6 3.2:2.65 3.25:2.65 3.25:2.75 3.3:2.75 3.3:2.8 3.35:2.8 3.35:2.85 3.4:2.85 3.4:2.9 3.45:2.9 3.45:2.95 3.5:2.95 3.5:3.05 3.55:3.05 3.55:3.1 3.6:3.1 3.6:3.15 3.65:3.15 3.65:3.2 3.7:3.2 3.7:3.3 3.75:3.3 3.75:3.35 3.8:3.35 3.8:3.4 3.85:3.4 3.85:3.45 3.9:3.45 3.9:3.55 3.95:3.55 3.95:3.6 4:3.6 4:3.65 4.05:3.65 4.05:3.7 4.1:3.7 4.1:3.8 4.15:3.8 4.15:3.85 4.2:3.85 4.2:3.9 4.25:3.9 4.25:3.95 4.3:3.95 4.3:4.05 4.35:4.05 4.35:4.1 4.4:4.1 4.4:4.15 4.45:4.15 4.45:4.2 4.5:4.2 4.5:4.3 4.55:4.3 4.55:4.35 4.6:4.35 4.6:4.4 4.65:4.4 4.65:4.45 4.7:4.45 4.7:4.55 4.75:4.55 4.75:4.6 4.8:4.6 4.8:4.65 4.85:4.65 4.85:4.7 4.9:4.7 4.9:4.8 4.95:4.8 4.95:4.85 5:4.85 5:4.9 5.05:4.9 5.05:4.95 5.1:4.95 5.1:5.05 5.15:5.05 5.15:5.1 5.2:5.1 5.2:5.15 5.25:5.15 5.25:5.2 5.3:5.2 5.3:5.25 5.35:5.25 5.35:5.35 5.4:5.35 5.4:5.4 5.45:5.4 5.45:5.45 5.5:5.45 5.5:5.5 5.55:5.5 5.55:5.6 5.6:5.6 5.6:5.65 5.65:5.65 5.65:5.7 5.7:5.7 5.7:5.75 5.75:5.75 5.75:5.85 5.8:5.85 5.8:5.9 5.85:5.9 5.85:5.95 5.9:5.95 5.9:6 5.95:6 5.95:6.1 6:6.1 6:6.15 6.05:6.15 6.05:6.2 6.1:6.2 6.1:6.25 6.15:6.25 6.15:6.35 6.2:6.35 6.2:6.4 6.25:6.4 6.25:6.45 6.3:6.45 6.3:6.5 6.35:6.5 6.35:6.6 6.4:6.6 6.4:6.65 6.45:6.65 6.45:6.7 6.5:6.7 6.5:6.75 6.55:6.75 6.55:6.85 6.6:6.85 6.6:6.9 6.65:6.9 6.65:6.95 6.7:6.95 6.7:7 6.75:7 6.75:7.1 6.8:7.1 6.8:7.15 6.85:7.15 6.85:7.2 6.9:7.2 6.9:7.25 6.95:7.25 6.95:7.35 7:7.35 7:7.4 7.05:7.4 7.05:7.45 7.1:7.45 7.1:7.5 7.15:7.5 7.15:7.55 7.2:7.55 7.2:7.65 7.25:7.65 7.25:7.7 7.3:7.7 7.3:7.75 7.35:7.75 7.35:7.8 7.4:7.8 7.4:7.9 7.45:7.9 7.45:7.95 7.5:7.95 7.5:8 7.55:8 7.55:8.05 7.6:8.05 7.6:8.15 7.65:8.15 7.65:8.2 7.7:8.2 7.7:8.25 7.75:8.25 7.75:8.3 7.8:8.3 7.8:8.4 7.85:8.4 7.85:8.45 7.9:8.45 7.9:8.5 7.95:8.5 7.95:8.55 8:8.55 8:8.65 8.05:8.65 8.05:8.7 8.1:8.7 8.1:8.75 8.15:8.75 8.15:8.8 8.2:8.8 8.2:8.9 8.25:8.9 8.25:8.95 8.3:8.95 8.3:9 8.35:9 8.35:9.05 8.4:9.05 8.4:9.15 8.45:9.15 8.45:9.2 8.5:9.2 8.5:9.25 8.55:9.25 8.55:9.3 8.6:9.3 8.6:9.4 8.65:9.4 8.65:9.45 8.7:9.45 8.7:9.5 8.75:9.5 8.75:9.55 8.8:9.55 8.8:9.65 8.85:9.65 8.85:9.7 8.9:9.7 8.9:9.75 8.95:9.75 8.95:9.8 9:9.8 9:9.85 9.05:9.85 9.05:9.95 9.1:9.95 9.1:10 9.15:10 9.15:10.05 9.2:10.05 9.2:10.1 9.25:10.1 9.25:10.2 9.3:10.2 9.3:10.25 9.35:10.25 9.35:10.3 9.4:10.3 9.4:10.35 9.45:10.35 9.45:10.45 9.5:10.45 9.5:10.5 9.55:10.5 9.55:10.55 9.6:10.55 9.6:10.6 9.65:10.6 9.65:10.7 9.7:10.7 9.7:10.75 9.75:10.75 9.75:10.8 9.8:10.8 9.8:10.85 9.85:10.85 9.85:10.95 9.9:10.95 9.9:11 9.95:11 9.95:11.05 10:11.05 10:11.1 10.05:11.1 10.05:11.2 10.1:11.2 10.1:11.25 10.15:11.25 10.15:11.3 10.2:11.3 10.2:11.35 10.25:11.35 10.25:11.45 10.3:11.45 10.3:11.5 10.35:11.5 10.35:11.55 10.4:11.55 10.4:11.6 10.45:11.6 10.45:11.7 10.5:11.7 10.5:11.75 10.55:11.75 10.55:11.8 10.6:11.8 10.6:11.85 10.65:11.85 10.65:11.95 10.7:11.95 10.7:12 10.75:12 10.75:12.05 10.8:12.05 10.8:12.1 10.85:12.1 10.85:12.15 10.9:12.15 10.9:12.25 10.95:12.25 10.95:12.3 11:12.3 11:12.35 11.05:12.35 11.05:12.4 11.1:12.4 11.1:12.5 11.15:12.5 11.15:12.55 11.2:12.55 11.2:12.6 11.25:12.6 11.25:14.3 0.6:14.3 0.6:12.6 8.05:12.6 8.05:11.7 8:11.7 8:11.65 7.95:11.65 7.95:11.55 7.9:11.55 7.9:11.5 7.85:11.5 7.85:11.45 7.8:11.45 7.8:11.4 7.75:11.4 7.75:11.3 7.7:11.3 7.7:11.25 7.65:11.25 7.65:11.2 7.6:11.2 7.6:11.1 7.55:11.1 7.55:11.05 7.5:11.05 7.5:11 7.45:11 7.45:10.95 7.4:10.95 7.4:10.85 7.35:10.85 7.35:10.8 7.3:10.8 7.3:10.75 7.25:10.75 7.25:10.7 7.2:10.7 7.2:10.6 7.15:10.6 7.15:10.55 7.1:10.55 7.1:10.5 7.05:10.5 7.05:10.45 7:10.45 7:10.35 6.95:10.35 6.95:10.3 6.9:10.3 6.9:10.25 6.85:10.25 6.85:10.2 6.8:10.2 6.8:10.1 6.75:10.1 6.75:10.05 6.7:10.05 6.7:10 6.65:10 6.65:9.95 6.6:9.95 6.6:9.85 6.55:9.85 6.55:9.8 6.5:9.8 6.5:9.75 6.45:9.75 6.45:9.7 6.4:9.7 6.4:9.6 6.35:9.6 6.35:9.55 6.3:9.55 6.3:9.5 6.25:9.5 6.25:9.45 6.2:9.45 6.2:9.35 6.15:9.35 6.15:9.3 6.1:9.3 6.1:9.25 6.05:9.25 6.05:9.2 6:9.2 6:9.1 5.95:9.1 5.95:9.05 5.9:9.05 5.9:9 5.85:9 5.85:8.95 5.8:8.95 5.8:8.85 5.75:8.85 5.75:8.8 5.7:8.8 5.7:8.75 5.65:8.75 5.65:8.7 5.6:8.7 5.6:8.6 5.55:8.6 5.55:8.55 5.5:8.55 5.5:8.5 5.45:8.5 5.45:8.45 5.4:8.45 5.4:8.35 5.35:8.35 5.35:8.3 5.3:8.3 5.3:8.25 5.25:8.25 5.25:8.15 5.2:8.15 5.2:8.1 5.15:8.1 5.15:8.05 5.1:8.05 5.1:8 5.05:8 5.05:7.9 5:7.9 5:7.85 4.95:7.85 4.95:7.8 4.9:7.8 4.9:7.75 4.85:7.75 4.85:7.65 4.8:7.65 4.8:7.6 4.75:7.6 4.75:7.55 4.7:7.55 4.7:7.5 4.65:7.5 4.65:7.4 4.6:7.4 4.6:7.35 4.55:7.35 4.55:7.3 4.5:7.3 4.5:7.25 4.45:7.25 4.45:7.15 4.4:7.15 4.4:7.1 4.35:7.1 4.35:7.05 4.3:7.05 4.3:7 4.25:7 4.25:6.9 4.2:6.9 4.2:6.85 4.15:6.85 4.15:6.8 4.1:6.8 4.1:6.75 4.05:6.75 4.05:6.65 4:6.65 4:6.6 3.95:6.6 3.95:6.55 3.9:6.55 3.9:6.5 3.85:6.5 3.85:6.4 3.8:6.4 3.8:6.35 3.75:6.35 3.75:6.3 3.7:6.3 3.7:6.25 3.65:6.25 3.65:6.15 3.6:6.15 3.6:6.1 3.55:6.1 3.55:6.05 3.5:6.05 3.5:6 3.45:6 3.45:5.9 3.4:5.9 3.4:5.85 3.35:5.85 3.35:5.8 3.3:5.8 3.3:5.75 3.25:5.75 3.25:5.65 3.2:5.65 3.2:5.6 3.15:5.6 3.15:5.55 3.1:5.55 3.1:5.45 3.05:5.45 3.05:5.4 3:5.4 3:5.35 2.95:5.35 2.95:5.3 2.9:5.3 2.9:5.2 2.85:5.2 2.85:5.15 2.8:5.15 2.8:5.1 2.75:5.1 2.75:5.05 2.7:5.05 2.7:4.95 2.65:4.95 2.65:4.9 2.6:4.9 2.6:4.85 2.55:4.85 2.55:4.8 2.5:4.8 2.5:4.7 2.45:4.7 2.45:4.65 2.4:4.65 2.4:4.6 2.35:4.6 2.35:4.55 2.3:4.55 2.3:4.45 2.25:4.45 2.25:4.4 2.2:4.4 2.2:4.35 2.15:4.35 2.15:4.3 2.1:4.3 2.1:4.2 2.05:4.2 2.05:4.15 2:4.15 2:4.1 1.95:4.1 1.95:4.05 1.9:4.05 1.9:3.95 1.85:3.95 1.85:3.9 1.8:3.9 1.8:3.85 1.75:3.85 1.75:3.8 1.7:3.8 1.7:3.7 1.65:3.7 1.65:3.65 1.6:3.65 1.6:3.6 1.55:3.6 1.55:3.55 1.5:3.55 1.5:3.45 1.45:3.45 1.45:3.4 1.4:3.4 1.4:3.35 1.35:3.35 1.35:3.3 1.3:3.3 1.3:3.2 1.25:3.2 1.25:3.15 1.2:3.15 1.2:3.1 1.15:3.1 1.15:3.05 1.1:3.05 1.1:2.95 1.05:2.95 1.05:2.9 1:2.9 1:2.85 0.95:2.85 0.95:2.8 0.9:2.8 0.9:2.7 0.85:2.7 0.85:2.65 0.8:2.65 0.8:2.6 0.75:2.6 0.75:2.5 0.7:2.5 0.7:2.45 0.65:2.45 0.65:2.4 0.6:2.4 0.6:2.35 0.55:2.35 0.55:2.25 0.5:2.25 0.5:2.2 0.45:2.2 0.45:2.15 0.4:2.15 0.4:2.1 0.35:2.1 0.35:2 0.3:2 0.3:1.95 0.25:1.95 0.25:1.9 0.2:1.9 0.2:1.85 0.15:1.85 0.15:1.75 0.1:1.75 0.1:1.7 0.05:1.7 0.05:1.65 0:1.65 0:0 11.25:0)
letterShapes["0"] = (list 9.6:7.85 9.55:7.85 9.55:8.55 9.5:8.55 9.5:9 9.45:9 9.45:9.35 9.4:9.35 9.4:9.6 9.35:9.6 9.35:9.9 9.3:9.9 9.3:10.1 9.25:10.1 9.25:10.3 9.2:10.3 9.2:10.5 9.15:10.5 9.15:10.7 9.1:10.7 9.1:10.85 9.05:10.85 9.05:10.95 9:10.95 9:11.1 8.95:11.1 8.95:11.25 8.9:11.25 8.9:11.4 8.85:11.4 8.85:11.5 8.8:11.5 8.8:11.6 8.75:11.6 8.75:11.7 8.7:11.7 8.7:11.85 8.65:11.85 8.65:11.9 8.6:11.9 8.6:12 8.55:12 8.55:12.1 8.5:12.1 8.5:12.2 8.45:12.2 8.45:12.3 8.4:12.3 8.4:12.35 8.35:12.35 8.35:12.45 8.3:12.45 8.3:12.5 8.25:12.5 8.25:12.55 8.2:12.55 8.2:12.65 8.15:12.65 8.15:12.7 8.1:12.7 8.1:12.8 8.05:12.8 8.05:12.85 8:12.85 8:12.9 7.95:12.9 7.95:12.95 7.9:12.95 7.9:13 7.85:13 7.85:13.05 7.8:13.05 7.8:13.1 7.75:13.1 7.75:13.15 7.7:13.15 7.7:6.1 7.65:6.1 7.65:5.5 7.6:5.5 7.6:5.05 7.55:5.05 7.55:4.7 7.5:4.7 7.5:4.45 7.45:4.45 7.45:4.25 7.4:4.25 7.4:4.05 7.35:4.05 7.35:3.85 7.3:3.85 7.3:3.7 7.25:3.7 7.25:3.55 7.2:3.55 7.2:3.4 7.15:3.4 7.15:3.3 7.1:3.3 7.1:3.15 7.05:3.15 7.05:3.05 7:3.05 7:2.95 6.95:2.95 6.95:2.85 6.9:2.85 6.9:2.75 6.85:2.75 6.85:2.7 6.8:2.7 6.8:2.6 6.75:2.6 6.75:2.55 6.7:2.55 6.7:2.45 6.65:2.45 6.65:2.4 6.6:2.4 6.6:2.35 6.55:2.35 6.55:2.3 6.5:2.3 6.5:2.25 6.45:2.25 6.45:2.15 6.4:2.15 6.4:2.1 6.35:2.1 6.35:2.05 6.25:2.05 6.25:2 6.2:2 6.2:1.95 6.15:1.95 6.15:1.9 6.05:1.9 6.05:1.85 6:1.85 6:1.8 5.9:1.8 5.9:1.75 5.8:1.75 5.8:1.7 5.7:1.7 5.7:1.65 5.55:1.65 5.55:1.6 5.4:1.6 5.4:1.55 4.15:1.55 4.15:1.6 4:1.6 4:1.65 3.85:1.65 3.85:1.7 3.75:1.7 3.75:1.75 3.65:1.75 3.65:1.8 3.55:1.8 3.55:1.85 3.45:1.85 3.45:1.9 3.4:1.9 3.4:1.95 3.35:1.95 3.35:2 3.3:2 3.3:2.05 3.2:2.05 3.2:2.1 3.15:2.1 3.15:2.15 3.1:2.15 3.1:2.25 3.05:2.25 3.05:2.3 3:2.3 3:2.35 2.95:2.35 2.95:2.4 2.9:2.4 2.9:2.45 2.85:2.45 2.85:2.55 2.8:2.55 2.8:2.6 2.75:2.6 2.75:2.7 2.7:2.7 2.7:2.75 2.65:2.75 2.65:2.85 2.6:2.85 2.6:2.95 2.55:2.95 2.55:3.05 2.5:3.05 2.5:3.15 2.45:3.15 2.45:3.3 2.4:3.3 2.4:3.4 2.35:3.4 2.35:3.55 2.3:3.55 2.3:3.7 2.25:3.7 2.25:3.85 2.2:3.85 2.2:4.05 2.15:4.05 2.15:4.25 2.1:4.25 2.1:4.45 2.05:4.45 2.05:4.7 2:4.7 2:5.05 1.95:5.05 1.95:5.45 1.9:5.45 1.9:6.1 1.85:6.1 1.85:8.1 1.9:8.1 1.9:8.75 1.95:8.75 1.95:9.15 2:9.15 2:9.5 2.05:9.5 2.05:9.75 2.1:9.75 2.1:9.95 2.15:9.95 2.15:10.15 2.2:10.15 2.2:10.35 2.25:10.35 2.25:10.5 2.3:10.5 2.3:10.65 2.35:10.65 2.35:10.8 2.4:10.8 2.4:10.9 2.45:10.9 2.45:11.05 2.5:11.05 2.5:11.15 2.55:11.15 2.55:11.25 2.6:11.25 2.6:11.35 2.65:11.35 2.65:11.45 2.7:11.45 2.7:11.5 2.75:11.5 2.75:11.6 2.8:11.6 2.8:11.65 2.85:11.65 2.85:11.75 2.9:11.75 2.9:11.8 2.95:11.8 2.95:11.85 3:11.85 3:11.9 3.05:11.9 3.05:11.95 3.1:11.95 3.1:12.05 3.15:12.05 3.15:12.1 3.2:12.1 3.2:12.15 3.3:12.15 3.3:12.2 3.35:12.2 3.35:12.25 3.4:12.25 3.4:12.3 3.5:12.3 3.5:12.35 3.55:12.35 3.55:12.4 3.65:12.4 3.65:12.45 3.75:12.45 3.75:12.5 3.85:12.5 3.85:12.55 4:12.55 4:12.6 4.15:12.6 4.15:12.65 5.4:12.65 5.4:12.6 5.55:12.6 5.55:12.55 5.7:12.55 5.7:12.5 5.8:12.5 5.8:12.45 5.9:12.45 5.9:12.4 6:12.4 6:12.35 6.05:12.35 6.05:12.3 6.15:12.3 6.15:12.25 6.2:12.25 6.2:12.2 6.25:12.2 6.25:12.15 6.35:12.15 6.35:12.1 6.4:12.1 6.4:12 6.45:12 6.45:11.95 6.5:11.95 6.5:11.9 6.55:11.9 6.55:11.85 6.6:11.85 6.6:11.8 6.65:11.8 6.65:11.75 6.7:11.75 6.7:11.65 6.75:11.65 6.75:11.6 6.8:11.6 6.8:11.5 6.85:11.5 6.85:11.45 6.9:11.45 6.9:11.35 6.95:11.35 6.95:11.25 7:11.25 7:11.15 7.05:11.15 7.05:11.05 7.1:11.05 7.1:10.9 7.15:10.9 7.15:10.8 7.2:10.8 7.2:10.65 7.25:10.65 7.25:10.5 7.3:10.5 7.3:10.35 7.35:10.35 7.35:10.15 7.4:10.15 7.4:9.95 7.45:9.95 7.45:9.75 7.5:9.75 7.5:9.5 7.55:9.5 7.55:9.15 7.6:9.15 7.6:8.7 7.65:8.7 7.65:8.1 7.7:8.1 7.7:13.2 7.65:13.2 7.65:13.25 7.6:13.25 7.6:13.3 7.55:13.3 7.55:13.35 7.5:13.35 7.5:13.4 7.45:13.4 7.45:13.45 7.35:13.45 7.35:13.5 7.3:13.5 7.3:13.55 7.25:13.55 7.25:13.6 7.15:13.6 7.15:13.65 7.1:13.65 7.1:13.7 7:13.7 7:13.75 6.9:13.75 6.9:13.8 6.8:13.8 6.8:13.85 6.75:13.85 6.75:13.9 6.6:13.9 6.6:13.95 6.5:13.95 6.5:14 6.35:14 6.35:14.05 6.25:14.05 6.25:14.1 6.05:14.1 6.05:14.15 5.85:14.15 5.85:14.2 5.6:14.2 5.6:14.25 3.95:14.25 3.95:14.2 3.7:14.2 3.7:14.15 3.5:14.15 3.5:14.1 3.3:14.1 3.3:14.05 3.2:14.05 3.2:14 3.05:14 3.05:13.95 2.95:13.95 2.95:13.9 2.8:13.9 2.8:13.85 2.75:13.85 2.75:13.8 2.65:13.8 2.65:13.75 2.55:13.75 2.55:13.7 2.45:13.7 2.45:13.65 2.4:13.65 2.4:13.6 2.3:13.6 2.3:13.55 2.25:13.55 2.25:13.5 2.2:13.5 2.2:13.45 2.1:13.45 2.1:13.4 2.05:13.4 2.05:13.35 2:13.35 2:13.3 1.95:13.3 1.95:13.25 1.9:13.25 1.9:13.2 1.85:13.2 1.85:13.15 1.8:13.15 1.8:13.1 1.75:13.1 1.75:13.05 1.7:13.05 1.7:13 1.65:13 1.65:12.95 1.6:12.95 1.6:12.9 1.55:12.9 1.55:12.85 1.5:12.85 1.5:12.8 1.45:12.8 1.45:12.7 1.4:12.7 1.4:12.65 1.35:12.65 1.35:12.55 1.3:12.55 1.3:12.5 1.25:12.5 1.25:12.45 1.2:12.45 1.2:12.35 1.15:12.35 1.15:12.3 1.1:12.3 1.1:12.2 1.05:12.2 1.05:12.1 1:12.1 1:12 0.95:12 0.95:11.9 0.9:11.9 0.9:11.85 0.85:11.85 0.85:11.7 0.8:11.7 0.8:11.6 0.75:11.6 0.75:11.5 0.7:11.5 0.7:11.4 0.65:11.4 0.65:11.25 0.6:11.25 0.6:11.1 0.55:11.1 0.55:11 0.5:11 0.5:10.85 0.45:10.85 0.45:10.7 0.4:10.7 0.4:10.5 0.35:10.5 0.35:10.3 0.3:10.3 0.3:10.1 0.25:10.1 0.25:9.9 0.2:9.9 0.2:9.6 0.15:9.6 0.15:9.35 0.1:9.35 0.1:9 0.05:9 0.05:8.55 0:8.55 0:5.65 0.05:5.65 0.05:5.2 0.1:5.2 0.1:4.85 0.15:4.85 0.15:4.55 0.2:4.55 0.2:4.3 0.25:4.3 0.25:4.1 0.3:4.1 0.3:3.9 0.35:3.9 0.35:3.7 0.4:3.7 0.4:3.5 0.45:3.5 0.45:3.35 0.5:3.35 0.5:3.2 0.55:3.2 0.55:3.1 0.6:3.1 0.6:2.95 0.65:2.95 0.65:2.8 0.7:2.8 0.7:2.7 0.75:2.7 0.75:2.6 0.8:2.6 0.8:2.5 0.85:2.5 0.85:2.35 0.9:2.35 0.9:2.3 0.95:2.3 0.95:2.2 1:2.2 1:2.1 1.05:2.1 1.05:2 1.1:2 1.1:1.9 1.15:1.9 1.15:1.85 1.2:1.85 1.2:1.75 1.25:1.75 1.25:1.7 1.3:1.7 1.3:1.65 1.35:1.65 1.35:1.55 1.4:1.55 1.4:1.5 1.45:1.5 1.45:1.4 1.5:1.4 1.5:1.35 1.55:1.35 1.55:1.3 1.6:1.3 1.6:1.25 1.65:1.25 1.65:1.2 1.7:1.2 1.7:1.15 1.75:1.15 1.75:1.1 1.8:1.1 1.8:1.05 1.85:1.05 1.85:1 1.9:1 1.9:0.95 1.95:0.95 1.95:0.9 2:0.9 2:0.85 2.05:0.85 2.05:0.8 2.1:0.8 2.1:0.75 2.2:0.75 2.2:0.7 2.25:0.7 2.25:0.65 2.3:0.65 2.3:0.6 2.4:0.6 2.4:0.55 2.45:0.55 2.45:0.5 2.55:0.5 2.55:0.45 2.65:0.45 2.65:0.4 2.75:0.4 2.75:0.35 2.8:0.35 2.8:0.3 2.95:0.3 2.95:0.25 3.05:0.25 3.05:0.2 3.15:0.2 3.15:0.15 3.3:0.15 3.3:0.1 3.5:0.1 3.5:0.05 3.7:0.05 3.7:0 5.85:0 5.85:0.05 6.05:0.05 6.05:0.1 6.25:0.1 6.25:0.15 6.35:0.15 6.35:0.2 6.5:0.2 6.5:0.25 6.6:0.25 6.6:0.3 6.75:0.3 6.75:0.35 6.8:0.35 6.8:0.4 6.9:0.4 6.9:0.45 7:0.45 7:0.5 7.1:0.5 7.1:0.55 7.15:0.55 7.15:0.6 7.25:0.6 7.25:0.65 7.3:0.65 7.3:0.7 7.35:0.7 7.35:0.75 7.45:0.75 7.45:0.8 7.5:0.8 7.5:0.85 7.55:0.85 7.55:0.9 7.6:0.9 7.6:0.95 7.65:0.95 7.65:1 7.7:1 7.7:1.05 7.75:1.05 7.75:1.1 7.8:1.1 7.8:1.15 7.85:1.15 7.85:1.2 7.9:1.2 7.9:1.25 7.95:1.25 7.95:1.3 8:1.3 8:1.35 8.05:1.35 8.05:1.4 8.1:1.4 8.1:1.5 8.15:1.5 8.15:1.55 8.2:1.55 8.2:1.65 8.25:1.65 8.25:1.7 8.3:1.7 8.3:1.75 8.35:1.75 8.35:1.85 8.4:1.85 8.4:1.9 8.45:1.9 8.45:2 8.5:2 8.5:2.1 8.55:2.1 8.55:2.2 8.6:2.2 8.6:2.3 8.65:2.3 8.65:2.35 8.7:2.35 8.7:2.5 8.75:2.5 8.75:2.6 8.8:2.6 8.8:2.7 8.85:2.7 8.85:2.8 8.9:2.8 8.9:2.95 8.95:2.95 8.95:3.1 9:3.1 9:3.25 9.05:3.25 9.05:3.35 9.1:3.35 9.1:3.5 9.15:3.5 9.15:3.7 9.2:3.7 9.2:3.9 9.25:3.9 9.25:4.1 9.3:4.1 9.3:4.3 9.35:4.3 9.35:4.6 9.4:4.6 9.4:4.85 9.45:4.85 9.45:5.2 9.5:5.2 9.5:5.65 9.55:5.65 9.55:6.35 9.6:6.35)
letterShapes["1"] = (list 5.15:14 3.75:14 3.75:13.9 3.7:13.9 3.7:13.7 3.65:13.7 3.65:13.55 3.6:13.55 3.6:13.4 3.55:13.4 3.55:13.25 3.5:13.25 3.5:13.1 3.45:13.1 3.45:13 3.4:13 3.4:12.9 3.35:12.9 3.35:12.8 3.3:12.8 3.3:12.7 3.25:12.7 3.25:12.6 3.2:12.6 3.2:12.55 3.15:12.55 3.15:12.45 3.1:12.45 3.1:12.4 3.05:12.4 3.05:12.35 3:12.35 3:12.25 2.95:12.25 2.95:12.2 2.9:12.2 2.9:12.15 2.85:12.15 2.85:12.1 2.75:12.1 2.75:12.05 2.7:12.05 2.7:12 2.65:12 2.65:11.95 2.55:11.95 2.55:11.9 2.5:11.9 2.5:11.85 2.4:11.85 2.4:11.8 2.3:11.8 2.3:11.75 2.2:11.75 2.2:11.7 2.05:11.7 2.05:11.65 1.9:11.65 1.9:11.6 1.75:11.6 1.75:11.55 1.5:11.55 1.5:11.5 1.25:11.5 1.25:11.45 0.85:11.45 0.85:11.4 0.3:11.4 0.3:11.35 0:11.35 0:9.95 3.25:9.95 3.25:0 5.15:0)
letterShapes["2"] = (list 9.5:1.6 2.2:1.6 2.2:2.55 2.25:2.55 2.25:2.6 2.3:2.6 2.3:2.7 2.35:2.7 2.35:2.75 2.4:2.75 2.4:2.85 2.45:2.85 2.45:2.9 2.5:2.9 2.5:2.95 2.55:2.95 2.55:3 2.6:3 2.6:3.05 2.65:3.05 2.65:3.1 2.7:3.1 2.7:3.15 2.75:3.15 2.75:3.2 2.8:3.2 2.8:3.25 2.85:3.25 2.85:3.3 2.9:3.3 2.9:3.35 2.95:3.35 2.95:3.4 3:3.4 3:3.45 3.05:3.45 3.05:3.5 3.1:3.5 3.1:3.55 3.2:3.55 3.2:3.6 3.25:3.6 3.25:3.65 3.3:3.65 3.3:3.7 3.35:3.7 3.35:3.75 3.45:3.75 3.45:3.8 3.5:3.8 3.5:3.85 3.6:3.85 3.6:3.9 3.65:3.9 3.65:3.95 3.75:3.95 3.75:4 3.8:4 3.8:4.05 3.9:4.05 3.9:4.1 3.95:4.1 3.95:4.15 4.05:4.15 4.05:4.2 4.15:4.2 4.15:4.25 4.25:4.25 4.25:4.3 4.3:4.3 4.3:4.35 4.4:4.35 4.4:4.4 4.5:4.4 4.5:4.45 4.6:4.45 4.6:4.5 4.7:4.5 4.7:4.55 4.75:4.55 4.75:4.6 4.85:4.6 4.85:4.65 4.95:4.65 4.95:4.7 5.05:4.7 5.05:4.75 5.15:4.75 5.15:4.8 5.25:4.8 5.25:4.85 5.3:4.85 5.3:4.9 5.4:4.9 5.4:4.95 5.5:4.95 5.5:5 5.6:5 5.6:5.05 5.7:5.05 5.7:5.1 5.8:5.1 5.8:5.15 5.85:5.15 5.85:5.2 5.95:5.2 5.95:5.25 6.05:5.25 6.05:5.3 6.15:5.3 6.15:5.35 6.25:5.35 6.25:5.4 6.35:5.4 6.35:5.45 6.4:5.45 6.4:5.5 6.5:5.5 6.5:5.55 6.6:5.55 6.6:5.6 6.7:5.6 6.7:5.65 6.75:5.65 6.75:5.7 6.85:5.7 6.85:5.75 6.95:5.75 6.95:5.8 7:5.8 7:5.85 7.1:5.85 7.1:5.9 7.15:5.9 7.15:5.95 7.25:5.95 7.25:6 7.3:6 7.3:6.05 7.4:6.05 7.4:6.1 7.45:6.1 7.45:6.15 7.55:6.15 7.55:6.2 7.6:6.2 7.6:6.25 7.65:6.25 7.65:6.3 7.75:6.3 7.75:6.35 7.8:6.35 7.8:6.4 7.85:6.4 7.85:6.45 7.9:6.45 7.9:6.5 8:6.5 8:6.55 8.05:6.55 8.05:6.6 8.1:6.6 8.1:6.65 8.15:6.65 8.15:6.7 8.2:6.7 8.2:6.75 8.25:6.75 8.25:6.8 8.3:6.8 8.3:6.85 8.35:6.85 8.35:6.9 8.4:6.9 8.4:6.95 8.45:6.95 8.45:7 8.5:7 8.5:7.05 8.55:7.05 8.55:7.1 8.6:7.1 8.6:7.2 8.65:7.2 8.65:7.25 8.7:7.25 8.7:7.3 8.75:7.3 8.75:7.4 8.8:7.4 8.8:7.45 8.85:7.45 8.85:7.5 8.9:7.5 8.9:7.6 8.95:7.6 8.95:7.7 9:7.7 9:7.8 9.05:7.8 9.05:7.9 9.1:7.9 9.1:8 9.15:8 9.15:8.1 9.2:8.1 9.2:8.2 9.25:8.2 9.25:8.35 9.3:8.35 9.3:8.5 9.35:8.5 9.35:8.7 9.4:8.7 9.4:8.95 9.45:8.95 9.45:10.6 9.4:10.6 9.4:10.85 9.35:10.85 9.35:11.05 9.3:11.05 9.3:11.2 9.25:11.2 9.25:11.35 9.2:11.35 9.2:11.5 9.15:11.5 9.15:11.6 9.1:11.6 9.1:11.7 9.05:11.7 9.05:11.8 9:11.8 9:11.9 8.95:11.9 8.95:12 8.9:12 8.9:12.05 8.85:12.05 8.85:12.15 8.8:12.15 8.8:12.2 8.75:12.2 8.75:12.3 8.7:12.3 8.7:12.35 8.65:12.35 8.65:12.4 8.6:12.4 8.6:12.5 8.55:12.5 8.55:12.55 8.5:12.55 8.5:12.6 8.45:12.6 8.45:12.65 8.4:12.65 8.4:12.7 8.35:12.7 8.35:12.75 8.3:12.75 8.3:12.8 8.25:12.8 8.25:12.85 8.2:12.85 8.2:12.9 8.15:12.9 8.15:12.95 8.1:12.95 8.1:13 8:13 8:13.05 7.95:13.05 7.95:13.1 7.9:13.1 7.9:13.15 7.8:13.15 7.8:13.2 7.75:13.2 7.75:13.25 7.65:13.25 7.65:13.3 7.6:13.3 7.6:13.35 7.5:13.35 7.5:13.4 7.4:13.4 7.4:13.45 7.3:13.45 7.3:13.5 7.25:13.5 7.25:13.55 7.1:13.55 7.1:13.6 7:13.6 7:13.65 6.9:13.65 6.9:13.7 6.75:13.7 6.75:13.75 6.6:13.75 6.6:13.8 6.4:13.8 6.4:13.85 6.2:13.85 6.2:13.9 5.95:13.9 5.95:13.95 4.1:13.95 4.1:13.9 3.8:13.9 3.8:13.85 3.6:13.85 3.6:13.8 3.4:13.8 3.4:13.75 3.25:13.75 3.25:13.7 3.1:13.7 3.1:13.65 2.95:13.65 2.95:13.6 2.8:13.6 2.8:13.55 2.7:13.55 2.7:13.5 2.6:13.5 2.6:13.45 2.5:13.45 2.5:13.4 2.4:13.4 2.4:13.35 2.35:13.35 2.35:13.3 2.25:13.3 2.25:13.25 2.15:13.25 2.15:13.2 2.1:13.2 2.1:13.15 2:13.15 2:13.1 1.95:13.1 1.95:13.05 1.9:13.05 1.9:13 1.8:13 1.8:12.95 1.75:12.95 1.75:12.9 1.7:12.9 1.7:12.85 1.65:12.85 1.65:12.8 1.6:12.8 1.6:12.75 1.55:12.75 1.55:12.7 1.5:12.7 1.5:12.65 1.45:12.65 1.45:12.6 1.4:12.6 1.4:12.55 1.35:12.55 1.35:12.5 1.3:12.5 1.3:12.45 1.25:12.45 1.25:12.35 1.2:12.35 1.2:12.3 1.15:12.3 1.15:12.25 1.1:12.25 1.1:12.15 1.05:12.15 1.05:12.1 1:12.1 1:12 0.95:12 0.95:11.9 0.9:11.9 0.9:11.85 0.85:11.85 0.85:11.75 0.8:11.75 0.8:11.65 0.75:11.65 0.75:11.5 0.7:11.5 0.7:11.4 0.65:11.4 0.65:11.25 0.6:11.25 0.6:11.15 0.55:11.15 0.55:11 0.5:11 0.5:10.8 0.45:10.8 0.45:10.6 0.4:10.6 0.4:10.35 0.35:10.35 0.35:8.95 2:8.95 2:9.3 2.05:9.3 2.05:9.75 2.1:9.75 2.1:10.05 2.15:10.05 2.15:10.3 2.2:10.3 2.2:10.5 2.25:10.5 2.25:10.65 2.3:10.65 2.3:10.75 2.35:10.75 2.35:10.9 2.4:10.9 2.4:11 2.45:11 2.45:11.1 2.5:11.1 2.5:11.2 2.55:11.2 2.55:11.3 2.6:11.3 2.6:11.35 2.65:11.35 2.65:11.4 2.7:11.4 2.7:11.5 2.75:11.5 2.75:11.55 2.8:11.55 2.8:11.6 2.85:11.6 2.85:11.65 2.9:11.65 2.9:11.7 2.95:11.7 2.95:11.75 3:11.75 3:11.8 3.05:11.8 3.05:11.85 3.1:11.85 3.1:11.9 3.2:11.9 3.2:11.95 3.25:11.95 3.25:12 3.3:12 3.3:12.05 3.4:12.05 3.4:12.1 3.5:12.1 3.5:12.15 3.6:12.15 3.6:12.2 3.75:12.2 3.75:12.25 3.9:12.25 3.9:12.3 4.1:12.3 4.1:12.35 4.35:12.35 4.35:12.4 5.3:12.4 5.3:12.35 5.6:12.35 5.6:12.3 5.8:12.3 5.8:12.25 5.95:12.25 5.95:12.2 6.1:12.2 6.1:12.15 6.2:12.15 6.2:12.1 6.3:12.1 6.3:12.05 6.4:12.05 6.4:12 6.5:12 6.5:11.95 6.55:11.95 6.55:11.9 6.65:11.9 6.65:11.85 6.7:11.85 6.7:11.8 6.75:11.8 6.75:11.75 6.8:11.75 6.8:11.7 6.85:11.7 6.85:11.65 6.9:11.65 6.9:11.6 6.95:11.6 6.95:11.55 7:11.55 7:11.5 7.05:11.5 7.05:11.45 7.1:11.45 7.1:11.4 7.15:11.4 7.15:11.3 7.2:11.3 7.2:11.25 7.25:11.25 7.25:11.15 7.3:11.15 7.3:11.05 7.35:11.05 7.35:10.95 7.4:10.95 7.4:10.85 7.45:10.85 7.45:10.7 7.5:10.7 7.5:10.5 7.55:10.5 7.55:9.1 7.5:9.1 7.5:8.9 7.45:8.9 7.45:8.75 7.4:8.75 7.4:8.6 7.35:8.6 7.35:8.5 7.3:8.5 7.3:8.4 7.25:8.4 7.25:8.3 7.2:8.3 7.2:8.25 7.15:8.25 7.15:8.15 7.1:8.15 7.1:8.1 7.05:8.1 7.05:8.05 7:8.05 7:7.95 6.95:7.95 6.95:7.9 6.9:7.9 6.9:7.85 6.85:7.85 6.85:7.8 6.8:7.8 6.8:7.75 6.75:7.75 6.75:7.7 6.7:7.7 6.7:7.65 6.6:7.65 6.6:7.6 6.55:7.6 6.55:7.55 6.5:7.55 6.5:7.5 6.45:7.5 6.45:7.45 6.35:7.45 6.35:7.4 6.3:7.4 6.3:7.35 6.25:7.35 6.25:7.3 6.15:7.3 6.15:7.25 6.1:7.25 6.1:7.2 6:7.2 6:7.15 5.95:7.15 5.95:7.1 5.85:7.1 5.85:7.05 5.75:7.05 5.75:7 5.7:7 5.7:6.95 5.6:6.95 5.6:6.9 5.5:6.9 5.5:6.85 5.45:6.85 5.45:6.8 5.35:6.8 5.35:6.75 5.25:6.75 5.25:6.7 5.15:6.7 5.15:6.65 5.1:6.65 5.1:6.6 5:6.6 5:6.55 4.9:6.55 4.9:6.5 4.85:6.5 4.85:6.45 4.75:6.45 4.75:6.4 4.65:6.4 4.65:6.35 4.55:6.35 4.55:6.3 4.5:6.3 4.5:6.25 4.4:6.25 4.4:6.2 4.3:6.2 4.3:6.15 4.25:6.15 4.25:6.1 4.15:6.1 4.15:6.05 4.05:6.05 4.05:6 3.95:6 3.95:5.95 3.9:5.95 3.9:5.9 3.8:5.9 3.8:5.85 3.7:5.85 3.7:5.8 3.65:5.8 3.65:5.75 3.55:5.75 3.55:5.7 3.45:5.7 3.45:5.65 3.35:5.65 3.35:5.6 3.3:5.6 3.3:5.55 3.2:5.55 3.2:5.5 3.1:5.5 3.1:5.45 3.05:5.45 3.05:5.4 2.95:5.4 2.95:5.35 2.9:5.35 2.9:5.3 2.8:5.3 2.8:5.25 2.7:5.25 2.7:5.2 2.65:5.2 2.65:5.15 2.55:5.15 2.55:5.1 2.5:5.1 2.5:5.05 2.4:5.05 2.4:5 2.35:5 2.35:4.95 2.3:4.95 2.3:4.9 2.2:4.9 2.2:4.85 2.15:4.85 2.15:4.8 2.1:4.8 2.1:4.75 2.05:4.75 2.05:4.7 1.95:4.7 1.95:4.65 1.9:4.65 1.9:4.6 1.85:4.6 1.85:4.55 1.8:4.55 1.8:4.5 1.75:4.5 1.75:4.45 1.7:4.45 1.7:4.4 1.65:4.4 1.65:4.35 1.6:4.35 1.6:4.3 1.55:4.3 1.55:4.25 1.5:4.25 1.5:4.2 1.45:4.2 1.45:4.15 1.4:4.15 1.4:4.1 1.35:4.1 1.35:4.05 1.3:4.05 1.3:4 1.25:4 1.25:3.9 1.2:3.9 1.2:3.85 1.15:3.85 1.15:3.8 1.1:3.8 1.1:3.75 1.05:3.75 1.05:3.65 1:3.65 1:3.6 0.95:3.6 0.95:3.55 0.9:3.55 0.9:3.45 0.85:3.45 0.85:3.4 0.8:3.4 0.8:3.3 0.75:3.3 0.75:3.2 0.7:3.2 0.7:3.15 0.65:3.15 0.65:3.05 0.6:3.05 0.6:2.95 0.55:2.95 0.55:2.85 0.5:2.85 0.5:2.75 0.45:2.75 0.45:2.65 0.4:2.65 0.4:2.5 0.35:2.5 0.35:2.4 0.3:2.4 0.3:2.25 0.25:2.25 0.25:2.1 0.2:2.1 0.2:1.95 0.15:1.95 0.15:1.8 0.1:1.8 0.1:1.6 0.05:1.6 0.05:1.4 0:1.4 0:0 9.5:0)
letterShapes["3"] = (list 9.5:5.2 9.45:5.2 9.45:5.45 9.4:5.45 9.4:5.6 9.35:5.6 9.35:5.75 9.3:5.75 9.3:5.9 9.25:5.9 9.25:6 9.2:6 9.2:6.1 9.15:6.1 9.15:6.2 9.1:6.2 9.1:6.3 9.05:6.3 9.05:6.35 9:6.35 9:6.45 8.95:6.45 8.95:6.5 8.9:6.5 8.9:6.6 8.85:6.6 8.85:6.65 8.8:6.65 8.8:6.7 8.75:6.7 8.75:6.75 8.7:6.75 8.7:6.8 8.65:6.8 8.65:6.85 8.6:6.85 8.6:6.9 8.55:6.9 8.55:6.95 8.5:6.95 8.5:7 8.4:7 8.4:7.05 8.35:7.05 8.35:7.1 8.3:7.1 8.3:7.15 8.2:7.15 8.2:7.2 8.15:7.2 8.15:7.25 8.05:7.25 8.05:7.3 8:7.3 8:8.2 8.1:8.2 8.1:8.25 8.15:8.25 8.15:8.3 8.2:8.3 8.2:8.35 8.25:8.35 8.25:8.45 8.3:8.45 8.3:8.5 8.35:8.5 8.35:8.55 8.4:8.55 8.4:8.6 8.45:8.6 8.45:8.7 8.5:8.7 8.5:8.75 8.55:8.75 8.55:8.85 8.6:8.85 8.6:8.95 8.65:8.95 8.65:9.05 8.7:9.05 8.7:9.15 8.75:9.15 8.75:9.3 8.8:9.3 8.8:9.4 8.85:9.4 8.85:9.6 8.9:9.6 8.9:9.8 8.95:9.8 8.95:11.35 8.9:11.35 8.9:11.55 8.85:11.55 8.85:11.75 8.8:11.75 8.8:11.9 8.75:11.9 8.75:12 8.7:12 8.7:12.15 8.65:12.15 8.65:12.25 8.6:12.25 8.6:12.35 8.55:12.35 8.55:12.45 8.5:12.45 8.5:12.5 8.45:12.5 8.45:12.6 8.4:12.6 8.4:12.65 8.35:12.65 8.35:12.75 8.3:12.75 8.3:12.8 8.25:12.8 8.25:12.85 8.2:12.85 8.2:12.9 8.15:12.9 8.15:13 8.1:13 8.1:13.05 8.05:13.05 8.05:13.1 8:13.1 8:13.15 7.95:13.15 7.95:13.2 7.9:13.2 7.9:13.25 7.8:13.25 7.8:13.3 7.75:13.3 7.75:13.35 7.7:13.35 7.7:13.4 7.65:13.4 7.65:13.45 7.55:13.45 7.55:13.5 7.5:13.5 7.5:13.55 7.4:13.55 7.4:13.6 7.35:13.6 7.35:13.65 7.25:13.65 7.25:13.7 7.15:13.7 7.15:13.75 7.05:13.75 7.05:13.8 6.95:13.8 6.95:13.85 6.85:13.85 6.85:13.9 6.75:13.9 6.75:13.95 6.6:13.95 6.6:14 6.45:14 6.45:14.05 6.3:14.05 6.3:14.1 6.1:14.1 6.1:14.15 5.9:14.15 5.9:14.2 5.65:14.2 5.65:14.25 3.7:14.25 3.7:14.2 3.4:14.2 3.4:14.15 3.15:14.15 3.15:14.1 3:14.1 3:14.05 2.85:14.05 2.85:14 2.7:14 2.7:13.95 2.55:13.95 2.55:13.9 2.45:13.9 2.45:13.85 2.35:13.85 2.35:13.8 2.25:13.8 2.25:13.75 2.15:13.75 2.15:13.7 2.05:13.7 2.05:13.65 1.95:13.65 1.95:13.6 1.9:13.6 1.9:13.55 1.8:13.55 1.8:13.5 1.75:13.5 1.75:13.45 1.7:13.45 1.7:13.4 1.6:13.4 1.6:13.35 1.55:13.35 1.55:13.3 1.5:13.3 1.5:13.25 1.45:13.25 1.45:13.2 1.4:13.2 1.4:13.15 1.35:13.15 1.35:13.1 1.3:13.1 1.3:13.05 1.25:13.05 1.25:13 1.2:13 1.2:12.95 1.15:12.95 1.15:12.9 1.1:12.9 1.1:12.8 1.05:12.8 1.05:12.75 1:12.75 1:12.7 0.95:12.7 0.95:12.6 0.9:12.6 0.9:12.55 0.85:12.55 0.85:12.45 0.8:12.45 0.8:12.4 0.75:12.4 0.75:12.3 0.7:12.3 0.7:12.2 0.65:12.2 0.65:12.1 0.6:12.1 0.6:11.95 0.55:11.95 0.55:11.85 0.5:11.85 0.5:11.7 0.45:11.7 0.45:11.55 0.4:11.55 0.4:11.4 0.35:11.4 0.35:11.2 0.3:11.2 0.3:11 0.25:11 0.25:9.7 1.85:9.7 1.85:10 1.9:10 1.9:10.35 1.95:10.35 1.95:10.65 2:10.65 2:10.85 2.05:10.85 2.05:11 2.1:11 2.1:11.15 2.15:11.15 2.15:11.3 2.2:11.3 2.2:11.4 2.25:11.4 2.25:11.5 2.3:11.5 2.3:11.6 2.35:11.6 2.35:11.65 2.4:11.65 2.4:11.75 2.45:11.75 2.45:11.8 2.5:11.8 2.5:11.85 2.55:11.85 2.55:11.95 2.6:11.95 2.6:12 2.65:12 2.65:12.05 2.7:12.05 2.7:12.1 2.8:12.1 2.8:12.15 2.85:12.15 2.85:12.2 2.9:12.2 2.9:12.25 2.95:12.25 2.95:12.3 3.05:12.3 3.05:12.35 3.15:12.35 3.15:12.4 3.25:12.4 3.25:12.45 3.35:12.45 3.35:12.5 3.45:12.5 3.45:12.55 3.65:12.55 3.65:12.6 3.8:12.6 3.8:12.65 4.1:12.65 4.1:12.7 5.1:12.7 5.1:12.65 5.4:12.65 5.4:12.6 5.6:12.6 5.6:12.55 5.75:12.55 5.75:12.5 5.9:12.5 5.9:12.45 6:12.45 6:12.4 6.1:12.4 6.1:12.35 6.2:12.35 6.2:12.3 6.25:12.3 6.25:12.25 6.35:12.25 6.35:12.2 6.4:12.2 6.4:12.15 6.45:12.15 6.45:12.1 6.55:12.1 6.55:12.05 6.6:12.05 6.6:12 6.65:12 6.65:11.9 6.7:11.9 6.7:11.85 6.75:11.85 6.75:11.8 6.8:11.8 6.8:11.75 6.85:11.75 6.85:11.65 6.9:11.65 6.9:11.55 6.95:11.55 6.95:11.45 7:11.45 7:11.35 7.05:11.35 7.05:11.25 7.1:11.25 7.1:11.05 7.15:11.05 7.15:9.85 7.1:9.85 7.1:9.65 7.05:9.65 7.05:9.5 7:9.5 7:9.4 6.95:9.4 6.95:9.3 6.9:9.3 6.9:9.2 6.85:9.2 6.85:9.15 6.8:9.15 6.8:9.1 6.75:9.1 6.75:9 6.7:9 6.7:8.95 6.65:8.95 6.65:8.9 6.6:8.9 6.6:8.85 6.55:8.85 6.55:8.8 6.5:8.8 6.5:8.75 6.4:8.75 6.4:8.7 6.35:8.7 6.35:8.65 6.25:8.65 6.25:8.6 6.2:8.6 6.2:8.55 6.1:8.55 6.1:8.5 6:8.5 6:8.45 5.85:8.45 5.85:8.4 5.75:8.4 5.75:8.35 5.55:8.35 5.55:8.3 5.35:8.3 5.35:8.25 5:8.25 5:8.2 3.6:8.2 3.6:6.75 5:6.75 5:6.7 5.4:6.7 5.4:6.65 5.7:6.65 5.7:6.6 5.9:6.6 5.9:6.55 6.05:6.55 6.05:6.5 6.2:6.5 6.2:6.45 6.3:6.45 6.3:6.4 6.4:6.4 6.4:6.35 6.5:6.35 6.5:6.3 6.6:6.3 6.6:6.25 6.65:6.25 6.65:6.2 6.75:6.2 6.75:6.15 6.8:6.15 6.8:6.1 6.9:6.1 6.9:6.05 6.95:6.05 6.95:6 7:6 7:5.95 7.05:5.95 7.05:5.9 7.1:5.9 7.1:5.85 7.15:5.85 7.15:5.75 7.2:5.75 7.2:5.7 7.25:5.7 7.25:5.65 7.3:5.65 7.3:5.55 7.35:5.55 7.35:5.45 7.4:5.45 7.4:5.35 7.45:5.35 7.45:5.25 7.5:5.25 7.5:5.1 7.55:5.1 7.55:4.9 7.6:4.9 7.6:3.55 7.55:3.55 7.55:3.35 7.5:3.35 7.5:3.2 7.45:3.2 7.45:3.1 7.4:3.1 7.4:3 7.35:3 7.35:2.9 7.3:2.9 7.3:2.8 7.25:2.8 7.25:2.75 7.2:2.75 7.2:2.65 7.15:2.65 7.15:2.6 7.1:2.6 7.1:2.55 7.05:2.55 7.05:2.45 7:2.45 7:2.4 6.95:2.4 6.95:2.35 6.9:2.35 6.9:2.3 6.85:2.3 6.85:2.25 6.8:2.25 6.8:2.2 6.7:2.2 6.7:2.15 6.65:2.15 6.65:2.1 6.6:2.1 6.6:2.05 6.5:2.05 6.5:2 6.45:2 6.45:1.95 6.35:1.95 6.35:1.9 6.25:1.9 6.25:1.85 6.15:1.85 6.15:1.8 6.05:1.8 6.05:1.75 5.9:1.75 5.9:1.7 5.8:1.7 5.8:1.65 5.6:1.65 5.6:1.6 5.4:1.6 5.4:1.55 5.05:1.55 5.05:1.5 4.05:1.5 4.05:1.55 3.7:1.55 3.7:1.6 3.5:1.6 3.5:1.65 3.35:1.65 3.35:1.7 3.2:1.7 3.2:1.75 3.05:1.75 3.05:1.8 2.95:1.8 2.95:1.85 2.9:1.85 2.9:1.9 2.8:1.9 2.8:1.95 2.7:1.95 2.7:2 2.65:2 2.65:2.05 2.6:2.05 2.6:2.1 2.5:2.1 2.5:2.15 2.45:2.15 2.45:2.2 2.4:2.2 2.4:2.25 2.35:2.25 2.35:2.3 2.3:2.3 2.3:2.35 2.25:2.35 2.25:2.45 2.2:2.45 2.2:2.5 2.15:2.5 2.15:2.55 2.1:2.55 2.1:2.65 2.05:2.65 2.05:2.75 2:2.75 2:2.8 1.95:2.8 1.95:2.95 1.9:2.95 1.9:3.05 1.85:3.05 1.85:3.2 1.8:3.2 1.8:3.35 1.75:3.35 1.75:3.55 1.7:3.55 1.7:3.8 1.65:3.8 1.65:4.25 1.6:4.25 1.6:4.55 0:4.55 0:3.1 0.05:3.1 0.05:2.9 0.1:2.9 0.1:2.75 0.15:2.75 0.15:2.6 0.2:2.6 0.2:2.45 0.25:2.45 0.25:2.35 0.3:2.35 0.3:2.2 0.35:2.2 0.35:2.1 0.4:2.1 0.4:2 0.45:2 0.45:1.9 0.5:1.9 0.5:1.85 0.55:1.85 0.55:1.75 0.6:1.75 0.6:1.65 0.65:1.65 0.65:1.6 0.7:1.6 0.7:1.5 0.75:1.5 0.75:1.45 0.8:1.45 0.8:1.4 0.85:1.4 0.85:1.35 0.9:1.35 0.9:1.3 0.95:1.3 0.95:1.2 1:1.2 1:1.15 1.05:1.15 1.05:1.1 1.1:1.1 1.1:1.05 1.2:1.05 1.2:1 1.25:1 1.25:0.95 1.3:0.95 1.3:0.9 1.35:0.9 1.35:0.85 1.4:0.85 1.4:0.8 1.5:0.8 1.5:0.75 1.55:0.75 1.55:0.7 1.65:0.7 1.65:0.65 1.7:0.65 1.7:0.6 1.8:0.6 1.8:0.55 1.9:0.55 1.9:0.5 2:0.5 2:0.45 2.1:0.45 2.1:0.4 2.2:0.4 2.2:0.35 2.3:0.35 2.3:0.3 2.45:0.3 2.45:0.25 2.6:0.25 2.6:0.2 2.7:0.2 2.7:0.15 2.9:0.15 2.9:0.1 3.05:0.1 3.05:0.05 3.3:0.05 3.3:0 5.8:0 5.8:0.05 6.05:0.05 6.05:0.1 6.25:0.1 6.25:0.15 6.45:0.15 6.45:0.2 6.6:0.2 6.6:0.25 6.75:0.25 6.75:0.3 6.85:0.3 6.85:0.35 7:0.35 7:0.4 7.1:0.4 7.1:0.45 7.2:0.45 7.2:0.5 7.3:0.5 7.3:0.55 7.4:0.55 7.4:0.6 7.45:0.6 7.45:0.65 7.55:0.65 7.55:0.7 7.65:0.7 7.65:0.75 7.7:0.75 7.7:0.8 7.8:0.8 7.8:0.85 7.85:0.85 7.85:0.9 7.9:0.9 7.9:0.95 8:0.95 8:1 8.05:1 8.05:1.05 8.1:1.05 8.1:1.1 8.15:1.1 8.15:1.15 8.2:1.15 8.2:1.2 8.25:1.2 8.25:1.25 8.3:1.25 8.3:1.3 8.35:1.3 8.35:1.35 8.4:1.35 8.4:1.4 8.45:1.4 8.45:1.45 8.5:1.45 8.5:1.5 8.55:1.5 8.55:1.55 8.6:1.55 8.6:1.6 8.65:1.6 8.65:1.7 8.7:1.7 8.7:1.75 8.75:1.75 8.75:1.8 8.8:1.8 8.8:1.9 8.85:1.9 8.85:1.95 8.9:1.95 8.9:2.05 8.95:2.05 8.95:2.15 9:2.15 9:2.25 9.05:2.25 9.05:2.35 9.1:2.35 9.1:2.45 9.15:2.45 9.15:2.55 9.2:2.55 9.2:2.65 9.25:2.65 9.25:2.8 9.3:2.8 9.3:2.95 9.35:2.95 9.35:3.1 9.4:3.1 9.4:3.35 9.45:3.35 9.45:3.55 9.5:3.55)
letterShapes["4"] = (list 9.9:4.9 7.85:4.9 7.85:14 6.4:14 6.4:13.95 6.35:13.95 6.35:13.9 6.3:13.9 6.3:13.85 6.25:13.85 6.25:13.75 6.2:13.75 6.2:13.7 6.15:13.7 6.15:13.6 6.1:13.6 6.1:4.9 2.2:4.9 2.2:5.8 2.25:5.8 2.25:5.9 2.3:5.9 2.3:5.95 2.35:5.95 2.35:6.05 2.4:6.05 2.4:6.1 2.45:6.1 2.45:6.15 2.5:6.15 2.5:6.25 2.55:6.25 2.55:6.3 2.6:6.3 2.6:6.4 2.65:6.4 2.65:6.45 2.7:6.45 2.7:6.55 2.75:6.55 2.75:6.6 2.8:6.6 2.8:6.65 2.85:6.65 2.85:6.75 2.9:6.75 2.9:6.8 2.95:6.8 2.95:6.9 3:6.9 3:6.95 3.05:6.95 3.05:7 3.1:7 3.1:7.1 3.15:7.1 3.15:7.15 3.2:7.15 3.2:7.25 3.25:7.25 3.25:7.3 3.3:7.3 3.3:7.4 3.35:7.4 3.35:7.45 3.4:7.45 3.4:7.5 3.45:7.5 3.45:7.6 3.5:7.6 3.5:7.65 3.55:7.65 3.55:7.75 3.6:7.75 3.6:7.8 3.65:7.8 3.65:7.9 3.7:7.9 3.7:7.95 3.75:7.95 3.75:8 3.8:8 3.8:8.1 3.85:8.1 3.85:8.15 3.9:8.15 3.9:8.25 3.95:8.25 3.95:8.3 4:8.3 4:8.35 4.05:8.35 4.05:8.45 4.1:8.45 4.1:8.5 4.15:8.5 4.15:8.6 4.2:8.6 4.2:8.65 4.25:8.65 4.25:8.75 4.3:8.75 4.3:8.8 4.35:8.8 4.35:8.85 4.4:8.85 4.4:8.95 4.45:8.95 4.45:9 4.5:9 4.5:9.1 4.55:9.1 4.55:9.15 4.6:9.15 4.6:9.25 4.65:9.25 4.65:9.3 4.7:9.3 4.7:9.35 4.75:9.35 4.75:9.45 4.8:9.45 4.8:9.5 4.85:9.5 4.85:9.6 4.9:9.6 4.9:9.65 4.95:9.65 4.95:9.7 5:9.7 5:9.8 5.05:9.8 5.05:9.85 5.1:9.85 5.1:9.95 5.15:9.95 5.15:10 5.2:10 5.2:10.1 6.1:10.1 6.1:13.55 6.05:13.55 6.05:13.5 6:13.5 6:13.4 5.95:13.4 5.95:13.35 5.9:13.35 5.9:13.3 5.85:13.3 5.85:13.2 5.8:13.2 5.8:13.15 5.75:13.15 5.75:13.05 5.7:13.05 5.7:13 5.65:13 5.65:12.95 5.6:12.95 5.6:12.85 5.55:12.85 5.55:12.8 5.5:12.8 5.5:12.7 5.45:12.7 5.45:12.65 5.4:12.65 5.4:12.6 5.35:12.6 5.35:12.5 5.3:12.5 5.3:12.45 5.25:12.45 5.25:12.4 5.2:12.4 5.2:12.3 5.15:12.3 5.15:12.25 5.1:12.25 5.1:12.15 5.05:12.15 5.05:12.1 5:12.1 5:12.05 4.95:12.05 4.95:11.95 4.9:11.95 4.9:11.9 4.85:11.9 4.85:11.8 4.8:11.8 4.8:11.75 4.75:11.75 4.75:11.7 4.7:11.7 4.7:11.6 4.65:11.6 4.65:11.55 4.6:11.55 4.6:11.5 4.55:11.5 4.55:11.4 4.5:11.4 4.5:11.35 4.45:11.35 4.45:11.25 4.4:11.25 4.4:11.2 4.35:11.2 4.35:11.15 4.3:11.15 4.3:11.05 4.25:11.05 4.25:11 4.2:11 4.2:10.95 4.15:10.95 4.15:10.85 4.1:10.85 4.1:10.8 4.05:10.8 4.05:10.7 4:10.7 4:10.65 3.95:10.65 3.95:10.6 3.9:10.6 3.9:10.5 3.85:10.5 3.85:10.45 3.8:10.45 3.8:10.35 3.75:10.35 3.75:10.3 3.7:10.3 3.7:10.25 3.65:10.25 3.65:10.15 3.6:10.15 3.6:10.1 3.55:10.1 3.55:10.05 3.5:10.05 3.5:9.95 3.45:9.95 3.45:9.9 3.4:9.9 3.4:9.8 3.35:9.8 3.35:9.75 3.3:9.75 3.3:9.7 3.25:9.7 3.25:9.6 3.2:9.6 3.2:9.55 3.15:9.55 3.15:9.45 3.1:9.45 3.1:9.4 3.05:9.4 3.05:9.35 3:9.35 3:9.25 2.95:9.25 2.95:9.2 2.9:9.2 2.9:9.15 2.85:9.15 2.85:9.05 2.8:9.05 2.8:9 2.75:9 2.75:8.9 2.7:8.9 2.7:8.85 2.65:8.85 2.65:8.8 2.6:8.8 2.6:8.7 2.55:8.7 2.55:8.65 2.5:8.65 2.5:8.6 2.45:8.6 2.45:8.5 2.4:8.5 2.4:8.45 2.35:8.45 2.35:8.35 2.3:8.35 2.3:8.3 2.25:8.3 2.25:8.25 2.2:8.25 2.2:8.15 2.15:8.15 2.15:8.1 2.1:8.1 2.1:8 2.05:8 2.05:7.95 2:7.95 2:7.9 1.95:7.9 1.95:7.8 1.9:7.8 1.9:7.75 1.85:7.75 1.85:7.7 1.8:7.7 1.8:7.6 1.75:7.6 1.75:7.55 1.7:7.55 1.7:7.45 1.65:7.45 1.65:7.4 1.6:7.4 1.6:7.35 1.55:7.35 1.55:7.25 1.5:7.25 1.5:7.2 1.45:7.2 1.45:7.1 1.4:7.1 1.4:7.05 1.35:7.05 1.35:7 1.3:7 1.3:6.9 1.25:6.9 1.25:6.85 1.2:6.85 1.2:6.8 1.15:6.8 1.15:6.7 1.1:6.7 1.1:6.65 1.05:6.65 1.05:6.55 1:6.55 1:6.5 0.95:6.5 0.95:6.45 0.9:6.45 0.9:6.35 0.85:6.35 0.85:6.3 0.8:6.3 0.8:6.25 0.75:6.25 0.75:6.15 0.7:6.15 0.7:6.1 0.65:6.1 0.65:6 0.6:6 0.6:5.95 0.55:5.95 0.55:5.9 0.5:5.9 0.5:5.8 0.45:5.8 0.45:5.75 0.4:5.75 0.4:5.65 0.35:5.65 0.35:5.6 0.3:5.6 0.3:5.55 0.25:5.55 0.25:5.45 0.2:5.45 0.2:5.4 0.15:5.4 0.15:5.35 0.1:5.35 0.1:5.25 0.05:5.25 0.05:5.2 0:5.2 0:3.4 6.1:3.4 6.1:0 7.85:0 7.85:3.4 9.9:3.4)
letterShapes["5"] = (list 9.3:5.65 9.25:5.65 9.25:5.95 9.2:5.95 9.2:6.1 9.15:6.1 9.15:6.3 9.1:6.3 9.1:6.45 9.05:6.45 9.05:6.55 9:6.55 9:6.7 8.95:6.7 8.95:6.8 8.9:6.8 8.9:6.9 8.85:6.9 8.85:7 8.8:7 8.8:7.1 8.75:7.1 8.75:7.2 8.7:7.2 8.7:7.25 8.65:7.25 8.65:7.35 8.6:7.35 8.6:7.4 8.55:7.4 8.55:7.45 8.5:7.45 8.5:7.55 8.45:7.55 8.45:7.6 8.4:7.6 8.4:7.65 8.35:7.65 8.35:7.75 8.3:7.75 8.3:7.8 8.25:7.8 8.25:7.85 8.2:7.85 8.2:7.9 8.15:7.9 8.15:7.95 8.1:7.95 8.1:8 8.05:8 8.05:8.05 8:8.05 8:8.1 7.95:8.1 7.95:8.15 7.9:8.15 7.9:8.2 7.85:8.2 7.85:8.25 7.75:8.25 7.75:8.3 7.7:8.3 7.7:8.35 7.65:8.35 7.65:8.4 7.55:8.4 7.55:8.45 7.5:8.45 7.5:8.5 7.45:8.5 7.45:8.55 7.35:8.55 7.35:8.6 7.25:8.6 7.25:8.65 7.2:8.65 7.2:8.7 7.1:8.7 7.1:8.75 7:8.75 7:8.8 6.9:8.8 6.9:8.85 6.8:8.85 6.8:8.9 6.7:8.9 6.7:8.95 6.6:8.95 6.6:9 6.45:9 6.45:9.05 6.3:9.05 6.3:9.1 6.15:9.1 6.15:9.15 6:9.15 6:9.2 5.75:9.2 5.75:9.25 5.55:9.25 5.55:9.3 3.85:9.3 3.85:9.25 3.65:9.25 3.65:9.2 3.4:9.2 3.4:9.15 3.25:9.15 3.25:9.1 3.1:9.1 3.1:9.05 2.2:9.05 2.2:9.95 2.25:9.95 2.25:10.3 2.3:10.3 2.3:10.6 2.35:10.6 2.35:10.95 2.4:10.95 2.4:11.25 2.45:11.25 2.45:11.55 2.5:11.55 2.5:11.9 2.55:11.9 2.55:12.2 2.6:12.2 2.6:12.35 8.55:12.35 8.55:14.05 1.25:14.05 1.25:13.7 1.2:13.7 1.2:13.35 1.15:13.35 1.15:13 1.1:13 1.1:12.65 1.05:12.65 1.05:12.25 1:12.25 1:11.9 0.95:11.9 0.95:11.55 0.9:11.55 0.9:11.2 0.85:11.2 0.85:10.85 0.8:10.85 0.8:10.5 0.75:10.5 0.75:10.15 0.7:10.15 0.7:9.8 0.65:9.8 0.65:9.4 0.6:9.4 0.6:9.05 0.55:9.05 0.55:8.7 0.5:8.7 0.5:8.35 0.45:8.35 0.45:8 0.4:8 0.4:7.65 0.35:7.65 0.35:6.5 1.8:6.5 1.8:6.55 1.85:6.55 1.85:6.6 1.9:6.6 1.9:6.65 1.95:6.65 1.95:6.7 2:6.7 2:6.75 2.05:6.75 2.05:6.8 2.1:6.8 2.1:6.85 2.15:6.85 2.15:6.9 2.2:6.9 2.2:6.95 2.25:6.95 2.25:7 2.3:7 2.3:7.05 2.4:7.05 2.4:7.1 2.45:7.1 2.45:7.15 2.5:7.15 2.5:7.2 2.6:7.2 2.6:7.25 2.65:7.25 2.65:7.3 2.75:7.3 2.75:7.35 2.85:7.35 2.85:7.4 2.95:7.4 2.95:7.45 3.05:7.45 3.05:7.5 3.15:7.5 3.15:7.55 3.3:7.55 3.3:7.6 3.45:7.6 3.45:7.65 3.65:7.65 3.65:7.7 3.9:7.7 3.9:7.75 4.8:7.75 4.8:7.7 5.1:7.7 5.1:7.65 5.3:7.65 5.3:7.6 5.5:7.6 5.5:7.55 5.6:7.55 5.6:7.5 5.75:7.5 5.75:7.45 5.85:7.45 5.85:7.4 5.95:7.4 5.95:7.35 6.05:7.35 6.05:7.3 6.15:7.3 6.15:7.25 6.2:7.25 6.2:7.2 6.3:7.2 6.3:7.15 6.35:7.15 6.35:7.1 6.4:7.1 6.4:7.05 6.45:7.05 6.45:7 6.5:7 6.5:6.95 6.6:6.95 6.6:6.9 6.65:6.9 6.65:6.8 6.7:6.8 6.7:6.75 6.75:6.75 6.75:6.7 6.8:6.7 6.8:6.65 6.85:6.65 6.85:6.6 6.9:6.6 6.9:6.5 6.95:6.5 6.95:6.45 7:6.45 7:6.35 7.05:6.35 7.05:6.25 7.1:6.25 7.1:6.15 7.15:6.15 7.15:6.05 7.2:6.05 7.2:5.95 7.25:5.95 7.25:5.8 7.3:5.8 7.3:5.65 7.35:5.65 7.35:5.45 7.4:5.45 7.4:5.1 7.45:5.1 7.45:4.2 7.4:4.2 7.4:3.9 7.35:3.9 7.35:3.65 7.3:3.65 7.3:3.5 7.25:3.5 7.25:3.35 7.2:3.35 7.2:3.25 7.15:3.25 7.15:3.1 7.1:3.1 7.1:3 7.05:3 7.05:2.9 7:2.9 7:2.85 6.95:2.85 6.95:2.75 6.9:2.75 6.9:2.7 6.85:2.7 6.85:2.6 6.8:2.6 6.8:2.55 6.75:2.55 6.75:2.5 6.7:2.5 6.7:2.4 6.65:2.4 6.65:2.35 6.6:2.35 6.6:2.3 6.55:2.3 6.55:2.25 6.5:2.25 6.5:2.2 6.45:2.2 6.45:2.15 6.4:2.15 6.4:2.1 6.3:2.1 6.3:2.05 6.25:2.05 6.25:2 6.2:2 6.2:1.95 6.1:1.95 6.1:1.9 6.05:1.9 6.05:1.85 5.95:1.85 5.95:1.8 5.85:1.8 5.85:1.75 5.75:1.75 5.75:1.7 5.65:1.7 5.65:1.65 5.5:1.65 5.5:1.6 5.35:1.6 5.35:1.55 5.2:1.55 5.2:1.5 4.9:1.5 4.9:1.45 4:1.45 4:1.5 3.65:1.5 3.65:1.55 3.45:1.55 3.45:1.6 3.25:1.6 3.25:1.65 3.1:1.65 3.1:1.7 3:1.7 3:1.75 2.9:1.75 2.9:1.8 2.8:1.8 2.8:1.85 2.7:1.85 2.7:1.9 2.6:1.9 2.6:1.95 2.55:1.95 2.55:2 2.45:2 2.45:2.05 2.4:2.05 2.4:2.1 2.35:2.1 2.35:2.15 2.3:2.15 2.3:2.2 2.25:2.2 2.25:2.25 2.2:2.25 2.2:2.3 2.15:2.3 2.15:2.35 2.1:2.35 2.1:2.4 2.05:2.4 2.05:2.45 2:2.45 2:2.5 1.95:2.5 1.95:2.6 1.9:2.6 1.9:2.7 1.85:2.7 1.85:2.75 1.8:2.75 1.8:2.85 1.75:2.85 1.75:2.95 1.7:2.95 1.7:3.1 1.65:3.1 1.65:3.25 1.6:3.25 1.6:3.45 1.55:3.45 1.55:3.75 1.5:3.75 1.5:3.8 0:3.8 0:2.45 0.05:2.45 0.05:2.3 0.1:2.3 0.1:2.2 0.15:2.2 0.15:2.1 0.2:2.1 0.2:2 0.25:2 0.25:1.9 0.3:1.9 0.3:1.85 0.35:1.85 0.35:1.75 0.4:1.75 0.4:1.7 0.45:1.7 0.45:1.6 0.5:1.6 0.5:1.55 0.55:1.55 0.55:1.45 0.6:1.45 0.6:1.4 0.65:1.4 0.65:1.35 0.7:1.35 0.7:1.3 0.75:1.3 0.75:1.25 0.8:1.25 0.8:1.2 0.85:1.2 0.85:1.15 0.9:1.15 0.9:1.1 0.95:1.1 0.95:1.05 1:1.05 1:1 1.05:1 1.05:0.95 1.1:0.95 1.1:0.9 1.15:0.9 1.15:0.85 1.25:0.85 1.25:0.8 1.3:0.8 1.3:0.75 1.35:0.75 1.35:0.7 1.45:0.7 1.45:0.65 1.55:0.65 1.55:0.6 1.6:0.6 1.6:0.55 1.7:0.55 1.7:0.5 1.8:0.5 1.8:0.45 1.9:0.45 1.9:0.4 2:0.4 2:0.35 2.15:0.35 2.15:0.3 2.25:0.3 2.25:0.25 2.4:0.25 2.4:0.2 2.55:0.2 2.55:0.15 2.75:0.15 2.75:0.1 3:0.1 3:0.05 3.25:0.05 3.25:0 5.3:0 5.3:0.05 5.6:0.05 5.6:0.1 5.85:0.1 5.85:0.15 6.05:0.15 6.05:0.2 6.2:0.2 6.2:0.25 6.35:0.25 6.35:0.3 6.5:0.3 6.5:0.35 6.6:0.35 6.6:0.4 6.75:0.4 6.75:0.45 6.85:0.45 6.85:0.5 6.95:0.5 6.95:0.55 7.05:0.55 7.05:0.6 7.15:0.6 7.15:0.65 7.2:0.65 7.2:0.7 7.3:0.7 7.3:0.75 7.35:0.75 7.35:0.8 7.45:0.8 7.45:0.85 7.5:0.85 7.5:0.9 7.6:0.9 7.6:0.95 7.65:0.95 7.65:1 7.7:1 7.7:1.05 7.75:1.05 7.75:1.1 7.8:1.1 7.8:1.15 7.85:1.15 7.85:1.2 7.9:1.2 7.9:1.25 7.95:1.25 7.95:1.3 8:1.3 8:1.35 8.1:1.35 8.1:1.4 8.15:1.4 8.15:1.5 8.2:1.5 8.2:1.55 8.25:1.55 8.25:1.6 8.3:1.6 8.3:1.65 8.35:1.65 8.35:1.75 8.4:1.75 8.4:1.8 8.45:1.8 8.45:1.85 8.5:1.85 8.5:1.95 8.55:1.95 8.55:2.05 8.6:2.05 8.6:2.1 8.65:2.1 8.65:2.2 8.7:2.2 8.7:2.3 8.75:2.3 8.75:2.4 8.8:2.4 8.8:2.5 8.85:2.5 8.85:2.6 8.9:2.6 8.9:2.7 8.95:2.7 8.95:2.85 9:2.85 9:2.95 9.05:2.95 9.05:3.1 9.1:3.1 9.1:3.3 9.15:3.3 9.15:3.45 9.2:3.45 9.2:3.7 9.25:3.7 9.25:4 9.3:4)
letterShapes["6"] = (list 9.5:5.65 9.45:5.65 9.45:5.95 9.4:5.95 9.4:6.1 9.35:6.1 9.35:6.3 9.3:6.3 9.3:6.45 9.25:6.45 9.25:6.55 9.2:6.55 9.2:6.7 9.15:6.7 9.15:6.8 9.1:6.8 9.1:6.9 9.05:6.9 9.05:7 9:7 9:7.1 8.95:7.1 8.95:7.2 8.9:7.2 8.9:7.25 8.85:7.25 8.85:7.35 8.8:7.35 8.8:7.4 8.75:7.4 8.75:7.45 8.7:7.45 8.7:7.55 8.65:7.55 8.65:7.6 8.6:7.6 8.6:7.65 8.55:7.65 8.55:7.7 8.5:7.7 8.5:7.8 8.45:7.8 8.45:7.85 8.4:7.85 8.4:7.9 8.35:7.9 8.35:7.95 8.3:7.95 8.3:8 8.25:8 8.25:8.05 8.15:8.05 8.15:8.1 8.1:8.1 8.1:8.15 8.05:8.15 8.05:8.2 8:8.2 8:8.25 7.95:8.25 7.95:8.3 7.85:8.3 7.85:8.35 7.8:8.35 7.8:8.4 7.7:8.4 7.7:3.9 7.65:3.9 7.65:3.65 7.6:3.65 7.6:3.45 7.55:3.45 7.55:3.3 7.5:3.3 7.5:3.2 7.45:3.2 7.45:3.05 7.4:3.05 7.4:2.95 7.35:2.95 7.35:2.85 7.3:2.85 7.3:2.8 7.25:2.8 7.25:2.7 7.2:2.7 7.2:2.6 7.15:2.6 7.15:2.55 7.1:2.55 7.1:2.5 7.05:2.5 7.05:2.4 7:2.4 7:2.35 6.95:2.35 6.95:2.3 6.9:2.3 6.9:2.25 6.85:2.25 6.85:2.2 6.8:2.2 6.8:2.15 6.75:2.15 6.75:2.1 6.65:2.1 6.65:2.05 6.6:2.05 6.6:2 6.55:2 6.55:1.95 6.45:1.95 6.45:1.9 6.4:1.9 6.4:1.85 6.3:1.85 6.3:1.8 6.2:1.8 6.2:1.75 6.1:1.75 6.1:1.7 6:1.7 6:1.65 5.85:1.65 5.85:1.6 5.65:1.6 5.65:1.55 5.4:1.55 5.4:1.5 4.5:1.5 4.5:1.55 4.2:1.55 4.2:1.6 4.05:1.6 4.05:1.65 3.85:1.65 3.85:1.7 3.75:1.7 3.75:1.75 3.6:1.75 3.6:1.8 3.5:1.8 3.5:1.85 3.45:1.85 3.45:1.9 3.35:1.9 3.35:1.95 3.25:1.95 3.25:2 3.2:2 3.2:2.05 3.1:2.05 3.1:2.1 3.05:2.1 3.05:2.15 3:2.15 3:2.2 2.95:2.2 2.95:2.25 2.9:2.25 2.9:2.3 2.85:2.3 2.85:2.35 2.8:2.35 2.8:2.4 2.75:2.4 2.75:2.45 2.7:2.45 2.7:2.5 2.65:2.5 2.65:2.6 2.6:2.6 2.6:2.65 2.55:2.65 2.55:2.7 2.5:2.7 2.5:2.8 2.45:2.8 2.45:2.9 2.4:2.9 2.4:3 2.35:3 2.35:3.1 2.3:3.1 2.3:3.2 2.25:3.2 2.25:3.3 2.2:3.3 2.2:3.45 2.15:3.45 2.15:3.6 2.1:3.6 2.1:3.8 2.05:3.8 2.05:4.1 2:4.1 2:5.1 2.05:5.1 2.05:5.4 2.1:5.4 2.1:5.6 2.15:5.6 2.15:5.75 2.2:5.75 2.2:5.9 2.25:5.9 2.25:6 2.3:6 2.3:6.1 2.35:6.1 2.35:6.2 2.4:6.2 2.4:6.3 2.45:6.3 2.45:6.4 2.5:6.4 2.5:6.45 2.55:6.45 2.55:6.55 2.6:6.55 2.6:6.6 2.65:6.6 2.65:6.65 2.7:6.65 2.7:6.7 2.75:6.7 2.75:6.8 2.8:6.8 2.8:6.85 2.85:6.85 2.85:6.9 2.95:6.9 2.95:6.95 3:6.95 3:7 3.05:7 3.05:7.05 3.1:7.05 3.1:7.1 3.2:7.1 3.2:7.15 3.25:7.15 3.25:7.2 3.35:7.2 3.35:7.25 3.45:7.25 3.45:7.3 3.55:7.3 3.55:7.35 3.65:7.35 3.65:7.4 3.8:7.4 3.8:7.45 3.95:7.45 3.95:7.5 4.15:7.5 4.15:7.55 4.45:7.55 4.45:7.6 5.35:7.6 5.35:7.55 5.65:7.55 5.65:7.5 5.85:7.5 5.85:7.45 6:7.45 6:7.4 6.15:7.4 6.15:7.35 6.25:7.35 6.25:7.3 6.35:7.3 6.35:7.25 6.45:7.25 6.45:7.2 6.5:7.2 6.5:7.15 6.6:7.15 6.6:7.1 6.65:7.1 6.65:7.05 6.75:7.05 6.75:7 6.8:7 6.8:6.95 6.85:6.95 6.85:6.9 6.9:6.9 6.9:6.85 6.95:6.85 6.95:6.8 7:6.8 7:6.75 7.05:6.75 7.05:6.7 7.1:6.7 7.1:6.6 7.15:6.6 7.15:6.55 7.2:6.55 7.2:6.5 7.25:6.5 7.25:6.4 7.3:6.4 7.3:6.3 7.35:6.3 7.35:6.25 7.4:6.25 7.4:6.15 7.45:6.15 7.45:6 7.5:6 7.5:5.9 7.55:5.9 7.55:5.75 7.6:5.75 7.6:5.6 7.65:5.6 7.65:5.4 7.7:5.4 7.7:8.45 7.65:8.45 7.65:8.5 7.55:8.5 7.55:8.55 7.45:8.55 7.45:8.6 7.4:8.6 7.4:8.65 7.3:8.65 7.3:8.7 7.2:8.7 7.2:8.75 7.05:8.75 7.05:8.8 6.95:8.8 6.95:8.85 6.85:8.85 6.85:8.9 6.7:8.9 6.7:8.95 6.55:8.95 6.55:9 6.35:9 6.35:9.05 6.2:9.05 6.2:9.1 5.9:9.1 5.9:9.15 4.3:9.15 4.3:9.1 4.05:9.1 4.05:9.05 3.85:9.05 3.85:9 3.7:9 3.7:8.95 3.55:8.95 3.55:8.9 3.4:8.9 3.4:8.85 3.3:8.85 3.3:8.8 3.2:8.8 3.2:8.75 3.1:8.75 3.1:8.7 3:8.7 3:8.65 2.95:8.65 2.95:8.6 2:8.6 2:9.6 2.05:9.6 2.05:9.8 2.1:9.8 2.1:9.95 2.15:9.95 2.15:10.1 2.2:10.1 2.2:10.25 2.25:10.25 2.25:10.4 2.3:10.4 2.3:10.5 2.35:10.5 2.35:10.65 2.4:10.65 2.4:10.75 2.45:10.75 2.45:10.85 2.5:10.85 2.5:10.95 2.55:10.95 2.55:11.05 2.6:11.05 2.6:11.15 2.65:11.15 2.65:11.2 2.7:11.2 2.7:11.3 2.75:11.3 2.75:11.35 2.8:11.35 2.8:11.45 2.85:11.45 2.85:11.5 2.9:11.5 2.9:11.6 2.95:11.6 2.95:11.65 3:11.65 3:11.7 3.05:11.7 3.05:11.75 3.1:11.75 3.1:11.8 3.15:11.8 3.15:11.85 3.2:11.85 3.2:11.9 3.25:11.9 3.25:11.95 3.3:11.95 3.3:12 3.35:12 3.35:12.05 3.4:12.05 3.4:12.1 3.45:12.1 3.45:12.15 3.5:12.15 3.5:12.2 3.6:12.2 3.6:12.25 3.65:12.25 3.65:12.3 3.75:12.3 3.75:12.35 3.8:12.35 3.8:12.4 3.9:12.4 3.9:12.45 4:12.45 4:12.5 4.15:12.5 4.15:12.55 4.25:12.55 4.25:12.6 4.45:12.6 4.45:12.65 5.8:12.65 5.8:12.6 6:12.6 6:12.55 6.15:12.55 6.15:12.5 6.25:12.5 6.25:12.45 6.35:12.45 6.35:12.4 6.45:12.4 6.45:12.35 6.55:12.35 6.55:12.3 6.6:12.3 6.6:12.25 6.65:12.25 6.65:12.2 6.75:12.2 6.75:12.15 6.8:12.15 6.8:12.1 6.85:12.1 6.85:12.05 6.9:12.05 6.9:12 6.95:12 6.95:11.9 7:11.9 7:11.85 7.05:11.85 7.05:11.8 7.1:11.8 7.1:11.7 7.15:11.7 7.15:11.6 7.2:11.6 7.2:11.5 7.25:11.5 7.25:11.45 7.3:11.45 7.3:11.3 7.35:11.3 7.35:11.2 7.4:11.2 7.4:11.05 7.45:11.05 7.45:10.85 7.5:10.85 7.5:10.65 7.55:10.65 7.55:10.55 9.05:10.55 9.05:11.75 9:11.75 9:11.9 8.95:11.9 8.95:12 8.9:12 8.9:12.1 8.85:12.1 8.85:12.2 8.8:12.2 8.8:12.3 8.75:12.3 8.75:12.4 8.7:12.4 8.7:12.5 8.65:12.5 8.65:12.55 8.6:12.55 8.6:12.65 8.55:12.65 8.55:12.7 8.5:12.7 8.5:12.8 8.45:12.8 8.45:12.85 8.4:12.85 8.4:12.9 8.35:12.9 8.35:12.95 8.3:12.95 8.3:13 8.25:13 8.25:13.05 8.2:13.05 8.2:13.1 8.15:13.1 8.15:13.15 8.1:13.15 8.1:13.2 8.05:13.2 8.05:13.25 8:13.25 8:13.3 7.95:13.3 7.95:13.35 7.9:13.35 7.9:13.4 7.85:13.4 7.85:13.45 7.75:13.45 7.75:13.5 7.7:13.5 7.7:13.55 7.6:13.55 7.6:13.6 7.55:13.6 7.55:13.65 7.45:13.65 7.45:13.7 7.4:13.7 7.4:13.75 7.3:13.75 7.3:13.8 7.2:13.8 7.2:13.85 7.1:13.85 7.1:13.9 6.95:13.9 6.95:13.95 6.85:13.95 6.85:14 6.7:14 6.7:14.05 6.55:14.05 6.55:14.1 6.4:14.1 6.4:14.15 6.2:14.15 6.2:14.2 5.95:14.2 5.95:14.25 4.3:14.25 4.3:14.2 4:14.2 4:14.15 3.8:14.15 3.8:14.1 3.65:14.1 3.65:14.05 3.5:14.05 3.5:14 3.35:14 3.35:13.95 3.25:13.95 3.25:13.9 3.15:13.9 3.15:13.85 3.05:13.85 3.05:13.8 2.95:13.8 2.95:13.75 2.85:13.75 2.85:13.7 2.75:13.7 2.75:13.65 2.7:13.65 2.7:13.6 2.6:13.6 2.6:13.55 2.5:13.55 2.5:13.5 2.45:13.5 2.45:13.45 2.4:13.45 2.4:13.4 2.3:13.4 2.3:13.35 2.25:13.35 2.25:13.3 2.2:13.3 2.2:13.25 2.15:13.25 2.15:13.2 2.1:13.2 2.1:13.15 2.05:13.15 2.05:13.1 2:13.1 2:13.05 1.95:13.05 1.95:13 1.9:13 1.9:12.95 1.85:12.95 1.85:12.9 1.8:12.9 1.8:12.85 1.75:12.85 1.75:12.8 1.7:12.8 1.7:12.75 1.65:12.75 1.65:12.7 1.6:12.7 1.6:12.6 1.55:12.6 1.55:12.55 1.5:12.55 1.5:12.5 1.45:12.5 1.45:12.4 1.4:12.4 1.4:12.35 1.35:12.35 1.35:12.3 1.3:12.3 1.3:12.2 1.25:12.2 1.25:12.15 1.2:12.15 1.2:12.05 1.15:12.05 1.15:11.95 1.1:11.95 1.1:11.85 1.05:11.85 1.05:11.8 1:11.8 1:11.7 0.95:11.7 0.95:11.6 0.9:11.6 0.9:11.5 0.85:11.5 0.85:11.35 0.8:11.35 0.8:11.25 0.75:11.25 0.75:11.15 0.7:11.15 0.7:11.05 0.65:11.05 0.65:10.9 0.6:10.9 0.6:10.75 0.55:10.75 0.55:10.6 0.5:10.6 0.5:10.45 0.45:10.45 0.45:10.3 0.4:10.3 0.4:10.1 0.35:10.1 0.35:9.95 0.3:9.95 0.3:9.75 0.25:9.75 0.25:9.5 0.2:9.5 0.2:9.25 0.15:9.25 0.15:8.95 0.1:8.95 0.1:8.65 0.05:8.65 0.05:8.2 0:8.2 0:5.2 0.05:5.2 0.05:4.75 0.1:4.75 0.1:4.45 0.15:4.45 0.15:4.15 0.2:4.15 0.2:3.95 0.25:3.95 0.25:3.75 0.3:3.75 0.3:3.55 0.35:3.55 0.35:3.4 0.4:3.4 0.4:3.25 0.45:3.25 0.45:3.1 0.5:3.1 0.5:2.95 0.55:2.95 0.55:2.8 0.6:2.8 0.6:2.7 0.65:2.7 0.65:2.6 0.7:2.6 0.7:2.5 0.75:2.5 0.75:2.4 0.8:2.4 0.8:2.3 0.85:2.3 0.85:2.2 0.9:2.2 0.9:2.1 0.95:2.1 0.95:2.05 1:2.05 1:1.95 1.05:1.95 1.05:1.85 1.1:1.85 1.1:1.8 1.15:1.8 1.15:1.7 1.2:1.7 1.2:1.65 1.25:1.65 1.25:1.6 1.3:1.6 1.3:1.55 1.35:1.55 1.35:1.45 1.4:1.45 1.4:1.4 1.45:1.4 1.45:1.35 1.5:1.35 1.5:1.3 1.55:1.3 1.55:1.25 1.6:1.25 1.6:1.2 1.65:1.2 1.65:1.15 1.7:1.15 1.7:1.1 1.75:1.1 1.75:1.05 1.8:1.05 1.8:1 1.85:1 1.85:0.95 1.9:0.95 1.9:0.9 1.95:0.9 1.95:0.85 2.05:0.85 2.05:0.8 2.1:0.8 2.1:0.75 2.15:0.75 2.15:0.7 2.25:0.7 2.25:0.65 2.3:0.65 2.3:0.6 2.4:0.6 2.4:0.55 2.45:0.55 2.45:0.5 2.55:0.5 2.55:0.45 2.65:0.45 2.65:0.4 2.75:0.4 2.75:0.35 2.85:0.35 2.85:0.3 2.95:0.3 2.95:0.25 3.05:0.25 3.05:0.2 3.2:0.2 3.2:0.15 3.35:0.15 3.35:0.1 3.5:0.1 3.5:0.05 3.7:0.05 3.7:0 6.05:0 6.05:0.05 6.3:0.05 6.3:0.1 6.5:0.1 6.5:0.15 6.65:0.15 6.65:0.2 6.75:0.2 6.75:0.25 6.9:0.25 6.9:0.3 7:0.3 7:0.35 7.1:0.35 7.1:0.4 7.2:0.4 7.2:0.45 7.3:0.45 7.3:0.5 7.35:0.5 7.35:0.55 7.45:0.55 7.45:0.6 7.5:0.6 7.5:0.65 7.6:0.65 7.6:0.7 7.65:0.7 7.65:0.75 7.7:0.75 7.7:0.8 7.75:0.8 7.75:0.85 7.8:0.85 7.8:0.9 7.9:0.9 7.9:0.95 7.95:0.95 7.95:1 8:1 8:1.05 8.05:1.05 8.05:1.1 8.1:1.1 8.1:1.15 8.15:1.15 8.15:1.2 8.2:1.2 8.2:1.25 8.25:1.25 8.25:1.35 8.3:1.35 8.3:1.4 8.35:1.4 8.35:1.45 8.4:1.45 8.4:1.5 8.45:1.5 8.45:1.55 8.5:1.55 8.5:1.65 8.55:1.65 8.55:1.7 8.6:1.7 8.6:1.75 8.65:1.75 8.65:1.85 8.7:1.85 8.7:1.9 8.75:1.9 8.75:1.95 8.8:1.95 8.8:2.05 8.85:2.05 8.85:2.15 8.9:2.15 8.9:2.2 8.95:2.2 8.95:2.3 9:2.3 9:2.4 9.05:2.4 9.05:2.5 9.1:2.5 9.1:2.6 9.15:2.6 9.15:2.7 9.2:2.7 9.2:2.85 9.25:2.85 9.25:2.95 9.3:2.95 9.3:3.15 9.35:3.15 9.35:3.3 9.4:3.3 9.4:3.5 9.45:3.5 9.45:3.75 9.5:3.75)
letterShapes["7"] = (list 9.65:13.7 0:13.7 0:12 6.95:12 6.95:11.05 6.9:11.05 6.9:11 6.85:11 6.85:10.95 6.8:10.95 6.8:10.85 6.75:10.85 6.75:10.8 6.7:10.8 6.7:10.75 6.65:10.75 6.65:10.65 6.6:10.65 6.6:10.6 6.55:10.6 6.55:10.55 6.5:10.55 6.5:10.45 6.45:10.45 6.45:10.4 6.4:10.4 6.4:10.3 6.35:10.3 6.35:10.25 6.3:10.25 6.3:10.2 6.25:10.2 6.25:10.1 6.2:10.1 6.2:10.05 6.15:10.05 6.15:9.95 6.1:9.95 6.1:9.9 6.05:9.9 6.05:9.8 6:9.8 6:9.75 5.95:9.75 5.95:9.65 5.9:9.65 5.9:9.6 5.85:9.6 5.85:9.5 5.8:9.5 5.8:9.45 5.75:9.45 5.75:9.35 5.7:9.35 5.7:9.3 5.65:9.3 5.65:9.2 5.6:9.2 5.6:9.1 5.55:9.1 5.55:9.05 5.5:9.05 5.5:8.95 5.45:8.95 5.45:8.85 5.4:8.85 5.4:8.8 5.35:8.8 5.35:8.7 5.3:8.7 5.3:8.65 5.25:8.65 5.25:8.55 5.2:8.55 5.2:8.45 5.15:8.45 5.15:8.35 5.1:8.35 5.1:8.3 5.05:8.3 5.05:8.2 5:8.2 5:8.1 4.95:8.1 4.95:8.05 4.9:8.05 4.9:7.95 4.85:7.95 4.85:7.85 4.8:7.85 4.8:7.75 4.75:7.75 4.75:7.65 4.7:7.65 4.7:7.6 4.65:7.6 4.65:7.5 4.6:7.5 4.6:7.4 4.55:7.4 4.55:7.3 4.5:7.3 4.5:7.2 4.45:7.2 4.45:7.1 4.4:7.1 4.4:7.05 4.35:7.05 4.35:6.95 4.3:6.95 4.3:6.85 4.25:6.85 4.25:6.75 4.2:6.75 4.2:6.65 4.15:6.65 4.15:6.55 4.1:6.55 4.1:6.45 4.05:6.45 4.05:6.35 4:6.35 4:6.25 3.95:6.25 3.95:6.1 3.9:6.1 3.9:6 3.85:6 3.85:5.9 3.8:5.9 3.8:5.8 3.75:5.8 3.75:5.7 3.7:5.7 3.7:5.6 3.65:5.6 3.65:5.5 3.6:5.5 3.6:5.35 3.55:5.35 3.55:5.25 3.5:5.25 3.5:5.15 3.45:5.15 3.45:5 3.4:5 3.4:4.9 3.35:4.9 3.35:4.8 3.3:4.8 3.3:4.65 3.25:4.65 3.25:4.55 3.2:4.55 3.2:4.4 3.15:4.4 3.15:4.3 3.1:4.3 3.1:4.15 3.05:4.15 3.05:4.05 3:4.05 3:3.9 2.95:3.9 2.95:3.75 2.9:3.75 2.9:3.6 2.85:3.6 2.85:3.5 2.8:3.5 2.8:3.35 2.75:3.35 2.75:3.2 2.7:3.2 2.7:3.05 2.65:3.05 2.65:2.9 2.6:2.9 2.6:2.7 2.55:2.7 2.55:2.55 2.5:2.55 2.5:2.4 2.45:2.4 2.45:2.25 2.4:2.25 2.4:2.05 2.35:2.05 2.35:1.85 2.3:1.85 2.3:1.65 2.25:1.65 2.25:1.45 2.2:1.45 2.2:1.25 2.15:1.25 2.15:0 3.9:0 3.9:0.2 3.95:0.2 3.95:0.45 4:0.45 4:0.7 4.05:0.7 4.05:1 4.1:1 4.1:1.2 4.15:1.2 4.15:1.4 4.2:1.4 4.2:1.65 4.25:1.65 4.25:1.85 4.3:1.85 4.3:2.05 4.35:2.05 4.35:2.25 4.4:2.25 4.4:2.45 4.45:2.45 4.45:2.6 4.5:2.6 4.5:2.75 4.55:2.75 4.55:2.95 4.6:2.95 4.6:3.1 4.65:3.1 4.65:3.3 4.7:3.3 4.7:3.45 4.75:3.45 4.75:3.6 4.8:3.6 4.8:3.75 4.85:3.75 4.85:3.9 4.9:3.9 4.9:4.05 4.95:4.05 4.95:4.2 5:4.2 5:4.35 5.05:4.35 5.05:4.45 5.1:4.45 5.1:4.6 5.15:4.6 5.15:4.7 5.2:4.7 5.2:4.85 5.25:4.85 5.25:5 5.3:5 5.3:5.1 5.35:5.1 5.35:5.25 5.4:5.25 5.4:5.35 5.45:5.35 5.45:5.45 5.5:5.45 5.5:5.6 5.55:5.6 5.55:5.7 5.6:5.7 5.6:5.8 5.65:5.8 5.65:5.95 5.7:5.95 5.7:6.05 5.75:6.05 5.75:6.15 5.8:6.15 5.8:6.25 5.85:6.25 5.85:6.4 5.9:6.4 5.9:6.5 5.95:6.5 5.95:6.6 6:6.6 6:6.7 6.05:6.7 6.05:6.8 6.1:6.8 6.1:6.9 6.15:6.9 6.15:7 6.2:7 6.2:7.1 6.25:7.1 6.25:7.2 6.3:7.2 6.3:7.3 6.35:7.3 6.35:7.4 6.4:7.4 6.4:7.5 6.45:7.5 6.45:7.6 6.5:7.6 6.5:7.7 6.55:7.7 6.55:7.8 6.6:7.8 6.6:7.85 6.65:7.85 6.65:7.95 6.7:7.95 6.7:8.05 6.75:8.05 6.75:8.15 6.8:8.15 6.8:8.2 6.85:8.2 6.85:8.3 6.9:8.3 6.9:8.4 6.95:8.4 6.95:8.5 7:8.5 7:8.6 7.05:8.6 7.05:8.65 7.1:8.65 7.1:8.75 7.15:8.75 7.15:8.85 7.2:8.85 7.2:8.9 7.25:8.9 7.25:9 7.3:9 7.3:9.05 7.35:9.05 7.35:9.15 7.4:9.15 7.4:9.25 7.45:9.25 7.45:9.3 7.5:9.3 7.5:9.4 7.55:9.4 7.55:9.45 7.6:9.45 7.6:9.55 7.65:9.55 7.65:9.6 7.7:9.6 7.7:9.7 7.75:9.7 7.75:9.75 7.8:9.75 7.8:9.85 7.85:9.85 7.85:9.9 7.9:9.9 7.9:10 7.95:10 7.95:10.05 8:10.05 8:10.15 8.05:10.15 8.05:10.2 8.1:10.2 8.1:10.3 8.15:10.3 8.15:10.35 8.2:10.35 8.2:10.45 8.25:10.45 8.25:10.5 8.3:10.5 8.3:10.55 8.35:10.55 8.35:10.65 8.4:10.65 8.4:10.7 8.45:10.7 8.45:10.75 8.5:10.75 8.5:10.85 8.55:10.85 8.55:10.9 8.6:10.9 8.6:10.95 8.65:10.95 8.65:11.05 8.7:11.05 8.7:11.1 8.75:11.1 8.75:11.15 8.8:11.15 8.8:11.2 8.85:11.2 8.85:11.3 8.9:11.3 8.9:11.35 8.95:11.35 8.95:11.4 9:11.4 9:11.45 9.05:11.45 9.05:11.55 9.1:11.55 9.1:11.6 9.15:11.6 9.15:11.65 9.2:11.65 9.2:11.7 9.25:11.7 9.25:11.75 9.3:11.75 9.3:11.8 9.35:11.8 9.35:11.9 9.4:11.9 9.4:11.95 9.45:11.95 9.45:12 9.5:12 9.5:12.05 9.55:12.05 9.55:12.1 9.6:12.1 9.6:12.15 9.65:12.15)
letterShapes["8"] = (list 9.45:5.05 9.4:5.05 9.4:5.3 9.35:5.3 9.35:5.5 9.3:5.5 9.3:5.65 9.25:5.65 9.25:5.75 9.2:5.75 9.2:5.9 9.15:5.9 9.15:6 9.1:6 9.1:6.1 9.05:6.1 9.05:6.15 9:6.15 9:6.25 8.95:6.25 8.95:6.35 8.9:6.35 8.9:6.4 8.85:6.4 8.85:6.5 8.8:6.5 8.8:6.55 8.75:6.55 8.75:6.6 8.7:6.6 8.7:6.65 8.65:6.65 8.65:6.75 8.6:6.75 8.6:6.8 8.55:6.8 8.55:6.85 8.5:6.85 8.5:6.9 8.45:6.9 8.45:6.95 8.4:6.95 8.4:7 8.3:7 8.3:7.05 8.25:7.05 8.25:7.1 8.2:7.1 8.2:7.15 8.15:7.15 8.15:7.2 8.05:7.2 8.05:7.25 8:7.25 8:7.3 7.95:7.3 7.95:8.2 8:8.2 8:8.25 8.05:8.25 8.05:8.3 8.1:8.3 8.1:8.35 8.15:8.35 8.15:8.4 8.2:8.4 8.2:8.45 8.25:8.45 8.25:8.5 8.3:8.5 8.3:8.55 8.35:8.55 8.35:8.6 8.4:8.6 8.4:8.65 8.45:8.65 8.45:8.75 8.5:8.75 8.5:8.8 8.55:8.8 8.55:8.9 8.6:8.9 8.6:9 8.65:9 8.65:9.1 8.7:9.1 8.7:9.2 8.75:9.2 8.75:9.3 8.8:9.3 8.8:9.45 8.85:9.45 8.85:9.65 8.9:9.65 8.9:9.85 8.95:9.85 8.95:11.35 8.9:11.35 8.9:11.6 8.85:11.6 8.85:11.75 8.8:11.75 8.8:11.9 8.75:11.9 8.75:12 8.7:12 8.7:12.1 8.65:12.1 8.65:12.25 8.6:12.25 8.6:12.3 8.55:12.3 8.55:12.4 8.5:12.4 8.5:12.5 8.45:12.5 8.45:12.55 8.4:12.55 8.4:12.65 8.35:12.65 8.35:12.7 8.3:12.7 8.3:12.8 8.25:12.8 8.25:12.85 8.2:12.85 8.2:12.9 8.15:12.9 8.15:12.95 8.1:12.95 8.1:13 8.05:13 8.05:13.05 8:13.05 8:13.1 7.95:13.1 7.95:13.15 7.9:13.15 7.9:13.2 7.85:13.2 7.85:13.25 7.8:13.25 7.8:13.3 7.75:13.3 7.75:13.35 7.7:13.35 7.7:13.4 7.6:13.4 7.6:3.65 7.55:3.65 7.55:3.35 7.5:3.35 7.5:3.15 7.45:3.15 7.45:3 7.4:3 7.4:2.9 7.35:2.9 7.35:2.75 7.3:2.75 7.3:2.65 7.25:2.65 7.25:2.6 7.2:2.6 7.2:2.5 7.15:2.5 7.15:2.45 7.1:2.45 7.1:2.35 7.05:2.35 7.05:2.3 7:2.3 7:2.25 6.95:2.25 6.95:2.2 6.9:2.2 6.9:2.15 6.85:2.15 6.85:2.1 6.75:2.1 6.75:2.05 6.7:2.05 6.7:2 6.65:2 6.65:1.95 6.55:1.95 6.55:1.9 6.5:1.9 6.5:1.85 6.4:1.85 6.4:1.8 6.3:1.8 6.3:1.75 6.15:1.75 6.15:1.7 6.05:1.7 6.05:1.65 5.85:1.65 5.85:1.6 5.65:1.6 5.65:1.55 5.3:1.55 5.3:1.5 4.3:1.5 4.3:1.55 3.95:1.55 3.95:1.6 3.75:1.6 3.75:1.65 3.55:1.65 3.55:1.7 3.4:1.7 3.4:1.75 3.3:1.75 3.3:1.8 3.2:1.8 3.2:1.85 3.1:1.85 3.1:1.9 3:1.9 3:1.95 2.95:1.95 2.95:2 2.85:2 2.85:2.05 2.8:2.05 2.8:2.1 2.7:2.1 2.7:2.15 2.65:2.15 2.65:2.2 2.6:2.2 2.6:2.25 2.55:2.25 2.55:2.3 2.5:2.3 2.5:2.35 2.45:2.35 2.45:2.4 2.4:2.4 2.4:2.45 2.35:2.45 2.35:2.55 2.3:2.55 2.3:2.6 2.25:2.6 2.25:2.7 2.2:2.7 2.2:2.75 2.15:2.75 2.15:2.85 2.1:2.85 2.1:2.95 2.05:2.95 2.05:3.1 2:3.1 2:3.2 1.95:3.2 1.95:3.35 1.9:3.35 1.9:3.55 1.85:3.55 1.85:4.9 1.9:4.9 1.9:5.1 1.95:5.1 1.95:5.25 2:5.25 2:5.35 2.05:5.35 2.05:5.45 2.1:5.45 2.1:5.55 2.15:5.55 2.15:5.65 2.2:5.65 2.2:5.7 2.25:5.7 2.25:5.75 2.3:5.75 2.3:5.85 2.35:5.85 2.35:5.9 2.4:5.9 2.4:5.95 2.45:5.95 2.45:6 2.5:6 2.5:6.05 2.55:6.05 2.55:6.1 2.6:6.1 2.6:6.15 2.65:6.15 2.65:6.2 2.7:6.2 2.7:6.25 2.75:6.25 2.75:6.3 2.85:6.3 2.85:6.35 2.9:6.35 2.9:6.4 3:6.4 3:6.45 3.1:6.45 3.1:6.5 3.15:6.5 3.15:6.55 3.3:6.55 3.3:6.6 3.4:6.6 3.4:6.65 3.55:6.65 3.55:6.7 3.7:6.7 3.7:6.75 3.9:6.75 3.9:6.8 4.25:6.8 4.25:6.85 5.15:6.85 5.15:6.8 5.45:6.8 5.45:6.75 5.7:6.75 5.7:6.7 5.85:6.7 5.85:6.65 6:6.65 6:6.6 6.1:6.6 6.1:6.55 6.25:6.55 6.25:6.5 6.35:6.5 6.35:6.45 6.4:6.45 6.4:6.4 6.5:6.4 6.5:6.35 6.6:6.35 6.6:6.3 6.65:6.3 6.65:6.25 6.7:6.25 6.7:6.2 6.75:6.2 6.75:6.15 6.8:6.15 6.8:6.1 6.9:6.1 6.9:6.05 6.95:6.05 6.95:5.95 7:5.95 7:5.9 7.05:5.9 7.05:5.85 7.1:5.85 7.1:5.8 7.15:5.8 7.15:5.7 7.2:5.7 7.2:5.65 7.25:5.65 7.25:5.55 7.3:5.55 7.3:5.45 7.35:5.45 7.35:5.35 7.4:5.35 7.4:5.2 7.45:5.2 7.45:5.05 7.5:5.05 7.5:4.85 7.55:4.85 7.55:4.6 7.6:4.6 7.6:13.45 7.55:13.45 7.55:13.5 7.5:13.5 7.5:13.55 7.4:13.55 7.4:13.6 7.35:13.6 7.35:13.65 7.25:13.65 7.25:13.7 7.15:13.7 7.15:10.05 7.1:10.05 7.1:9.85 7.05:9.85 7.05:9.7 7:9.7 7:9.6 6.95:9.6 6.95:9.5 6.9:9.5 6.9:9.45 6.85:9.45 6.85:9.35 6.8:9.35 6.8:9.3 6.75:9.3 6.75:9.25 6.7:9.25 6.7:9.15 6.65:9.15 6.65:9.1 6.6:9.1 6.6:9.05 6.55:9.05 6.55:9 6.5:9 6.5:8.95 6.45:8.95 6.45:8.9 6.35:8.9 6.35:8.85 6.3:8.85 6.3:8.8 6.2:8.8 6.2:8.75 6.15:8.75 6.15:8.7 6.05:8.7 6.05:8.65 5.95:8.65 5.95:8.6 5.85:8.6 5.85:8.55 5.75:8.55 5.75:8.5 5.55:8.5 5.55:8.45 5.35:8.45 5.35:8.4 4:8.4 4:8.45 3.85:8.45 3.85:8.5 3.7:8.5 3.7:8.55 3.55:8.55 3.55:8.6 3.45:8.6 3.45:8.65 3.35:8.65 3.35:8.7 3.25:8.7 3.25:8.75 3.15:8.75 3.15:8.8 3.1:8.8 3.1:8.85 3.05:8.85 3.05:8.9 2.95:8.9 2.95:8.95 2.9:8.95 2.9:9 2.85:9 2.85:9.05 2.8:9.05 2.8:9.1 2.75:9.1 2.75:9.15 2.7:9.15 2.7:9.2 2.65:9.2 2.65:9.25 2.6:9.25 2.6:9.35 2.55:9.35 2.55:9.4 2.5:9.4 2.5:9.5 2.45:9.5 2.45:9.55 2.4:9.55 2.4:9.7 2.35:9.7 2.35:9.8 2.3:9.8 2.3:9.95 2.25:9.95 2.25:11.1 2.3:11.1 2.3:11.3 2.35:11.3 2.35:11.45 2.4:11.45 2.4:11.55 2.45:11.55 2.45:11.65 2.5:11.65 2.5:11.75 2.55:11.75 2.55:11.8 2.6:11.8 2.6:11.9 2.65:11.9 2.65:11.95 2.7:11.95 2.7:12 2.75:12 2.75:12.05 2.8:12.05 2.8:12.1 2.85:12.1 2.85:12.15 2.9:12.15 2.9:12.2 2.95:12.2 2.95:12.25 3:12.25 3:12.3 3.1:12.3 3.1:12.35 3.15:12.35 3.15:12.4 3.25:12.4 3.25:12.45 3.35:12.45 3.35:12.5 3.5:12.5 3.5:12.55 3.65:12.55 3.65:12.6 3.8:12.6 3.8:12.65 4.1:12.65 4.1:12.7 5.05:12.7 5.05:12.65 5.4:12.65 5.4:12.6 5.6:12.6 5.6:12.55 5.75:12.55 5.75:12.5 5.9:12.5 5.9:12.45 6:12.45 6:12.4 6.1:12.4 6.1:12.35 6.2:12.35 6.2:12.3 6.3:12.3 6.3:12.25 6.35:12.25 6.35:12.2 6.45:12.2 6.45:12.15 6.5:12.15 6.5:12.1 6.55:12.1 6.55:12.05 6.6:12.05 6.6:12 6.65:12 6.65:11.95 6.7:11.95 6.7:11.9 6.75:11.9 6.75:11.85 6.8:11.85 6.8:11.75 6.85:11.75 6.85:11.7 6.9:11.7 6.9:11.6 6.95:11.6 6.95:11.55 7:11.55 7:11.45 7.05:11.45 7.05:11.3 7.1:11.3 7.1:11.15 7.15:11.15 7.15:13.75 7.05:13.75 7.05:13.8 6.95:13.8 6.95:13.85 6.85:13.85 6.85:13.9 6.75:13.9 6.75:13.95 6.6:13.95 6.6:14 6.45:14 6.45:14.05 6.3:14.05 6.3:14.1 6.1:14.1 6.1:14.15 5.9:14.15 5.9:14.2 5.6:14.2 5.6:14.25 3.75:14.25 3.75:14.2 3.45:14.2 3.45:14.15 3.25:14.15 3.25:14.1 3.05:14.1 3.05:14.05 2.9:14.05 2.9:14 2.8:14 2.8:13.95 2.65:13.95 2.65:13.9 2.55:13.9 2.55:13.85 2.45:13.85 2.45:13.8 2.35:13.8 2.35:13.75 2.25:13.75 2.25:13.7 2.15:13.7 2.15:13.65 2.1:13.65 2.1:13.6 2:13.6 2:13.55 1.95:13.55 1.95:13.5 1.85:13.5 1.85:13.45 1.8:13.45 1.8:13.4 1.75:13.4 1.75:13.35 1.7:13.35 1.7:13.3 1.6:13.3 1.6:13.25 1.55:13.25 1.55:13.2 1.5:13.2 1.5:13.15 1.45:13.15 1.45:13.1 1.4:13.1 1.4:13.05 1.35:13.05 1.35:12.95 1.3:12.95 1.3:12.9 1.25:12.9 1.25:12.85 1.2:12.85 1.2:12.8 1.15:12.8 1.15:12.7 1.1:12.7 1.1:12.65 1.05:12.65 1.05:12.55 1:12.55 1:12.5 0.95:12.5 0.95:12.4 0.9:12.4 0.9:12.3 0.85:12.3 0.85:12.2 0.8:12.2 0.8:12.1 0.75:12.1 0.75:12 0.7:12 0.7:11.9 0.65:11.9 0.65:11.75 0.6:11.75 0.6:11.6 0.55:11.6 0.55:11.4 0.5:11.4 0.5:11.15 0.45:11.15 0.45:9.7 0.5:9.7 0.5:9.5 0.55:9.5 0.55:9.35 0.6:9.35 0.6:9.25 0.65:9.25 0.65:9.1 0.7:9.1 0.7:9.05 0.75:9.05 0.75:8.95 0.8:8.95 0.8:8.85 0.85:8.85 0.85:8.75 0.9:8.75 0.9:8.7 0.95:8.7 0.95:8.65 1:8.65 1:8.6 1.05:8.6 1.05:8.5 1.1:8.5 1.1:8.45 1.15:8.45 1.15:8.4 1.2:8.4 1.2:8.35 1.25:8.35 1.25:8.3 1.3:8.3 1.3:8.25 1.4:8.25 1.4:8.2 1.45:8.2 1.45:7.25 1.4:7.25 1.4:7.2 1.3:7.2 1.3:7.15 1.25:7.15 1.25:7.1 1.2:7.1 1.2:7.05 1.1:7.05 1.1:7 1.05:7 1.05:6.95 1:6.95 1:6.9 0.95:6.9 0.95:6.85 0.9:6.85 0.9:6.8 0.85:6.8 0.85:6.75 0.8:6.75 0.8:6.7 0.75:6.7 0.75:6.65 0.7:6.65 0.7:6.6 0.65:6.6 0.65:6.55 0.6:6.55 0.6:6.45 0.55:6.45 0.55:6.4 0.5:6.4 0.5:6.3 0.45:6.3 0.45:6.25 0.4:6.25 0.4:6.15 0.35:6.15 0.35:6.1 0.3:6.1 0.3:6 0.25:6 0.25:5.9 0.2:5.9 0.2:5.75 0.15:5.75 0.15:5.65 0.1:5.65 0.1:5.5 0.05:5.5 0.05:5.3 0:5.3 0:3.05 0.05:3.05 0.05:2.85 0.1:2.85 0.1:2.7 0.15:2.7 0.15:2.55 0.2:2.55 0.2:2.45 0.25:2.45 0.25:2.35 0.3:2.35 0.3:2.25 0.35:2.25 0.35:2.15 0.4:2.15 0.4:2.05 0.45:2.05 0.45:1.95 0.5:1.95 0.5:1.9 0.55:1.9 0.55:1.8 0.6:1.8 0.6:1.75 0.65:1.75 0.65:1.65 0.7:1.65 0.7:1.6 0.75:1.6 0.75:1.55 0.8:1.55 0.8:1.5 0.85:1.5 0.85:1.45 0.9:1.45 0.9:1.4 0.95:1.4 0.95:1.35 1:1.35 1:1.3 1.05:1.3 1.05:1.25 1.1:1.25 1.1:1.2 1.15:1.2 1.15:1.15 1.2:1.15 1.2:1.1 1.25:1.1 1.25:1.05 1.3:1.05 1.3:1 1.4:1 1.4:0.95 1.45:0.95 1.45:0.9 1.5:0.9 1.5:0.85 1.6:0.85 1.6:0.8 1.65:0.8 1.65:0.75 1.75:0.75 1.75:0.7 1.8:0.7 1.8:0.65 1.9:0.65 1.9:0.6 2:0.6 2:0.55 2.1:0.55 2.1:0.5 2.2:0.5 2.2:0.45 2.3:0.45 2.3:0.4 2.4:0.4 2.4:0.35 2.55:0.35 2.55:0.3 2.65:0.3 2.65:0.25 2.8:0.25 2.8:0.2 3:0.2 3:0.15 3.15:0.15 3.15:0.1 3.35:0.1 3.35:0.05 3.55:0.05 3.55:0 6:0 6:0.05 6.2:0.05 6.2:0.1 6.4:0.1 6.4:0.15 6.55:0.15 6.55:0.2 6.7:0.2 6.7:0.25 6.85:0.25 6.85:0.3 6.95:0.3 6.95:0.35 7.1:0.35 7.1:0.4 7.2:0.4 7.2:0.45 7.3:0.45 7.3:0.5 7.4:0.5 7.4:0.55 7.45:0.55 7.45:0.6 7.55:0.6 7.55:0.65 7.65:0.65 7.65:0.7 7.7:0.7 7.7:0.75 7.8:0.75 7.8:0.8 7.85:0.8 7.85:0.85 7.9:0.85 7.9:0.9 7.95:0.9 7.95:0.95 8.05:0.95 8.05:1 8.1:1 8.1:1.05 8.15:1.05 8.15:1.1 8.2:1.1 8.2:1.15 8.25:1.15 8.25:1.2 8.3:1.2 8.3:1.25 8.35:1.25 8.35:1.3 8.4:1.3 8.4:1.35 8.45:1.35 8.45:1.4 8.5:1.4 8.5:1.5 8.55:1.5 8.55:1.55 8.6:1.55 8.6:1.6 8.65:1.6 8.65:1.65 8.7:1.65 8.7:1.75 8.75:1.75 8.75:1.8 8.8:1.8 8.8:1.9 8.85:1.9 8.85:1.95 8.9:1.95 8.9:2.05 8.95:2.05 8.95:2.15 9:2.15 9:2.25 9.05:2.25 9.05:2.35 9.1:2.35 9.1:2.45 9.15:2.45 9.15:2.6 9.2:2.6 9.2:2.7 9.25:2.7 9.25:2.9 9.3:2.9 9.3:3.05 9.35:3.05 9.35:3.25 9.4:3.25 9.4:3.5 9.45:3.5)
letterShapes["9"] = (list 9.3:8.65 9.25:8.65 9.25:9.3 9.2:9.3 9.2:9.65 9.15:9.65 9.15:9.95 9.1:9.95 9.1:10.25 9.05:10.25 9.05:10.45 9:10.45 9:10.65 8.95:10.65 8.95:10.85 8.9:10.85 8.9:11 8.85:11 8.85:11.15 8.8:11.15 8.8:11.3 8.75:11.3 8.75:11.45 8.7:11.45 8.7:11.55 8.65:11.55 8.65:11.65 8.6:11.65 8.6:11.8 8.55:11.8 8.55:11.9 8.5:11.9 8.5:12 8.45:12 8.45:12.05 8.4:12.05 8.4:12.15 8.35:12.15 8.35:12.25 8.3:12.25 8.3:12.35 8.25:12.35 8.25:12.4 8.2:12.4 8.2:12.5 8.15:12.5 8.15:12.55 8.1:12.55 8.1:12.65 8.05:12.65 8.05:12.7 8:12.7 8:12.75 7.95:12.75 7.95:12.8 7.9:12.8 7.9:12.85 7.85:12.85 7.85:12.95 7.8:12.95 7.8:13 7.75:13 7.75:13.05 7.7:13.05 7.7:13.1 7.65:13.1 7.65:13.15 7.6:13.15 7.6:13.2 7.55:13.2 7.55:13.25 7.45:13.25 7.45:13.3 7.4:13.3 7.4:13.35 7.35:13.35 7.35:13.4 7.3:13.4 7.3:13.45 7.25:13.45 7.25:9.2 7.2:9.2 7.2:8.8 7.15:8.8 7.15:8.6 7.1:8.6 7.1:8.4 7.05:8.4 7.05:8.25 7:8.25 7:8.1 6.95:8.1 6.95:8 6.9:8 6.9:7.9 6.85:7.9 6.85:7.8 6.8:7.8 6.8:7.7 6.75:7.7 6.75:7.65 6.7:7.65 6.7:7.55 6.65:7.55 6.65:7.5 6.6:7.5 6.6:7.45 6.55:7.45 6.55:7.35 6.5:7.35 6.5:7.3 6.45:7.3 6.45:7.25 6.4:7.25 6.4:7.2 6.35:7.2 6.35:7.15 6.3:7.15 6.3:7.1 6.2:7.1 6.2:7.05 6.15:7.05 6.15:7 6.05:7 6.05:6.95 6:6.95 6:6.9 5.9:6.9 5.9:6.85 5.8:6.85 5.8:6.8 5.7:6.8 5.7:6.75 5.6:6.75 5.6:6.7 5.45:6.7 5.45:6.65 5.25:6.65 5.25:6.6 5:6.6 5:6.55 4:6.55 4:6.6 3.7:6.6 3.7:6.65 3.5:6.65 3.5:6.7 3.3:6.7 3.3:6.75 3.2:6.75 3.2:6.8 3.05:6.8 3.05:6.85 2.95:6.85 2.95:6.9 2.9:6.9 2.9:6.95 2.8:6.95 2.8:7 2.7:7 2.7:7.05 2.65:7.05 2.65:7.1 2.6:7.1 2.6:7.15 2.55:7.15 2.55:7.2 2.5:7.2 2.5:7.25 2.45:7.25 2.45:7.3 2.4:7.3 2.4:7.35 2.35:7.35 2.35:7.4 2.3:7.4 2.3:7.45 2.25:7.45 2.25:7.55 2.2:7.55 2.2:7.6 2.15:7.6 2.15:7.7 2.1:7.7 2.1:7.75 2.05:7.75 2.05:7.85 2:7.85 2:8 1.95:8 1.95:8.1 1.9:8.1 1.9:8.25 1.85:8.25 1.85:8.45 1.8:8.45 1.8:8.65 1.75:8.65 1.75:9.05 1.7:9.05 1.7:10 1.75:10 1.75:10.35 1.8:10.35 1.8:10.6 1.85:10.6 1.85:10.8 1.9:10.8 1.9:10.95 1.95:10.95 1.95:11.05 2:11.05 2:11.15 2.05:11.15 2.05:11.25 2.1:11.25 2.1:11.4 2.15:11.4 2.15:11.45 2.2:11.45 2.2:11.55 2.25:11.55 2.25:11.6 2.3:11.6 2.3:11.7 2.35:11.7 2.35:11.75 2.4:11.75 2.4:11.8 2.45:11.8 2.45:11.85 2.5:11.85 2.5:11.9 2.55:11.9 2.55:11.95 2.6:11.95 2.6:12.05 2.7:12.05 2.7:12.1 2.75:12.1 2.75:12.15 2.8:12.15 2.8:12.2 2.85:12.2 2.85:12.25 2.95:12.25 2.95:12.3 3:12.3 3:12.35 3.1:12.35 3.1:12.4 3.2:12.4 3.2:12.45 3.3:12.45 3.3:12.5 3.45:12.5 3.45:12.55 3.55:12.55 3.55:12.6 3.75:12.6 3.75:12.65 4:12.65 4:12.7 4.9:12.7 4.9:12.65 5.2:12.65 5.2:12.6 5.4:12.6 5.4:12.55 5.55:12.55 5.55:12.5 5.65:12.5 5.65:12.45 5.8:12.45 5.8:12.4 5.9:12.4 5.9:12.35 6:12.35 6:12.3 6.05:12.3 6.05:12.25 6.15:12.25 6.15:12.2 6.2:12.2 6.2:12.15 6.25:12.15 6.25:12.1 6.3:12.1 6.3:12.05 6.4:12.05 6.4:12 6.45:12 6.45:11.95 6.5:11.95 6.5:11.9 6.55:11.9 6.55:11.8 6.6:11.8 6.6:11.75 6.65:11.75 6.65:11.7 6.7:11.7 6.7:11.65 6.75:11.65 6.75:11.55 6.8:11.55 6.8:11.45 6.85:11.45 6.85:11.4 6.9:11.4 6.9:11.3 6.95:11.3 6.95:11.15 7:11.15 7:11.05 7.05:11.05 7.05:10.9 7.1:10.9 7.1:10.75 7.15:10.75 7.15:10.5 7.2:10.5 7.2:10.15 7.25:10.15 7.25:13.45 7.2:13.45 7.2:13.5 7.15:13.5 7.15:13.55 7.1:13.55 7.1:13.6 7:13.6 7:13.65 6.9:13.65 6.9:13.7 6.85:13.7 6.85:13.75 6.75:13.75 6.75:13.8 6.65:13.8 6.65:13.85 6.55:13.85 6.55:13.9 6.4:13.9 6.4:13.95 6.3:13.95 6.3:14 6.15:14 6.15:14.05 6:14.05 6:14.1 5.8:14.1 5.8:14.15 5.6:14.15 5.6:14.2 5.3:14.2 5.3:14.25 3.55:14.25 3.55:14.2 3.3:14.2 3.3:14.15 3.1:14.15 3.1:14.1 2.9:14.1 2.9:14.05 2.75:14.05 2.75:14 2.65:14 2.65:13.95 2.5:13.95 2.5:13.9 2.4:13.9 2.4:13.85 2.3:13.85 2.3:13.8 2.2:13.8 2.2:13.75 2.1:13.75 2.1:13.7 2:13.7 2:13.65 1.95:13.65 1.95:13.6 1.85:13.6 1.85:13.55 1.8:13.55 1.8:13.5 1.7:13.5 1.7:13.45 1.65:13.45 1.65:13.4 1.6:13.4 1.6:13.35 1.55:13.35 1.55:13.3 1.5:13.3 1.5:13.25 1.4:13.25 1.4:13.2 1.35:13.2 1.35:13.15 1.3:13.15 1.3:13.1 1.25:13.1 1.25:13.05 1.2:13.05 1.2:13 1.15:13 1.15:12.95 1.1:12.95 1.1:12.9 1.05:12.9 1.05:12.8 1:12.8 1:12.75 0.95:12.75 0.95:12.7 0.9:12.7 0.9:12.65 0.85:12.65 0.85:12.55 0.8:12.55 0.8:12.5 0.75:12.5 0.75:12.4 0.7:12.4 0.7:12.35 0.65:12.35 0.65:12.25 0.6:12.25 0.6:12.2 0.55:12.2 0.55:12.1 0.5:12.1 0.5:12 0.45:12 0.45:11.9 0.4:11.9 0.4:11.8 0.35:11.8 0.35:11.65 0.3:11.65 0.3:11.55 0.25:11.55 0.25:11.4 0.2:11.4 0.2:11.25 0.15:11.25 0.15:11.1 0.1:11.1 0.1:10.9 0.05:10.9 0.05:10.7 0:10.7 0:8.3 0.05:8.3 0.05:8.05 0.1:8.05 0.1:7.9 0.15:7.9 0.15:7.75 0.2:7.75 0.2:7.6 0.25:7.6 0.25:7.5 0.3:7.5 0.3:7.35 0.35:7.35 0.35:7.25 0.4:7.25 0.4:7.15 0.45:7.15 0.45:7.05 0.5:7.05 0.5:6.95 0.55:6.95 0.55:6.9 0.6:6.9 0.6:6.8 0.65:6.8 0.65:6.75 0.7:6.75 0.7:6.65 0.75:6.65 0.75:6.6 0.8:6.6 0.8:6.5 0.85:6.5 0.85:6.45 0.9:6.45 0.9:6.4 0.95:6.4 0.95:6.35 1:6.35 1:6.3 1.05:6.3 1.05:6.25 1.1:6.25 1.1:6.2 1.15:6.2 1.15:6.15 1.2:6.15 1.2:6.1 1.25:6.1 1.25:6.05 1.3:6.05 1.3:6 1.35:6 1.35:5.95 1.4:5.95 1.4:5.9 1.45:5.9 1.45:5.85 1.55:5.85 1.55:5.8 1.6:5.8 1.6:5.75 1.65:5.75 1.65:5.7 1.75:5.7 1.75:5.65 1.8:5.65 1.8:5.6 1.9:5.6 1.9:5.55 2:5.55 2:5.5 2.05:5.5 2.05:5.45 2.15:5.45 2.15:5.4 2.3:5.4 2.3:5.35 2.4:5.35 2.4:5.3 2.5:5.3 2.5:5.25 2.65:5.25 2.65:5.2 2.8:5.2 2.8:5.15 2.95:5.15 2.95:5.1 3.2:5.1 3.2:5.05 3.45:5.05 3.45:5 5.05:5 5.05:5.05 5.3:5.05 5.3:5.1 5.5:5.1 5.5:5.15 5.65:5.15 5.65:5.2 5.8:5.2 5.8:5.25 5.9:5.25 5.9:5.3 6.05:5.3 6.05:5.35 6.15:5.35 6.15:5.4 6.25:5.4 6.25:5.45 7.2:5.45 7.2:4.5 7.15:4.5 7.15:4.3 7.1:4.3 7.1:4.15 7.05:4.15 7.05:4 7:4 7:3.85 6.95:3.85 6.95:3.7 6.9:3.7 6.9:3.55 6.85:3.55 6.85:3.4 6.8:3.4 6.8:3.3 6.75:3.3 6.75:3.2 6.7:3.2 6.7:3.1 6.65:3.1 6.65:3 6.6:3 6.6:2.9 6.55:2.9 6.55:2.8 6.5:2.8 6.5:2.7 6.45:2.7 6.45:2.65 6.4:2.65 6.4:2.55 6.35:2.55 6.35:2.5 6.3:2.5 6.3:2.4 6.25:2.4 6.25:2.35 6.2:2.35 6.2:2.3 6.15:2.3 6.15:2.25 6.1:2.25 6.1:2.15 6.05:2.15 6.05:2.1 6:2.1 6:2.05 5.95:2.05 5.95:2 5.9:2 5.9:1.95 5.8:1.95 5.8:1.9 5.75:1.9 5.75:1.85 5.7:1.85 5.7:1.8 5.65:1.8 5.65:1.75 5.55:1.75 5.55:1.7 5.45:1.7 5.45:1.65 5.4:1.65 5.4:1.6 5.25:1.6 5.25:1.55 5.15:1.55 5.15:1.5 5:1.5 5:1.45 4.85:1.45 4.85:1.4 3.5:1.4 3.5:1.45 3.3:1.45 3.3:1.5 3.15:1.5 3.15:1.55 3.05:1.55 3.05:1.6 2.95:1.6 2.95:1.65 2.85:1.65 2.85:1.7 2.8:1.7 2.8:1.75 2.7:1.75 2.7:1.8 2.65:1.8 2.65:1.85 2.6:1.85 2.6:1.9 2.55:1.9 2.55:1.95 2.5:1.95 2.5:2 2.45:2 2.45:2.05 2.4:2.05 2.4:2.1 2.35:2.1 2.35:2.15 2.3:2.15 2.3:2.2 2.25:2.2 2.25:2.3 2.2:2.3 2.2:2.35 2.15:2.35 2.15:2.45 2.1:2.45 2.1:2.55 2.05:2.55 2.05:2.65 2:2.65 2:2.8 1.95:2.8 1.95:2.95 1.9:2.95 1.9:3.1 1.85:3.1 1.85:3.4 1.8:3.4 1.8:3.65 0.25:3.65 0.25:2.4 0.3:2.4 0.3:2.25 0.35:2.25 0.35:2.15 0.4:2.15 0.4:2 0.45:2 0.45:1.9 0.5:1.9 0.5:1.8 0.55:1.8 0.55:1.75 0.6:1.75 0.6:1.65 0.65:1.65 0.65:1.55 0.7:1.55 0.7:1.5 0.75:1.5 0.75:1.45 0.8:1.45 0.8:1.35 0.85:1.35 0.85:1.3 0.9:1.3 0.9:1.25 0.95:1.25 0.95:1.2 1:1.2 1:1.1 1.05:1.1 1.05:1.05 1.1:1.05 1.1:1 1.15:1 1.15:0.95 1.2:0.95 1.2:0.9 1.3:0.9 1.3:0.85 1.35:0.85 1.35:0.8 1.4:0.8 1.4:0.75 1.45:0.75 1.45:0.7 1.55:0.7 1.55:0.65 1.6:0.65 1.6:0.6 1.65:0.6 1.65:0.55 1.75:0.55 1.75:0.5 1.85:0.5 1.85:0.45 1.9:0.45 1.9:0.4 2:0.4 2:0.35 2.1:0.35 2.1:0.3 2.25:0.3 2.25:0.25 2.35:0.25 2.35:0.2 2.5:0.2 2.5:0.15 2.6:0.15 2.6:0.1 2.8:0.1 2.8:0.05 3:0.05 3:0 5.3:0 5.3:0.05 5.5:0.05 5.5:0.1 5.65:0.1 5.65:0.15 5.8:0.15 5.8:0.2 5.95:0.2 5.95:0.25 6.05:0.25 6.05:0.3 6.15:0.3 6.15:0.35 6.25:0.35 6.25:0.4 6.35:0.4 6.35:0.45 6.45:0.45 6.45:0.5 6.5:0.5 6.5:0.55 6.6:0.55 6.6:0.6 6.65:0.6 6.65:0.65 6.75:0.65 6.75:0.7 6.8:0.7 6.8:0.75 6.85:0.75 6.85:0.8 6.9:0.8 6.9:0.85 7:0.85 7:0.9 7.05:0.9 7.05:0.95 7.1:0.95 7.1:1 7.15:1 7.15:1.05 7.2:1.05 7.2:1.1 7.25:1.1 7.25:1.15 7.3:1.15 7.3:1.2 7.35:1.2 7.35:1.25 7.4:1.25 7.4:1.3 7.45:1.3 7.45:1.35 7.5:1.35 7.5:1.4 7.55:1.4 7.55:1.5 7.6:1.5 7.6:1.55 7.65:1.55 7.65:1.6 7.7:1.6 7.7:1.7 7.75:1.7 7.75:1.75 7.8:1.75 7.8:1.85 7.85:1.85 7.85:1.9 7.9:1.9 7.9:2 7.95:2 7.95:2.05 8:2.05 8:2.15 8.05:2.15 8.05:2.25 8.1:2.25 8.1:2.3 8.15:2.3 8.15:2.4 8.2:2.4 8.2:2.5 8.25:2.5 8.25:2.6 8.3:2.6 8.3:2.7 8.35:2.7 8.35:2.8 8.4:2.8 8.4:2.95 8.45:2.95 8.45:3.05 8.5:3.05 8.5:3.2 8.55:3.2 8.55:3.3 8.6:3.3 8.6:3.45 8.65:3.45 8.65:3.6 8.7:3.6 8.7:3.75 8.75:3.75 8.75:3.9 8.8:3.9 8.8:4.1 8.85:4.1 8.85:4.3 8.9:4.3 8.9:4.5 8.95:4.5 8.95:4.7 9:4.7 9:4.95 9.05:4.95 9.05:5.2 9.1:5.2 9.1:5.55 9.15:5.55 9.15:5.85 9.2:5.85 9.2:6.3 9.25:6.3 9.25:6.95 9.3:6.95)

(tcCreateDeviceClass
 "symbolic" "partNumCharClass"
 ;;; Class parameters
 (
  (shape       nil)
  )
 ;;; Formal parameters
 (
  (layers           (list (list "met1" "drawing")))
  ) 
  shape = (caaar shape)
  (foreach lpp layers
    polyID = (dbCreatePolygon tcCellView lpp shape)
    )
 )

;;; 
;;; $Id: partNumClass.il,v 1.2 2006/06/26 18:50:24 kuc Exp $
;;; 
;;; partNumClass.il
;;; 
;;; Copyright (c) 2006 by Cypress Semiconductor
;;; Cypress Kentucky CAD Center (KYCC)
;;; 
;;; Date  : Jun 23, 2006
;;; Author: Kungyen Chang (kuc) @ KYCC
;;; 
;;; Description:
;;;   This class is a pcell for letters and numbers
;;;   in layout using the points for the shapes for
;;;   characters in partNumClassData.il
;;;   
;;; 
;;; Revision History:
;;;   kuc 06/23/06  initial version
;;;   kuc 06/26/06  improved cell, now instantiates other single character cells
;;; 

(tcCreateDeviceClass
 "symbolic" "partNumClass"
 ;;; Class parameters
 (
  )
 ;;; Formal parameters
 (
  (text             "abc")
  (layers           (list (list "met1" "drawing")))
  (textSpacing      1.25)
  (textScale        1.00)
  )

   label = (upperCase text)

   (if textSpacing < 0
       (error "partNumClass: textSpacing must be >= 0")
       )
   (if (equal text "")
       (error "partNumClass: text parameter must exist")
     )

   ;;; Draw letters
   coord = 0
   (for c 1 (strlen label)
	(setq currentLetterName (strcat "partnum" (substring label c 1)))
	(setq currentLetter (dbOpenCellView tcCellView~>lib  currentLetterName "symbolic" nil "r"))
	(unless currentLetter
	  (error "partNumClass:  Cannot find/open letter cell %s\n" currentLetterName)
	  )
	(unless currentLetter~>isParamCell
	  (error "partNumClass:  Letter cell %s is not a pcell\n" currentLetterName)
	  )

	polyID = (dbCreateParamInst tcCellView currentLetter (strcat "letter" (sprintf nil "%d" c)) 0:0 "R0" 1 (list (list "layers" "list" layers)))
	magnification = 1 + (textScale - 1) * 0.5
	
	(dbMoveFig polyID nil (list coord:0 "R0" magnification))
	coord = coord + ((caadr polyID->bBox) - (caar polyID->bBox))
	
	coord = coord + textSpacing
	)
   )



(setq charSet "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
(for c 1 (strlen charSet)
  (setq currentChar (substring charSet c 1))
  (setq charCell (strcat "partnum" currentChar))
  (setq currentShape letterShapes[currentChar])

  (tcDeclareDevice
   "symbolic" "partNumCharClass" charCell
   ;;; Class parameters
   (
    (shape         `((list '(,currentShape))))
    )
   ;;; Formal parameters
   (
    )
   )
  )

(tcDeclareDevice
 "symbolic" "partNumClass" "partnum"
 ;;; Class parameters
 (
  )
 ;;; Formal parameters
 (
  )
 )

)
;;; 
;;; $Id: rawTech.tf,v 1.7 2009/09/11 16:10:51 vun Exp $
;;; 
;;; rawTech.tf
;;; 
;;; Copyright (c) 2007 by Cypress Semiconductor
;;; Cypress Kentucky CAD Center (KYCC)
;;; 
;;; Date  : Jun 11, 2007
;;; Author: Chris Van Meter (cva) @ KYCC
;;; 
;;; Description:
;;; 
;;; Revision History:
;;;   vun 03/11/08  copied from s8q
;;;   vun 03/21/08  updated contacts and seal
;;;   osd 08/27/08  SPR 49212 updates
;;;   cva 02/04/09  TDR rev BB
;;;   lpj 06/02/09  added laserTargets to dieSealRingClassAdv devices
;;;   vun 09/11/09  TDR rev BJ, updated nikon
;;; 


;;; 
;;; $Id: rawTech.tf,v 1.45 2009/07/31 18:14:17 kuc Exp $
;;; 
;;; rawTech.tf
;;; 
;;; Copyright (c) 2005 by Cypress Semiconductor
;;; Cypress Kentucky CAD Center (KYCC)
;;; 
;;; Date  : Jul 24, 2005
;;; Author: Bassem El-Azzami (bae) @ KYCC
;;; 
;;; Description:
;;;   This file contains partial technology information for s8
;;; written in Cadence technology file format.  This file defines
;;; the technology file devices and all of the rules for running
;;; the Cadence layout automation tools.
;;; 
;;; Revision History:
;;;   bae 07/24/05  initial release (copied from c8x and modified)
;;;   bub 08/08/05  modified TPM1 and DFM1
;;;   rnh 09/29/05  Added rcInterConEnhClass3 for Contacts.
;;;   rnh 09/29/05  DFL1 Enhancement for SPR 27346.
;;;   rnh 10/19/05  DFL1sd2 and DFL1sd Enhancement for SPR 27748.
;;;   rnh 11/02/05  Reversed the X and Y enclosure values for DFL1sd and DFL1sd2.
;;;   rnh 11/03/05  Initialise devices option added.
;;;   bae 11/11/05  Added n/pDrainOnly fets
;;;   kuc 11/16/05  Added varactor pcell and special contacts
;;;   rnh 11/25/05  Added guardRingEnh rod Pcell SPR-27737.
;;;   rnh 11/25/05  Added rodTripleGuardRing.il after mNormTranImpClass.il.
;;;   bae 12/01/05  Added some contacts and discrete *tran pcells
;;;   kuc 12/16/05  Moved short pcells to common file
;;;   kuc 12/21/05  Modified varactor pcell
;;;   osd 01/26/06  TDR *M updates
;;;   bae 02/06/06  Changed nsdm/psdm enclosure of Trans and their contacts by 
;;;                 an extra snap grid from all sides (SPR28655 requested by designers)
;;;                 Added hvDFM1sd (SPR28092)
;;;   vun 03/06/06  Added MPP
;;;   bae 03/13/06  changed npcon_6 to licon_15
;;;   bae 04/19/06  Reduced nsdm/psdm enclosure of Trans and their contacts by 
;;;                 a snap grid from all sides back to original (SPR 30563)
;;;   vun 05/09/06  Added extended drain devices to common flow.
;;;   bae 06/20/06  added nfet/pfet pcells
;;;   vun 07/21/06  Updated MPP to be choppable SPR 31945.
;;;   kuc 07/27/06  Added varactor updates
;;;   kuc 07/31/06  removed poly-to-li strapping for gate contacts in varactor
;;;   ipr 08/09/06  fixed diffLEncVia diffREncVia numbers for hvDFTPM1s (SPR 32226)
;;;   kuc 08/25/06  added antenna_diode pcell
;;;   ipr 08/28/06  added gatetogateSpacing to nfet/pfet (SPR 32184)
;;;   vun 10/17/06  added esd pcell
;;;   bae 11/03/06  added butting PYM* varactor contacts
;;;   kuc 11/15/06  updated esd pfet
;;;   kuc 12/12/06  updated esd cascode pfet
;;;   kuc 01/19/07  even MORE esd pfet updates
;;;   kuc 02/06/07  more esd pfet updates again
;;;   kuc 03/16/07  made HV default on pEsdFet pcells
;;;   cva 12/07/07  TDR rev AJ
;;;   kuc 03/06/08  added varactor2
;;;   vun 10/01/08  moved isopwellres to s8x
;;;   ipr 01/23/09  Enabled LOD on nfet and pfet and added contact Pcells for LOD
;;;   ipr 02/16/09  LOD updates (SPR 54432, 53933, 53771)
;;;   kuc 06/23/09  added xframe
;;;   kuc 07/31/09  removing xframe for now
;;;

;;; **********************************************************************
;;;                             devices
;;; **********************************************************************

(devices

 (tcCreateCDSDeviceClass)
 
;;; 
;;; $Id: anchorClass.il,v 1.15 2007/05/30 20:17:48 kuc Exp $
;;;
;;; anchorClass.il
;;; 
;;; Copyright (c) 2000 by Cypress Semiconductor
;;; Cypress India Design Center (INDC)
;;; 
;;; Date  : Nov 6, 2000
;;; Author: David John/CAD @ INDC
;;; 
;;; Description:
;;;   This class has been developed to declare anchors
;;;   used in spaces on a chip. This class creates
;;;   the full anchor structure.
;;;
;;;   The design document can be viewed online from
;;;   CAD Projects Documentation->
;;;           Device Library Pcells->
;;;                 Phase II Design Document
;;;   or from the UNIX path
;;;   release-v-tree/4.4/doc/projects/devLib/design2.pdf
;;;
;;;   Spec. 01-70001 (8.14) contains the details of Metal Stress Relief 
;;;   Rules and the rivet structure.
;;;
;;; Revision History:
;;;  
;;; dxj 01/24/01 Checking in file for the first time.
;;; cry 09/04/01 Adding capability to specify implant for contacts
;;; kgr 01/30/02 Correcting snap to grid function
;;; dxj 03/08/02 Fix for SPR 8541, 10641
;;;              Support implant on poly for T013
;;; kmi 09/15/03 Fixing implantnclosure on bent part
;;; jtv 02/13/04 Fixing error observed in TCS 677 of rule stress_8_14_3_6
;;; jtv 02/25/04 Correction to above to remove notches
;;; agktmp12 08/10/04
;;;              Fixed the max width violation errors. 
;;;               Now some layers are special layers, where we can limit 
;;;               the max width of such layers. (Eg; ddli max width in c9)
;;;             Modified input properties for USER(in CDF form),
;;;              according to BROS.
;;; kmi 12/17/04 making splLayer a list, expanding anchorContact to support X-Y enclosures
;;; vun 04/22/05 update splLayer to be centered on the 45.
;;; rnh 06/30/05 Provided more offset on the vertical metal strip for placing the last cotact.
;;; kuc 11/10/05 added bigVias parameter, when this is t the 45 degree number of contacts will be decreased
;;; kuc 12/07/05 removed bigVias, replaced with anchorZShrink, this gives much more control over how much to scale the corners
;;; kuc 05/30/07 updated to add even ends to multiple anchors
;;;

(tcCreateDeviceClass
 "symbolic" "anchorClass"
 ;; class parameters
 ;; all parameters default to ram6x technology
 (
  (anchorLayers        '("poly" "met1"))
  (anchorImpLayers     '( ))
  (anchorContacts      '( '("mcon"  0.500) '("via"   0.700))) ;; '( (list contactLayer (list encX encY) || encXY)....
  (anchorWidth         7.500)
  (anchorSpace        12.500)
  (viaPitch            7.750)
  (contactPitch        7.750)
  (grid                0.025)
  (splLayer            nil)
  (splLayerMaxWidth        7.500) 
  (anchorZShrink       0.0)  ;; sizes down the corner length usable for placing contacts, used when contacts are really big
 )

 ;; formal parameters
 (
  (ancType         "")
  (endStyle        "")
  (fullAnchor      "FALSE")
  (horizOr45       "FALSE")   
  (anchorLengthX   20.0)
  (anchorLengthY   20.0)
  (anchorLengthZ   0.0)
  (numAnchors      1)
  (chamfer         "FALSE")
  (evenEnds        "FALSE")
 )

 (foreach xList anchorLayers
  (when (and splLayer (listp xList))
   (error (sprintf nil "anchorClass: anchorLayers (list (list * *)) can not be used in parallel with splLayer\n"))
  )
 )

 ;; Parse arguments
 (if (or (equal chamfer t) (equal chamfer "TRUE") (equal endStyle "STAGGER")) 
  then
  (setq chamfer t)
  else
  (setq chamfer nil)
 )
 
 (if (or (equal evenEnds t) (equal evenEnds "TRUE"))
   then
   (setq evenEnds t)
   else
   (setq evenEnds nil)
   )

 (if (or (equal fullAnchor t) (equal fullAnchor "TRUE"))
  then
  (setq fullAnchor t)
  else
  (setq fullAnchor nil)
 )
 (if (or (equal horizOr45 t) (equal horizOr45 "TRUE"))
  then
  (setq horizOr45 t)
  else
  (setq horizOr45 nil)
 )
 ;; Reassigning "fullAnchor" & "horizOr45" according to SHAPE specified by user
 (if (equal ancType "full")
  then
  fullAnchor = t 
 ) 
 (if (equal ancType "slant")
  then
  fullAnchor = nil 
  horizOr45 =  nil
 )

 (if (equal ancType "horizontal")
  then
  fullAnchor = nil
  horizOr45 = t
 )

 /* geometry */

 ;;
 ;;           anchorLengthX
 ;;         ______________________
 ;;     B  |                        ;;        |____________________     ;;                             \     ;;  anchorSpace                 \    \ anchorLengthZ
 ;;                               \     ;;        8_______________7       \     ;;     A  |                \       \     ;;        |_____________    \       \     ;;        1            2\    \       \    |
 ;;                       \    \6      |   | 
 ;;                       3\    |      |   |
 ;;                         |   |      |   |
 ;;                         |   |      |   | anchorLengthY
 ;;      FIGURE 1           |   |      |   |
 ;;                        4|___|5     |___|
 ;;
 ;;
root2 = sqrt(2)
gridMult = round(1.0/grid)

;; Number of anchors can be integer only
numAnchors = floor(numAnchors)

;; snap all to grid
anchorWidth  = (times (ceiling (plus (quotient anchorWidth grid) -1e-6)) grid)
 anchorCenter = anchorWidth/2

anchorSpace   = grid*ceiling(anchorSpace*gridMult)

anchorLengthX = grid*ceiling(anchorLengthX*gridMult)
anchorLengthY = grid*ceiling(anchorLengthY*gridMult)
anchorLengthZ = grid*ceiling(anchorLengthZ/root2*gridMult)
anchorCenterZ = grid*ceiling((anchorCenter/root2)*gridMult)
anchorWidthZ  = grid*floor((anchorWidth/root2)*gridMult)
 ;; modified to fix max dli width in z direction
;anchorWidthZ  = grid*ceiling((anchorWidth/root2)*gridMult)
anchorSpaceZ  = grid*ceiling((anchorSpace/root2)*gridMult)

 /* tan(22.5)  = 0.414213562 */
tanCal        = 0.414213562
dAnchorLength = grid*ceiling(tanCal*(anchorWidth+anchorSpace)*gridMult)
 ;; To satisfy anchorWidth, the width for 45 degree anchor is rounded to
 ;; the next higher grid. To get around problems with spacing
 ;; between 45 degree grids, the spacing is also rounded to
 ;; the next higher grid
 dAnchorLength = dAnchorLength+grid

;; 45 degree bend length should be atleast anchorWidth*root2
anchorLengthZ = (max anchorLengthZ anchorWidth)

 ;; initialize variables
 chamferL = 0.0

 ;; Chamfer the anchor edge on user request
 (when chamfer
  chamferL = anchorWidth + anchorSpace
 )

 /* Start device definition */

;; The number of contact types for this technology
numContacts = length(anchorContacts)
 minSpace = 0

 ;; The minimum amount of space required for accomodating
 ;; a row of contacts and vias
(foreach contact anchorContacts
 minSpace = minSpace+cadr(contact)
)
minSpace45 = minSpace*root2

;; The greater of the pitch values is used so that
;; it's sure to meet the minimum requirement for both
;; the contact and via
(if viaPitch >= contactPitch then
 usePitch = viaPitch
 else
 usePitch = contactPitch
)

;; Assumes that the last contact is of bigger dimension than mcon
;; Draw based on last contact width
usePitch45 = usePitch + (minSpace45-minSpace)
 usePitch   = grid*ceiling(usePitch*gridMult) + grid
 usePitch45 = grid*ceiling(usePitch45*gridMult) + grid
 ;; The pitch used must be big enough to accomodate
 ;; all contacts and vias. If not,set the pitch to
 ;; the minSpace
 (unless usePitch >= minSpace
  usePitch = minSpace
 )
 (unless usePitch45 >= minSpace45
  usePitch45 = minSpace45
 )

contactSpace = grid*floor((usePitch - minSpace)/numContacts*gridMult)
contactSpace45 = grid*floor((usePitch45 - minSpace45)/numContacts*gridMult)

 ;; Set the minimum length of anchor for horizontal and vertical
 ;; anchors
minLength =  usePitch+contactSpace
(when (anchorLengthX < minLength)
 anchorLengthX = minLength
)

(when (anchorLengthY < minLength)
 anchorLengthY = minLength
)  

;; Draw the anchor
;;
;;       11_______________10
;;        |               |      7
;;        |_______________|9    /  ;;        12                  8/    ;;                             \     ;;         _______________      \     ;;        |                \     \     ;;        |_____________    \     \  /6
 ;;                      \    \    5\/
 ;;                       \    \      ___
 ;;                        \    |   4|   |3
 ;;                         |   |    |   |
 ;;                         |   |    |   |
 ;;      FIGURE 2           |   |    |   |
 ;;                         |___|    |___|
 ;;                                  1   2
 ;;
 ;; The strategy for drawing anchors is shown above. For better reusability of
 ;; code, the code is divided into 3 sections. Each section draws one of the 
 ;; parts of the anchor as shown above. If the full anchor is required, it is
 ;; split into 3 parts. These 3 parts are drawn in such a way that they are
 ;; integrated to form a full anchor. The code is also used for drawing only
 ;; straight anchor or 45 degree anchor pieces.
 ;;
 ;;
 (when fullAnchor
  ;; For vertical anchor
  ;;
  ;; Draws the polygon (1,2,3,4)
  ;; point 1 = (x0,y0)
  ;; point 3 = (x0+dx,y0+dy)
  ;; 
  ;; The parameters ddx and ddy take care of the fact that successive anchors
  ;; are bigger than the innermost one by dAnchorLength.
  ;;
  ;; xOffset is used to draw the anchor contacts in the middle of the anchor.
  ;;
  x0   = 0
  y0   = -anchorLengthY	
  (when evenEnds
    dx0  = anchorWidth+anchorSpace
    dy0  = -chamferL
    )
  (unless evenEnds
    dx0  = anchorWidth+anchorSpace+grid
    dy0  = -chamferL+grid
    )
  dx   = anchorWidth
  dy   = anchorLengthY
  ddx  = 0
  ddy  = dAnchorLength + chamferL

  ;;;;;SoftJin
  ;;; for full anchor, this will extend to 
  for(i 1 numAnchors     
      ;; Draw the multiple layer stack
      (foreach thisLayer anchorLayers
       (if (or (equal thisLayer splLayer) (listp thisLayer)) then
        (when (listp thisLayer) 
           (setq splLayerMaxWidth (cadr thisLayer))
           (setq thisLayer (car thisLayer))
        )
        (dbCreateRect tcCellView (list thisLayer "drawing")
         (list (x0+(anchorWidth-splLayerMaxWidth)/2):y0 
          ;;(x0+dx-((anchorWidth-splLayerMaxWidth)/2)):(y0+dy))
          (x0+dx-((anchorWidth-splLayerMaxWidth)/2)):(y0+(dy - splLayerMaxWidth/2)))
        )
        else
        (dbCreateRect tcCellView (list thisLayer "drawing")
         (list x0:y0 (x0+dx):(y0+dy))
        )
       )
      ) ; multiple layer stack
      (when i==numAnchors (setq pVert (list x0+dx:y0)))

      numArrays = ceiling(dy/usePitch-0.5)
      xOffset = x0 + anchorCenter
      ;; verOffSet = y0+dy-(anchorWidth/2.0)
      verOffSet = y0+dy-anchorWidth
      ;; "verOffSet" will be the maximum limit upto which we can place the contacts

  ;; Draw interconnecting non stacked contacts
  (for j 1 numArrays
   k = 1
   occupiedSpace = 0
   (foreach contact anchorContacts
    contactWidth = cadr(contact)
    xl = grid*ceiling((xOffset-contactWidth/2)*gridMult)
    yl = grid*ceiling((y0 + (j-1)*usePitch + k*contactSpace + occupiedSpace)*gridMult)
    xu = xl+contactWidth
    yu = yl+contactWidth
    ;; go into next IF loop only if next contact can be placed
    (if (leqp yu verOffSet)
     then
     dbCreateRect(tcCellView list(car(contact) "drawing")
                  list(xl:yl xu:yu))
     k = k+1
     occupiedSpace = occupiedSpace + contactWidth
     (when (caddr contact)
      (setq contactImplant (member (caddr contact) contact))
      ;; an implant is specified for this contact
      (if (nth 2 contactImplant) then
       (setq contactImpEncX (nth 1 contactImplant))
       (setq contactImpEncY (nth 2 contactImplant))
       else
       (setq contactImpEncX (nth 1 contactImplant))
       (setq contactImpEncY (nth 1 contactImplant))
      )
      (dbCreateRect tcCellView (car contactImplant)
       (list (list (plus xl -contactImpEncX) (plus yl -contactImpEncY))
        (list (plus xu contactImpEncX)  (plus yu contactImpEncY))
       )
      )
     );;end of when
    );;end of if
    );;end of foreach
    ) ; draw nonstacked contacts

    x0=x0+dx0
    y0=y0+dy0
    dx=dx+ddx
    dy=dy+ddy
    ) ; Vertical anchor
    )

(when (or fullAnchor (not horizOr45))
 ;; For 45 degree anchor
 ;;
 ;; Draws the polygon (5,6,7,8)
 ;; point 5 = (x3,y3)
 ;; point 6 = (x0,y0)
 ;; point 7 = (x1,y1)
 ;; point 8 = (x2,y2)
 ;; 
 (if fullAnchor then
  ;anchorLengthZ = anchorWidth
  x0   = anchorWidth
  y0   = 0.0
  dx   = anchorLengthZ
  dy   = anchorLengthZ
  ddx  = anchorWidth+anchorSpace-dAnchorLength
  ddy  = anchorWidth+anchorSpace-dAnchorLength
  else
  x0   = 0.0
  y0   = 0.0
  dx   = anchorLengthZ
  dy   = anchorLengthZ
  ddx  = anchorWidth+anchorSpace-dAnchorLength
  ddy  = anchorWidth+anchorSpace-dAnchorLength
 )
 (when evenEnds
  dx0  = anchorWidth+anchorSpace
  dy0  = dAnchorLength
  )
 (unless evenEnds
  dx0  = anchorWidth+anchorSpace+grid
  dy0  = dAnchorLength+grid
  )

 (for i 1 numAnchors
  ;; Draw the multiple layer stack
  (foreach thisLayer anchorLayers
   x1 = x0-dx
   y1 = y0+dy
   x2 = x1-anchorWidthZ
   y2 = y1-anchorWidthZ
   x3 = x0-anchorWidthZ
   y3 = y0-anchorWidthZ
   (if (or (equal thisLayer splLayer) (listp thisLayer)) then
    (when (listp thisLayer)
      (setq splLayerMaxWidth (cadr thisLayer))
      (setq thisLayer (car thisLayer))
    )
    (if fullAnchor
     then
     sjn_X6 = x0 - ((anchorWidth-splLayerMaxWidth)/2)
     sjn_Y6 = y0 - (splLayerMaxWidth/2)
     sjn_X7 = x1 - (splLayerMaxWidth/2)
     sjn_Y7 = y1 - ((anchorWidth-splLayerMaxWidth)/2)

     sjn_X8 = grid*ceiling((sjn_X7-(splLayerMaxWidth/root2))*gridMult)
     sjn_Y8 = grid*ceiling((sjn_Y7-(splLayerMaxWidth/root2))*gridMult)
     sjn_X5 = grid*ceiling((sjn_X6-(splLayerMaxWidth/root2))*gridMult)
     sjn_Y5 = grid*ceiling((sjn_Y6-(splLayerMaxWidth/root2))*gridMult)
     else
     temp_Offset = (((anchorWidth-splLayerMaxWidth)*root2)/4)
     sjn_X6 = x0 - temp_Offset 
     sjn_Y6 = y0 - temp_Offset
     sjn_X7 = x1 - temp_Offset
     sjn_Y7 = y1 - temp_Offset

     sjn_X8 = x2 + temp_Offset
     sjn_Y8 = y2 + temp_Offset
     sjn_X5 = x3 + temp_Offset 
     sjn_Y5 = y3 + temp_Offset
    )

    (dbCreatePolygon tcCellView (list thisLayer "drawing")
     (list sjn_X6:sjn_Y6 sjn_X7:sjn_Y7 sjn_X8:sjn_Y8
      sjn_X5:sjn_Y5 sjn_X6:sjn_Y6)) 
    else
(dbCreatePolygon tcCellView (list thisLayer "drawing")
 (list x0:y0 x1:y1 x2:y2 x3:y3 x0:y0)
)
)
) ; multiple layer stack		
(when i==numAnchors (setq p45 (list x0:y0 x1:y1)))

;; Draw the non stacked interconnecting contacts
numArrays = ceiling(dx/usePitch45*root2)
 ;	  numArrays = ceiling(dx/usePitch45*root2-0.5)

 offset = anchorCenterZ

 (if fullAnchor
  then
  sltOffset = (plus (grid*ceiling((x0 - dx - (anchorWidthZ/2))*gridMult)) (quotient anchorZShrink 2))
  else
  sltOffset = (plus (grid*ceiling((x0 - dx - (anchorWidthZ/2) + (contactSpace45/root2))*gridMult)) (quotient anchorZShrink 2))
 )
 ;; "sltOffset" will be the maximum limit upto which we can place the contacts

 ;; Skip a set of contacts if it is a full anchor.
;; Keeping them on full anchor causes spacing violations.
(if fullAnchor then start=1 else start=1)

 (for j start numArrays
  k = 1
  occupiedSpace = 0
  (foreach contact anchorContacts
   contactWidth = cadr(contact)
   xl = grid*ceiling((x0 - offset - ((j-1)*usePitch45 + k*contactSpace45 + occupiedSpace)/root2)*gridMult)
   yl = grid*ceiling((y0 - offset + ((j-1)*usePitch45 + k*contactSpace45 + occupiedSpace)/root2)*gridMult)
   xu = xl-contactWidth
   yu = yl+contactWidth
   ;; go into next IF loop only if next contact can be placed
   (if (geqp xl-contactSpace sltOffset)
    then
    dbCreateRect(tcCellView list(car(contact) "drawing")
                 list(xl:yl xu:yu))
    k = k+1
    occupiedSpace = occupiedSpace + contactWidth*root2
    (when (caddr contact)
      (setq contactImplant (member (caddr contact) contact))
      ;; an implant is specified for this contact
      (if (nth 2 contactImplant) then
       (setq contactImpEncX (nth 1 contactImplant))
       (setq contactImpEncY (nth 2 contactImplant))
       else
       (setq contactImpEncX (nth 1 contactImplant))
       (setq contactImpEncY (nth 1 contactImplant))
      )
     (dbCreateRect tcCellView (car contactImplant)
      (list (list (plus xl contactImpEncX)
             (difference yl contactImpEncY)
            )
       (list (difference xu contactImpEncX)
        (plus yu contactImpEncY)
       )))
    )
   )
   )
   ) ; contacts

   x0=x0+dx0	
   y0=y0+dy0	
   dx=dx+ddx	
   dy=dy+ddy	
   ) ; 45 degree anchor
   )

   ;; For horizontal anchor
   ;; Draws the polygon (9,10,11,12)
   ;; point 9  = (x0,y0)
   ;; point 11 = (x0+dx,y0+dy)
   ;;
(when (or fullAnchor horizOr45)
 (if fullAnchor then
  x0   = -anchorLengthX - (anchorLengthZ-anchorWidth)
  y0   = anchorLengthZ - anchorWidth
  (when evenEnds
    dx0  = -chamferL
    dy0  = anchorWidth+anchorSpace
    )
  (unless evenEnds
    dx0  = -chamferL+grid
    dy0  = anchorWidth+anchorSpace+grid
    )
  dx   = anchorLengthX
  dy   = anchorWidth
  ddx  = dAnchorLength + chamferL
  ddy  = 0
  ;;; SoftJin
  ;;; this is a full anchor.
  ;;horizOffSet = grid*ceiling((x0 + anchorLengthX-anchorWidth/root2/2.0)*gridMult)
  else
  x0   = 0
  y0   = 0
  dx0  = 0 
 dy0  = anchorWidth+anchorSpace 
 dx   = anchorLengthX
 dy   = anchorWidth
 ddx  = 0
 ddy  = 0
 ;;; SoftJin
 ;;; this is a horizontal  anchor only.
 )
 horizOffSet = anchorLengthX 
 ;; "horizOffSet" will be the maximum limit upto which we can place the contacts

 for(i 1 numAnchors       
     ;; Draw the multiple layer stack
     (foreach thisLayer anchorLayers
      (if (or (equal thisLayer splLayer) (listp thisLayer)) then
       (when (listp thisLayer)
        (setq splLayerMaxWidth (cadr thisLayer))
        (setq thisLayer (car thisLayer))
       )
       (dbCreateRect tcCellView (list thisLayer "drawing")
		     (cond
		      (fullAnchor
		       (list x0:(y0+((anchorWidth-splLayerMaxWidth)/2))
			     x0+(dx - splLayerMaxWidth/2):(y0+dy-(anchorWidth-splLayerMaxWidth)/2))
		       )
		      (t
		       (list x0:(y0+((anchorWidth-splLayerMaxWidth)/2))
			     x0+dx:(y0+dy-(anchorWidth-splLayerMaxWidth)/2))
		       )
		      ))
       else
       (dbCreateRect tcCellView (list thisLayer "drawing")
        (list x0:y0 (x0+dx):(y0+dy))
       )
      )
     ) ; multiple layer stack		
     (when i==numAnchors (setq pHor (list x0:y0+dy)))

     numArrays = ceiling(dx/usePitch)
     yOffset = y0 + anchorCenter

     (if fullAnchor
      horizOffSet = grid*ceiling((x0 + dx - (anchorWidth/2.0))*gridMult)
     )

     ;; Draw interconnecting non stacked contacts
     (for j 1 numArrays
      k = 1
      occupiedSpace = 0
      (foreach contact anchorContacts
       contactWidth = cadr(contact)
       xl = grid*ceiling((x0 + (j-1)*usePitch + k*contactSpace + occupiedSpace)*gridMult)
       yl = grid*ceiling((yOffset-contactWidth/2)*gridMult)
       xu = xl+contactWidth
       yu = yl+contactWidth
       ;;; SoftJin
       ;; go into next IF loop only if next contact can be placed
       (if (leqp xu horizOffSet)
        then
        dbCreateRect(tcCellView list(car(contact) "drawing")
                     list(xl:yl xu:yu))
        k = k+1
        occupiedSpace = occupiedSpace + contactWidth
        (when (caddr contact)
         (setq contactImplant (member (caddr contact) contact))
         ;; an implant is specified for this contact
         (if (nth 2 contactImplant) then
          (setq contactImpEncX (nth 1 contactImplant))
          (setq contactImpEncY (nth 2 contactImplant))
          else
          (setq contactImpEncX (nth 1 contactImplant))
          (setq contactImpEncY (nth 1 contactImplant))
         )
         (dbCreateRect tcCellView (car contactImplant)
          (list (list (plus xl -contactImpEncX)
                 (plus yl -contactImpEncY)
                )
           (list (plus xu contactImpEncX)
            (plus yu contactImpEncY)
           )))
        )
       )
       )
       ) ; draw non stacked contacts

       x0=x0+dx0	
       y0=y0+dy0	
       dx=dx+ddx	
       dy=dy+ddy	
       ) ; Horizontal anchor

       )

       (when anchorImpLayers
        (foreach impSet anchorImpLayers
         impLayer = car(impSet)
         impEnc   = cadr(impSet)

         ancW     = numAnchors*(anchorWidth+anchorSpace)-anchorSpace
         ancW45   = grid*ceiling(ancW/root2*gridMult) + impEnc

         impEnc45 = grid*ceiling(impEnc*root2*gridMult)
         impW     = ancW + 2*impEnc
         impW45   = grid*ceiling(impW*root2*gridMult)
         impL     = anchorLengthX + 2*impEnc

         (cond 
          (fullAnchor 
           x1anc = caar(pVert)     y1anc = cadar(pVert)
           x2anc = caar(p45)	     y2anc = cadar(p45)
           x3anc = caadr(p45)	     y3anc = cadadr(p45)
           x4anc = caar(pHor)	     y4anc = cadar(pHor)

           x5anc = x4anc              y5anc = y4anc-ancW
           x6anc = x3anc-ancW*tanCal  y6anc = y3anc-ancW
           x7anc = x2anc-ancW         y7anc = y2anc-ancW*tanCal
           x8anc = x1anc-ancW         y8anc = y1anc

           x6anc = grid*floor(x6anc*gridMult)
           y7anc = grid*floor(y7anc*gridMult)

           x1 = x1anc + impEnc45   y1 = y1anc - impEnc
           x2 = x2anc + impEnc45   y2 = y2anc
           x3 = x3anc              y3 = y3anc + impEnc45
           x4 = x4anc - impEnc     y4 = y4anc + impEnc45
           x5 = x5anc - impEnc     y5 = y5anc - impEnc45
           x6 = x6anc - impEnc     y6 = y6anc - impEnc45
           x7 = x7anc - impEnc45   y7 = y7anc - impEnc
           x8 = x8anc - impEnc45   y8 = y8anc - impEnc

pAll = (list x1:y1 x2:y2 x3:y3 x4:y4 x5:y5 x6:y6 x7:y7 x8:y8 x1:y1)

 (dbCreatePolygon tcCellView (list impLayer "drawing") pAll)
 )

(horizOr45  
 x1anc = caar(pHor)           y1anc = cadar(pHor)
 x2anc = x1anc+anchorLengthX  y2anc = y1anc-ancW

 x1 = x1anc-impEnc            y1 = y1anc+impEnc
 x2 = x2anc+impEnc            y2 = y2anc-impEnc

 pAll = (list x1:y1 x2:y2)
 (dbCreateRect tcCellView (list impLayer "drawing") pAll)
)

(t
 x1anc = caar(p45)       y1anc = cadar(p45)
 x2anc = caadr(p45)      y2anc = cadadr(p45)
 x3anc = x2anc-ancW45    y3anc = y2anc-ancW45
 x4anc = x1anc-ancW45    y4anc = y1anc-ancW45

 x1 = x1anc+impEnc45     y1 = y1anc
 x2 = x2anc              y2 = y2anc+impEnc45
 x3 = x3anc-impEnc45     y3 = y3anc
 x4 = x4anc              y4 = y4anc-impEnc45

 pAll = (list x1:y1 x2:y2 x3:y3 x4:y4)
 (dbCreatePolygon tcCellView (list impLayer "drawing") pAll)
)
)
)
)

) ;tcCreateDeviceClass



;;; 
;;; $Id: bentResImpClass.il,v 1.5 2006/03/03 19:15:03 kuc Exp $
;;; 
;;; bentResImpClass.il
;;; 
;;; Copyright (c) 1997 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Mar 04, 1997
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This is the device library code for the bent resistor.
;;; 
;;; Revision History:
;;;   gtc 04/03/97  Fixing an error case of where it placed the resCut
;;;   gtc 04/22/97  Debugging placement of contacts
;;;   akr 11/17/97  Fixed contact spacing when numbends is 2
;;;   gtc 01/21/98  Copying over from v20
;;;   jim 09/11/98  Updated to use new rcInterConClass parameters
;;;   akr 10/15/98  Added Implant layer
;;;   gtc 12/29/98  Updating the implant layer so that it will not push out
;;;                 the contacts, but have more res in the center.  Also fixed
;;;                 bug in placement of last contact for rw where there is
;;;                 more than one via in the contact pcell.
;;;   xgs 11/06/00  Added isEsdRes to formal params
;;;   cry 08/20/01  copied from bentResClass.il to add toggled implants
;;;                 removed isEsdRes since existing parameters can do
;;;                 this, and toggling is unnecessary
;;;   kmi 04/08/03  Updating the class to support rc3InterConImpClass and
;;;                 rc3InterConImpEnhClass (SPR 15627)
;;;   xvgtmp2 05/01/05 Added Min NwellWidth check, by adding wellMinWidth 
;;;			class parameter and corresponding Logic.
;;;   bae 02/03/06  fixed wellMinwidth logic (SPR 29479)
;;;   kuc 02/21/06  added ability to turn off implantLayer
;;;

(putpropqq bentResImpClass "$Id: bentResImpClass.il,v 1.5 2006/03/03 19:15:03 kuc Exp $" SCCS)

(tcCreateDeviceClass
 "symbolic" "bentResImpClass"
 ;; Class parameters
 (
  (resistorLayer     "y0")
  (resIdLayer        "y1")
  (minResSpace       0.0)
  (resCutLayer       "y2")
  (resCutWidth       0.0)
  (resistorLayerGrid 0.0)
  (implantLayer      nil)   ;;; any implant layer for resistor (e.g., silblk) (always on)
  (impEnc            0.0)   ;;; enclosure of resistor layer by implant layer.
  (impWidth          0.0)   ;;; minimum width of the implant layer
  (fullImplantLayer  nil)   ;;; layer to implant into entire resistorLayer
  (fullImpEnc        0.0)   ;;; enclosure of resistorLayer by fullImplantLayer
  (wellLayer         nil)
  (wellminWidth   0.0)      ;;; the Optional well Layer min width

  (wellEnc           0.0)
  (impSpaceContact   0.0)
 )
 ;; Formal parameters
 (
  (rw               0.0)
  (rl               0.0)
  (spaceBetweenRuns 0.0)
  (maxRunLength     0.0)
  (variability      "FALSE")
  (contactName       "")
  (implant            t)   ;;; controls whether fullImplantLayer is drawn or not
  (secondImplant      t)   ;;; controls whether implantLayer is drawn or not
 )

 ;; convert boolean parameters to either t or nil
 ;; this way we can use the simple (when parameter) syntax
 ;; and speed up pcell evaluation and make code simpler
 (if (or (equal implant t) (equal implant "TRUE")) then
   (setq implant t)
   else
   (setq implant nil)
   )
 (if (or (equal secondImplant t) (equal secondImplant "TRUE")) then
   (setq secondImplant t)
   else
   (setq secondImplant nil)
   )

 (setq net (dbMakeNet tcCellView "r0"))
 (setq net2 (dbMakeNet tcCellView "r1"))
 (setq impOffset impSpaceContact)
 ;; do a sanity check that the spaceBetweenRuns is > minResSpace
 (when (greaterp minResSpace (plus 1e-6 spaceBetweenRuns))
     (error "bentResImpClass  spaceBetweenRuns must be at least %f\n" minResSpace)
 )

 ;; do a sanity check that the rw is < maxRunLength
 (when (greaterp (plus rw spaceBetweenRuns) (plus (quotient maxRunLength 2.0) 1e-6))
     (error "bentResImpClass  maxRunLength must be at least 2 * rw + spaceBetweenRuns (%f)\n" (plus spaceBetweenRuns (times 2.0 rw)))
 )

 ;; open the contact and do sanity checks on it
 (setq contactId (dbOpenCellView tcCellView~>lib contactName "symbolic" nil "rn"))
 (unless contactId
     (error "bentResImpClass  Cannot find/open contact %s\n" contactName)
 )
 (unless contactId~>isParamCell
     (error "bentResImpClass  Contact %s is not a pcell\n" contactName)
 )

 ;; look at the contact to find the space from the outside to the furthest
 ;; edge of the via in the contact.
 ;; Make sure that the resistor layer is in the contact
 ;;
 (cond ((equal resistorLayer contactId~>botLayer)
	(setq resInContactBbox contactId~>botLayerBbox)
	(setq layer2 contactId~>topLayer)
       )
     ((equal resistorLayer contactId~>topLayer)
      (setq resInContactBbox contactId~>topLayerPinBbox)
      (setq layer2 contactId~>botLayer)
     )
     (t
      (error "bentResImpClass  Cannot find layer %L in contact %s  (found %L and %L)\n" resistorLayer contactName contactId~>botLayer contactId~>topLayer)
     )
 )

 ;; viaBbox is the bounding box of the via within the contact pcell
 (setq viaBbox contactId~>contactLayerBbox)

 ;; resContactEdgeToEndOfViaSpace is the distance between the leftmost
 ;; edge of the resistor layer in the contact pcell to the rightmost
 ;; edge of the via layer in the contact pcell.
 (setq resContactEdgeToEndOfViaSpace (difference (caadr viaBbox) (caar resInContactBbox)))

 ;; see if it needs to dogbone the contacts
 (setq dogbone (greaterp (cadadr resInContactBbox) (plus rw 1e-6)))

 ;; make contact calculations.  See how many rows of contacts can fit in rw
 (setq contactWidth (difference (cadadr viaBbox) (cadar viaBbox)))
 (setq params contactId~>parameters)
 (if params~>yPitch then
     (setq contactPitch params~>yPitch)
  else
     (setq contactPitch (plus contactId~>contactWidth contactId~>contactSpace))
 )
 (if params~>l then
     (setq contactSpace (difference contactPitch params~>l))
  else
     (setq contactSpace contactId~>contactSpace)
 )


 (setq effectiveRw (plus rw (times -2.0 (cadar viaBbox)) contactSpace))
 (setq numRowsContacts (max 1 (fix (plus 1e-6 (quotient effectiveRw contactPitch)))))
 (setq instParams (list (list "row" "integer" numRowsContacts)
			(list "column" "integer" 1)))
 (when params~>implant
   (if implant then
     (setq instParams (xcons instParams
			     (list "implant" "boolean" t)
			     ))
     else
     (setq instParams (xcons instParams
			     (list "implant" "boolean" "FALSE")
			     ))
     )
   )
 (when params~>inWell
   (if wellLayer then
     (setq instParams (xcons instParams
			     (list "inWell" "boolean" t)
			     ))
     else
     (setq instParams (xcons instParams
			     (list "inWell" "boolean" "FALSE")
			     ))
     )
   )
 ;; calculate the Y offset required to center the vias
 (setq actualContactW (plus (times contactPitch numRowsContacts) -contactSpace
			    (times 2.0 (cadar viaBbox))))
 (setq contactYdelta (quotient (difference rw actualContactW) 2.0))
 (setq contactYdelta  (times resistorLayerGrid (fix (plus 0.999 (quotient contactYdelta resistorLayerGrid)))))

 ;; the effectiveRl is not representative of the resistance, but it will
 ;; make the calculations much easier because it will account for the
 ;; extra space required by the contacts.
 (setq effectiveRl (plus rl -rw (times 2.0 resContactEdgeToEndOfViaSpace)))
 (when dogbone (setq effectiveRl (plus effectiveRl (times 2.0 (caar viaBbox)))))
 (setq effectiveRl (plus effectiveRl (times 2.0 impOffset) (times 2.0 impEnc)))

 ;; find out how many "rows" there will be in the bent resistor
 (cond ((lessp effectiveRl maxRunLength)
	(setq numBends 1)
	(setq theRunLength effectiveRl)
       )
     (t

      (setq effectiveRl (plus effectiveRl spaceBetweenRuns))
      (setq numBends (fix (plus 0.999 (quotient effectiveRl
						(plus maxRunLength spaceBetweenRuns)))))

      ;;
      ;; if variability is disabled, massage the run length to evenly
      ;; distribute among each run
      ;;
      (cond ((and variability (nequal variability "FALSE"))
	     (setq theRunLength maxRunLength)
	    )
	  (t
	   (setq runDelta (quotient
			   (difference (times numBends
					      (plus spaceBetweenRuns maxRunLength))
				       effectiveRl) numBends))
	   (setq runDelta (times (fix (plus 1e-6 (quotient runDelta resistorLayerGrid)))
				 resistorLayerGrid))
	   (setq theRunLength (difference maxRunLength runDelta))
	  )
      )
     )
 )

 (when (and dogbone (greaterp numBends 2) (lessp (plus spaceBetweenRuns contactYdelta 1e-6) minResSpace))
     (error "bentResImpClass  dogbone'd contacts require a larger spaceBetweenRuns\n")
 )

 (when (and dogbone (equal numBends 2) (lessp (plus spaceBetweenRuns (times contactYdelta 2) 1e-6) minResSpace))
     (error "bentResImpClass  dogbone'd contacts require a larger spaceBetweenRuns\n")
 )

 ;; set up variables to aid drawing the resistor
 ;;   resXorigin = the leftmost X point of the resistor
 ;;   resXend = the rightmost X point of the resistor
 ;;   leftBendXend = the x end of a vertical bend on the left side
 ;;   rightBendXorigin = the x origin of a vertical bend on the right side
 ;;   resYorigin = the Y origin to draw the resistor bend
 ;;   resYdelta = the Y pitch between horizontal bends in the resistor
 ;;
 (setq resXorigin -resContactEdgeToEndOfViaSpace)
 (setq resXend (plus resXorigin theRunLength rw))
 (setq leftBendXend (plus resXorigin rw))
 (setq rightBendXorigin (difference resXend rw))
 (setq resYorigin 0.0)
 (setq resYdelta (plus rw spaceBetweenRuns))

 ;; calculate the amount of variability to add to the last contact
 (cond ((greaterp numBends 1)
	(setq lastContactVariability
	      (plus (times numBends (plus theRunLength spaceBetweenRuns))
		    -spaceBetweenRuns
		    (difference rw (times 2.0 resContactEdgeToEndOfViaSpace))
		    -rl))
       )
     (t
      (setq lastContactVariability 0.0)
     )
 )

 (setq firstContactVariability 0.0)

 (when (greaterp numBends 1)
     ;; when the contacts are dogbone'd, the extraction code does not properly
     ;; extract the resistance.  The resIdLayer cannot overlap any of the ends
     ;; of the dogbone.  In order to extract the resistance specified by the
     ;; parameters, the actual length of the resistor will be slightly larger
     ;; the rl parameter.
     ;;
     (when dogbone
	 (setq lastContactVariability (difference lastContactVariability
						  (times 2.0 (caar viaBbox)))))

     ;; if the last contact would end on a vertical bend, add variability to
     ;; the first contact so that the last contact will not end on a vertical
     ;; bend (the maxVariability could use some more refinement)
     ;;
     (setq maxVariability (difference theRunLength minResSpace (caadr resInContactBbox)))

     (when (greaterp lastContactVariability maxVariability)
	 (setq firstContactVariability
	       (difference lastContactVariability maxVariability))
	 (setq lastContactVariability
	       (difference lastContactVariability firstContactVariability))
     )
 )

 (setq halfRw (times (fix (plus 1e-6 (quotient rw (times 2.0 resistorLayerGrid 2.0))))
		     resistorLayerGrid))

 ;; Find out where it will place the "rescut".  It will set the variable
 ;; "cutLength", which is a countdown to where it will place the rescut.
 ;; The rescut needs to be placed as close as possible to the center of
 ;; the resistor in order for extraction to more accurately calculate the
 ;; parasitics of the resistor.
 (setq cutLength (quotient rl 2.0))

 ;; massage the cutLength to make the cut location correctly compensate
 ;; for the initial contact
 (cond (dogbone
	(setq cutLength (plus cutLength (caadr resInContactBbox) -halfRw
			      firstContactVariability))
       )
     (t
      (setq cutLength (plus cutLength resContactEdgeToEndOfViaSpace -halfRw
			    firstContactVariability))
     )
 )

 ;; The first half of the resistor should be attached to net, and the
 ;; second half (once it draws the res cut) should be attached to net2.
 ;; Set "theNet" to net, and once it places the cut, it will be set to net2.
 (setq theNet net)

 ;; Draw all of the resistorLayer and all but the first and last row of the
 ;; resIdLayer
 ;;
 (for row 1 numBends

      ;; if the cut does not belong on this bend
      (cond ((theRunLength < (plus cutLength halfRw))

	     ;; draw the horizontal run of the resistorLayer
	     (setq dbid (dbCreateRect tcCellView resistorLayer (list resXorigin:resYorigin
								     resXend:(plus resYorigin rw))))
	     (dbAddFigToNet dbid theNet)
	    )

	  ;; if this is the cut row, draw two pieces of the resistor,
	  ;; one on each side of the net
	  (t
	   (cond ((evenp row)
		  (setq cutXorigin (difference resXend cutLength halfRw))
		  (when (greaterp cutXorigin (difference resXend rw resCutWidth))
		      (setq cutXorigin (difference resXend rw resCutWidth))
		  )
		 )
	       (t
		(setq cutXorigin (plus resXorigin cutLength halfRw))
		(when (lessp cutXorigin (plus resXorigin rw))
		    (setq cutXorigin (plus resXorigin rw))
		)
	       )
	   )
	   (setq dbidL (dbCreateRect tcCellView resistorLayer (list resXorigin:resYorigin
								    cutXorigin:(plus resYorigin rw))))
	   (setq dbidR (dbCreateRect tcCellView resistorLayer (list cutXorigin:resYorigin
								    resXend:(plus resYorigin rw))))

	   ;; don't draw the resid layer if this is the first or last row
	   (unless (or (equal row 1) (equal row numBends))
	       (dbCreateRect tcCellView resIdLayer (list resXorigin:resYorigin
							 resXend:(plus resYorigin rw)))

	       (when (and implantLayer secondImplant)
		(setq impXorigin (difference resXorigin impEnc))
		(setq impYorigin (difference resYorigin impEnc))
		(setq impXend    (max (plus resXend impEnc)
				      (plus impXorigin impWidth)))
		(setq impYend    (max (plus resYorigin rw impEnc)
				      (plus impYorigin impWidth)))
	       (dbCreateRect tcCellView implantLayer (list impXorigin:impYorigin
							 impXend:impYend))
	       )
	   )

	   ;; draw the rescut layer (required by the extraction code
	   ;; to create two terminals)
	   (dbCreateRect tcCellView resCutLayer (list cutXorigin:resYorigin
						      (plus cutXorigin resCutWidth):(plus resYorigin rw)))

	   ;; add the resistor sides to the proper nets
	   (cond ((evenp row)
		  (dbAddFigToNet dbidL net)
		  (dbAddFigToNet dbidR net2)
		 )
	       (t
		(dbAddFigToNet dbidL net2)
		(dbAddFigToNet dbidR net)
	       )
	   )
	   (setq theNet net2)

	   ;; artifically increase the cutLength so that it will not cut again
	   (setq cutLength (plus cutLength theRunLength))
	  )
      )

      ;; if this is still the first net, reduce the remaining distance to
      ;; the resistor cut
      (when (equal theNet net)
	  (setq cutLength (difference cutLength theRunLength))
      )

      ;;
      ;; End drawing a horizontal section of the bent resistor.
      ;; If necessary, draw a vertal connection to the next horizonal section.
      ;;

      ;;
      ;; if it is not the last row, draw a vertical connection to the next row
      ;;
      (when (nequal row numBends)

	  ;; if this is not the first row, draw resid layer over the last row
	  (unless (equal 1 row)
	      (dbCreateRect tcCellView resIdLayer dbid~>bBox)

	      (when (and implantLayer secondImplant)
		(setq impXorigin (difference (caar dbid~>bBox) impEnc))
		(setq impYorigin (difference (cadar dbid~>bBox) impEnc))
		(setq impXend    (max (plus (caadr dbid->bBox) impEnc)
				      (plus impXorigin impWidth)))
		(setq impYend    (max (plus (cadadr dbid~>bBox) impEnc)
				      (plus impYorigin impWidth)))
		(dbCreateRect tcCellView implantLayer (list impXorigin:impYorigin impXend:impYend))
		)
	  )

	  ;; if the row is odd, prepare to draw a vertical bend on the right
	  (when (oddp row)
	      (setq stubXorigin rightBendXorigin)
	      (setq stubXend resXend)
	  )

	  ;; if the row is even, prepare to draw a vertical bend on the left
	  (when (evenp row)
	      (setq stubXorigin resXorigin)
	      (setq stubXend leftBendXend)
	  )

	  (cond ((spaceBetweenRuns < (difference cutLength halfRw))
		 ;; if the resistor cut does not occur in this segment,
		 ;; draw the vertical bend
		 (setq dbid (dbCreateRect tcCellView resistorLayer
					  (list stubXorigin:resYorigin
						stubXend:(difference resYorigin spaceBetweenRuns))))
		 (dbAddFigToNet dbid theNet)
		 (dbCreateRect tcCellView resIdLayer dbid~>bBox)
		 
		 (when (and implantLayer secondImplant)
		   (setq impXorigin (difference (caar dbid~>bBox) impEnc))
		   (setq impYorigin (difference (cadar dbid~>bBox) impEnc))
		   (setq impXend    (max (plus (caadr dbid->bBox) impEnc)
					 (plus impXorigin impWidth)))
		   (setq impYend    (max (plus (cadadr dbid~>bBox) impEnc)
					 (plus impYorigin impWidth)))
		   (dbCreateRect tcCellView implantLayer (list impXorigin:impYorigin impXend:impYend))
		   )
		 ;; if this is still the first net, reduce the remaining
		 ;; distance to the resistor cut
		 (when (equal theNet net)
		     (setq cutLength (difference cutLength spaceBetweenRuns))
		 )
		)

	      (t

	       ;; account for the bend correction in the cutLength
	       (setq cutLength (difference cutLength halfRw))

	       ;; make sure you get a clean cut through all of the diffusion
	       (setq cutLength (max 0.0 cutLength))

	       ;; if the cut will occur in this segment, draw two pieces of the
	       ;; resistor, one on each side of the net.
	       (when (greaterp cutLength 0.0)
		   (setq dbid (dbCreateRect tcCellView resistorLayer
					    (list stubXorigin:resYorigin
						  stubXend:(difference resYorigin cutLength))))
		   (dbAddFigToNet dbid theNet)
	       )

	       (setq theNet net2)
	       (setq dbid (dbCreateRect tcCellView resistorLayer
					(list stubXorigin:(difference resYorigin cutLength)
					      stubXend:(difference resYorigin spaceBetweenRuns))))
	       (dbAddFigToNet dbid theNet)

	       ;; draw the resid layer over both sections
	       (dbCreateRect tcCellView resIdLayer
			     (list stubXorigin:resYorigin
				   stubXend:(difference resYorigin spaceBetweenRuns)))

	       (when (and implantLayer secondImplant)
		 (setq stubXoriginImpCoord (difference stubXorigin impEnc))
		 (setq stubXendImpCoord (max (plus stubXend impEnc)
				       (plus stubXoriginImpCoord impWidth)))
		 (dbCreateRect tcCellView implantLayer (list stubXoriginImpCoord:resYorigin
							     stubXendImpCoord:(difference resYorigin spaceBetweenRuns)))
		 )
	       ;; draw the resistor cut
	       (dbCreateRect tcCellView resCutLayer (list stubXorigin:(difference resYorigin cutLength)
							  stubXend:(difference resYorigin cutLength resCutWidth)))

	       ;; set the resistor cut length so it will not cut again
	       (setq cutLength (plus theRunLength cutLength))
	      )
	  )

	  (setq resYorigin (difference resYorigin resYdelta))
      )
 )

 ;;
 ;; draw the first contact
 ;;
 (setq dbid (dbCreateParamInst tcCellView contactId "brc0"
			       (plus firstContactVariability -resContactEdgeToEndOfViaSpace):contactYdelta
			       "R0" 1 instParams
			       ))
 (setq theMaster dbid~>master)
 (cond ((equal resistorLayer theMaster~>botLayer)
	(setq layer2Bbox theMaster~>topLayerPinBbox)
	(setq resInContactBbox theMaster~>botLayerBbox)
       )
     (t
      (setq layer2Bbox theMaster~>botLayerBbox)
      (setq resInContactBbox theMaster~>topLayerPinBbox)
     )
 )
 (cond (dogbone
	(setq resVariabilityW (cadadr resInContactBbox))
       )
     (t
      (setq resVariabilityW rw)
     )
 )
 (setq layer2VarYoffset1 (cadar layer2Bbox))
 (setq layer2VarYoffset2 (cadadr layer2Bbox))

 ;; draw the variability for the first contact
 (setq dbid (dbCreateRect tcCellView layer2
			  (list (plus resXorigin (caar layer2Bbox)):(plus layer2VarYoffset1 contactYdelta)
				(plus resXorigin (caadr layer2Bbox) firstContactVariability):(plus layer2VarYoffset2 contactYdelta))))
 (dbAddFigToNet dbid net)
 (setq pinid (dbCreatePin net dbid))
 pinid~>accessDir = (list "top" "bottom" "left" "right")

 (when dogbone
     (dbCreateRect tcCellView resistorLayer
		   (list resXorigin:contactYdelta
			 (plus resXorigin (caadr resInContactBbox) firstContactVariability):(plus resVariabilityW contactYdelta)))
     (setq firstContactVariability (plus firstContactVariability (caar viaBbox)))
 )

 ;; draw the resistor recognition layer for the first run.
 ;; If there is only one run, set different stopping conditions.
 (setq resIdXend (plus resXorigin theRunLength rw
		       (cond ((and (equal numBends 1) dogbone)
			      (plus (minus (caadr resInContactBbox)) -impOffset -impEnc))
			   ((equal numBends 1)
			    (plus -resContactEdgeToEndOfViaSpace -impOffset -impEnc))
			   (t 0.0))))
 (dbCreateRect tcCellView resIdLayer
	       (list (plus impOffset impEnc firstContactVariability):0.0
		     resIdXend:rw))
 
 (when (and implantLayer secondImplant)
     (setq resIdXend (plus resIdXend impEnc))
     (dbCreateRect tcCellView implantLayer
		   (list (plus impOffset firstContactVariability):(minus impEnc)
			 (max resIdXend (plus firstContactVariability impWidth)):(max (plus rw impEnc) (plus (minus impEnc) impWidth))))
   )

 ;;
 ;; draw the last contact
 ;;
 (cond
     ((onep numBends)
      (cond
	  (dogbone
	   (setq lastContactXorigin (plus resIdXend impOffset (minus (caar resInContactBbox))))
	  )
	  (t
	   (setq lastContactXorigin (plus resIdXend impOffset (minus (caar viaBbox))))
	  )
      )
      (setq layer2VarXorigin (plus lastContactXorigin (caar layer2Bbox)))
      (setq layer2VarXend (difference resXend (caar layer2Bbox)))
     )
     ((oddp numBends)
      (setq lastContactXorigin (difference resXend resContactEdgeToEndOfViaSpace (caar viaBbox) lastContactVariability -impEnc -impEnc -impOffset -impOffset))
      (setq layer2VarXorigin (plus lastContactXorigin (caar layer2Bbox)))
      (setq layer2VarXend (difference resXend (caar layer2Bbox)))
      (setq resIdXorigin resXorigin)
      (setq resIdXend (plus resXend -lastContactVariability -resContactEdgeToEndOfViaSpace impEnc impOffset))
     )
     (t
      (setq lastContactXorigin (plus resXorigin lastContactVariability -impEnc -impEnc -impOffset -impOffset))
      (setq layer2VarXorigin (plus resXorigin (caar layer2Bbox)))
      (setq layer2VarXend (plus lastContactVariability -impOffset -impOffset -impEnc -impEnc))
      (setq resIdXorigin (plus lastContactVariability -impOffset -impEnc))
      (setq resIdXend resXend)
     )
 )

 (setq lastContactYorigin (difference resYorigin contactYdelta -rw (cadadr resInContactBbox)))

 (dbCreateParamInst tcCellView contactId "brc1" lastContactXorigin:lastContactYorigin "R0" 1
		    instParams)

 ;; if necessary, draw the variability for the last contact
 (setq dbid (dbCreateRect tcCellView layer2
			  (list layer2VarXorigin:(plus lastContactYorigin layer2VarYoffset1)
				layer2VarXend:(plus lastContactYorigin layer2VarYoffset2))))
 (dbAddFigToNet dbid net2)
 (setq pinid (dbCreatePin net2 dbid))
 pinid~>accessDir = (list "top" "bottom" "left" "right")

 (when dogbone
     (dbCreateRect tcCellView resistorLayer
		   (list (difference layer2VarXorigin (caar layer2Bbox)):lastContactYorigin
			 (plus layer2VarXend (caar layer2Bbox)):(plus lastContactYorigin resVariabilityW)))

     (cond ((oddp numBends)
	    (setq resIdXend (difference resIdXend (caar viaBbox)))
	   )
	 (t
	  (setq resIdXorigin (plus resIdXorigin (caar viaBbox)))
	 )
     )
 )

 ;; draw the resistor recognition layer for the last run
 (unless (equal 1 numBends)
     (dbCreateRect tcCellView resIdLayer
		   (list resIdXorigin:resYorigin
			 resIdXend:(plus resYorigin rw)))

     (when (and implantLayer secondImplant)
	 (setq resIdXorigin (difference resIdXorigin impEnc))	
	 (setq resIdXend (plus resIdXend impEnc))
       (dbCreateRect tcCellView implantLayer
		     (list resIdXorigin:(difference resYorigin impEnc)
			   (max resIdXend (plus resIdXorigin impWidth)):(max (plus resYorigin rw impEnc) (plus (difference resYorigin impEnc) impWidth))))
     )
 )

 ;; draw the well around the resistor, if necessary
 (when wellLayer
    wellLayer_Xorigin = (difference resXorigin wellEnc)
  wellLayer_Yorigin = (max (plus rw wellEnc) (plus contactYdelta wellEnc (cadadr resInContactBbox)))
  wellLayer_Xend = (plus resXend wellEnc)
  wellLayer_Yend = (min (difference resYorigin wellEnc) (plus lastContactYorigin -wellEnc))

    	(when (wellLayer_Xend-wellLayer_Xorigin)< wellminWidth
		Diff_well_width = wellminWidth - (wellLayer_Xend-wellLayer_Xorigin)
		wellLayer_Xend = wellLayer_Xend + (Diff_well_width/2)
		wellLayer_Xorigin = wellLayer_Xorigin - (Diff_well_width/2)
	)
	(when (wellLayer_Yorigin-wellLayer_Yend)< wellminWidth
		Diff_well_width = wellminWidth - (wellLayer_Yorigin-wellLayer_Yend)
		wellLayer_Yend = wellLayer_Yend - (Diff_well_width/2)
		wellLayer_Yorigin = wellLayer_Yorigin + (Diff_well_width/2)
	)
 
     wellLayer_bBox = list(wellLayer_Xorigin:wellLayer_Yorigin wellLayer_Xend:wellLayer_Yend)

     (dbCreateRect tcCellView wellLayer wellLayer_bBox)
/*(list 
					 (list (difference resXorigin wellEnc)
					       (max (plus rw wellEnc)
						    (plus contactYdelta wellEnc (cadadr resInContactBbox))))
					 (list (plus resXend wellEnc)
					       (min (difference resYorigin wellEnc)
						    (plus lastContactYorigin -wellEnc)))))*/
 )
 (when (and fullImplantLayer implant)
   (dbCreateRect tcCellView fullImplantLayer (list
					      (list (difference resXorigin fullImpEnc)
						    (max (plus rw fullImpEnc)
							 (plus contactYdelta fullImpEnc
							       (cadadr resInContactBbox)
							       )
							 )
						    )
					      (list (plus resXend fullImpEnc)
						    (min (difference resYorigin fullImpEnc)
							 (difference lastContactYorigin fullImpEnc)
							 )
						    )
					      )
		 )
   )
)
;;; 
;;; $Id: dieSealRingClass.il,v 1.13 2004/04/30 20:47:36 jtv Exp $ %T%
;;; 
;;; dieSealRingClass.il
;;; 
;;; Copyright (c) 1997 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Mar 07, 1997
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This is the device library code for the die seal ring.  It will put
;;; Nikon Crosses in the four corners, each covered with the pad cut.
;;; It will use the generic ring to draw all of the rings.
;;; 
;;; Revision History:
;;;   gtc 04/03/97  Removing "cornerCut" as a parameter and calculating
;;;                 its value in here.  Letting it default to 0.0
;;;                 enclosure of the sealringId layer.
;;;   gtc 04/22/97  Adding "padEncNikonInside" parameter
;;;   gtc 05/29/97  eliminating areaid seal's additional width in bevel
;;;   gtc 06/20/97  w & l parameters now refer to the w & l of the inside
;;;                 of the die seal ring.  Drawing the sealringIdLayer
;;;                 at this level instead of the sublevel.
;;;   gtc 07/25/97  Breaking the areaid seal into 4 geometries to work around
;;;                 a vampire bug
;;;   gtc 09/11/97  Breaking up all other layers into 4 geometries
;;;   gtc 10/09/97  Reworking all kinds of calculations to better eliminate
;;;                 the off grid errors resulting from errors in floating
;;;                 point math.  Doing most of the calculations in integers,
;;;                 and using an integer based version of the generic ring.
;;;   gtc 01/22/98  Copying over from v20
;;;   akg 01/31/00  Adding parameters related to metal-stress rule zones
;;;   kmi 04/12/02  Adding additional bevel length when the width of a layer is too big
;;;                 for bevels to be created (45 degree problem on corners, SPR 11698)
;;;   ymx 03/20/03  Added bevelSnap.
;;;   kmi 03/26/03  Correcting bevelSnap
;;;   ymx 08/01/03  Added remDefaultPad for sw4
;;;   lpn 01/28/04  Added the discrete contacts/vias for TCS 790  
;;;   jtv 04/17/04  spr 19286, update pcell to have bevel width = sqrt2 * W
;;;

(putpropqq dieSealRingClass "$Id: dieSealRingClass.il,v 1.13 2004/04/30 20:47:36 jtv Exp $ %T%" SCCS)

(tcCreateDeviceClass
 "symbolic" "dieSealRingClass"
 ;; Class parameters
 (
  ;; due to a Cadence feature, you must have your list quoted similar to below
  ;; each item is a list of '(layer spaceFromOutside layerWidth makePin grid)
  (ringLayers '('(("tap" "drawing") 5.0 3.0 nil 0.05)
               '(("met1" "drawing") 6.0 2.5 nil 0.05)
               '(("met2" "drawing") 5.5 4.0 t 0.05)))
  
  (discreteViaLayers nil)
  (sealringIdLayer (list "y1" "drawing"))
  (sealringIdWidth 0.0)
  (sealringGrid 0.0)
  (genericRingName "")
  (nikonCrossName "")
  (genericRivetRingName "")
  (padLayer (list "y0" "drawing"))
  (remDefaultPad nil) ;;added for sw4 technology. This technology does not 
                       ;;have a pad in the pcell. This switch will enable removal
                       ;;of the place holder padlayer ("y0" "drawing")
  (padGrid  0.0)
  (padEncNikon 0.0)
  (padEncNikonInside 0.0)
  ;; following 4 are needed to define zones for metal-stress 
  (rdLayer nil)          ;; layer marking dead zone 
  (rcLayer nil)          ;; layer marking critical corner
  (dLayer  nil)          ;; layer marking critical side
  (scaleF  1)            ;; scale factor for the technology
  ;; following 4 parameters are optional - no need to be pass these from device
  (criticalL 5080.0)     ;; determining die length 200 mils on Si (scale factor=1)
  (defRd   0.0)          ;; default rd is 0 mils on si (for scale factor=1) 
  (defRc   152.4)        ;; default rc is 6 mils on si (for scale factor=1)
  (defD    101.6)        ;; default D  is 4 mils on si (for scale factor=1)
 )
 ;; Formal parameters
 (
  (w 0.0)
  (l 0.0)
  (extraLLcut 0.0)
  (extraULcut 0.0)
  (extraLRcut 0.0)
  (extraURcut 0.0)
 )
 (setq extraLLcut_orig extraLLcut)
 (setq extraULcut_orig extraULcut)
 (setq extraLRcut_orig extraLRcut)
 (setq extraURcut_orig extraURcut )

 (setq dbuperuu tcCellView~>DBUPerUU)
 (setq grid (fix (times dbuperuu sealringGrid)))
 (setq s2 (sqrt 2.0))
 ;; get the input parameters in integers
 (foreach param '(sealringIdWidth padEncNikon padEncNikonInside w l extraLLcut extraULcut extraLRcut extraURcut padGrid)
     (set param (fix (times dbuperuu (eval param))))
     (unless (zerop (mod (eval param) grid))
	 (set param (xtimes (xquotient (xplus (eval param) grid) grid) grid))
     )
 )


 (setq net (dbMakeNet tcCellView "ppd"))
 (setq minSealRingIdWidth 0)

 ;; open the generic ring and do sanity checks on it
 (setq ringId (dbOpenCellView tcCellView~>lib genericRingName "symbolic" nil "rn"))
 (unless ringId
     (error "dieSealRingClass:  Cannot find/open generic ring %s\n" genericRingName)
 )
 (unless ringId~>isParamCell
     (error "dieSealRingClass:  Ring %s is not a pcell\n" genericRingName)
 )

 ;; open the generic rivet ring and do sanity checks on it
 (when (genericRivetRingName != "")
     (setq rivetRingId (dbOpenCellView tcCellView~>lib genericRivetRingName "symbolic" nil "rn"))
     (unless rivetRingId
	 (error "dieSealRingClass:  Cannot find/open generic rivet ring %s\n" genericRivetRingName)
     )
     (unless rivetRingId~>isParamCell
	 (error "dieSealRingClass:  Rivet ring %s is not a pcell\n" genericRivetRingName)
     )
 )


 ;; open the nikon cross and do sanity checks on it
 (setq nikonId (dbOpenCellView tcCellView~>lib nikonCrossName "symbolic" nil "rn"))
 (unless nikonId
     (error "dieSealRingClass:  Cannot find/open nikon cross %s\n" nikonCrossName)
 )
 (unless nikonId~>isParamCell
     (error "dieSealRingClass:  Nikon cross %s is not a pcell\n" nikonCrossName)
 )

 ;; grow the width and length by 2 * sealring width so that the user can
 ;; enter the size of the die
 (foreach layer ringLayers
     (setq thisLpp (car layer))
     (setq spacing (fix (times dbuperuu (cadr layer))))
     (setq ringWidth (fix (times dbuperuu (caddr layer))))
     (setq makePin (nth 3 layer))
     (setq layGrid (fix (times dbuperuu (nth 4 layer))))

     (setq intRingLayers (cons (list thisLpp spacing ringWidth makePin layGrid)
			       intRingLayers)
     )

     ;; make sure that the sealring ID layer will enclose this layer
     (when (lessp minSealRingIdWidth (xplus spacing ringWidth))
	 (setq minSealRingIdWidth (xplus spacing ringWidth))
     )
 )

 (setq sealringIdWidth (max sealringIdWidth minSealRingIdWidth))
 (setq w (xplus w (xtimes 2 sealringIdWidth)))
 (setq l (xplus l (xtimes 2 sealringIdWidth)))


 ;; Create Metal_Stress zones

 (setq len (quotient l dbuperuu))
 (setq wid (quotient w dbuperuu))
 (setq smalldie nil)


 (if l > w then
     (setq ar (quotient len wid))
     (if len < (criticalL/scaleF) then
	 (setq smalldie t))
  else
     (setq ar (quotient wid len))
     (if wid < (criticalL/scaleF) then
	 (setq smalldie t))
 )

 (if smalldie then
     rd = defRd/scaleF
     rc = defRc/scaleF
     d  = defD/scaleF
  else
     rd = (6.43-(1.28*ar)+(0.69*ar*ar))*25.4/scaleF
     rc = (11.25+(3.47*ar))*25.4/scaleF
     d  = (-1.31+(3.87*ar))*25.4/scaleF
 )

 ;; Create deadzone
 (if rdLayer && (rd > 0) then     
     (dbCreateEllipse tcCellView rdLayer (list -rd:-rd rd:rd))
     (dbCreateEllipse tcCellView rdLayer (list -rd:(wid-rd) rd:(wid+rd)))
     (dbCreateEllipse tcCellView rdLayer (list (len-rd):-rd (len+rd):rd))
     (dbCreateEllipse tcCellView rdLayer (list (len-rd):(wid-rd) (len+rd):(wid+rd))) 
 )

 ;; Create critical corner
 (if rcLayer then
     (dbCreateEllipse tcCellView rcLayer (list -rc:-rc rc:rc))
     (dbCreateEllipse tcCellView rcLayer (list -rc:(wid-rc) rc:(wid+rc)))
     (dbCreateEllipse tcCellView rcLayer (list (len-rc):-rc (len+rc):rc))
     (dbCreateEllipse tcCellView rcLayer (list (len-rc):(wid-rc) (len+rc):(wid+rc)))
 )

 ;; Create critical side
 (if dLayer then
     (dbCreateRect tcCellView dLayer (list 0:0 d:wid))
     (dbCreateRect tcCellView dLayer (list 0:0 len:d))
     (dbCreateRect tcCellView dLayer (list 0:(wid-d) len:wid))
     (dbCreateRect tcCellView dLayer (list (len-d):0 len:wid))
 )

 ;; create the nikon cross and pad opening in the LL corner
 (setq dbid (dbCreateParamInst tcCellView nikonId "llNikon" (quotient padEncNikon dbuperuu):(quotient padEncNikon dbuperuu) "R0" 1 nil))
 (setq theMaster dbid~>master)
 (setq cutPoints nil)
 (foreach point theMaster~>outlinePoints
     (setq cutPoints (cons (plus padEncNikon (fix (times dbuperuu (car point)))):(plus padEncNikon (fix (times dbuperuu (cadr point))))
			   cutPoints))
 )
 ;; calculate the corner cut necessary to satisfy the pad enclosure of
 ;; the nikon cross
 (when (zerop padEncNikonInside) (setq padEncNikonInside padEncNikon))
 (setq cornerCut (fix (plus (times 2.0 padEncNikon) (times s2 padEncNikonInside) (times dbuperuu (car (nth 3 theMaster~>outlinePoints))) (times dbuperuu (car (nth 2 theMaster~>outlinePoints))))))

 ;; snap the cornerCut to grid
 (unless (zerop (mod cornerCut padGrid))
     (setq cornerCut (xtimes (xquotient (xplus cornerCut padGrid) padGrid) padGrid))
 )

 ;; Bevels are not creted when the bevel length in a corner is less than 
 ;; ringWidth-ringWidth*(sqr(2)-1)     (see ringClass.il)
 ;; so we might have sealRing with 90 degrees corners. In order to avoid this, bevelAdd is calculated .
 ;; spr 19286 found that the dsr pcell beveled edges were not sqrt2 * width, and failed a manual stress
 ;; to solve this, the minBevelRequired was changed from (ringWidth-ringWidth*(sqr(2)-1) to be ringWidth
 (setq bevelAdd 0)
 (foreach layer intRingLayers
     (setq spacing (cadr layer))
     (setq bevelLength (plus cornerCut -spacing (fix (times spacing (difference s2 1.0)))))
     (setq minBevelRequired (ceiling (times (caddr layer) 1.0)))
     (setq bevelAjdust (difference minBevelRequired bevelLength))
     (if (and (greaterp bevelAjdust 0) (leqp bevelAdd bevelAjdust)) then
         (setq bevelAdd bevelAjdust)
     )
 )
 ;; bevelAdd should be snaped to grid otherwise there may exist
 ;; a space between padRing and triangular pad in corners. 
 ;; RingClass snaps bevel values so we must do the same here before
 ;; building pad corners and calling the class.
 ;;
 ;; Snap it up to a grid : 
 ;; The procedure (xtimes (xquotient (xplus ... used throughout this code
 ;; will round up a number to the grid ( example: 20 will become 25) what must be prevented
 ;; ( example: 20 must stay 20, and 21 should be snapped to 25) 
 ;; The following code does it. 
 ;; Converting padGrid to a float number
 (setq padGridFloat (times padGrid 1.0))
 ;; snap up to a grid 
 (setq bevelAdd (times (ceiling (quotient bevelAdd padGridFloat)) padGrid))

 (setq extraLLcut (plus extraLLcut bevelAdd))
 (setq extraULcut (plus extraULcut bevelAdd))
 (setq extraLRcut (plus extraLRcut bevelAdd))
 (setq extraURcut (plus extraURcut bevelAdd))



 ;; divide the cut points by the dbuperuu
 (setq realCutPoints nil)
 (foreach point cutPoints
     (setq realCutPoints (cons (quotient (car point) dbuperuu):(quotient (cadr point) dbuperuu)
			       realCutPoints)
     )
 )
 (setq realCutPoints (reverse realCutPoints))
 (setq padLayerId_1 (dbCreatePolygon tcCellView padLayer
		      (cons 0.0:0.0
			(append realCutPoints
				(list
				 (car realCutPoints)
				 0.0:0.0
				 (quotient (plus cornerCut extraLLcut) dbuperuu):0.0
				 0.0:(quotient (plus cornerCut extraLLcut) dbuperuu))))))

  

 ;; create the nikon cross and pad opening in the LR corner
 (setq dbid (dbCreateParamInst tcCellView nikonId "lrNikon" (quotient (difference l padEncNikon) dbuperuu):(quotient padEncNikon dbuperuu) "MY" 1 nil))
 (setq theMaster dbid~>master)
 (setq cutPoints nil)
 (foreach point theMaster~>outlinePoints
     (setq cutPoints (cons (difference l padEncNikon (fix (times dbuperuu (car point)))):(plus padEncNikon (fix (times dbuperuu (cadr point))))
			   cutPoints))
 )

 ;; divide the cut points by the dbuperuu
 (setq realCutPoints nil)
 (foreach point cutPoints
     (setq realCutPoints (cons (quotient (car point) dbuperuu):(quotient (cadr point) dbuperuu)
			       realCutPoints)
     )
 )
 (setq realCutPoints (reverse realCutPoints))
 (setq padLayerId_2 (dbCreatePolygon tcCellView padLayer
		      (cons (quotient l dbuperuu):0.0
			(append realCutPoints
				(list 
				 (car realCutPoints)
				 (quotient l dbuperuu):0.0
				 (quotient (difference l cornerCut extraLRcut) dbuperuu):0.0
				 (quotient l dbuperuu):(quotient (plus cornerCut extraLRcut) dbuperuu))))))

 ;; create the nikon cross and pad opening in the UR corner
 (setq dbid (dbCreateParamInst tcCellView nikonId "urNikon" (quotient (difference l padEncNikon) dbuperuu):(quotient (difference w padEncNikon) dbuperuu) "R180" 1 nil))
 (setq theMaster dbid~>master)
 (setq cutPoints nil)
 (foreach point theMaster~>outlinePoints
     (setq cutPoints (cons (difference l padEncNikon (fix (times dbuperuu (car point)))):(difference w padEncNikon (fix (times dbuperuu (cadr point))))
			   cutPoints))
 )
 ;; divide the cut points by the dbuperuu
 (setq realCutPoints nil)
 (foreach point cutPoints
     (setq realCutPoints (cons (quotient (car point) dbuperuu):(quotient (cadr point) dbuperuu)
			       realCutPoints)
     )
 )
 (setq realCutPoints (reverse realCutPoints))
 (setq padLayerId_3 (dbCreatePolygon tcCellView padLayer
		      (cons (quotient l dbuperuu):(quotient w dbuperuu)
			(append realCutPoints
				(list
				 (car realCutPoints)
				 (quotient l dbuperuu):(quotient w dbuperuu)
				 (quotient (difference l cornerCut extraURcut) dbuperuu):(quotient w dbuperuu)
				 (quotient l dbuperuu):(quotient (difference w cornerCut extraURcut) dbuperuu))))))


 ;; create the nikon cross and pad opening in the UL corner
 (setq dbid (dbCreateParamInst tcCellView nikonId "ulNikon" (quotient padEncNikon dbuperuu):(quotient (difference w padEncNikon) dbuperuu) "MX" 1 nil))
 (setq theMaster dbid~>master)
 (setq cutPoints nil)
 (foreach point theMaster~>outlinePoints
     (setq cutPoints (cons (plus padEncNikon (fix (times (car point) dbuperuu))):(difference w padEncNikon (fix (times dbuperuu (cadr point))))
			   cutPoints))
 )

 ;; divide the cut points by the dbuperuu
 (setq realCutPoints nil)
 (foreach point cutPoints
     (setq realCutPoints (cons (quotient (car point) dbuperuu):(quotient (cadr point) dbuperuu)
			       realCutPoints)
     )
 )
 (setq realCutPoints (reverse realCutPoints))
 (setq padLayerId_4 (dbCreatePolygon tcCellView padLayer
		      (cons 0.0:(quotient w dbuperuu)
			(append realCutPoints
				(list
				 (car realCutPoints)
				 0.0:(quotient w dbuperuu)
				 (quotient (plus cornerCut extraULcut) dbuperuu):(quotient w dbuperuu)
				 0.0:(quotient (difference w cornerCut extraULcut) dbuperuu))))))

 ;;If no padlayer is defined, remove the defalut "y0" "drawing". This is required for sw4 tech.
 (if remDefaultPad then
      (dbDeleteObject padLayerId_4)
      (dbDeleteObject padLayerId_3)
      (dbDeleteObject padLayerId_2)
      (dbDeleteObject padLayerId_1)
 )

 ;; loop through all of the ring layers and draw them


 (setq ringCount 0)
 (foreach layer intRingLayers

     (setq spacing (cadr layer))
     (setq ringWidth (caddr layer))
     (setq grid (nth 4 layer))

     ;; calculate the extra offset required because of the bevelled corners
     (setq extraOffset (fix (times spacing (difference s2 1.0))))
     (setq bevelLength (plus cornerCut -spacing extraOffset))
     (setq dbid
	   (dbCreateParamInst tcCellView ringId (sprintf nil "ring%d" ringCount)
			      0.0:0.0 "R0" 1
			      (list
			       (list "w" "int" (fix (difference w (times 2 spacing))))
			       (list "l" "int" (fix (difference l (times 2 spacing))))
			       (list "xOffset" "int" spacing)
			       (list "yOffset" "int" spacing)
			       (list "ringLayer" "list" nil)
			       (list "ringWidth" "int" ringWidth)
			       (list "additionalWidthInBevel" "int" 0)
			       (list "llBevelLength" "int" (plus extraLLcut bevelLength))
			       (list "ulBevelLength" "int" (plus extraULcut bevelLength))
			       (list "lrBevelLength" "int" (plus extraLRcut bevelLength))
			       (list "urBevelLength" "int" (plus extraURcut bevelLength))
			       (list "bevelTheOutside" "boolean" t)
			       (list "grid" "int" grid)
			       (list "breakupPolygons" "boolean" "TRUE")
			      )
	   )
     )
     (setq theMaster dbid~>master)
     (setq dbid1 (dbCreatePolygon tcCellView (car layer) theMaster~>ringPoints1))
     (setq dbid2 (dbCreatePolygon tcCellView (car layer) theMaster~>ringPoints2))
     (setq dbid3 (dbCreatePolygon tcCellView (car layer) theMaster~>ringPoints3))
     (setq dbid4 (dbCreatePolygon tcCellView (car layer) theMaster~>ringPoints4))
     (dbAddFigToNet dbid1 net)
     (dbAddFigToNet dbid2 net)
     (dbAddFigToNet dbid3 net)
     (dbAddFigToNet dbid4 net)

     (when (nth 3 layer)
	 (setq pinid (dbCreatePin net dbid1))
	 pinid~>accessDir = (list "top" "bottom" "left" "right")
	 (setq pinid (dbCreatePin net dbid2))
	 pinid~>accessDir = (list "top" "bottom" "left" "right")
	 (setq pinid (dbCreatePin net dbid3))
	 pinid~>accessDir = (list "top" "bottom" "left" "right")
	 (setq pinid (dbCreatePin net dbid4))
	 pinid~>accessDir = (list "top" "bottom" "left" "right")
     )

     (setq ringCount (plus ringCount 1))
 )

;; Draw discrete contacts

 (when (listp discreteViaLayers)
     (when rivetRingId
	 (setq viaCount 0)
	 
	 (foreach layer discreteViaLayers
	     
	     (setq thisLpp      (car   layer))  ;; contact layer
	     (setq spacing      (cadr  layer))  ;; offset from the scribe line
	     (setq viaWidth     (caddr layer))  ;; width of contact 
	     (setq viaSpaceY    (nth 3 layer))  ;; spacing between contacts in y direction
	     (setq viaSpaceX    (nth 4 layer))  ;; spacing between contacts in x direction
	     (setq grid_orig    (nth 5 layer))  ;; grid of the contact layer
	     (setq bevel_offset (nth 6 layer))  ;; additional offset in 45 degree corner 
	     (setq ringWidth    (nth 7 layer))  ;; width of the contact ring
	     (setq lessRivetNearBevel    (nth 8 layer)) ;; reduce the contacts near the 45 degree corner
	     (setq numColsLess  (nth 9 layer))	;; reduce the number of columns of contacts in  45 degree corner 
	     (setq updatedClass (nth 10 layer))	;; use the updated rivet ring class for 45 degree corner section
	     (setq altCorCon    (nth 11 layer)) ;; alternate the contacts  in the corner region only
	     (setq rivetLayer2  (nth 12 layer)) ;; additional contact layer if contacts should alternate
	     
	     
	     ;; calculate the extra offset required because of the bevelled corners
	     (setq extraOffset (fix (times spacing (difference s2 1.0))))
	     (setq bevelLength (plus (quotient cornerCut dbuperuu) -spacing extraOffset))
	     
	     (setq paramList (list
			      (list "w" "float" (difference wid (times 2 spacing)))
			      (list "l" "float" (difference len (times 2 spacing)))
			      (list "xOffset" "float" spacing)
			      (list "yOffset" "float" spacing)
			      (list "rivetLayer" "list" (car layer))
			      (list "ringWidth"  "float" ringWidth)
			      (list "rivetWidth" "float" viaWidth)
			      (list "rivetSpace" "float" viaSpaceY)
			      (list "rivetSpaceX" "float" viaSpaceX)
			      (list "llBevelLength" "float" (plus extraLLcut_orig bevelLength bevel_offset))
			      (list "ulBevelLength" "float" (plus extraULcut_orig bevelLength bevel_offset))
			      (list "lrBevelLength" "float" (plus extraLRcut_orig bevelLength bevel_offset))
			      (list "urBevelLength" "float" (plus extraURcut_orig bevelLength bevel_offset))
			      (list "autoIncreaseBevelWidth" "boolean" "FALSE")
			      (list "grid" "float" grid_orig)
			      (list "lessConNearbevel" "boolean" lessRivetNearBevel)
			      (list "numColsLess"  "int"     numColsLess)
			      (list "updatedClass" "boolean" updatedClass)
                              (list "altCorCon"    "boolean" altCorCon) 
	     ))
	     (when rivetLayer2 (setq paramList (cons (list "rivetLayer2" "list" rivetLayer2) paramList)))
	     
	     (setq dbid
		   (dbCreateParamInst tcCellView rivetRingId 
				      (sprintf nil "%s%d" (caar layer) viaCount)
				      0.0:0.0 "R0" 1 paramList)
	     )
	     (setq viaCount (plus viaCount 1))
	     
	 )
     )
 ) 
 
 ;; create the sealring identification layer around the die seal ring
 (setq dbid (dbCreateParamInst tcCellView ringId "sealid" 0.0:0.0 "R0" 1
			       (list
				(list "w" "int" w)
				(list "l" "int" l)
				(list "xOffset" "int" 0)
				(list "yOffset" "int" 0)
				(list "ringLayer" "list" nil)
				(list "ringWidth" "int" sealringIdWidth)
				(list "additionalWidthInBevel" "int" 0)
				(list "llBevelLength" "int" (plus cornerCut extraLLcut))
				(list "ulBevelLength" "int" (plus cornerCut extraULcut))
				(list "lrBevelLength" "int" (plus cornerCut extraLRcut))
				(list "urBevelLength" "int" (plus cornerCut extraURcut))
				(list "bevelTheOutside" "boolean" "FALSE")
				(list "grid" "int" (fix (times dbuperuu sealringGrid)))
				(list "breakupPolygons" "boolean" "TRUE")
			       )
	    )
 )
 (when sealringIdLayer
     (setq theMaster dbid~>master)
     (dbCreatePolygon tcCellView sealringIdLayer theMaster~>ringPoints1)
     (dbCreatePolygon tcCellView sealringIdLayer theMaster~>ringPoints2)
     (dbCreatePolygon tcCellView sealringIdLayer theMaster~>ringPoints3)
     (dbCreatePolygon tcCellView sealringIdLayer theMaster~>ringPoints4)
 )

 (dbClose ringId)
 (dbClose nikonId)
 
)
;;; 
;;; $Id: drainContactPolImpClass.il,v 1.6 2005/01/18 11:45:24 xvg Exp $ %T%
;;; 
;;; drainContactPolImpClass.il
;;; 
;;; Copyright (c) 1996 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Oct 16, 1996
;;; Author: Sanjay Rekhi/Senior CAD (syr) @ CSDC
;;; 
;;; Description:
;;;   This file contains the code for source and drain contact tiles
;;;   that will be used by the transistor device.
;;;
;;; Revision History:
;;;   syr 12/03/96  To correct left/right enclosure problem.
;;;   gtc 12/05/96  Corrected minimum width check to account for floating
;;;                 point round off errors
;;;   gtc 01/22/98  Copying over from v20
;;;   cry 07/21/01  Copied from drainContactClass to allow polarized implants
;;;   cry 09/25/01  Added capabilty of specifying XL and XR and Y imp enclosures
;;;   lpn 02/08/02  Added an option to draw diffCoreImplant layer enclosing Diff layer
;;;   kmi 07/25/02  adding bBoxVia1, bBoxLayer2, emulateSlotVia and centerVia1 
;;;   dxj 12/19/02  Add diff/tap implant choices, contact choices
;;; 

(putpropqq drainContactPolImpClass "$Id: drainContactPolImpClass.il,v 1.6 2005/01/18 11:45:24 xvg Exp $ %T%" SCCS)

(tcCreateDeviceClass
 "symbolic"  "drainContactPolImpClass"
 ;;; Class parameters
 (
  (diffLayer          "hilite")
  (layer2             "prBoundary")
  (maxvLayer           nil)
  (viaLayer            nil)
  (viaWidth            0.0)
  (viaSpace            0.0)
  (diffREnc            0.0)    ;;; Right Side Enclosure of the contact by bottom layer. Should be contact
                               ;;; space to gate or minOverlap (for single ended Drain contact).
  (diffLEnc            0.0)    ;;; Left  Side Enclosure of the contact by bottom layer. Should be contact
                               ;;; space to gate.
  (diffYEnc            0.0)    ;;; Y Enclosure of te contact by bottom layer
  (layer2REnc          0.0)    ;;; Right Side Enclosure of the contact by top layer
  (layer2LEnc          0.0)    ;;; Left Side Enclosure of the contact by top layer
  (layer2YEnc          0.0)    ;;; Y Enclosure of the contact by top layer
  (layer2Width         0.0)    ;;; minWidth of layer2
  (diffImplant         nil)    ;;; diff implant layer list (inWell=nil:inWell=t)
  (diffImpXLEnc (list 0.0 0.0)) ;;; diff XL implant enclosure list (inWell=nil:inWell=t)
  (diffImpXREnc (list 0.0 0.0)) ;;; diff XR implant enclosure list (inWell=nil:inWell=t)
  (diffImpYEnc  (list 0.0 0.0)) ;;; diff Y implant enclosure list (inWell=nil:inWell=t)
 
  (diffCoreImplant         nil)    ;;; diff implant layer list (inWell=nil:inWell=t)
  (diffCoreImpXLEnc (list 0.0 0.0)) ;;; diff XL implant enclosure list (inWell=nil:inWell=t)
  (diffCoreImpXREnc (list 0.0 0.0)) ;;; diff XR implant enclosure list (inWell=nil:inWell=t)
  (diffCoreImpYEnc  (list 0.0 0.0)) ;;; diff Y implant enclosure list (inWell=nil:inWell=t)

  (diffImpEncList      nil)
  (wellLayer           nil)    ;;; the layer to be drawn for the well when inWell and implants are on
  (wellminWidth        0.0)    ;;; The min width of the well to be drawn
  (wellLayerEnc        0.0)    ;;; the amount by which the wellLayer must enclose diffLayer
  (emulateSlotVia   nil)  ; emulates layer2-via1 (diff) enclosure as it is with slotVias
  (centerVia1         nil)  ; center via1 (Y direction)
  (centerLayer2       nil)  ; center layer1 (Y direction)
  (snapGrid       (TECHgetProp snapGrid))
 )

 ;;; Formal Parameters
 (
  (w 0.0)
  (inWell        "FALSE")
  (implant       "FALSE")
  (diffImpChoice 0) ;; use (nth diffImpChoice diffImpEncList) to get the correct enclosures
 )




 ;; convert boolean parameters to either t or nil
 ;; this way we can use the simple (when parameter) syntax
 ;; and speed up pcell evaluation and make code simpler
 (if (or (equal implant t) (equal implant "TRUE")) then
   (setq implant t)
   else
   (setq implant nil)
   )
 (if (or (equal inWell t) (equal inWell "TRUE")) then
   (setq inWell t)
   else
   (setq inWell nil)
   )
  
 ;;; when purpose is not specified, ensure it is drawing.
 ;;; for all class layers.
 (when (stringp diffLayer)
     (setq diffLayer (list diffLayer "drawing"))
 )
 (when (stringp maxvLayer)
     (setq maxvLayer (list maxvLayer "drawing"))
 )
 (when (stringp viaLayer)
     (setq viaLayer (list viaLayer "drawing"))
 )
 (when (stringp layer2)
     (setq layer2 (list layer2 "drawing"))
 )
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;; DERIVE EFFECTIVE IMPLANT LAYERS AND INCLOSURES
 ;;; BASED ON POLARITY
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 ;; save some time if implants are off - not used then
 (when implant
   ;;;;;;;;;;;;;;;;;;;;;;
   ;;; DIFF LAYER IMPLANT
   ;;;;;;;;;;;;;;;;;;;;;;
     
     (when diffImplant
	 (if inWell then
	     (setq diffImplant    (cadr diffImplant))
	     (setq diffImpXLEnc   (cadr diffImpXLEnc))
	     (setq diffImpXREnc   (cadr diffImpXREnc))
	     (setq diffImpYEnc    (cadr diffImpYEnc))
	  else
	     (setq diffImplant    (car diffImplant))
	     (setq diffImpXLEnc   (car diffImpXLEnc))
	     (setq diffImpXREnc   (car diffImpXREnc))
	     (setq diffImpYEnc    (car diffImpYEnc))
	 )
     )
 
     (when diffCoreImplant
	 (if inWell then
	     (setq diffCoreImplant    (cadr diffCoreImplant))
	     (setq diffCoreImpXLEnc   (cadr diffCoreImpXLEnc))
	     (setq diffCoreImpXREnc   (cadr diffCoreImpXREnc))
	     (setq diffCoreImpYEnc    (cadr diffCoreImpYEnc))
	  else
	     (setq diffCoreImplant    (car diffCoreImplant))
	     (setq diffCoreImpXLEnc   (car diffCoreImpXLEnc))
	     (setq diffCoreImpXREnc   (car diffCoreImpXREnc))
	     (setq diffCoreImpYEnc    (car diffCoreImpYEnc))
	 )
     )
     
     
 )

 ;; 
 ;; The diff/tap imlant choice is decided as follows
 ;;
 ;; - The user choice is translated to diffImpChoice/tapImpChoice parameter by tran class
 ;; - Contact classes have diffImpChoice(formal param) and diffImpEncList(class param)
 ;; - The contact class uses (nth diffImpChoice diffImpEncList) to get the implant 
 ;;   enclosure corresponding to the choice
 ;; 
 (when implant
     ;; Use implant enclosure choices as a list of diffEncXL, diffEncXR, diffEncY
     (when diffImpEncList
	 (if inWell then
	     (setq encList (cadr (nth diffImpChoice diffImpEncList)))
	  else
	     (setq encList (car (nth diffImpChoice diffImpEncList)))
	 )
	 (setq diffImpXLEnc (nth 0 encList))
	 (setq diffImpXREnc (nth 1 encList))
	 (setq diffImpYEnc  (nth 2 encList))
     )
 )
 
 
 ;;; Create the net
 (setq netId (dbCreateNet tcCellView "pdd"))
 
 ;;; Set the diffLayerLen. We begin by the assumption, that the viaWidth + diffLEnc + diffREnc
 ;;; is always greater than the minWidth of diffLayer.
 (setq diffLen (plus viaWidth diffLEnc diffREnc))

 ;;; If the specifiedwidth of diffLayer is not wide enough to pass minimum needed to
 ;;; hold atleast one contact - then error.
 ;;; The drc should catch the problem, when the specified width is less than minimum.
 (when (greaterp (difference (plus viaWidth (times 2.0 diffYEnc)) w) 1e-6)
     (error (sprintf nil "Specified width %L is less than needed %L\n" w 
		     (plus viaWidth (times 2.0 diffYEnc))))
 )
 
 ;;; And create the rectangle
 (setq dbid (dbCreateRect tcCellView diffLayer (list 0:0 diffLen:w)))
 ;;; Create the pin for the new rectangle
 (dbCreatePin netId dbid)
 (dbCreateProp tcCellView "diffLayer" "ILList" diffLayer)
 (dbCreateProp tcCellView "diffLayerBbox"  "ILList" (list (list 0.0 0.0) (list diffLen w)))
 (when maxvLayer
     (dbCreateRect tcCellView maxvLayer (list 0:0 diffLen:w))
 )
 
 (when implant
   ;; draw the diff implant
   (when diffImplant
     (dbCreateRect tcCellView diffImplant
		   (list (list
			  (minus diffImpXLEnc)
			  (minus diffImpYEnc)
			  )
			 (list
			  (plus diffLen diffImpXREnc)
			  (plus w       diffImpYEnc)
			  )
			 ))
   ) ;; end when diffImplant
 
   (when diffCoreImplant
       (dbCreateRect tcCellView diffCoreImplant
		     (list (list
			  (minus diffCoreImpXLEnc)
			  (minus diffCoreImpYEnc)
			   )
			   (list
			    (plus diffLen diffCoreImpXREnc)
			    (plus w       diffCoreImpYEnc)
			  )
		     ))
   ) ;; end when diffCoreImplant
 
   ;; draw the well
   (when (and inWell wellLayer)
	   wellLayer_Xorigin = (minus wellLayerEnc)
	   wellLayer_Yorigin = (minus wellLayerEnc)
	   wellLayer_Xend = (plus diffLen wellLayerEnc)
	   wellLayer_Yend = (plus w       wellLayerEnc)

    	(when (wellLayer_Xend-wellLayer_Xorigin)< wellminWidth
		Diff_well_width = wellminWidth - (wellLayer_Xend-wellLayer_Xorigin)
		wellLayer_Xend = wellLayer_Xend + (Diff_well_width/2)
		wellLayer_Xorigin = wellLayer_Xorigin - (Diff_well_width/2)
	)
	(when (wellLayer_Yend-wellLayer_Yorigin)< wellminWidth
		Diff_well_width = wellminWidth - (wellLayer_Yend-wellLayer_Yorigin)
		wellLayer_Yend = wellLayer_Yend + (Diff_well_width/2)
		wellLayer_Yorigin = wellLayer_Yorigin - (Diff_well_width/2)
	)
 
     wellLayer_bBox = list(wellLayer_Xorigin:wellLayer_Yorigin wellLayer_Xend:wellLayer_Yend)


       (dbCreateRect tcCellView wellLayer wellLayer_bBox)
/*		  ( (list (list
			  (minus wellLayerEnc)
			  (minus wellLayerEnc)
			 )
			 (list
			  (plus diffLen wellLayerEnc)
			  (plus w       wellLayerEnc)
			 )
		   ))*/
   ) ;; end when inWell
 )  ;; end when implant
 
 ;;; Start Drawing the contacts. 
 ;;; The x and y direction coordinates will be calculated as per the min overlap
 ;;; parameters.
 (setq x1Coord diffLEnc)
 (setq x2Coord (plus diffLEnc viaWidth))
 (setq viaPitch (plus viaWidth viaSpace))
 
 
 ;;; While we can fit another via, given the yNotCovered
 (if centerVia1 then
     (setq viaDrawSpaceY (difference w (times diffYEnc 2)))
     (setq viaRow (floor (quotient  (plus viaDrawSpaceY viaSpace) viaPitch)))
     (if (equal viaRow 0) (setq viaRow 1))
     (setq viaYoffset (quotient (difference viaDrawSpaceY (difference (times viaRow viaPitch) viaSpace)) 2))
     (setq y1Coord (plus diffYEnc (times (fix (plus (quotient viaYoffset snapGrid) 1e-6)) snapGrid)))
     (setq theY y1Coord)
     (for r 1 viaRow
             (setq dbId (dbCreateRect tcCellView viaLayer
                                      (list  x1Coord:theY
                                             x2Coord:(plus theY viaWidth))))
             (dbAddFigToNet dbId netId)
             (setq theY (plus theY viaPitch))
     )
     (setq y2Coord (difference theY viaSpace))
     (dbCreateProp tcCellView "bBoxVia1" "list" (list x1Coord:y1Coord x2Coord:y2Coord))

  else
    ;;; yNotCovered will be used as a counter to find out how much of diffWidth
    ;;; has not been consumed by the contacts (viaWidth, viaSpace and 2 * diffYEnc).
    (setq y1Coord diffYEnc)
    (setq yNotCovered (difference w (times 2.0 diffYEnc)))
    (while (greaterp (difference yNotCovered viaWidth) -1e-6)
       ;;; find the topRight Y Coordinate of the via Rectangle
       (setq y2Coord (plus y1Coord viaWidth))
       ;;; and draw the via. Also add it to the net.
       (setq dbid (dbCreateRect tcCellView viaLayer (list x1Coord:y1Coord x2Coord:y2Coord)))
       (dbAddFigToNet dbid netId)
       ;;; Reset the lower left Y coordinate of the via box
       (setq y1Coord (plus y1Coord viaPitch))
       ;;; Also reset the diffWidth which is not yet covered
       (setq yNotCovered (difference yNotCovered viaPitch))
    )
    (dbCreateProp tcCellView "bBoxVia1" "list" (list x1Coord:diffYEnc x2Coord:y2Coord))
 )

 ;;; Set the length of layer2, should be enough to pass minWidth DRC 
 ;;; yet minimally cover the contact. The layer2REnc and layer2LEnc should
 ;;; be so specified such that the the minimum width in X direction is always
 ;;; satisfied.
 (setq layer2Len (max layer2Width (plus viaWidth layer2REnc layer2LEnc)))
 
 ;;; Set the width of layer2, should be wide enough to pass minWidth DRC 
 ;;; yet minimally cover the drawn contacts. This is derived from the 
 ;;; via lower Y coordinate = diffYEnc, the via top Y coordinate = y2Coord
 ;;; and the enclosure of via by layer2 in Y direction.
 
 (if centerLayer2 then
     (setq layer2lowerY (difference y1Coord layer2YEnc))
  else
     (setq layer2lowerY (difference diffYEnc layer2YEnc))
 )

 (setq layer2Wid (max layer2Width 
		      (difference (plus y2Coord layer2YEnc) layer2lowerY)				  
		      )
       )

 ;;; Draw the layer2 rectangle, ensuring that the minimum overlap requirements of the
 ;;; via is met.
 (setq x1Coord (difference x1Coord layer2LEnc))
 (setq x2Coord (plus x1Coord layer2Len))
 (if emulateSlotVia then
   (setq y1Coord (difference diffYEnc layer2YEnc))
   (setq y2Coord (plus (difference w diffYEnc) layer2YEnc))

  else
   (if centerVia1 then
       (setq y1Coord (difference y1Coord layer2YEnc))  ;; since lower via Coordinate is diffYEnc
    else
       (setq y1Coord (difference diffYEnc layer2YEnc))  ;; since lower via Coordinate is diffYEnc
   )
   (setq y2Coord (plus y1Coord layer2Wid))
 )
 (setq dbid (dbCreateRect tcCellView layer2 (list x1Coord:y1Coord x2Coord:y2Coord)))
 (dbCreatePin netId dbid)

 ;;; Create the properties, that will be used by the hierarchical devices to obtain
 ;;; properties.

 ;;; Since we have convereted layer2 to a list, we can use ILList. If we had left layer2
 ;;; to be the same as class parameter, then we should have used "list".
 (dbCreateProp tcCellView "topLayer" "ILList" layer2)
 (dbCreateProp tcCellView "topLayerPinBbox"  "ILList" (list (list x1Coord y1Coord) (list x2Coord y2Coord)))
 (dbCreateProp tcCellView "bBoxLayer2"  "ILList" (list (list x1Coord y1Coord) (list x2Coord y2Coord)))
)

(tfcDefineDeviceClassProp
;;(viewName       devClassName      propName          propValue)
;;;-------------------------------------------------------------------
 (symbolic        drainContactPolImpClass    function          "contact")
)
;;; 
;;; $Id: drainContact3PolImpClass.il,v 1.5 2002/08/05 21:06:27 kmi Exp $ %T%
;;; 
;;; drainContact3PolImpClass.il
;;; 
;;; Copyright (c) 1996 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Oct 21, 1996
;;; Author: Sanjay Rekhi/Senior CAD (syr) @ CSDC
;;; 
;;; Description:
;;;  Pcell code for the three layer drain Contact Class.
;;;  This code will be used to declare the three layer
;;;  single and double drain tiles for the hierarchical transistors.
;;;  When maxvLayer is non-nil (should be the name of the maxv idLayer = maxv "dg")
;;;
;;; Revision History:
;;;   syr 12/03/96  Eliminate the unused diffWidth parameter
;;;   gtc 12/05/96  Corrected minimum width check to account for floating
;;;                 point round off errors
;;;   gtc 05/05/97  Adding "centerVia2" and "via2Grid" parameters.
;;;   gtc 01/22/98  Copying over from v20
;;;   cry 07/31/01  Copied from drainContact3Class to allow polarized implants
;;;   cry 09/25/01  Added capabilty of specifying XL and XR and Y imp enclosures
;;;   lpn 02/08/02  Added an option to draw diffCoreImplant layer enclosing Diff layer
;;;   kmi 03/28/02  Adding bBoxVia1, bBoxLayer2, bBoxVia2
;;;   kmi 06/04/02  Adding bBoxLayer3 
;;;   kmi 07/25/02  added emulateSlotVia, centerVia1 and centerVia2
;;; 

(putpropqq drainContact3PolImpClass "$Id: drainContact3PolImpClass.il,v 1.5 2002/08/05 21:06:27 kmi Exp $ %T%" SCCS)

(tcCreateDeviceClass
 "symbolic"  "drainContact3PolImpClass"
 ;;; Class parameters
 (
  (diffLayer "hilite")
  (layer2 "prBoundary")
  (layer3 "hilite")
  (maxvLayer nil)              ;;; The non-nil parameter is the ("maxv" "drawing")
  (via1Layer "text")
  (via1Width 0.0)
  (via1Space 0.0)
  (via2Layer "text")
  (via2Width 0.0)
  (via2Space 0.0)
  (diffREncVia1 0.0)           ;;; Right Side Enclosure of the contact by bottom layer. Should be contact
                               ;;; space to gate or minOverlap (for single ended Drain contact).
  (diffLEncVia1 0.0)           ;;; Left  Side Enclosure of the contact by bottom layer. Should be contact
                               ;;; space to gate.
  (diffYEncVia1 0.0)           ;;; Y Enclosure of via1 by diff
  (layer2XEncVia1 0.0)         ;;; Right Side Enclosure of via1 by layer2 (middle layer)
  (layer2YEncVia1 0.0)         ;;; Y Enclosure of via1 by layer2 (middle layer)
  (layer2XEncVia2 0.0)         ;;; X Enclosure of via2 by layer2
  (layer2YEncVia2 0.0)         ;;; Y Enclosure of via2 by layer2
  ;;; Instead of worrying about the grids and always locking how layer3 should be
  ;;; drawn, give the flexibility to the engineer as to how the layer3 must be
  ;;; be drawn. We can now offset the layer3 based on Right/Left enclosures.
  (layer3REncVia2 0.0)         ;;; Right Enclosure of via2 by layer3 (top most layer)
  (layer3LEncVia2 0.0)         ;;; Left Enclosure of via2 by layer3 (top most layer)
  (layer3YEncVia2 0.0)         ;;; Y Enclosure of via2 by layer3 (top most layer)
  (layer2Width 0.0)            ;;; minWidth of layer2
  (layer3Width 0.0)            ;;; minWidth of layer3
  (centerVia2 "FALSE")         ;;; whether the via2 should be centered or if it
                               ;;; should have the same LL corner as via1
  (via2Grid 0.0)               ;;; This is only used when centerVia2 is true
  (diffImplant         nil)    ;;; diff implant layer list (inWell=nil:inWell=t)
  (diffImpXLEnc (list 0.0 0.0)) ;;; diff XL implant enclosure list (inWell=nil:inWell=t)
  (diffImpXREnc (list 0.0 0.0)) ;;; diff XR implant enclosure list (inWell=nil:inWell=t)
  (diffImpYEnc  (list 0.0 0.0)) ;;; diff Y implant enclosure list (inWell=nil:inWell=t)
  (diffCoreImplant         nil)    ;;; diff implant layer list (inWell=nil:inWell=t)
  (diffCoreImpXLEnc (list 0.0 0.0)) ;;; diff XL implant enclosure list (inWell=nil:inWell=t)
  (diffCoreImpXREnc (list 0.0 0.0)) ;;; diff XR implant enclosure list (inWell=nil:inWell=t)
  (diffCoreImpYEnc  (list 0.0 0.0)) ;;; diff Y implant enclosure list (inWell=nil:inWell=t)
  (wellLayer           nil)    ;;; the layer to be drawn for the well when inWell and implants are on
  (wellLayerEnc        0.0)    ;;; the amount by which the wellLayer must enclose diffLayer
  (emulateSlotVia   nil)  ; emulates layer2-via1 (diff) enclosure as it is with slotVias
  (centerVia1         nil)  ; center via1 (Y direction)
  (snapGrid       (TECHgetProp snapGrid)) ;; layers snapped to this grid after division
 )

 ;;; Formal Parameters
 (
  (w 0.0)
  (inWell        "FALSE")
  (implant       "FALSE")
 )
 
 ;; convert boolean parameters to either t or nil
 ;; this way we can use the simple (when parameter) syntax
 ;; and speed up pcell evaluation and make code simpler
 (if (or (equal implant t) (equal implant "TRUE")) then
   (setq implant t)
   else
   (setq implant nil)
   )
 (if (or (equal inWell t) (equal inWell "TRUE")) then
   (setq inWell t)
   else
   (setq inWell nil)
   )
 
 ;;; Create the net to be used throughout the class
 (setq netId (dbCreateNet tcCellView "pdd"))

 ;;; make sure that the layer parameters that will be passed on as properties
 ;;; of the master view are lists.
 (when (stringp diffLayer)
     (setq diffLayer (list diffLayer "drawing"))
 )
 (when (stringp layer3)
     (setq layer3 (list layer3 "drawing"))
 )
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;; DERIVE EFFECTIVE IMPLANT LAYERS AND INCLOSURES
 ;;; BASED ON POLARITY
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 ;; save some time if implants are off - not used then
 (when implant
   ;;;;;;;;;;;;;;;;;;;;;;
   ;;; DIFF LAYER IMPLANT
   ;;;;;;;;;;;;;;;;;;;;;;
   
   (when diffImplant
     (if inWell then
       (setq diffImplant    (cadr diffImplant))
       (setq diffImpXLEnc   (cadr diffImpXLEnc))
       (setq diffImpXREnc   (cadr diffImpXREnc))
       (setq diffImpYEnc    (cadr diffImpYEnc))
      else
       (setq diffImplant    (car diffImplant))
       (setq diffImpXLEnc   (car diffImpXLEnc))
       (setq diffImpXREnc   (car diffImpXREnc))
       (setq diffImpYEnc    (car diffImpYEnc))
       )
     )
   )
 
    (when diffCoreImplant
	 (if inWell then
	     (setq diffCoreImplant    (cadr diffCoreImplant))
	     (setq diffCoreImpXLEnc   (cadr diffCoreImpXLEnc))
	     (setq diffCoreImpXREnc   (cadr diffCoreImpXREnc))
	     (setq diffCoreImpYEnc    (cadr diffCoreImpYEnc))
	  else
	     (setq diffCoreImplant    (car diffCoreImplant))
	     (setq diffCoreImpXLEnc   (car diffCoreImpXLEnc))
	     (setq diffCoreImpXREnc   (car diffCoreImpXREnc))
	     (setq diffCoreImpYEnc    (car diffCoreImpYEnc))
	 )
     )

 ;;; Set the diffLen. We begin by the assumption, that the via1Width + diffLEnc + diffREnc
 ;;; is always greater than the minWidth of diffLayer.
 (setq diffLen (plus via1Width diffLEncVia1 diffREncVia1))

 ;;; If the width of the diffLayer is not wide enough to hold at least one contact - error.
 (when (greaterp (difference (plus via1Width (times 2.0 diffYEncVia1)) w) 1e-6)
     (error (sprintf nil "Specified width %f is less than that required %f\n"
		     w (plus via1Width (times 2.0 diffYEncVia1))))
 )
 ;;; And create the rectangle
 (setq dbid (dbCreateRect tcCellView diffLayer (list 0:0 diffLen:w)))

 (dbCreatePin netId dbid)
 (dbCreateProp tcCellView "diffLayer" "ILList" diffLayer)
 (dbCreateProp tcCellView "diffLayerBbox" "ILList" (list (list 0.0 0.0) (list diffLen w)))
 (when maxvLayer
     (dbCreateRect tcCellView maxvLayer (list 0:0 diffLen:w))
 )

 (when implant
   ;; draw the diff implant
   (when diffImplant
     (dbCreateRect tcCellView diffImplant
		   (list (list
			  (minus diffImpXLEnc)
			  (minus diffImpYEnc)
			  )
			 (list
			  (plus diffLen diffImpXREnc)
			  (plus w       diffImpYEnc)
			  )
			 ))
   ) ;; end when diffImplant
 

   (when diffCoreImplant
       (dbCreateRect tcCellView diffCoreImplant
		     (list (list
			    (minus diffCoreImpXLEnc)
			    (minus diffCoreImpYEnc)
			   )
			   (list
			    (plus diffLen diffCoreImpXREnc)
			    (plus w       diffCoreImpYEnc)
			   )
		     ))
   ) ;; end when diffCoreImplant
   
   ;; draw the well
   (when (and inWell wellLayer)
     (dbCreateRect tcCellView wellLayer
		   (list (list
			  (minus wellLayerEnc)
			  (minus wellLayerEnc)
			  )
			 (list
			  (plus diffLen wellLayerEnc)
			  (plus w       wellLayerEnc)
			  )
			 ))
   ) ;; end when inWell
 )  ;; end when implant

 ;;; Start Drawing the contacts. 
 ;;; The x and y coordinates will be calculated based on the 
 ;;; minimum overlap parameters.
 (setq x1Coord diffLEncVia1)
 (setq y1Coord diffYEncVia1)
 (setq x2Coord (plus diffLEncVia1 via1Width))
 (setq via1Pitch (plus via1Width via1Space))

 (if centerVia1 then
     (setq via1DrawSpaceY (difference w (times diffYEncVia1 2)))
     (setq via1Row (floor (quotient  (plus via1DrawSpaceY via1Space) via1Pitch)))
     (if (equal via1Row 0) (setq via1Row 1))
     (setq via1Yoffset (quotient (difference via1DrawSpaceY (difference (times via1Row via1Pitch) via1Space)) 2))
     (setq y1Coord (plus diffYEncVia1 (times (fix (plus (quotient via1Yoffset snapGrid) 1e-6)) snapGrid)))
     (setq theY y1Coord)
     (for r 1 via1Row
             (setq dbId (dbCreateRect tcCellView via1Layer
                                      (list  x1Coord:theY
                                             x2Coord:(plus theY via1Width))))
             (dbAddFigToNet dbId netId)
             (setq theY (plus theY via1Pitch))
     )
     (setq y2Coord (difference theY via1Space))

  else
     ;;; yNotCovered will be used as a counter to find out how much of w
     ;;; has not been consumed by the contacts (via1Width, via1Space and 2 * diffYEncVia1).
     (setq yNotCovered (difference w (times 2.0 diffYEncVia1)))

     ;;; While we can fit another via, given the yNotCovered
     (while (greaterp (difference yNotCovered via1Width) -1e-6)
        ;;; find the topRight Y Coordinate of the via Rectangle
        (setq y2Coord (plus y1Coord via1Width))
        ;;; and draw the via
        (setq dbid (dbCreateRect tcCellView via1Layer (list x1Coord:y1Coord x2Coord:y2Coord)))
        (dbAddFigToNet dbid netId)
        ;;; Reset the lower left Y coordinate of the via box
        (setq y1Coord (plus y1Coord via1Pitch))
        ;;; Also reset the diffWidth which is not yet covered
        (setq yNotCovered (difference yNotCovered via1Pitch))
    )
 )
 ;;; Add bBoxVia1 property here after all vias have been placed.
 ;;; bBox will include lower left coordinates of the first contact and upper right 
 ;;; coordinates of the last contact placed
 (dbCreateProp tcCellView "bBoxVia1" "list" (list diffLEncVia1:diffYEncVia1 x2Coord:y2Coord))

 ;;; Set the length of layer2, should be enough to pass minWidth DRC 
 ;;; minimally cover via1 and via2. Twice the layer2XEncVia1 should
 ;;; be so specified such that the the minimum width in X direction is always
 ;;; satisfied.
 (setq layer2Len (max layer2Width (plus via1Width (times 2.0 layer2XEncVia1))
		      (plus via2Width (times 2.0 layer2XEncVia2)))
 )
 
 ;;; Set the width of layer2, should be wide enough to pass minWidth DRC 
 ;;; and minimally cover the drawn via1 and via2 contacts
 ;;; This is derived from the lower Y coordinate of the via1: diffYEncVia1,
 ;;; the via1 top Y coordinate = y2Coord, and from via2 width plus twice the
 ;;; layer2YEncVia2 and the enclosure of via by layer2 in Y direction.

 ;;; find the number of via2's that can be drawn (at least 1)
 (setq numVia2 (max (fix (plus (quotient 
				;; effective width since the last via2Space is unneeded
				(plus w 
				      via2Space
				      ;; we don't want layer2 expanded just because of via2
				      (minus (plus layer2YEncVia2 layer2YEncVia2))
				      ;; we already have this little extra
				      (minus (difference  diffYEncVia1 layer2YEncVia1))
				      )
				;; divide by this
				(plus via2Width via2Space)
				)
			       ;; add a smidgen on so fix can't round down if it's
			       ;; already an integer
			       0.000001))
		    1 )
       )
 
 (setq layer2Wid (max layer2Width (difference (plus y2Coord layer2YEncVia1)
					      (difference diffYEncVia1 layer2YEncVia1))
		      (plus (times via2Width numVia2) ;;; all the via2's drawable
			    (times via2Space (difference numVia2 1))
			    (times 2.0 layer2YEncVia2)
			    )
		      )
 )

 

 ;;; Draw the layer2 Rectangle. 
 ;;; The layer2 coordinate is calculated such that it minimally encloses the via2.
 ;;; If we need to we can add another boolean parameter to offset the whole via2 and layer2
 ;;; combo, by subtracting layer2XEncVia1, rather than just the layer2XEncVia2
 ;;; (unless via2Offset (setq x1Coord (difference x1Coord layer2XEncVia1))
 (cond ((and centerVia2 (nequal centerVia2 "FALSE"))
	(setq halfVia2Grid (quotient via2Grid 2.0))
	(setq x1Coord (plus x1Coord -layer2XEncVia2 (quotient (difference via1Width via2Width) 2.0)))
	(when (oddp (fix (plus 0.99 (quotient x1Coord halfVia2Grid))))
	    (setq x1Coord (times halfVia2Grid (fix (plus 1.99 (quotient x1Coord halfVia2Grid)))))
	)
       )
     (t
      (setq x1Coord (difference x1Coord layer2XEncVia2))
     )
 )
 (setq x2Coord (plus x1Coord layer2Len))
 (if emulateSlotVia then
   (setq y1Coord (difference diffYEncVia1 layer2YEncVia1))
   (setq y2Coord (plus (difference w diffYEncVia1) layer2YEncVia1))
  else
   (if centerVia1 then 
      (setq y1Coord (difference y1Coord layer2YEncVia1))  ;; since lower via Coordinate is diffYEnc
    else
      (setq y1Coord (difference diffYEncVia1 layer2YEncVia1))  ;; since lower via Coordinate is diffYEnc
   )
   (setq y2Coord (plus y1Coord layer2Wid))
 ) 

 (setq dbid (dbCreateRect tcCellView layer2 (list x1Coord:y1Coord x2Coord:y2Coord)))
 ;;; add property
 (dbCreateProp tcCellView "bBoxLayer2" "list" (list x1Coord:y1Coord x2Coord:y2Coord))

 (dbCreatePin netId dbid)

;;; DRAW VIA2
 (setq via2Pitch (plus via2Width via2Space))
 (setq via2LowerX (plus x1Coord layer2XEncVia2))
 (setq x1Coord via2LowerX)
 (setq x2Coord (plus x1Coord via2Width))
 (if emulateSlotVia then
     (setq via2Row (floor (quotient w via2Pitch)))
     (if (equal via2Row 0) (setq via2Row 1))
     (setq via2Yoffset (quotient (difference w (difference (times via2Row via2Pitch) via2Space)) 2))
     (setq via2LowerY (times (fix (plus (quotient via2Yoffset snapGrid) 1e-6)) snapGrid))
     (setq theY via2LowerY)
     (for r 1 via2Row
             (setq dbId (dbCreateRect tcCellView via2Layer
                                      (list  x1Coord:theY
                                             x2Coord:(plus theY via2Width))))
             (dbAddFigToNet dbId netId)
             (setq theY (plus theY via2Pitch))
     )
     (setq y2Coord (difference theY via2Space))

  else

    ;;; Based on the layer2width start drawing the via2 contacts.
    (setq via2LowerY (plus y1Coord layer2YEncVia2)) ;; We need this to calculate layer3
    (setq y1Coord via2LowerY)

    ;;; yNotCovered will be used as a counter to find out how much of layer2Wid
    ;;; has not been consumed by the contacts (via2Width, via2Space and 2 * layer2YEncVia2).
    (setq yNotCovered (difference layer2Wid (times 2.0 layer2YEncVia2)))

    ;;; While we can fit another via, given the yNotCovered
    (while (greaterp (difference yNotCovered via2Width) -1e-6)
     ;;; find the topRight Y Coordinate of the via Rectangle
     (setq y2Coord (plus y1Coord via2Width))
     ;;; and draw the via
     (setq dbid (dbCreateRect tcCellView via2Layer (list x1Coord:y1Coord x2Coord:y2Coord)))
     (dbAddFigToNet dbid netId)
     ;;; Reset the lower left Y coordinate of the via box
     (setq y1Coord (plus y1Coord via2Pitch))
     ;;; Also reset the layer2Width which is not yet covered
     (setq yNotCovered (difference yNotCovered via2Pitch))
    )
 )
 ;;; Add bBoxVia2 property here after all vias have been placed.
 ;;; bBox will include lower left coordinates of the first contact and upper right 
 ;;; coordinates of the last contact placed
 (dbCreateProp tcCellView "bBoxVia2" "list" (list via2LowerX:via2LowerY x2Coord:y2Coord))

 ;;; Now layer3 needs to be drawn to cover the via2 contacts, such that it passes
 ;;; the minimum width DRC, and minimally cover the via2 in X and Y directions.
 (setq layer3Len (max layer3Width (plus via2Width layer3REncVia2 layer3LEncVia2)))
 
 (setq layer3Wid (max layer3Width (difference (plus y2Coord layer3YEncVia2)
					      (difference via2LowerY layer3YEncVia2)))
 )

 ;;; Draw the layer3 Rectangle.

 (setq x1Coord (difference x1Coord layer3LEncVia2))
 (setq x2Coord (plus x1Coord layer3Len))
 (setq y1Coord (difference via2LowerY layer3YEncVia2))
 (setq y2Coord (plus y1Coord layer3Wid))

 (setq dbid (dbCreateRect tcCellView layer3 (list x1Coord:y1Coord x2Coord:y2Coord)))

 (dbCreatePin netId dbid)

 ;;; Create the properties, that will be used by the hierarchical devices to obtain
 ;;; the neccessary properties.

 (dbCreateProp tcCellView "topLayer" "list" layer3)
 (dbCreateProp tcCellView "topLayerPinBbox"  "ILList" (list (list x1Coord y1Coord) (list x2Coord y2Coord)))

 ;;; some contacts may have only two layers (topLayerPinBbox then refers to layer2),
 ;;;  so to precisely identify layer3: 
 (dbCreateProp tcCellView "bBoxLayer3"  "ILList" (list (list x1Coord y1Coord) (list x2Coord y2Coord)))
 
)

(tfcDefineDeviceClassProp
;;(viewName       devClassName      propName          propValue)
;;;-------------------------------------------------------------------
 (symbolic        drainContact3PolImpClass    function          "contact")
)
;;; 
;;; $Id: drainOnlyClass.il,v 1.3 2005/01/18 11:45:24 xvg Exp $ %T%
;;; 
;;; drainOnlyClass.il
;;; 
;;; Copyright (c) 1996 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Oct 24, 1996
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This is the drain only device for the device library.  It is used to
;;; create the transistor devices nDrainOnly, pDrainOnly, and dDrainOnly.
;;;  It will have tap for the source, and diff for the drain.  It can
;;; optionally handle user specified contacts over the source and drain
;;; regions.
;;; 
;;; Revision History:
;;;   gtc 01/13/97  debugged well enclosure on tap side
;;;   gtc 01/22/98  Copying over from v20
;;;   xgs 09/29/00  Changing polyExt to formal parameter ( SPR 7745 )
;;; 
;;; 

(tcCreateDeviceClass
 "symbolic" "drainOnlyClass"
 ;;; Class parameters
 (
  (diffLayer "hilite") ; the layer the diffusion is drawn in
  (gateLayer "marker") ; the layer the gate is drawn in
  (tapLayer "y4")      ; the layer the tap is drawn in
  (wellLayer nil)      ; the optional layer the well is drawn in
  (wellminWidth   0.0) ; the Optional well Layer min width
  (depLayer nil)       ; the optional layer the depletion is drawn in
  (diffExt  0.0)       ; the extension of diffusion beyond the gate
  (tapExt   0.0)       ; the extension of tap beyond the gate
  (wellEncDiff 0.0)    ; the minimum enclosure of diff by well
  (wellEncTap 0.0)     ; the minimum enclosure of tap by well
  (depEncDiff 0.0)     ; the minimum enclosure of diff by depletion
  (depEncGate 0.0)     ; the minimum enclosure of gate by depletion
 )
 ;;; Formal parameters
 (
  (drainContact "")    ; the optional contact to attach to the drain
  (sourceContact "")   ; the optional contact to attach to the source
  (polyExt   0.0)      ; the extension of poly beyond the diffusion
  (srcOffset 0.0)      ; the X offset of the source contact
  (drnOffset 0.0)      ; the X offset of the drain contact
  (l 0.0)              ; the length of the drain only device
  (w 0.0)              ; the width of the drain only device
  (tapSource t)        ; whether there is a tap source
 )

 (setq gNet (dbCreateNet tcCellView "g"))
 (setq sNet (dbCreateNet tcCellView "s"))
 (setq dNet (dbCreateNet tcCellView "d"))

 (setq srcConId (setq drnConId (setq srcPinId (setq drnPinId nil))))

 (when (stringp diffLayer)
     (setq diffLayer (list diffLayer "drawing"))
 )

 ;;; get the dbids of the named contacts
 ;;; first the endSource contact, see if the field is defined and get the id
 ;;; If cannot find the cell -- error. The cell should be in the same library
 ;;; as the current pcell is.
 (when (nequal sourceContact "")
     (setq srcConId (dbOpenCellView tcCellView~>lib sourceContact "symbolic" nil "rn"))
     (unless srcConId
	 (error (strcat "Cannot find/open sourceContact contact cell `" sourceContact "'"))
     )
 )

 ;;; next the endDrain contact, see if the field is defined and get the id.
 ;;; If cannot find the cell -- error. The cell should be in the same library
 ;;; as the current pcell is.
 (when (nequal drainContact "")
     (setq drnConId (dbOpenCellView tcCellView~>lib drainContact "symbolic" nil "rn"))
     (unless drnConId
	 (error (strcat "Cannot find/open drainContact contact cell `" drainContact "'"))
     )
 )

 ;;; Create the source contact
 (cond ((equal tapSource "TRUE")

	(setq tapXorigin -tapExt)

	; if a source contact is specified, place an instance of it
	(when srcConId
	    (setq inst (dbCreateParamInst tcCellView srcConId "c0"
					  (minus srcOffset):0 "MY" 1
					  (list (list "w" "float" w)))
	    )
	    (unless inst
		(error "Failed to create instance of source contact")
	    )

	    ; make sure the source contact contains the correct properties
	    ; that are needed to place the pin and handle the well enclosure
	    (when (and (setq master inst~>master)
		       (setq topBbox master~>topLayerPinBbox)
		       (setq topLayer master~>topLayer)
		       (setq diffBbox master~>diffLayerBbox))

		; create a pin at this level of the hierarchy identical to
		; the one on the top layer of the source contact
		dbId = (dbCreateRect tcCellView
				     topLayer
				     (list (difference 0.0 srcOffset (caar topBbox)):(cadar topBbox)
					   (difference 0.0 srcOffset (caadr topBbox)):(cadadr topBbox)))
		(dbAddFigToNet dbId sNet)
		srcPinId = (dbCreatePin sNet dbId)

		; make sure that there is not a gap in the tap between
		; the source tap and the source contact's tap
		(setq tapXorigin (min -tapExt (difference 0.0 srcOffset
							  (max (caar diffBbox) (caadr diffBbox)))))

		; make sure the well enclosure is satisfied around
		; the source contact.  
		(setq wellXorigin (min -wellEncDiff
				   (difference 0.0 wellEncTap
					       (max tapExt 
						    (plus srcOffset
							  (max (caar diffBbox)
							       (caadr diffBbox)))))))
		(setq wellYorigin (min (difference 0.0 wellEncTap
						   (min 0.0 (cadar diffBbox) (cadadr diffBbox)))
				       -wellEncTap))
		(setq wellYend (max (plus wellEncTap
					  (max (cadar diffBbox) (cadadr diffBbox)))
				    (plus w wellEncTap)))

	    )
	)

	; add the tap on the source side at this level of the hierarchy
	dbId = (dbCreateRect tcCellView tapLayer (list tapXorigin:0.0 0.0:w))
	(dbAddFigToNet dbId sNet)
	(unless srcPinId
	    pinId = (dbCreatePin sNet dbId)
	    pinId~>accessDir = (list "left")
	    (setq wellXorigin (difference 0.0 tapExt wellEncTap))
	    (setq wellYorigin (min -wellEncDiff -wellEncTap))
	    (setq wellYend (difference w wellYorigin))
	)
       )
     (t
      ; when there is not a source contact, you don't have to worry about
      ; satisfying the well enclosure around the contact.
      (setq wellXorigin -wellEncDiff)
      (setq wellYorigin -wellEncDiff)
      (setq wellYend (difference w wellYorigin))
     )
 )

 ;;; Create the gate in 3 stages:  over the diff, bottom pin, top pin
 dbId = (dbCreateRect tcCellView gateLayer (list 0.0:0.0 l:w))
 (dbAddFigToNet dbId gNet)

 dbId = (dbCreateRect tcCellView gateLayer (list 0.0:-polyExt l:0.0))
 (dbAddFigToNet dbId gNet)
 pinId = (dbCreatePin gNet dbId)
 pinId~>accessDir = (list "bottom")

 dbId = (dbCreateRect tcCellView gateLayer (list 0.0:w l:(plus w polyExt)))
 (dbAddFigToNet dbId gNet)
 pinId = (dbCreatePin gNet dbId)
 pinId~>accessDir = (list "top")

 ;;; Create the diff under the gate
 dbId = (dbCreateRect tcCellView diffLayer (list 0.0:0.0 l:w))

 (setq diffXend (plus l diffExt))

 ;;; Create the drain contact
 (when drnConId
     (setq inst (dbCreateParamInst tcCellView drnConId "c1"
				   (plus l drnOffset):0 "0" 1
				   (list (list "w" "float" w)))
     )
     (unless inst
	 (error "Failed to create instance of drain contact")
     )

     (when (and (setq master inst~>master)
		(setq topBbox master~>topLayerPinBbox)
		(setq topLayer master~>topLayer)
		(setq diffBbox master~>diffLayerBbox))
	 dbId = (dbCreateRect tcCellView topLayer
			      (list (plus l drnOffset (caar topBbox)):(cadar topBbox)
				    (plus l drnOffset (caadr topBbox)):(cadadr topBbox)))
	 (dbAddFigToNet dbId dNet)
	 drnPinId = (dbCreatePin dNet dbId)

	 (setq diffXend (plus l (max diffExt (plus drnOffset (max (caar diffBbox) (caadr diffBbox))))))

	 (setq wellXend (plus l wellEncDiff
			      (max diffExt
				   (plus drnOffset (max
						    (caar diffBbox)
						    (caadr diffBbox))))))
	 (setq wellYorigin (min wellYorigin
			       (difference 0.0 wellEncDiff
					   (min (cadar diffBbox)
						(cadadr diffBbox)))))
	 (setq wellYend (max wellYend
			    (plus wellEncDiff (max (cadar diffBbox)
						   (cadadr diffBbox)))))
	 (when (setq tapBbox master~>tapLayerBbox)
	     (setq wellYorigin (min wellYorigin
				    (difference (min (cadar tapBbox)
						     (cadadr tapBbox))
						wellEncTap)))
	     (setq wellYend (max wellYend
				 (plus wellEncTap (max (cadar tapBbox)
						       (cadadr tapBbox)))))
	     (setq wellXend (max wellXend
				 (plus l drnOffset wellEncTap (max (caar tapBbox)
								   (caadr tapBbox)))))
	 )
     )
 )
 dbId = (dbCreateRect tcCellView diffLayer (list l:0.0 diffXend:w))
 (dbAddFigToNet dbId dNet)
 (unless drnPinId
     pinId = (dbCreatePin dNet dbId)
     pinId~>accessDir = (list "right")
     (setq wellXend (plus l diffExt wellEncDiff))
 )

 ;;; Create the well
 (when wellLayer
	(when (wellXend-wellXorigin)< wellminWidth
		Diff_well_width = wellminWidth - (wellXend-wellXorigin)
		wellXend = wellXend + (Diff_well_width/2)
		wellXorigin = wellXorigin - (Diff_well_width/2)
	)
	(when (wellYend-wellYorigin)< wellminWidth
		Diff_well_width = wellminWidth - (wellYend-wellYorigin)
		wellYend = wellYend + (Diff_well_width/2)
		wellYorigin = wellYorigin - (Diff_well_width/2)
	)


     dbId = (dbCreateRect tcCellView wellLayer
			  (list wellXorigin:wellYorigin wellXend:wellYend))
 )

 ;;; Create the depletion
 (when depLayer
     dbId = (dbCreateRect tcCellView depLayer
			  (list -depEncDiff:-depEncGate
				(plus l depEncDiff):(plus w depEncGate)))
 )

)

;;; 
;;; $Id: enDstrap3PolImpClass.il,v 1.4 2003/02/12 09:51:38 dxj Exp $ %T%
;;; 
;;; enDstrap3PolImpClass.il
;;; 
;;; Copyright (c) 1996 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Sep 19, 1996
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This file defines the class for the double sided strapping
;;; power contacts that require square vias.  This should be used
;;; in technologies that require the vias to be square, such as Ram3.
;;; 
;;; 
;;; Revision History:
;;;   gtc 12/17/96  Updates from review.  Allow smaller w by pushing out
;;;                 the tip tap contacts.  Also, changing the names of
;;;                 tap enclosure parameters to more comprehendable items
;;;   gtc 01/13/97  Debugging tip tap contact spacing
;;;   gtc 01/22/98  Copying over from v20
;;;   xgs 06/16/00  Adding option for placing mcons only over diff ( not on tip_taps )
;;;   cry 08/27/01  Adding implants and the option to place the tap between two pieces
;;;                 of diff
;;;   hai 10/23/01  Fixed mismatch parens (SPR 9938)
;;;   kmi 06/21/02  Correcting a bug: via1 contacts were not drawn when 
;;;                 diff/tapWidth-via1Enc==via1Enc 
;;;   kmi 07/25/02  adding emulateSlotVia, centerVia1 and centerVia2
;;;   dxj 12/19/02  Add diff/tap implant choices, contact choices
;;;

(putpropqq enDstrap3PolImpClass "$Id: enDstrap3PolImpClass.il,v 1.4 2003/02/12 09:51:38 dxj Exp $ %T%" SCCS)

(tcCreateDeviceClass
 "symbolic" "enDstrap3PolImpClass"
 ;; class parameters
 (
  (diff "hilite")               ; the layer to draw the diff in
  (tap "prBoundary")            ; the layer to draw the tap in
  (layer2 ("marker" "warning")) ; the layer to draw layer2 in
  (layer3 nil)                  ; the layer to draw layer3 in
  (via1Layer ("marker" "error")); the layer to draw the via1's in
  (via2Layer nil)               ; the layer to draw the via2's in
  (centerRecognition nil)       ; the layer to draw the center tap rec. in
  (diffWidth 0.0)               ; the minimum width of diffusion
  (tapWidth 0.0)                ; the minimum width of tap
  (tapWidthBetweenDiff 0.0)     ; the minimum width of tap between diffusion
  (tapWidthButtingDiff 0.0)     ; the minimum width of tap butting diffusion
  (layer2Width 0.0)             ; the minimum width of layer2
  (layer3Width 0.0)             ; the minimum width of layer3
  (via1Width 0.0)               ; the minimum width of via1
  (via2Width 0.0)               ; the minimum width of via2
  (via1Space 0.0)               ; the minimum space between via1's
  (via2Space 0.0)               ; the minimum space between via2's
  (diffYEncVia 0.0)             ; the minimum Y enclosure of via1 by diff
  (diffXEncVia 0.0)             ; the minimum X enclosure of via1 by diff
  (diffXOutEncVia 0.0)          ; min X enc of via1 by diff (outside) (centerTap only)
  (tipTapYInEncVia 0.0)         ; the minimum Y enclosure of via1 by tip tap
                                ; on the edge butting diffusion
  (tipTapYOutEncVia 0.0)        ; the minimum Y enclosure of via1 by tip tap
                                ; on the edge opposite diffusion
  (tipTapXEncVia 0.0)           ; the minimum X enclosure of via1 by tip tap
  (centerTapXEncVia 0.0)        ; the minimum X enclosure of via1 by center tap
  (centerTapYEncVia 0.0)        ; the minimum Y enclosure of via1 by center tap
  (layer2XEncVia 0.0)           ; the minimum X enclosure of via1 by layer2
  (layer2YEncVia 0.0)           ; the minimum Y enclosure of via1 by layer2
  (layer2XEncVia2 0.0)          ; the minimum X enclosure of via2 by layer2
  (layer2YEncVia2 0.0)          ; the minimum Y enclosure of via2 by layer2
  (layer3XEncVia2 0.0)          ; the minimum X enclosure of via2 by layer3
  (layer3YEncVia2 0.0)          ; the minimum Y enclosure of via2 by layer3
  (tapSpaceGate 0.0)            ; the minimum space between the center taps and the poly
  (tapSpacePoly 0.0)            ; the minimum space between the tip taps and poly
  (maxDiffToTapContactSpace 99999.9)
  (halfDiffusionGrid 0.0)
  (minPinWidth 0.05)
  (diffImplant         nil)       ; diff implant layer list (inWell=nil:inWell=t)
  (diffImpEnc     (list 0.0 0.0)) ; diff implant enclosure list (inWell=nil:inWell=t)
  (diffImpEncButt (list 0.0 0.0)) ; diff implant butting enclosure list (inWell=nil:inWell=t)
  (tapImplant          nil)       ; tap  implant layer list (inWell=nil:inWell=t)
  (tapImpEnc      (list 0.0 0.0)) ; tap  implant enclosure list (inWell=nil:inWell=t)
  (tapImpEncButt  (list 0.0 0.0)) ; tap  implant butting enclosure list (inWell=nil:inWell=t)
  (diffImpEncList      nil)
  (tapImpEncList       nil)
  (wellLayer           nil) ; the layer to be drawn for the well when inWell and implants are on
  (wellLayerDiffEnc    0.0) ; the amount by which the wellLayer must enclose diff
  (wellLayerTapEnc     0.0) ; the amound by which the wellLayer must enclose tap
  (snapGrid       (TECHgetProp snapGrid))
  (emulateSlotVia   nil)  ; emulates layer2-via1 (diff) enclosure as it is with slotVias
  (centerVia1         nil)  ; center via1 (Y direction)
  (centerVia2         nil)  ; center via2 (Y direction)
  (centerLayer2       nil)  ; center layer2 (Y direction)
 )

 ; the maxDiffToTapContactSpace should be slightly smaller than the
 ; actual value in the TDR.  If the TDR value is maxDiffToTapTDR,
 ; the value passed as maxDiffToTapContactSpace should satisfy:
 ;
 ; (setq halfLength (max halfLength
 ;		       (plus (max (quotient tapWidthBetweenDiff 2.0)
 ;				  (plus (quotient via1Width 2.0) centerTapXEncVia))
 ;			     (max tapSpaceGate tapSpacePoly))))
 ; (setq maxDiffToTapContactSpace
 ;       (sqrt (difference (times maxDiffToTapTDR maxDiffToTapTDR)
 ;			 (times halfLength halfLength))))
 ;
 ; It should be passed as a parameter so that it will be calculated once
 ; by a CAD guy rather than a gazillion times by each submaster.  The
 ; number does not have to be on grid.
 ;

 ;; formal parameters
 (
  (w 0.0)
  (implant t)
  (inWell "FALSE")
  (centerTap "FALSE")
  (topEndTap t)
  (bottomEndTap t)
  (noDiffContact "FALSE") ;; works only on "side tap"
  (allowCenteredMCONs "FALSE")
  (diffImpChoice 0) ;; use (nth diffImpChoice diffImpEncList) to get the correct enclosures
  (tapImpChoice  0)
 )
 
 ;; convert boolean parameters to either t or nil
 ;; this way we can use the simple (when parameter) syntax
 ;; and speed up pcell evaluation and make code simpler
 (if (or (equal implant t) (equal implant "TRUE")) then
   (setq implant t)
   else
   (setq implant nil)
   )
 (if (or (equal inWell t) (equal inWell "TRUE")) then
   (setq inWell t)
   else
   (setq inWell nil)
   )
 (if (or (equal centerTap t) (equal centerTap "TRUE")) then
   (setq centerTap t)
   else
   (setq centerTap nil)
   )
 (if (or (equal topEndTap t) (equal topEndTap "TRUE")) then
   (setq topEndTap t)
   else
   (setq topEndTap nil)
   )
 (if (or (equal bottomEndTap t) (equal bottomEndTap "TRUE")) then
   (setq bottomEndTap t)
   else
   (setq bottomEndTap nil)
   )
 (if (or (equal allowCenteredMCONs t) (equal allowCenteredMCONs "TRUE")) then
   (setq allowCenteredMCONs t)
   else
   (setq allowCenteredMCONs nil)
   )

 (setq noDiffContact (equal noDiffContact "TRUE"))

 (setq via1Pitch (plus via1Width via1Space))
 (setq via2Pitch (plus via2Width via2Space))

 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;; DERIVE EFFECTIVE IMPLANT LAYERS AND INCLOSURES
 ;;; BASED ON POLARITY
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 ;; save some time if implants are off - not used then
 (when implant
   ;;;;;;;;;;;;;;;;;;;;;;
   ;;; DIFF LAYER IMPLANT
   ;;;;;;;;;;;;;;;;;;;;;;
   
   (when diffImplant
     (if inWell then
       (setq diffImplant    (cadr diffImplant))
       (setq diffImpEnc     (cadr diffImpEnc))
       (setq diffImpEncButt (cadr diffImpEncButt))
       else
       (setq diffImplant    (car diffImplant))
       (setq diffImpEnc     (car diffImpEnc))
       (setq diffImpEncButt (car diffImpEncButt))
       )
     )
   
   ;;;;;;;;;;;;;;;;;;;;;;
   ;;; TAP LAYER IMPLANT
   ;;;;;;;;;;;;;;;;;;;;;;
   (when tapImplant
     (if inWell then
       (setq tapImplant     (cadr tapImplant))
       (setq tapImpEnc      (cadr tapImpEnc))
       (setq tapImpEncButt  (cadr tapImpEncButt))
       else
       (setq tapImplant     (car tapImplant))
       (setq tapImpEnc      (car tapImpEnc))
       (setq tapImpEncButt  (car tapImpEncButt))
       )
     )
 ) ;; end when implant

 ;; 
 ;; The diff/tap imlant choice is decided as follows
 ;;
 ;; - The user choice is translated to diffImpChoice/tapImpChoice parameter by tran class
 ;; - Contact classes have diffImpChoice(formal param) and diffImpEncList(class param)
 ;; - The contact class uses (nth diffImpChoice diffImpEncList) to get the implant 
 ;;   enclosure corresponding to the choice
 ;; 
 (when implant
     ;; Use implant enclosure choices as a list of diffEncXL, diffEncXR, diffEncY
     (when diffImpEncList
	 (if inWell then
	     (setq encList (cadr (nth diffImpChoice diffImpEncList)))
	  else
	     (setq encList (car (nth diffImpChoice diffImpEncList)))
	 )
	 (setq diffImpEncXL (nth 0 encList))
	 (setq diffImpEncXR (nth 1 encList))
	 (setq diffImpEncY  (nth 2 encList))
     )

     (when tapImpEncList
	 (if inWell then
	     (setq encList (cadr (nth tapImpChoice tapImpEncList)))
	  else
	     (setq encList (car (nth tapImpChoice tapImpEncList)))
	 )
	 (setq tapImpEncXL (nth 0 encList))
	 (setq tapImpEncXR (nth 1 encList))
	 (setq tapImpEncY  (nth 2 encList))
     )

     ;; Set the XL,XR and Y enclosures for diff/tap implants
     ;; If they are not existing, then initialize them to diffImpEnc/tapImpEnc
     
     (setq diffImpEncY  (or (and (boundp 'diffImpEncY) diffImpEncY) diffImpEnc))
     (setq diffImpEncXL (or (and (boundp 'diffImpEncXL) diffImpEncXL) diffImpEnc))
     (setq diffImpEncXR (or (and (boundp 'diffImpEncXR) diffImpEncXR) diffImpEnc))

     (setq tapImpEncY   (or (and (boundp 'tapImpEncY) tapImpEncY) tapImpEnc))
     (setq tapImpEncXL  (or (and (boundp 'tapImpEncXL) tapImpEncXL) tapImpEnc))
     (setq tapImpEncXR  (or (and (boundp 'tapImpEncXR) tapImpEncXR) tapImpEnc))

 ) ; end when implant

 ;; brief sanity check preventing tip taps and center taps at the same time
 (if (and centerTap (or topEndTap bottomEndTap)) then
   (error "enDstrap3PolImpClass: cannot select centerTap at the same time as topEndTap or bottomEndTap\n")
 )
 
 ; a brief description of the variables used:
 ;
 ; allDir - list of right, left, top, and bottom
 ; centerDiffConYoffset - top enclosure of diff of the contact just below a center tap
 ; centerTaps - boolean of whether it has drawn any center taps yet
 ; diffConYoffsetAbuttingTap - after it draws a center tap, draw the above diffusion contact starting this much above the top of the center tap
 ; diffDelta - the width of the diffusion that it is going to draw for the current segment
 ; diffXend - the X end for the diffusion
 ; diffXorigin - the X origon for the diffusion
 ; doubleMaxDistanceToTap - 2 * maxDiffToTapContactSpace
 ; firstDiffConYoffset - how much the first diffusion contact in the lowermost diff (before any center taps) will be enclosed by diff in the Y direction
 ; hasTapInCenter - boolean of whether this width requires a center tap
 ; lastDiffConYoffset - minimum of how much the last (topmost) diffusion contact must be enclosed by diffusion in the Y direction
 ; maxConsecDiffContacts - integer, the maximum number of consecutive diff contacts that it can place before it has to place a center tap
 ; net - the net that the pcell is attached to
 ; tapXend - the X end for center tap
 ; tapXorigin - the X origin for center tap
 ; tapYoffset - the Y width to make the top and bottom taps
 ; tbTapXend - the X end for the top and bottom tip taps
 ; tbTapXorigin - the X origon for the top & bottom tip taps
 ; vai1Xend - the X end for the via1 contacts
 ; via1Xorigin - the X origin for the via1 contacts
 ; yValue - as it is drawing the dstrap from bottom to top, yValue is the current location of how far up it has advanced
 ; yRemaining - the width of the strap - yValue
 ; yVia1Offset - the pitch of the via1s: via1Space + via1Width


 (setq net (dbMakeNet tcCellView "ppd"))
 (dbCreateTerm net "ppd" "input")
 (setq allDir (list "right" "left" "top" "bottom"))

 ; a center tap is required if the width is > twice the maximum
 ; distance of diffusion from a tap contact 
 ; we don't use this method when centerTap is selected
 (setq hasTapInCenter
       (and (greaterp (difference (plus w (times 2 tipTapYInEncVia))
			     (times 2 maxDiffToTapContactSpace)) -1e-6)
	    (null centerTap)))

 (cond (hasTapInCenter
	;; now that a center tap is required, the objective is to maxamize
	;; the number of contacts that it places.
	(setq doubleMaxDistanceToTap (times 2 maxDiffToTapContactSpace))
	
	;; make sure that the tapWidthBetweenDiff is an even multiple of grid
	(when (oddp (fix (plus 1e-5 (quotient tapWidthBetweenDiff (times 2.0 halfDiffusionGrid)))))
	  (setq tapWidthBetweenDiff (plus tapWidthBetweenDiff (times 2.0 halfDiffusionGrid)))
	)
	
	(setq maxConsecDiffContacts
	      (fix (quotient
		    (plus maxDiffToTapContactSpace
			  (times -2.0 (max via1Space
					   (plus diffYEncVia tipTapYInEncVia)))
			  via1Space)
		    (plus via1Width via1Space))))
	(setq via1Xorigin (max diffXEncVia
			       (plus (quotient (difference tapWidthBetweenDiff via1Width) 2.0)
				     (max tapSpacePoly tapSpaceGate))
			       (plus centerTapXEncVia (max tapSpacePoly tapSpaceGate))))
	(setq via1Xend (plus via1Xorigin via1Width))
	
	(setq tapXorigin (min (difference via1Xorigin centerTapXEncVia)
			      (max tapSpaceGate tapSpacePoly)))
	
	(setq tapXend (max (plus tapXorigin tapWidthBetweenDiff)
			   (plus via1Xend centerTapXEncVia)))
	
	)
       (centerTap 
	;; this option is for tap between the two pieces of diff (always)
	
	;; make sure that the tapWidthBetweenDiff is an even multiple of grid
	(when (oddp (fix (plus 1e-5 (quotient tapWidthBetweenDiff (times 2.0 halfDiffusionGrid)))))
	  (setq tapWidthBetweenDiff (plus tapWidthBetweenDiff (times 2.0 halfDiffusionGrid)))
	  )
	(setq via1Xorigin (max diffXEncVia
			       (plus (quotient (difference tapWidthBetweenDiff via1Width) 2.0)
				     tapSpaceGate)
			       (plus centerTapXEncVia tapSpaceGate)
			       )
	      )
	(setq via1Xend (plus via1Xorigin via1Width))
	(setq tapXorigin (min (difference via1Xorigin centerTapXEncVia)
			      tapSpaceGate))
	(setq tapXend (max (plus tapXorigin tapWidthBetweenDiff)
			   (plus via1Xend centerTapXEncVia)
			   ))
	)
       (t 
	(setq doubleMaxDistanceToTap 99999.9)
	(setq via1Xorigin (max diffXEncVia
			       (plus tipTapXEncVia tapSpacePoly)))
	(setq via1Xend (plus via1Xorigin via1Width))
	(setq tapXorigin (difference via1Xorigin tipTapXEncVia))
	(setq tapXend (plus via1Xend tipTapXEncVia))
	)
 )

 (setq tbTapXorigin (min (difference via1Xorigin tipTapXEncVia)
			 (difference (plus via1Xorigin (quotient via1Width 2.0)) (quotient tapWidth 2.0))))
 (setq tbTapXend (plus via1Xend (difference via1Xorigin tbTapXorigin)))

 (setq diffXorigin 0.0)
 (setq diffXend (plus via1Xend via1Xorigin))
 (setq diffConYoffsetAbuttingTap (max diffYEncVia
				      (difference via1Space
						  (max tipTapYInEncVia
						       (difference tapWidthBetweenDiff via1Width centerTapYEncVia)
						  ))))
 (cond (bottomEndTap
	(setq firstDiffConYoffset (max diffYEncVia
				       (difference via1Space tipTapYInEncVia)))
       )
     (t
      (setq firstDiffConYoffset diffYEncVia)
     )
 )
 (cond (topEndTap
	(setq lastDiffConYoffset (max diffYEncVia
				      (difference via1Space tipTapYInEncVia)))
       )
     (t
      (setq lastDiffConYoffset diffYEncVia)
     )
 )

 (setq tapYoffset (max tapWidthButtingDiff
		       (plus via1Width tipTapYInEncVia tipTapYOutEncVia)))

 (setq minW (max diffWidth
		 (plus firstDiffConYoffset via1Width lastDiffConYoffset)))
 (when (lessp (difference w minW) -1e-6)
     (setq smallerMinW (max diffWidth tapWidth
			    (plus via1Width (times 2.0 diffYEncVia))))
     (when (greaterp (difference smallerMinW w) 1e-6)
	 (error "Cannot draw contact - w too small")
     )

     (cond ((and bottomEndTap topEndTap)
	    (setq diffDivisor 2.0))
	 (t (setq diffDivisor 1.0))
     )

     (setq diffSpread (quotient (difference minW w) diffDivisor))
     (and (oddp (round (quotient diffSpread halfDiffusionGrid)))
	  (setq diffSpread (plus diffSpread halfDiffusionGrid)))

     (cond ((and bottomEndTap topEndTap)
	    (setq firstDiffConYoffset (plus -diffSpread -tipTapYInEncVia via1Space))
	    (setq lastDiffConYoffset diffYEncVia)
	    (setq tapYoffset (max tapWidthButtingDiff
				  (plus diffSpread tipTapYInEncVia tipTapYOutEncVia via1Width)))
	    )
	   (bottomEndTap
	    (setq firstDiffConYoffset (plus -diffSpread -tipTapYInEncVia via1Space))
	    (setq tapYoffset (max tapWidthButtingDiff
				  (plus tipTapYOutEncVia via1Width via1Space -firstDiffConYoffset)))
	    )
	   (topEndTap
	    (setq firstDiffConYoffset diffYEncVia)
	    (setq lastDiffConYoffset diffYEncVia)
	    (setq tapYoffset (max tapWidthButtingDiff
				  (plus tipTapYOutEncVia tipTapYInEncVia 
					via1Width via1Space 
					firstDiffConYoffset via1Width -w)))
	    )
	   (centerTap
	    (setq firstDiffConYoffset diffYEncVia)
	    (setq tapYoffset 0.0)
	    )
     )
 )

 (setq yValue 0.0)
 (setq yRemaining w)
 (setq yVia1Offset (plus via1Space via1Width))

 (setq centerDiffConYoffset (difference via1Space centerTapYEncVia))
 (setq centerTaps nil)

 ; while it still needs to add more center taps (only for centerTap false)
 (while (and (null centerTap) (greaterp (difference (plus (times 2 tipTapYInEncVia) yRemaining)
						    doubleMaxDistanceToTap) -1e-6))

     (cond ((null centerTaps)
	    (setq diffDelta (plus firstDiffConYoffset
				  (times maxConsecDiffContacts via1Width)
				  (times (difference maxConsecDiffContacts 1)
					 via1Space)
				  centerDiffConYoffset)))
	   (t (setq diffDelta (plus centerDiffConYoffset
				    diffConYoffsetAbuttingTap
				    (times maxConsecDiffContacts via1Width)
				    (times (difference maxConsecDiffContacts 1)
					   via1Space)))))
     
     ; draw max consecutive diff contacts; first the diffusion
     (setq dbId (dbCreateRect tcCellView
			  diff
			  (list diffXorigin:yValue
				diffXend:(plus yValue diffDelta))))
     (dbAddFigToNet dbId net)
     (when implant
       (setq dbId (dbCreateRect tcCellView diffImplant
				(list (list (difference diffXorigin diffImpEncXL)
					    yValue
					    )
				      (list (plus diffXend diffImpEncXR)
					    (plus yValue diffDelta)
					    )
				      )))
       (dbAddFigToNet dbId net)
     )
     (cond (centerTaps
	    (setq yValue (plus yValue diffConYoffsetAbuttingTap)))
	 (t (setq yValue (plus yValue firstDiffConYoffset)))
     )

     ; now draw all of the via contacts over the diffusion
     (for i 1 maxConsecDiffContacts
	 dbId = (dbCreateRect tcCellView via1Layer (list via1Xorigin:yValue
					     via1Xend:(plus yValue via1Width)))
	 (dbAddFigToNet dbId net)

	 (setq yValue (plus yValue yVia1Offset))
     )

     (setq yValue (plus yValue centerDiffConYoffset -via1Space))

     ; draw a tap contact; first the tap
     (setq tapYWidthBetweenDiff (max tapWidthBetweenDiff
				     (plus (times 2.0 centerTapYEncVia)
					   via1Width)))

     (setq dbId (dbCreateRect tcCellView tap (list tapXorigin:yValue
						   tapXend:(plus yValue tapYWidthBetweenDiff))))
     (dbAddFigToNet dbId net)
     (when implant
       (setq dbId (dbCreateRect tcCellView tapImplant (list tapXorigin:yValue
							    tapXend:(plus yValue tapYWidthBetweenDiff))))
       (dbAddFigToNet dbId net)
       )

     (when centerRecognition
	 ; draw the center tap recognition layer
	 (setq dbId (dbCreateRect tcCellView centerRecognition
				  (list tapXorigin:yValue
					tapXend:(plus yValue tapYWidthBetweenDiff))))
     )
     (unless (or centerTaps bottomEndTap)
	 (setq tapBottomEdge yValue))
     (unless topEndTap
	 (setq tapTopEdge yValue))
     (setq centerTaps t)

     ; now the tap via contact
     dbId = (dbCreateRect tcCellView via1Layer (list via1Xorigin:(plus yValue
								centerTapYEncVia)
					 via1Xend:(plus yValue
							centerTapYEncVia
							via1Width)))
     (dbAddFigToNet dbId net)

     ; now the diff to the left and right of the center tap
     dbId = (dbCreateRect tcCellView diff (list diffXorigin:yValue
					 tapXorigin:(plus yValue tapYWidthBetweenDiff)))
     (dbAddFigToNet dbId net)
     (when implant
       (setq dbId (dbCreateRect tcCellView diffImplant (list (list (difference diffXorigin diffImpEncXL)
								   yValue
								   )
							     (list (plus tapXorigin diffImpEncButt)
								   (plus yValue tapYWidthBetweenDiff)
								   )
							     )))
       (dbAddFigToNet dbId net)
       )

     dbId = (dbCreateRect tcCellView diff (list tapXend:yValue
					 diffXend:(plus yValue tapYWidthBetweenDiff)))
     (dbAddFigToNet dbId net)
     (when implant
       (setq dbId (dbCreateRect tcCellView diffImplant (list (list (difference tapXend diffImpEncButt)
								   yValue
								   )
							     (list (plus diffXend diffImpEncXR)
								   (plus yValue tapYWidthBetweenDiff)))))
       (dbAddFigToNet dbId net)
       )

     (setq yValue (plus yValue tapYWidthBetweenDiff))
     (setq yRemaining (difference w yValue))
 )

 (when centerTap 
   ;; draw the center tap
   (setq dbId (dbCreateRect tcCellView tap (list tapXorigin:0.0 tapXend:w)))
   (dbAddFigToNet dbId net)
   (when centerRecognition
     ;; draw the center tap recognition layer
     (setq dbId (dbCreateRect tcCellView centerRecognition
			      (list tapXorigin:0.0  tapXend:w)))
     )
   (when implant
     (setq dbId (dbCreateRect tcCellView tapImplant (list (list (difference tapXorigin tapImpEncButt)
								-tapImpEncY
								)
							  (list (plus tapXend tapImpEncButt)
								(plus w tapImpEncY)
								)
							  )))
     )
   
   ;; draw the tap contacts   
   (if centerVia1 then
     (setq viaDrawSpaceY (difference w (times centerTapYEncVia 2)))
     (setq via1Row (floor (quotient  (plus viaDrawSpaceY via1Space) via1Pitch)))
     (if (equal via1Row 0) (setq via1Row 1))
     (setq via1Yoffset (quotient (difference viaDrawSpaceY (difference (times via1Row via1Pitch) via1Space)) 2))
     (setq via1Yorigin (plus centerTapYEncVia (times (fix (plus (quotient via1Yoffset snapGrid) 1e-6)) snapGrid)))
     (setq theY via1Yorigin)
     (for r 1 via1Row
             (setq dbId (dbCreateRect tcCellView via1Layer
                                      (list  via1Xorigin:theY
                                             via1Xend:(plus theY via1Width))))
             (dbAddFigToNet dbId net)
             (setq theY (plus theY via1Pitch))
     )
    else
     (setq theY centerTapYEncVia)
     ;; leqp (<=) can not be used because of rounding problem skill has
     ;; it does not "catch" that "equal": (leqp 0.5 0.5) is "FALSE"
     ;; using lessp( statement 1e-6)
     (while (lessp (difference theY (plus w -centerTapYEncVia -via1Width)) 1e-6)
       (setq dbId (dbCreateRect tcCellView via1Layer (list (list via1Xorigin theY)
							 (list via1Xend (plus theY via1Width)))))
       (dbAddFigToNet dbId net)
       (setq theY (plus theY via1Width via1Space))
     )
  ) 

   ;; Keep the via1 co-ordinates for drawing layer2 only on tap via1
   (setq tapVia1XO via1Xorigin)
   (setq tapVia1XE via1Xend)

   (setq lastDiffConYoffset (plus w -theY via1Space))
   ;; draw the left diff
   (setq dbid (dbCreateRect tcCellView diff (list (list diffXorigin 0.0)
						  (list tapXorigin w))))
   (dbAddFigToNet dbId net)
   (when implant
     (setq dbId (dbCreateRect tcCellView diffImplant (list (list (difference diffXorigin diffImpEncXL)
								 -diffImpEncY
								 )
							   (list (plus tapXorigin diffImpEncButt)
								 (plus w diffImpEncY)
								 )
							   )))
     (dbAddFigToNet dbId net)
     )
			     
   
   ;; draw the left diff contacts
   (setq via1Xorigin diffXOutEncVia)
   (setq via1Xend (plus via1Xorigin via1Width))
   (if centerVia1 then
     (setq viaDrawSpaceY (difference w (times diffYEncVia 2)))
     (setq via1Row (floor (quotient  (plus viaDrawSpaceY via1Space) via1Pitch)))
     (if (equal via1Row 0) (setq via1Row 1))
     (setq via1Yoffset (quotient (difference viaDrawSpaceY (difference (times via1Row via1Pitch) via1Space)) 2))
     (setq via1Yorigin (plus diffYEncVia (times (fix (plus (quotient via1Yoffset snapGrid) 1e-6)) snapGrid)))
     (setq theY via1Yorigin)
     (for r 1 via1Row
	  (unless noDiffContact
             (setq dbId (dbCreateRect tcCellView via1Layer
                                      (list  via1Xorigin:theY
                                             via1Xend:(plus theY via1Width))))
	  )
             (dbAddFigToNet dbId net)
             (setq theY (plus theY via1Pitch))
     )
    else
     (setq theY diffYEncVia)
     (while (lessp (difference theY (plus w -diffYEncVia -via1Width)) 1e-6)
	 (unless noDiffContact
	     (setq dbId (dbCreateRect tcCellView via1Layer (list (list via1Xorigin theY)
								 (list via1Xend (plus theY via1Width)))))
	 )
       (dbAddFigToNet dbId net)
       (setq theY (plus theY via1Width via1Space))
     )
   )
 
   ;; draw the right diff
   (setq dbId (dbCreateRect tcCellView diff (list (list tapXend 0.0)
						  (list diffXend w))))
   (dbAddFigToNet dbId net)
   (when implant
     (setq dbId (dbCreateRect tcCellView diffImplant (list (list (difference tapXend diffImpEncButt)
								 -diffImpEncY
								 )
							   (list (plus diffXend diffImpEncXR)
								 (plus w diffImpEncY)
								 )
							   )))
     (dbAddFigToNet dbId net)
     )

   ;; draw the right diff contacts
   (setq via1Xorigin (plus diffXend -diffXOutEncVia -via1Width))
   (setq via1Xend    (plus via1Xorigin via1Width))
   (if centerVia1 then
     (setq viaDrawSpaceY (difference w (times diffYEncVia 2)))
     (setq via1Row (floor (quotient  (plus viaDrawSpaceY via1Space) via1Pitch)))
     (if (equal via1Row 0) (setq via1Row 1))
     (setq via1Yoffset (quotient (difference viaDrawSpaceY (difference (times via1Row via1Pitch) via1Space)) 2))
     (setq via1Yorigin (plus diffYEncVia (times (fix (plus (quotient via1Yoffset snapGrid) 1e-6)) snapGrid)))
     (setq theY via1Yorigin)
     (for r 1 via1Row
	  (unless noDiffContact
             (setq dbId (dbCreateRect tcCellView via1Layer
                                      (list  via1Xorigin:theY
                                             via1Xend:(plus theY via1Width))))
	  )
             (dbAddFigToNet dbId net)
             (setq theY (plus theY via1Pitch))
     )
    else
     (setq theY diffYEncVia)
     (while (lessp (difference theY (plus w -diffYEncVia -via1Width)) 1e-6)
	 (unless noDiffContact
	     (setq dbId (dbCreateRect tcCellView via1Layer (list (list via1Xorigin theY)
								 (list via1Xend (plus theY via1Width)))))
	 )
       (dbAddFigToNet dbId net)
       (setq theY (plus theY via1Width via1Space))
     )
    ) 
   ;; set this up to get the correct layer2
   (setq via1Xorigin diffXOutEncVia)
   )
 (unless centerTap
   ;; if there is still space left over (there needs to be), draw more diff
   dbId = (dbCreateRect tcCellView diff (list diffXorigin:yValue
					      diffXend:w))
   (dbAddFigToNet dbId net)
   (when implant
     (setq dbId (dbCreateRect tcCellView diffImplant (list (list (difference diffXorigin diffImpEnc)
								 yValue
								 )
							   (list (plus diffXend diffImpEnc)
								 (plus w diffImpEnc)
								 )
							   )))
     (dbAddFigToNet dbId net)
     (setq dbId (dbCreateRect tcCellView diffImplant (list (list (difference diffXorigin diffImpEnc)
								 -diffImpEnc
								 )
							   (list (plus diffXend diffImpEnc)
								 0.0)
							   )))
     (dbAddFigToNet dbId net)
     )
 )
 (cond ((and (null centerTaps) (null centerTap))
	dbId = (dbCreateRect tcCellView diff (list via1Xorigin:0
					    via1Xend:w))
	(setq pinId (dbCreatePin net dbId))
	pinId~>accessDir = allDir
	(dbCreateProp tcCellView "diffLayerPinBbox" "list" dbId~>bBox)
       )
     (t
      dbId = (dbCreateRect tcCellView diff (list diffXorigin:0
					  (plus diffXorigin minPinWidth):w))
      (dbAddFigToNet dbId net)
      (setq pinId (dbCreatePin net dbId))
      pinId~>accessDir = (list "left")

      dbId = (dbCreateRect tcCellView diff (list (difference diffXend minPinWidth):0
					  diffXend:w))
      (dbAddFigToNet dbId net)
      (setq pinId (dbCreatePin net dbId))
      pinId~>accessDir = (list "right")

      (dbCreateProp tcCellView "diffLayerPinBbox" "list" (list diffXorigin:0
							diffXend:w))
     )
 )

 (dbCreateProp tcCellView "diffLayerBbox" "list" (list diffXorigin:0
						diffXend:w))

 ; draw the diffusion via1 contacts in the top diff
 (cond ((and (null centerTaps) (null centerTap))
	(setq yValue (plus yValue firstDiffConYoffset))
       )
     (t (setq yValue (plus yValue diffConYoffsetAbuttingTap)))
 )
 (unless centerTap
   (while (greaterp (difference w (plus yValue via1Width lastDiffConYoffset))
		    -1e-6)
     dbId = (dbCreateRect tcCellView via1Layer (list via1Xorigin:yValue
						     via1Xend:(plus yValue
								    via1Width)))
     (dbAddFigToNet dbId net)
     
     (setq yValue (plus yValue yVia1Offset))
     )
   )

 ; draw the bottom end tap, if needed
 (cond (bottomEndTap
	dbId = (dbCreateRect tcCellView tap (list tbTapXorigin:0.0
					   tbTapXend:-tapYoffset))
	(dbAddFigToNet dbId net)
	(when implant
	  (setq dbId (dbCreateRect tcCellView tapImplant (list (list (difference tbTapXorigin tapImpEnc)
								     tapImpEncButt
								     )
							       (list (plus tbTapXend tapImpEnc)
								     (plus -tapYoffset -tapImpEnc)
								     )
							       )))
	  (dbAddFigToNet dbId net)
	  )
	(setq tapBottomEdge -tapYoffset)
	(unless (or centerTaps topEndTap)
	    (setq tapTopEdge 0.0)
	)

	; now the tap via contact
	dbId = (dbCreateRect tcCellView via1Layer
			     (list via1Xorigin:(plus -tapYoffset tipTapYOutEncVia via1Width)
				   via1Xend:(plus -tapYoffset tipTapYOutEncVia)))
	(dbAddFigToNet dbId net)

	(setq via1MinY (plus -tapYoffset tipTapYOutEncVia))
       )
     (t
      (setq via1MinY firstDiffConYoffset)
     )
 )

 ; draw the top end tap, if needed
 (cond (topEndTap
	dbId = (dbCreateRect tcCellView tap (list tbTapXorigin:w
					   tbTapXend:(plus w tapYoffset)))
	(dbAddFigToNet dbId net)
	(when implant
	  (setq dbId (dbCreateRect tcCellView tapImplant (list (list (difference tbTapXorigin tapImpEnc)
								     (difference w tapImpEncButt)
								     )
							       (list (plus tbTapXend tapImpEnc)
								     (plus w tapYoffset tapImpEnc)
								     )
							       )))
	  (dbAddFigToNet dbId net)
	  )
	(setq tapTopEdge (plus w tapYoffset))
	(unless (or centerTaps bottomEndTap)
	    (setq tapBottomEdge w)
	)

	; now the tap via contact
	dbId = (dbCreateRect tcCellView via1Layer
			     (list via1Xorigin:(plus w tapYoffset -tipTapYOutEncVia -via1Width)
				   via1Xend:(plus w tapYoffset -tipTapYOutEncVia)))
	(dbAddFigToNet dbId net)

	(setq via1MaxY (plus w tapYoffset -tipTapYOutEncVia))
       )
     (t
      (setq via1MaxY (difference w lastDiffConYoffset))
     )
 )

 (when (or centerTaps topEndTap bottomEndTap)
     (dbCreateProp tcCellView "tapLayerBbox" "list" (list (min tbTapXorigin tapXorigin):tapBottomEdge
						   (max tbTapXend tapXend):tapTopEdge))
 )
 (when centerTap
   (dbCreateProp tcCellView "tapLayerBbox" "list"
		 (list tapXorigin:0.0 tapXend:w)
		 )
   )

 ;; If contacts are only on tap, layer2 also should be only on tap
 (when noDiffContact
     (setq via1Xorigin tapVia1XO)
     (setq via1Xend tapVia1XE)
 )

 ;; draw layer2 enclosing all of the via1s, and big enough to handle
 ;; via2s
 (setq layer2Length (max layer2Width
			 (plus (difference via1Xend via1Xorigin) (times 2 layer2XEncVia))))
 (when layer3
     (setq layer2Length (max layer2Length
			     (plus via2Width (times 2 layer2XEncVia2))))
 )

 ;; center layer2
 (if centerTap then 
   (setq layer2Xorigin (plus via1Xorigin
			     (quotient (difference via1Xend via1Xorigin) 2.0)
			     (minus (quotient layer2Length 2.0))))
   else
   (setq layer2Xorigin (plus via1Xorigin
			     (quotient (plus via1Width -layer2Length) 2.0)))
   )

 (setq layer2Xend (plus layer2Xorigin layer2Length))
 
 ;; snap layer2 X dimensions to grid
 (setq layer2Xorigin (times (fix (plus (quotient layer2Xorigin snapGrid) 1e-6)) snapGrid))
 (setq layer2Xend (times (ceiling (plus (quotient layer2Xend snapGrid) -1e-6)) snapGrid))
 
 (if emulateSlotVia then
    (setq layer2Yorigin (difference diffYEncVia (max layer2YEncVia layer2YEncVia2)))
  else
     (if centerLayer2 then
	 (setq layer2Yorigin (difference via1Yorigin layer2YEncVia))
      else
	 (setq layer2Yorigin (difference via1MinY layer2YEncVia))
     )
 )
 
 (if layer3 then 
   ;;; find the number of via2's that can be drawn in the transistor width (at least 1)
   ;;; the actual number drawn can be greater if top or bottom taps are present.
   (setq numVia2 (max (fix (plus (quotient 
				  ;; effective width since the last via2Space is unneeded
				  (plus w 
					via2Space
					;; we don't want layer2 expanded just because of via2
					(minus (plus layer2YEncVia2 layer2YEncVia2))
					;; we already have this little extra
					(minus layer2Yorigin)
					)
				  ;; divide by this
				  (plus via2Width via2Space)
				  )
				 ;; add a smidgen on so fix can't round down if it's
				 ;; already an integer
				 1e-6))
		      1 )
	 )
   
   (setq lastVia2Yend (plus (times via2Width numVia2) 
			    (times via2Space (difference numVia2 1))
			    layer2Yorigin layer2YEncVia2 ;;; origin of first via2
			    ))
   (if emulateSlotVia then
      (setq layer2Yend   (plus layer2YEncVia (difference w diffYEncVia)))
    else
      (setq layer2Yend (max (plus via1MaxY layer2YEncVia) (plus lastVia2Yend layer2YEncVia2)))
   )
 else
   ;; no layer3
   (if emulateSlotVia then
      (setq layer2Yend   (plus layer2YEncVia (difference w diffYEncVia)))
    else
     (setq layer2Yend (plus via1MaxY layer2YEncVia))
   )
 )
 (setq dbId (dbCreateRect tcCellView layer2
			  (list layer2Xorigin:layer2Yorigin
				layer2Xend:layer2Yend)))
 (dbAddFigToNet dbId net)
 (setq pinId (dbCreatePin net dbId))
 pinId~>accessDir = allDir

 (cond ((null layer3)
	(dbCreateProp tcCellView "topLayerPinBbox" "list" dbId~>bBox)
	(dbCreateProp tcCellView "topLayer" "list" layer2)	
       )
     (t
      ; draw the via2s in layer2
      (if allowCenteredMCONs then
	(setq via2Yorigin (plus 0.0 layer2YEncVia2))
	(setq lastVia2Yorigin w)
       else
	(setq via2Yorigin (plus layer2Yorigin layer2YEncVia2))
	(setq lastVia2Yorigin (difference layer2Yend layer2YEncVia2 via2Width))
      )
      (if centerTap then 
	(setq via2Xorigin (plus layer2Xorigin
				  (quotient (difference layer2Xend layer2Xorigin) 2.0)
				  (minus (quotient via2Width 2.0))))
	(setq via2Xorigin (times (fix (plus (quotient via2Xorigin snapGrid) 1e-6)) snapGrid))

       else
	(setq via2Xorigin (plus layer2Xorigin layer2XEncVia2))
      )
      (setq via2Xend (plus via2Xorigin via2Width))
      (if centerVia2 then
        (if emulateSlotVia then
           (setq via2Row (floor (quotient w via2Pitch)))
           (if (equal via2Row 0) (setq via2Row 1))
           (setq via2Yoffset (quotient (difference w (difference (times via2Row via2Pitch) via2Space)) 2))
           (setq via2Yorigin (times (fix (plus (quotient via2Yoffset snapGrid) 1e-6)) snapGrid))
         else
           (setq layer2Ywidth (difference layer2Yend layer2Yorigin))
           (setq via2DrawSpaceY (difference layer2Ywidth (times layer2YEncVia2 2)))
           (setq via2Row (floor (quotient  (plus via2DrawSpaceY via2Space) via2Pitch)))
           (if (equal via2Row 0) (setq via2Row 1))
           (setq via2Yoffset (quotient (difference via2DrawSpaceY (difference (times via2Row via2Pitch) via2Space)) 2))
           (setq via2Yorigin (plus layer2Yorigin layer2YEncVia2
                              (times (fix (plus (quotient via2Yoffset snapGrid) 1e-6)) snapGrid)))
        )
        (setq yValue via2Yorigin)
        (for r 1 via2Row
             (setq dbId (dbCreateRect tcCellView via2Layer
                                      (list  via2Xorigin:yValue
                                             (plus via2Xorigin via2Width):(plus yValue via2Width))))
             (dbAddFigToNet dbId net)
             (setq yValue (plus yValue via2Pitch))
        )


       else
         (setq via2Yoffset (plus via2Width via2Space))
         (setq yValue via2Yorigin)
      
         (if allowCenteredMCONs then
	   (while (greaterp (difference (difference lastVia2Yorigin via2Width) yValue) -1e-6)
					; draw a via2 contact
	      dbId = (dbCreateRect tcCellView via2Layer
				   (list via2Xorigin:yValue
					 via2Xend:(plus yValue via2Width)))
	      (dbAddFigToNet dbId net)
	      (setq yValue (plus yValue via2Yoffset))
	   )
         else
	   (while (greaterp (difference lastVia2Yorigin yValue) -1e-6)
					; draw a via2 contact
	      dbId = (dbCreateRect tcCellView via2Layer
				   (list via2Xorigin:yValue
					 via2Xend:(plus yValue via2Width)))
	      (dbAddFigToNet dbId net)
	      (setq yValue (plus yValue via2Yoffset))
	   )
         )
      )

      ; draw layer3 enclosing all of the via2s
      (setq layer3Xorigin (difference via2Xorigin layer3XEncVia2))
      (setq layer3Xend (plus via2Xend layer3XEncVia2))
      (and (lessp (difference layer3Xend layer3Xorigin) layer3Width)
	   (setq layer3Xend (plus layer3Xorigin layer3Width)))
      (setq layer3Yorigin (difference via2Yorigin layer3YEncVia2))
      (setq layer3Yend (plus (difference yValue via2Space) layer3YEncVia2))
      (and (lessp (difference layer3Yend layer3Yorigin) layer3Width)
	   (setq layer3Yend (plus layer3Yorigin layer3Width)))
      dbId = (dbCreateRect tcCellView layer3
			   (list layer3Xorigin:layer3Yorigin
				 layer3Xend:layer3Yend))
      (dbAddFigToNet dbId net)
      (setq pinId (dbCreatePin net dbId))
      pinId~>accessDir = allDir

      (dbCreateProp tcCellView "topLayerPinBbox" "list" dbId~>bBox)
      (dbCreateProp tcCellView "topLayer" "list" layer3)
     )
 )

)

(tfcDefineDeviceClassProp
;;(viewName       devClassName      propName          propValue)
;;;-------------------------------------------------------------------
 (symbolic        enDstrap3PolImpClass    function          "contact")
)
;;; 
;;; $Id: enSstrap3PolImpClass.il,v 1.5 2003/02/12 09:47:24 dxj Exp $
;;; 
;;; enSstrap3PolImpClass.il
;;; 
;;; Copyright (c) 1996 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Sep 19, 1996
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This file defines the pcell for the enclosed single sided
;;; strapping contacts.  It is to be used in technologies that
;;; require square vias, such as Ram3x.
;;; 
;;; Revision History:
;;;   gtc 12/05/96  Corrected minimum width check to account for floating
;;;                 point round off errors
;;;   gtc 12/06/96  Added tap recognition layer to net
;;;   gtc 12/17/96  Updates based on review.  Added smallerMinW checks.
;;;                 Can create with a smaller w, but pushes out tip tap vias.
;;;   gtc 12/17/96  Renaming the tap enclosure parameters to be more understandable 
;;;   gtc 01/13/97  Debugging tip tap contact spacing
;;;   gtc 01/21/97  Debugged problem when pushing tip taps out
;;;   gtc 01/21/97  Changed LAS connection condition for layer3
;;;   gtc 01/23/97  Fixed the tap enclosure for tip taps.  Cleaned up the
;;;                 conditions when pushing out the tip tap vias.
;;;   gtc 01/31/97  Fixed the (side) tapContactYorigin when pushing out
;;;                 the tip taps
;;;   gtc 04/22/97  Fixing the layer2 enclosure with no tip taps
;;;   gtc 01/22/98  Copying over from v20
;;;   gtc 12/03/98  removing one change that was not released in v20
;;;   akr 12/11/98  Fixed problem with tap placement
;;;   akr 01/04/99  Made it possible to remove diff contact
;;;   axg 05/19/99  Corrected calculation of tapContactXorigin by taking minSrc into account
;;;   cry 07/30/01  Copied from enSstrap3Class to allow selectable polarized implants
;;;                 without damaging existing designs (adding new formal parameters)
;;;   hai 10/23/01  Fixed mismatch parens (SPR 9938)
;;;   lpn 02/08/02  Added an option to draw diffCoreImplant layer enclosing Diff layer
;;;   kmi 07/16/02  added minSpaceDiffTapVia1; emulateSlotVia
;;;   kmi 07/25/02  added centerVia1 and centerVia2
;;;   dxj 12/19/02  Add diff/tap implant choices, contact choices
;;;

(putpropqq enSstrap3PolImpClass "$Id: enSstrap3PolImpClass.il,v 1.5 2003/02/12 09:47:24 dxj Exp $" SCCS)


(tcCreateDeviceClass
 "symbolic" "enSstrap3PolImpClass"
 ;; class parameters
 (
  (diff "hilite")           ; the layer to draw the diff in
  (tap "prBoundary")        ; the layer to draw the tap in
  (layer2 "hilite")         ; the layer to draw the layer2 in
  (layer3 nil)              ; the layer to draw the topmost layer in
  (via1Layer "hilite")      ; the layer to draw the via1 contacts in
  (via2Layer nil)           ; the layer to draw the via2 contacts in
  (sideRecognition nil)     ; the layer to identify the tap on the side
  (diffWidth 0.0)           ; the minimum width of diffusion
  (tapWidth 0.0)            ; the minimum width of tap for the tip taps
  (tapWidthButtingDiff 0.0) ; the width of tap bounded by diff on all sides
  (minSrc 0.0)
  (layer2Width 0.0)         ; the minimum width of layer2
  (layer3Width 0.0)         ; the minimum width of layer3
  (via1Width 0.0)           ; the minimum width of via1
  (via2Width 0.0)           ; the minimum width of via2
  (via1Space 0.0)           ; the minimum space between via1's
  (via2Space 0.0)           ; the minimum space between via2's
  (diffYEncVia 0.0)         ; the minimum Y enclosure of via1 by diff
  (diffLEncVia 0.0)         ; the minimum Left enclosure of via1 by diff
  (diffREncVia 0.0)         ; the minimum Right enclosure of via1 by diff

  (tipTapYInEncVia 0.0)     ; the minimum enclosure of via1 by tip tap in the 
                            ; Y direction on the side butting diff
  (tipTapYOutEncVia 0.0)    ; the minimum enclosure of via1 by tip tap in the
                            ; Y direction on the side opposite diff
  (tipTapXEncVia 0.0)       ; the minimum enclosure of via1 by tip tap in the
                            ; X direction
  (sideTapXInEncVia 0.0)    ; the minimum enclosure of via1 by side tap in the
                            ; X direction on the side butting diff
  (sideTapXOutEncVia 0.0)   ; the minimum enclosure of via1 by side tap in the
                            ; X direction on the side opposite diff
  (sideTapYEncVia 0.0)      ; the minimum enclosure of via1 by side tap in the
                            ; Y direction

  (layer2XEncVia 0.0)       ; the minimum X enclosure of via1 by layer2
  (layer2YEncVia 0.0)       ; the minimum Y enclosure of via1 by layer2
  (layer2XEncTipVia 0.0)    ; the minimum X enclosure of via1 by layer2 for the tip taps
  (layer2YEncTipVia 0.0)    ; the minimum Y enclosure of via1 by layer2 for the tip taps
  (layer2XEncVia2 0.0)      ; the minimum X enclosure of via2 by layer2
  (layer2YEncVia2 0.0)      ; the minimum Y enclosure of via2 by layer2
  (layer3XEncVia2 0.0)      ; the minimum X enclosure of via2 by layer3
  (layer3YEncVia2 0.0)      ; the minimum Y enclosure of via2 by layer3
  (tapSpacePoly 0.0)        ; the minimum space between poly and the tip taps
  (halfDiffusionGrid 0.0)   ; used to keep things on grid when pushing out the tip tap vias
  (minPinWidth 0.05)
  (diffImplant         nil)       ; diff implant layer list (inWell=nil:inWell=t)
  (diffImpEnc     (list 0.0 0.0)) ; diff implant enclosure list (inWell=nil:inWell=t)
  (diffImpEncButt (list 0.0 0.0)) ; diff implant butting enclosure list (inWell=nil:inWell=t)
  (diffCoreImplant         nil)       ; diff implant layer list (inWell=nil:inWell=t)
  (diffCoreImpEnc     (list 0.0 0.0)) ; diff implant enclosure list (inWell=nil:inWell=t)
  (diffCoreImpEncButt (list 0.0 0.0)) ; diff implant butting enclosure list (inWell=nil:inWell=t)
  (tapImplant          nil)       ; tap  implant layer list (inWell=nil:inWell=t)
  (tapImpEnc      (list 0.0 0.0)) ; tap  implant enclosure list (inWell=nil:inWell=t)
  (tapImpEncButt  (list 0.0 0.0)) ; tap  implant butting enclosure list (inWell=nil:inWell=t)
  (diffImpEncList      nil)
  (tapImpEncList       nil)
  (wellLayer           nil) ; the layer to be drawn for the well when inWell and implants are on
  (wellLayerDiffEnc    0.0) ; the amount by which the wellLayer must enclose diff
  (wellLayerTapEnc     0.0) ; the amound by which the wellLayer must enclose tap
  (minSpaceDiffTapVia1 0.0) ; min space btw. diffVia and tapVia
  (emulateSlotVia   nil)  ; emulates layer2-via1 (diff) enclosure as it is with slotVias
  (centerVia1         nil)  ; center via1 (Y direction)
  (centerVia2         nil)  ; center via2 (Y direction)
  (centerLayer2       nil)  ; center layer2 (Y direction)
  (snapGrid       (TECHgetProp snapGrid)) ;; layers snapped to this grid after division
 )

 ;; formal parameters
 (
  (w 0.0)
  (tryToStagger  "TRUE")
  (topEndTap     "TRUE")
  (bottomEndTap  "TRUE")
  (noDiffContact "FALSE")
  (inWell        "FALSE")
  (implant       "FALSE")
  (diffImpChoice 0) ;; use (nth diffImpChoice diffImpEncList) to get the correct enclosures
  (tapImpChoice  0)
 )

 (setq via1Pitch (plus via1Width via1Space))
 (setq via2Pitch (plus via2Width via2Space))


 (if (nequal minSpaceDiffTapVia1 0.0) then
     (setq diffLength (max (plus diffLEncVia via1Width diffREncVia) minSrc))
     (setq diffButtEnc (difference diffLength (plus diffLEncVia via1Width)))
     (setq sideTapXInEncVia (max (difference minSpaceDiffTapVia1 diffButtEnc) sideTapXInEncVia))
 )
 
 ;; convert boolean parameters to either t or nil
 ;; this way we can use the simple (when parameter) syntax
 ;; and speed up pcell evaluation and make code simpler
 (if (or (equal implant t) (equal implant "TRUE")) then
   (setq implant t)
   else
   (setq implant nil)
   )
 (if (or (equal inWell t) (equal inWell "TRUE")) then
   (setq inWell t)
   else
   (setq inWell nil)
   )

 ; a brief description of the variables used in this pcell
 ;
 ; allDir - list of right, left, top, and bottom
 ; contactWidth - the tap width of the tip taps
 ; contactYoffset - the pitch for via1s; different whether staggering is on
 ; dbId - temporary holder of a databaseId while creating objects
 ; diffContactYendEnc - either diffContactYwithoutTipTap or withTipTap, depending on if there is a top tip tap
 ; diffContactXend - the x end for the diff contacts
 ; diffContactYend - the top value for last (top) diff contact
 ; diffContactXorigin - the x origin for the diff contacts
 ; diffContactYorigin - the y origin of the first (bottom) diff contact
 ; diffContactYwithoutTipTap - min y enclosure of via1 by diff on a non tip tap edge
 ; diffContactYwithTipTap - min y enclosure of via1 by diff on a tip tap edge
 ; lastDiffContactYorigin - the largest y value possible for a diff contact
 ; lastTapContactYorigin - the largest y value possible for a tap contact
 ; lastVia2Yorigin - the largest y value possible for a via2 contact
 ; layer2MinWidth - the minimum width for layer2
 ; layer2Xend - the x end for layer2
 ; layer2Xorigin - the x origin for layer2
 ; layer2Yend - the y end for layer2
 ; layer2Yorigin - the y origin for layer2
 ; layer3Xend - the x end for layer3
 ; layer3Xorigin - the x origin for layer3
 ; layer3Yend - the y end for layer3
 ; layer3Yorigin - the y origin for layer3
 ; minW - minimum width for this contact
 ; net - the net that the pcell is attached to
 ; tcCellView - this cellview
 ; stagger - whether this pcell is big enough to stagger the diff & tap vias
 ; tapContactYendEnc - either tapContactYwithoutTipTap or withTipTap, depending on if there is a top tip tap
 ; tapContactXend - the x end for the (non tip) tap contacts
 ; tapContactXorigin - the x origin for the (non tip) tap contacts
 ; tapContactYend - the top value for the last (top, non tip) tap contact
 ; tapContactYorigin - the y origin of the first (bottom) tap contact
 ; tapContactYwithoutTipTap - min y enclosure of via1 by tap on a non tip tap edge
 ; tapContactYwithTipTap - min y enclosure of via1 by tap on a tip tap edge
 ; tapOrigin - the x origin for the beginning of the tap on the right
 ; tapRightEdge - the x end for the tap on the right
 ; tapXend - the x end of the tip tap
 ; tbLayer2Xend - the layer2 X end in the top & bottom (tb) tip tap area
 ; tbLayer2Xorigin - the layer2 X origin in the top & bottom (tb) tip tap area
 ; viaXend the x end of the via in the tip taps
 ; viaXorigin - the x origin of the via in the tip taps
 ; via2Xend - the x end for the layer2-3 contacts
 ; via2Xorigin - the x origin for the layer2-3 contacts
 ; via2Yoffset - the pitch between the via2 contacts
 ; via2Yorigin - the y origin for the layer2-3 contacts
 ; numVia2 - the number of via2's that can be drawn. used to calculate layer2Yend
 ; lastVia2Yend - the Y coordinate for the top of the topmost via2
 ; yValue - temporary y value as it's looping; drawing all the via contacts
 
 ; the following effective values are determined from the user selected
 ; values of implant and inWell, which toggle between the choices given by
 ; CAD as a list in the class parameters
 ; wellBbox - the bounding box of the wellLayer

 (setq net (dbMakeNet tcCellView "ppd"))
 (dbCreateTerm net "" "input")
 (setq allDir (list "right" "left" "top" "bottom"))
 (setq diffSpread 0.0)

 (when (stringp diff)
     (setq diff (list diff "drawing"))
 )
 (when (stringp tap)
     (setq tap (list tap "drawing"))
 )
 (when (stringp layer2)
     (setq layer2 (list layer2 "drawing"))
 )
 (when (and layer3 (stringp layer3))
     (setq layer3 (list layer3 "drawing"))
 )

 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;; DERIVE EFFECTIVE IMPLANT LAYERS AND INCLOSURES
 ;;; BASED ON POLARITY
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 ;; save some time if implants are off - not used then
 (when implant
   ;;;;;;;;;;;;;;;;;;;;;;
   ;;; DIFF LAYER IMPLANT
   ;;;;;;;;;;;;;;;;;;;;;;
     
     (when diffImplant
	 (if inWell then
	     (setq diffImplant    (cadr diffImplant))
	     (setq diffImpEnc     (cadr diffImpEnc))
	     (setq diffImpEncButt (cadr diffImpEncButt))
	  else
	     (setq diffImplant    (car diffImplant))
	     (setq diffImpEnc     (car diffImpEnc))
	     (setq diffImpEncButt (car diffImpEncButt))
       )
     )

     (when diffCoreImplant
	 (if inWell then
	     (setq diffCoreImplant    (cadr diffCoreImplant))
	     (setq diffCoreImpEnc     (cadr diffCoreImpEnc))
	     (setq diffCoreImpEncButt (cadr diffCoreImpEncButt))
	  else
	     (setq diffCoreImplant    (car diffCoreImplant))
	     (setq diffCoreImpEnc     (car diffCoreImpEnc))
	     (setq diffCoreImpEncButt (car diffCoreImpEncButt))
	 )
     )
   ;;;;;;;;;;;;;;;;;;;;;;
   ;;; TAP LAYER IMPLANT
   ;;;;;;;;;;;;;;;;;;;;;;
     (when tapImplant
	 (if inWell then
	     (setq tapImplant     (cadr tapImplant))
	     (setq tapImpEnc      (cadr tapImpEnc))
	     (setq tapImpEncButt  (cadr tapImpEncButt))
	  else
	     (setq tapImplant     (car tapImplant))
	     (setq tapImpEnc      (car tapImpEnc))
	     (setq tapImpEncButt  (car tapImpEncButt))
	 )
     )
 ) ;; end when implant

 ;; 
 ;; The diff/tap imlant choice is decided as follows
 ;;
 ;; - The user choice is translated to diffImpChoice/tapImpChoice parameter by tran class
 ;; - Contact classes have diffImpChoice(formal param) and diffImpEncList(class param)
 ;; - The contact class uses (nth diffImpChoice diffImpEncList) to get the implant 
 ;;   enclosure corresponding to the choice
 ;; 
 (when implant
     (when diffImpEncList
	 (if inWell then
	     (setq encList (cadr (nth diffImpChoice diffImpEncList)))
	  else
	     (setq encList (car (nth diffImpChoice diffImpEncList)))
	 )
	 (setq diffImpEncXL (nth 0 encList))
	 (setq diffImpEncXR (nth 1 encList))
	 (setq diffImpEncY  (nth 2 encList))
     )

     (when tapImpEncList
	 (if inWell then
	     (setq encList (cadr (nth tapImpChoice tapImpEncList)))
	  else
	     (setq encList (car (nth tapImpChoice tapImpEncList)))
	 )
	 (setq tapImpEncXL (nth 0 encList))
	 (setq tapImpEncXR (nth 1 encList))
	 (setq tapImpEncY  (nth 2 encList))
     )

     ;; Set the XL,XR and Y enclosures for diff/tap implants
     ;; If they are not existing, then initialize them to diffImpEnc/tapImpEnc
     
     (setq diffImpEncY  (or (and (boundp 'diffImpEncY) diffImpEncY) diffImpEnc))
     (setq diffImpEncXL (or (and (boundp 'diffImpEncXL) diffImpEncXL) diffImpEnc))
     (setq diffImpEncXR (or (and (boundp 'diffImpEncXR) diffImpEncXR) diffImpEnc))

     (setq tapImpEncY   (or (and (boundp 'tapImpEncY) tapImpEncY) tapImpEnc))
     (setq tapImpEncXL  (or (and (boundp 'tapImpEncXL) tapImpEncXL) tapImpEnc))
     (setq tapImpEncXR  (or (and (boundp 'tapImpEncXR) tapImpEncXR) tapImpEnc))
     
 ) ; end when implant

 (setq contactWidth (max tapWidthButtingDiff
			 (plus tipTapYInEncVia tipTapYOutEncVia via1Width)))

 (setq diffContactYwithTipTap (max (difference via1Space tipTapYInEncVia)
				   diffYEncVia))
 (setq tapContactYwithTipTap (max (difference via1Space tipTapYInEncVia)
				  sideTapYEncVia))
 (setq diffContactYwithoutTipTap diffYEncVia)
 (setq tapContactYwithoutTipTap sideTapYEncVia)

 ; make sure that the width is at least the minimum width
 (cond ((equal bottomEndTap "TRUE")
	(setq diffContactYorigin diffContactYwithTipTap)
	(setq tapContactYorigin tapContactYwithTipTap)
       )
     (t
      (setq diffContactYorigin diffContactYwithoutTipTap)
      (setq tapContactYorigin tapContactYwithoutTipTap)
     )
 )

 (cond ((equal topEndTap "TRUE")
	(setq lastDiffContactYorigin
	      (difference w diffContactYwithTipTap via1Width))
	(setq lastTapContactYorigin
	      (difference w tapContactYwithTipTap via1Width))
	(setq diffContactYendEnc diffContactYwithTipTap)
	(setq tapContactYendEnc tapContactYwithTipTap)
       )
     (t
      (setq lastDiffContactYorigin
	    (difference w diffContactYwithoutTipTap via1Width))
      (setq lastTapContactYorigin
	    (difference w tapContactYwithoutTipTap via1Width))
      (setq diffContactYendEnc diffContactYwithoutTipTap)
      (setq tapContactYendEnc tapContactYwithoutTipTap)
     )
 )

 ;; this is the minimum width necessary to keep the tap contacts as close
 ;; as possible to the diffusion
 (setq minW (max diffWidth tapWidth
		 (plus via1Width (times 2.0 (difference via1Space tipTapYInEncVia)))))
 (when (greaterp (difference minW w) 1e-6)

     ;; the smallerMinW is the minimum width necessary to successfully draw
     ;; a contact with pushing the tip tap contacts out.  There should only be
     ;; a width error if "w" is smaller than smallerMinW
     (setq smallerMinW (max diffWidth tapWidth
			    (plus via1Width (times 2.0 (max diffYEncVia sideTapYEncVia)))))
     (when (greaterp (difference smallerMinW w) 1e-6)
	 (error "Cannot draw enSstrap3PolImpClass - w too small")
     )

     ;; set up the stopping points for drawing the diff/tap contacts
     (setq lastDiffContactYorigin (difference w diffYEncVia via1Width))
     (setq lastTapContactYorigin (difference w sideTapYEncVia via1Width))

     ;; set up the diffContactYorigin, tapContactYorigin, contactWidth,
     ;; and diffSpread differently depending upon the combinations of end taps.
     ;;
     ;; 1. For both tip taps, make the diff contact centered, and push out
     ;;    both of the tip tap contacts the same amount
     ;;
     ;; 2. For only the bottom tip tap, push the diff contact up as far as
     ;;    possible so that the tip tap can be pushed out minimally
     ;;
     ;; 3. For only the top tip tap, keep the diff contact down as far as
     ;;    possible so that the tip tap can be pushed out minimally
     ;;
     (cond ((and (equal bottomEndTap "TRUE") (equal topEndTap "TRUE"))
	    ;; the tap must be pushed out by the difference in the in the
	    ;; minimum width without any push out, and the actual width
	    (setq diffSpread (quotient (difference minW w) 2.0))

	    ;; we must round up the diffusion spread to the nearest grid value
	    (and (oddp (round (quotient diffSpread halfDiffusionGrid)))
		 (setq diffSpread (plus diffSpread halfDiffusionGrid)))

	    (setq diffContactYorigin
		  (plus -diffSpread -tipTapYInEncVia via1Space))
	    (setq tapContactYorigin (max sideTapYEncVia diffContactYorigin))
	    (setq contactWidth (max tapWidthButtingDiff
				    (plus diffSpread tipTapYInEncVia
					  tipTapYOutEncVia via1Width)))
	   )
	 ((equal bottomEndTap "TRUE")
	  (setq diffContactYorigin (difference w diffYEncVia via1Width))
	  (when (greaterp diffContactYorigin
			  (difference via1Space tipTapYInEncVia))
	      (setq diffContactYorigin (difference via1Space tipTapYInEncVia)))
	  (setq tapContactYorigin (difference w sideTapYEncVia via1Width))

	  ;; Only use the "diffSpread" when the tipTapYInEncVia is smaller
	  ;; than the space the bottom tip tap needs to be pushed out
	  (setq potentialDiffSpread
		(difference via1Space
			    (min diffContactYorigin tapContactYorigin)))
	  (when (greaterp potentialDiffSpread tipTapYInEncVia)
	      (setq diffSpread potentialDiffSpread))

	  (setq contactWidth (max tapWidthButtingDiff
				  (plus tipTapYOutEncVia
					via1Width
					(max tipTapYInEncVia
					     potentialDiffSpread))))
	 )
	 ((equal topEndTap "TRUE")
	  (setq diffContactYorigin diffYEncVia)
	  (setq tapContactYorigin sideTapYEncVia)

	  ;; Only use the "diffSpread" when the tipTapYInEncVia is smaller
	  ;; than the space the top tip tap needs to be pushed out
	  (setq potentialDiffSpread
		(difference (plus (max diffContactYorigin tapContactYorigin)
				  via1Width via1Space) w))
	  (when (greaterp potentialDiffSpread tipTapYInEncVia)
	      (setq diffSpread potentialDiffSpread))

	  (setq contactWidth (max tapWidthButtingDiff
				  (plus tipTapYOutEncVia
					via1Width
					(max tipTapYInEncVia
					     potentialDiffSpread))))
	 )
     )
 )

 ;; determine if the width is large enough to stagger
 (setq stagger
       (and (equal tryToStagger "TRUE")
	    (greaterp (difference w (plus diffContactYorigin
					  via1Space
					  (times 2 via1Width)
					  tapContactYendEnc))
		      -1e-6)))
 (setq noDiffContact (equal noDiffContact "TRUE"))

 ;; set many kinds of origins/offsets depending on whether you stagger
 (cond (stagger
	(setq tapContactYorigin (plus diffContactYorigin via1Space via1Width))
	(setq contactYoffset (times 2 (plus via1Width via1Space)))
	(setq tapContactXorigin
	      (plus diffLEncVia via1Width diffREncVia sideTapXInEncVia))
	(setq tapOrigin (max (plus diffLEncVia via1Width diffREncVia) minSrc))
       )
     (t
      (setq contactYoffset (plus via1Width via1Space))
      (cond 
       (noDiffContact
	(setq tapContactXorigin (plus minSrc sideTapXInEncVia))
	)
       (t
	(setq tapContactXorigin
	      (max (plus diffLEncVia via1Width diffREncVia sideTapXInEncVia)
		   (plus diffLEncVia via1Width via1Space)
		   (plus minSrc sideTapXInEncVia)))
	)
       )
      (setq tapOrigin (max (plus diffLEncVia via1Width diffREncVia) minSrc))
     )
 )
 
 (setq diffContactXorigin diffLEncVia)
 (setq diffContactXend (plus diffContactXorigin via1Width))

 (setq tapContactXend (plus tapContactXorigin via1Width))

 (setq tapRightEdge (max (plus tapContactXorigin via1Width sideTapXOutEncVia)
			 (plus tapOrigin tapWidthButtingDiff)))

 ;; draw the diffusion
 (setq dbId (dbCreateRect tcCellView diff (list 0:0 tapOrigin:w)))
 (dbAddFigToNet dbId net)
 (dbCreateProp tcCellView "diffLayerBbox" "list" dbId~>bBox)
 
 ;; LAS has problems with locking objects in place when a wire touches
 ;; any piece of a pin.  If we had the entire diff area as the diff pin,
 ;; the resulting layouts from LAS would be much larger.  Therefore, we
 ;; create a thin diffusion pin adjacent to the side tap.
 (setq dbId (dbCreateRect tcCellView diff
			  (list (difference tapOrigin minPinWidth):0
				tapOrigin:w)))
 (dbAddFigToNet dbId net)
 (setq pinId (dbCreatePin net dbId))
 pinId~>accessDir = (list "left")
 (dbCreateProp tcCellView "diffLayerPinBbox" "list" dbId~>bBox)
 
 ;; draw the implant around the diff
 (when (and implant diffImplant)
   ;; note: if this is used in a flow with tip taps, changes for when top and bottom
   ;; taps are used are needed
   (setq dbId (dbCreateRect tcCellView diffImplant 
			    (list (list
				   (difference (caar  tcCellView~>diffLayerBbox) diffImpEncXL)
				   (difference (cadar tcCellView~>diffLayerBbox) diffImpEncY)
				   )
				  (list
				   (plus (caadr tcCellView~>diffLayerBbox) diffImpEncButt)
				   (plus (cadadr tcCellView~>diffLayerBbox) diffImpEncY))
				  )))
   (dbAddFigToNet dbId net)
 )
 

;; draw the Core implant around the diff
 (when (and implant diffCoreImplant)
   ;; note: if this is used in a flow with tip taps, changes for when top and bottom
   ;; taps are used are needed
   (setq dbId (dbCreateRect tcCellView diffCoreImplant 
			    (list (list
				   (difference (caar  tcCellView~>diffLayerBbox) diffCoreImpEnc)
				   (difference (cadar tcCellView~>diffLayerBbox) diffCoreImpEnc)
				   )
				  (list
				   (plus (caadr tcCellView~>diffLayerBbox)  diffCoreImpEncButt)
				   (plus (cadadr tcCellView~>diffLayerBbox) diffCoreImpEnc))
				  )))
   (dbAddFigToNet dbId net)
 )

 ;; draw the tap to the right of the diff; this is the "side tap"
 (setq dbId (dbCreateRect tcCellView tap (list tapOrigin:0 tapRightEdge:w)))
 (dbAddFigToNet dbId net)
 (setq tapLeftEdge tapOrigin)
 (setq tapBottomEdge 0.0)
 (setq tapTopEdge w)
 
 ;; draw the implant around the "side tap"
 (when (and implant tapImplant)
   (setq dbId (dbCreateRect tcCellView tapImplant 
			    (list (list
				   (difference tapOrigin tapImpEncButt)
				     (minus      tapImpEncY)
				     )
				  (list
				   (plus tapRightEdge tapImpEncXR)
				   (plus w tapImpEncY)
				   )
				  )))
   (dbAddFigToNet dbId net)
 )

  (if centerVia1 then
     ;; draw all of the diff contacts
     (setq viaDrawSpaceY (difference w (times diffYEncVia 2)))
     (setq via1Row (floor (quotient  (plus viaDrawSpaceY via1Space) via1Pitch)))
     (if (equal via1Row 0) (setq via1Row 1))
     (setq via1Yoffset (quotient (difference viaDrawSpaceY (difference (times via1Row via1Pitch) via1Space)) 2))
     (setq via1Yorigin (plus diffYEncVia (times (fix (plus (quotient via1Yoffset snapGrid) 1e-6)) snapGrid)))
     (setq yValue via1Yorigin)
     (for r 1 via1Row
           (unless noDiffContact
             (setq dbId (dbCreateRect tcCellView via1Layer
                                      (list  diffContactXorigin:yValue
                                             diffContactXend:(plus yValue via1Width))))
             (dbAddFigToNet dbId net)
           )
             (setq yValue (plus yValue via1Pitch))
     )
     (setq diffContactYend (difference yValue via1Space))

     ;; draw all of the tap contacts
     (setq viaDrawSpaceY (difference w (times sideTapYEncVia 2)))
     (setq via1Row (floor (quotient  (plus viaDrawSpaceY via1Space) via1Pitch)))
     (if (equal via1Row 0) (setq via1Row 1))
     (setq via1Yoffset (quotient (difference viaDrawSpaceY (difference (times via1Row via1Pitch) via1Space)) 2))
     (setq via1Yorigin (plus sideTapYEncVia (times (fix (plus (quotient via1Yoffset snapGrid) 1e-6)) snapGrid)))
     (setq yValue via1Yorigin)
     (for r 1 via1Row
             (setq dbId (dbCreateRect tcCellView via1Layer
                                      (list  tapContactXorigin:yValue
                                             tapContactXend:(plus yValue via1Width))))
             (dbAddFigToNet dbId net)
             (setq yValue (plus yValue via1Pitch))
     )
     (setq tapContactYend (difference yValue via1Space))
     
  else
     (setq via1Yorigin diffContactYorigin)
     (setq yValue diffContactYorigin)
     (while (greaterp (difference lastDiffContactYorigin yValue) -1e-6)
       ;; draw a diff contact
       (unless noDiffContact
         dbId = (dbCreateRect tcCellView
			  via1Layer
			  (list diffContactXorigin:yValue
				diffContactXend:(plus yValue via1Width)))
         (dbAddFigToNet dbId net)
       )
       (setq yValue (plus yValue contactYoffset))
     )
     (setq diffContactYend (plus via1Width (difference yValue contactYoffset)))

     ;; draw all of the tap contacts
     (setq yValue tapContactYorigin)
     (while (greaterp (difference lastTapContactYorigin yValue) -1e-6)
        ;; draw a tap contact
        dbId = (dbCreateRect tcCellView via1Layer
			  (list tapContactXorigin:yValue
				tapContactXend:(plus yValue via1Width)))
        (dbAddFigToNet dbId net)
        (setq yValue (plus yValue contactYoffset))
     )
     (setq tapContactYend (plus via1Width (difference yValue contactYoffset)))
 )
 (dbCreateProp tcCellView "bBoxVia1" "list" (list diffContactXorigin:via1Yorigin tapContactYend:yValue))

 ;; draw layer2 enclosing the diff and tap contacts
 (if noDiffContact then
   (setq layer2Xorigin (difference tapContactXorigin layer2XEncVia))
  else
   (setq layer2Xorigin (difference diffContactXorigin layer2XEncVia))
 )
 (setq layer2Xend (plus tapContactXend layer2XEncVia))
 
 ;; make sure it satisfies the minimum width for layer2
 (setq layer2MinWidth (max layer2Width
 			   (plus (times 2 layer2XEncVia2) via2Width)))
 (and (greaterp (difference layer2MinWidth
			    (difference layer2Xend layer2Xorigin)) -1e-6)
      (setq layer2Xend (plus layer2Xorigin layer2MinWidth)))
 
 ;; make sure it satisfies the minimum enclosure for via2contacts
 (if layer3 then
   ;; maximize via2's that fit above diff/tap
   (if emulateSlotVia then
      (setq layer2Yorigin (difference diffYEncVia (max layer2YEncVia layer2YEncVia2)))
    else
      (setq layer2Yorigin (min 0.0
			    (difference (min diffContactYorigin
					     tapContactYorigin)
					(max layer2YEncVia layer2YEncVia2))))
   )
   ;;; find the number of via2's that can be drawn (at least 1)
   (setq numVia2 (max (fix (plus (quotient 
				  ;; effective width since the last via2Space is unneeded
				  (plus w 
					via2Space
					;; we don't want layer2 expanded just because of via2
					(minus (plus layer2YEncVia2 layer2YEncVia2))
					;; we already have this little extra
					(minus layer2Yorigin)
					)
				  ;; divide by this
				  (plus via2Width via2Space)
				  )
				 ;; add a smidgen on so fix can't round down if it's
				 ;; already an integer
				 0.000001))
		      1 )
	 )
   
   (setq lastVia2Yend (plus (times via2Width numVia2) 
			    (times via2Space (difference numVia2 1))
			    layer2Yorigin layer2YEncVia2 ;;; origin of first via2
			    ))
   (if emulateSlotVia then
      (setq layer2Yend   (plus layer2YEncVia (difference w diffYEncVia)))
    else
      (setq layer2Yend   (max (plus (max diffContactYend tapContactYend) layer2YEncVia)
		   (plus lastVia2Yend layer2YEncVia2)))
   )
   ;; find x origin when contacts are centered
   (if centerVia2 then
     (setq via2Xoffset (quotient (difference via2Width via1Width) 2))
     (setq via2Xoffset (times (fix (plus (quotient via2Xoffset snapGrid) 1e-5)) snapGrid))
     (setq via2Xorigin (difference diffContactXorigin via2Xoffset))
     (setq via2Xend (plus via2Xorigin via2Width))
     (setq layer2Xorigin (difference via2Xorigin layer2XEncVia2))
   )
  else
   ;; no layer3
   (if noDiffContact then
       (if centerLayer2 then
	   (setq layer2Yorigin (difference via1Yorigin layer2YEncVia)) 
	else
	   (difference tapContactYorigin layer2YEncVia)
       )   
     (setq layer2Yend (plus tapContactYend layer2YEncVia))
    else
     (if emulateSlotVia then
        (setq layer2Yorigin (difference diffYEncVia layer2YEncVia))
        (setq layer2Yend   (plus layer2YEncVia (difference w diffYEncVia)))
      else
	 (if centerLayer2 then
	     (setq layer2Yorigin (difference via1Yorigin layer2YEncVia))
	  else
	     (setq layer2Yorigin (min 0.0
				      (difference (min diffContactYorigin ; via enc fix
						       tapContactYorigin
						  )
						  layer2YEncVia)))
	 )
        (setq layer2Yend (plus (max diffContactYend tapContactYend) layer2YEncVia)))
     )
   )
 dbId = (dbCreateRect tcCellView layer2 (list layer2Xorigin:layer2Yorigin layer2Xend:layer2Yend))
 (dbAddFigToNet dbId net)
 (setq pinId (dbCreatePin net dbId))
 pinId~>accessDir = allDir

 (dbCreateProp tcCellView "bBoxLayer2" "ILList" dbId~>bBox)
 ;; if there is not a layer3, create the top layer properties for layer2
 (unless layer3
     (dbCreateProp tcCellView "topLayerPinBbox" "list" dbId~>bBox)
     (dbCreateProp tcCellView "topLayer" "list" layer2)
 )


 ;; draw the tip tap contacts on the top and the bottom.  First, set up
 ;; a couple of variables controlling the x bounds for the via and layer2
 (setq viaXorigin (plus tapSpacePoly tipTapXEncVia))
 (setq viaXend (plus viaXorigin via1Width))
 (setq tbLayer2Xorigin (difference viaXorigin layer2XEncTipVia))
 (setq tbLayer2Xend (plus viaXend layer2XEncTipVia))
 (and (greaterp (difference layer2Width
 			    (difference tbLayer2Xend tbLayer2Xorigin)) -1e-6)
      (setq tbLayer2Xend (plus tbLayer2Xorigin layer2Width)))

 (when sideRecognition
     (setq dbId (dbCreateRect tcCellView sideRecognition
			      (list tapOrigin:(if (equal bottomEndTap "TRUE") -contactWidth 0.0)
				    tapRightEdge:(plus w (if (equal topEndTap "TRUE") contactWidth 0.0)))))
     (dbAddFigToNet dbId net)
 )

 ;; draw the bottom tip tap
 (cond ((equal bottomEndTap "TRUE")
	;; create the tap
	dbId = (dbCreateRect tcCellView
			     tap
			     (list tapSpacePoly:0
				   tapRightEdge:-contactWidth))
	(dbAddFigToNet dbId net)
	
	;; draw the implant over the bottom tip tap
	(when (and implant tapImplant)
	  (setq dbId (dbCreateRect tcCellView tapImplant
				   (list
				    (list (difference tapSpacePoly tapImpEnc)
					  tapImpEncButt
					  )
				    (list (plus tapRightEdge tapImpEnc)
					  (difference (minus contactWidth) tapImpEnc)
					  )
				    )))
	  (dbAddFigToNet dbId net)
	)
	;; make sure you cover the tap edge extremities
	(when (lessp tapSpacePoly tapLeftEdge)
	    (setq tapLeftEdge tapSpacePoly)
	)
	(when (lessp -contactWidth tapBottomEdge)
	    (setq tapBottomEdge -contactWidth)
	)

	;; don't place the via further away than necessary when it must
	;; satisfy the tapWidthButtingDiff
	(when (equal contactWidth tapWidthButtingDiff)
	    (setq tipTapYOutEncVia (difference tapWidthButtingDiff via1Width
					       tipTapYInEncVia diffSpread)))

	;; create the via
	dbId = (dbCreateRect tcCellView
			     via1Layer
			     (list viaXorigin:(plus -contactWidth
						    tipTapYOutEncVia)
				   viaXend:(plus -contactWidth
						 tipTapYOutEncVia
						 via1Width)))
	(dbAddFigToNet dbId net)

	;; create the layer2 over the tip tap
	dbId = (dbCreateRect tcCellView layer2
			     (list tbLayer2Xorigin:0.0
				   tbLayer2Xend:(plus -contactWidth
						      tipTapYOutEncVia
						      -layer2YEncTipVia)))
	(dbAddFigToNet dbId net)
	(setq pinId (dbCreatePin net dbId))
	pinId~>accessDir = allDir

       )
     (t t)
 )

 ;; draw the top tip tap
 (cond ((equal topEndTap "TRUE")
	;; create the tap
	dbId = (dbCreateRect tcCellView
			     tap
			     (list tapSpacePoly:w
				   tapRightEdge:(plus w contactWidth)))
	(dbAddFigToNet dbId net)
	
	;; create the tap implant
	(when (and implant tapImplant)
	  (setq dbId (dbCreateRect tcCellView tapImplant
				   (list
				    (list (difference tapSpacePoly tapImpEnc)
					  (difference w tapImpEncButt)
					  )
				    (list (plus tapRightEdge tapImpEnc)
					  (plus (plus w contactWidth)
						tapImpEnc)
					  ))))
	  (dbAddFigToNet dbId net)
	)
	;; make sure you cover the tap edge extremities
	(when (lessp tapSpacePoly tapLeftEdge)
	    (setq tapLeftEdge tapSpacePoly)
	)
	(when (greaterp (plus w contactWidth) tapTopEdge)
	    (setq tapTopEdge (plus w contactWidth))
	)

	;; don't place the via further away than necessary when it must
	;; satisfy the tapWidthButtingDiff
	(when (equal contactWidth tapWidthButtingDiff)
	    (setq tipTapYOutEncVia (difference tapWidthButtingDiff via1Width
					    tipTapYInEncVia diffSpread)))

	;; create the via
	dbId = (dbCreateRect tcCellView
			     via1Layer
			     (list viaXorigin:(plus w contactWidth
						    -tipTapYOutEncVia -via1Width)
				   viaXend:(plus w contactWidth
						 -tipTapYOutEncVia)))
	(dbAddFigToNet dbId net)

	;; create the layer2 over the tip tap
	dbId = (dbCreateRect tcCellView layer2
			     (list tbLayer2Xorigin:w
				   tbLayer2Xend:(plus w contactWidth
						      -tipTapYOutEncVia
						      layer2YEncTipVia)))
	(dbAddFigToNet dbId net)
	(setq pinId (dbCreatePin net dbId))
	pinId~>accessDir = allDir

       )
     (t t)
 )

 (dbCreateProp tcCellView "tapLayerBbox" "list" (list tapLeftEdge:tapBottomEdge
					       tapRightEdge:tapTopEdge))
 
 (when wellLayer
   ;; make the bounding box of the well large enough to cover the diff and tap
   (setq wellBbox (list (list
			 (min (difference (caar tcCellView~>diffLayerBbox) wellLayerDiffEnc)
			      (difference (caar tcCellView~>tapLayerBbox)  wellLayerTapEnc)
			      )
			 (min (difference (cadar tcCellView~>diffLayerBbox) wellLayerDiffEnc)
			      (difference (cadar tcCellView~>tapLayerBbox)  wellLayerTapEnc)
			      )
			 )
			 (list
			  (max (plus (caadr tcCellView~>diffLayerBbox) wellLayerDiffEnc)
			       (plus (caadr tcCellView~>tapLayerBbox)   wellLayerTapEnc)
			       )
			  (max (plus (cadadr tcCellView~>diffLayerBbox) wellLayerDiffEnc)
			       (plus (cadadr tcCellView~>tapLayerBbox)  wellLayerTapEnc)
			       )
			  ))
	 )
   
   (when (and implant inWell)
     (setq dbId (dbCreateRect tcCellView wellLayer wellBbox))
     (dbAddFigToNet dbId net)
     )
   (dbCreateProp tcCellView "wellLayerBbox" "list" wellBbox)
 )
   
	    
 
 (when layer3
   
     ;; draw the layer2-3 contacts
  (if centerVia2 then
    (if emulateSlotVia then
      (setq via2Row (floor (quotient w via2Pitch)))
      (if (equal via2Row 0) (setq via2Row 1))
      (setq via2Yoffset (quotient (difference w (difference (times via2Row via2Pitch) via2Space)) 2))
      (setq via2Yorigin (times (fix (plus (quotient via2Yoffset snapGrid) 1e-6)) snapGrid))
     else   
      (setq layer2Ywidth (difference layer2Yend layer2Yorigin))
      (setq via2DrawSpaceY (difference layer2Ywidth (times layer2YEncVia2 2)))
      (setq via2Row (floor (quotient  (plus via2DrawSpaceY via2Space) via2Pitch)))
      (if (equal via2Row 0) (setq via2Row 1))
      (setq via2Yoffset (quotient (difference via2DrawSpaceY (difference (times via2Row via2Pitch) via2Space)) 2))
      (setq via2Yorigin (plus layer2Yorigin layer2YEncVia2
                              (times (fix (plus (quotient via2Yoffset snapGrid) 1e-6)) snapGrid)))
     )
     (setq yValue via2Yorigin)
     (for r 1 via2Row
             (setq dbId (dbCreateRect tcCellView via2Layer
                                      (list  via2Xorigin:yValue
                                             (plus via2Xorigin via2Width):(plus yValue via2Width))))
             (dbAddFigToNet dbId net)
             (setq yValue (plus yValue via2Pitch))
     )
  else
     (setq via2Xorigin (plus layer2Xorigin layer2XEncVia2))
     (setq via2Xend (plus via2Xorigin via2Width))
     (setq via2Yorigin (plus layer2Yorigin layer2YEncVia2))
     (setq lastVia2Yorigin (difference layer2Yend layer2YEncVia2 via2Width))
     (setq via2Yoffset (plus via2Width via2Space))
     (setq yValue via2Yorigin)


       (while (greaterp (difference lastVia2Yorigin yValue) -1e-6)
	   ;; draw a via2 contact
	   dbId = (dbCreateRect tcCellView via2Layer
			      (list via2Xorigin:yValue
				    via2Xend:(plus yValue via2Width)))
	   (dbAddFigToNet dbId net)
     	   (setq yValue (plus yValue via2Yoffset))
     )
  )
  (dbCreateProp tcCellView "bBoxVia2" "list" (list via2Xorigin:via2Yorigin via2Xend:yValue))

  ;; draw layer3
     (setq layer3Xorigin (difference via2Xorigin layer3XEncVia2))
     (setq layer3Xend (plus via2Xend layer3XEncVia2))
     (and (lessp (difference layer3Xend layer3Xorigin) layer3Width)
	  (setq layer3Xend (plus layer3Xorigin layer3Width)))
     (setq layer3Yorigin (difference via2Yorigin layer3YEncVia2))
     (setq layer3Yend (plus (difference yValue via2Space) layer3YEncVia2))
     (and (lessp (difference layer3Yend layer3Yorigin) layer3Width)
	  (setq layer3Yend (plus layer3Yorigin layer3Width)))
     ;; this condition below is for LAS.  There must be layer3 up to at
     ;; least half of the width of the device for successful connections
     ;; to be made
     (cond ((lessp layer3Yend (quotient w 2.0))
	    (setq layer3Yend (quotient w 2.0))
	   )
     )
     dbId = (dbCreateRect tcCellView layer3
			  (list layer3Xorigin:layer3Yorigin
				layer3Xend:layer3Yend))
     (dbAddFigToNet dbId net)
     (setq pinId (dbCreatePin net dbId))
     pinId~>accessDir = allDir

     (dbCreateProp tcCellView "bBoxLayer3" "ILList" dbId~>bBox)
     (dbCreateProp tcCellView "topLayerPinBbox" "list" dbId~>bBox)
     (dbCreateProp tcCellView "topLayer" "list" layer3)
 )
)

(tfcDefineDeviceClassProp
;;(viewName       devClassName      propName          propValue)
;;;-------------------------------------------------------------------
 (symbolic        enSstrap3PolImpClass    function          "contact")
)

;;; $Id: enhStrap3PolImpClass.il,v 1.5 2002/08/05 21:12:50 kmi Exp $
;;; 
;;; enhStrap3PolImpClass.il
;;; 
;;; Copyright (c) 2001 by Cypress Semiconductor
;;; Cypress Kentucky CAD Center (KYCC)
;;; 
;;; Date  : August 8, 2001
;;; Author: Cory Davis (cry) @ KYCC
;;; 
;;; Description:
;;;   This file defines the class for a strapping contact between two
;;;   transistors of varying widths, generating the correct implants
;;;   and enclosures.  It allows implant layers to be
;;;   turned on and off. It also allows the polarity (n/p) to be toggled.
;;; 
;;; Revision History:
;;;   cry 08/08/01  initial version based on code from XVG
;;;   hai 10/23/01  Fixed mismatch parens (SPR 9938)
;;;   lpn 02/08/02  Added an option to draw diffCoreImplant layer enclosing Diff layer
;;;   kmi 05/21/02  Correcting point_c y coord error: nwell edge not on n x 45 degrees
;;;                 Adding slotVia contact
;;;   kmi 06/18/02  Adding idLayer
;;;   kmi 07/26/02  Adding tapImpEncNoButt
;;;

(putpropqq enhStrap3PolImpClass "$Id: enhStrap3PolImpClass.il,v 1.5 2002/08/05 21:12:50 kmi Exp $" SCCS)

(tcCreateDeviceClass
 "symbolic" "enhStrap3PolImpClass"
 ;; class parameters
 (
  (diffLayer          "y1")  ;;; the layer (& purpose) of diff
  (tapLayer       "hilite")  ;;; the layer (& purpose) of tap
  (via1Layer          "y4")  ;;; the layer (& purpose) of diff/tap to layer2 contacts
  (layer2     "prBoundary")  ;;; the layer (& purpose) of layer2 
  (via2Layer           nil)  ;;; the layer (& purpose) of layer2-layer3 contacts
  (layer3              nil)  ;;; the layer (& purpose) of layer3
  (wellLayer           nil)  ;;; the layer to be drawn for the well when inWell and implants are on
  (wellWidth           0.0)  ;;; minimum width of wellLayer
  (idLayer           nil)      ;;; the layer (& purpose) of idLayer
  (idLayerEncDiff    0.0)      ;;; enclosure of diffLayer by idLayer
  (idLayerEncTap     0.0)      ;;; enclosure of tapLayer by idLayer
  (idLayerEncWell    0.0)      ;;; enclosure of wellLayer by idLayer
  (idEncWell         nil)      ;;; true for idLayer enclosures wellLayer
  (diffSourceWidth     0.0)  ;;; minimum width of diffLayer
  (diffXEncVia1In      0.0)  ;;; diff X enclosure of via1Layer on the inner side (min, autoadjust)
  (diffXEncVia1Out     0.0)  ;;; diff X enclosure of via1Layer on the outer side
  (diffYEncVia1        0.0)  ;;; diff Y enclosure of via1Layer
  (tapXEncVia1         0.0)  ;;; tap X enclosure of via1Layer
  (tapYEncVia1         0.0)  ;;; tap Y enclosure of via1Layer
  (tapMinNarExt        0.0)  ;;; mininum extension of the tap on the narrowside
  (tapWidthBetween     0.0)  ;;; minimum width of tap between two diffs
  (tapButtSpace        0.0)  ;;; spacing between licon1 and difftap abutting edge
  (tapWidthButting     0.0)  ;;; minimum width of tap butting diff
  (layer2XEncVia1      0.0)  ;;; layer2 X enclosure of via1
  (layer2XEncVia2      0.0)  ;;; layer2 X enclosure of via2
  (layer2YEncVia1      0.0)  ;;; layer2 Y enclosure of via1
  (layer2YEncVia2      0.0)  ;;; layer2 Y enclosure of via2
  (layer3XEncVia2      0.0)  ;;; layer3 X enclosure of via2
  (layer3YEncVia2      0.0)  ;;; layer3 Y enclosure of via2
  (via1Width           0.0)  ;;; width  of via1 (x direction)
  (via1Length          0.0)  ;;; length of via1 (y direction)
  (via1Space           0.0)  ;;; minimum spacing of via1
  (via2Width           0.0)  ;;; width  of via2 (x direction)
  (via2Length          0.0)  ;;; length of via2 (y direction)
  (via2Space           0.0)  ;;; minimum spacing of via2
  (diffImplant         nil)        ;;; diff implant layer list (inWell=nil:inWell=t)
  (diffImpEnc     (list 0.0 0.0))  ;;; diff implant enclosure list (inWell=nil:inWell=t)
  (diffImpEncButt (list 0.0 0.0))  ;;; diff implant butting enclosure list (inWell=nil:inWell=t)
  (diffCoreImplant         nil)       ; diff implant layer list (inWell=nil:inWell=t)
  (diffCoreImpEnc     (list 0.0 0.0)) ; diff implant enclosure list (inWell=nil:inWell=t)
  (diffCoreImpEncButt (list 0.0 0.0)) ; diff implant butting enclosure list (inWell=nil:inWell=t)
  (tapImplant          nil)        ;;; tap  implant layer list (inWell=nil:inWell=t)
  (tapImpEnc      (list 0.0 0.0))  ;;; tap  implant enclosure list (inWell=nil:inWell=t)
  (tapImpEncButt  (list 0.0 0.0))  ;;; tap  implant butting enclosure list (inWell=nil:inWell=t)
  (tapImpEncNoButt  (list 0.0 0.0))  ;;; tap  implant not-butting enclosure list (inWell=nil:inWell=t)
  (wellLayerDiffEnc    0.0)  ;;; the amount by which the wellLayer must enclose diff
  (wellLayerTapEnc     0.0)  ;;; the amound by which the wellLayer must enclose tap
  (snapGrid       (TECHgetProp snapGrid)) ;; layers snapped to this grid after division
  (slotVia             nil)  ;;; slotVia contact name
  (diffTapViaSpace     0.0)  ;;; spacing between liconOnDiff to liconOnTap
  (emulateSlotViaEnc   nil)  ;;; emulate SlotVia contact layer2 enclosure
  (centerVia1          nil)  ;;; center via1 contacts
  (centerVia2          nil)  ;;; center via2 contacts
  )
 
 ;; formal parameters
 (
  (inWell          "FALSE")  ;;; whether in the well or not
  (implant               t)  ;;; draw implants or not
  (leftDiff              t)  ;;; draw left diff or not
  (rightDiff             t)  ;;; draw right diff or not
  (noLayer3        "FALSE")  ;;; don't draw layer3 when true
  (noEndEnc        "FALSE")  ;;; don't draw extra imp at end of dev
  (strap                 t)  ;;; strap the diffs to the tap
  (tranWidthL          0.0)  ;;; length of left transistor
  (tranWidthR          0.0)  ;;; length of right transistor
  (extraDiffL          0.0)  ;;; extension of diff on left
  (extraDiffR          0.0)  ;;; extension of diff on right
  (extraTapL           0.0)  ;;; extra extension of tap on left
  (extraTapR           0.0)  ;;; extra extension of tap on right
  (column                1)  ;;; the number of columns
  )


 ;; diffXEncVia1In might be out of grid: 
 (setq diffXEncVia1In (times (fix (plus (quotient diffXEncVia1In snapGrid) 1e-5)) snapGrid))

 
 ;; convert all boolean parameters to either t or nil
 ;; this way we can use the simple (when parameter) syntax
 ;; and speed up pcell evaluation and make code simpler
 (if (or (equal inWell t) (equal inWell "TRUE")) then
   (setq inWell t)
   else
   (setq inWell nil)
   )
 (if (or (equal implant t) (equal implant "TRUE")) then
   (setq implant t)
   else
   (setq implant nil)
   )
 (if (or (equal leftDiff t) (equal leftDiff "TRUE")) then
   (setq leftDiff t)
   else
   (setq leftDiff nil)
   )
 (if (or (equal rightDiff t) (equal rightDiff "TRUE")) then
   (setq rightDiff t)
   else
   (setq rightDiff nil)
   )
 (if (or (equal noLayer3 t) (equal noLayer3 "TRUE")) then
   (setq noLayer3 t)
   else
   (setq noLayer3 nil)
   )
 (if (or (equal noEndEnc t) (equal noEndEnc "TRUE")) then
   (setq noEndEnc t)
   else
   (setq noEndEnc nil)
   )
 (if (or (equal strap t) (equal strap "TRUE")) then
   (setq strap t)
   else
   (setq strap nil)
   )
 
 (setq net (dbMakeNet tcCellView "ppd"))
 (dbCreateTerm net "ppd" "input")
 (setq allDir (list "right" "left" "top" "bottom"))
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;; DERIVE EFFECTIVE IMPLANT LAYERS AND INCLOSURES
 ;;; BASED ON POLARITY
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 ;; save some time if implants are off - not used then
 (when implant
   ;;;;;;;;;;;;;;;;;;;;;;
   ;;; DIFF LAYER IMPLANT
   ;;;;;;;;;;;;;;;;;;;;;;
   
   (when diffImplant
     (if inWell then
       (setq diffImplant    (cadr diffImplant))
       (setq diffImpEnc     (cadr diffImpEnc))
       (setq diffImpEncButt (cadr diffImpEncButt))
       else
       (setq diffImplant    (car diffImplant))
       (setq diffImpEnc     (car diffImpEnc))
       (setq diffImpEncButt (car diffImpEncButt))
       )
     )
   
   (when diffCoreImplant
	 (if inWell then
	     (setq diffCoreImplant    (cadr diffCoreImplant))
	     (setq diffCoreImpEnc     (cadr diffCoreImpEnc))
	     (setq diffCoreImpEncButt (cadr diffCoreImpEncButt))
	  else
	     (setq diffCoreImplant    (car diffCoreImplant))
	     (setq diffCoreImpEnc     (car diffCoreImpEnc))
	     (setq diffCoreImpEncButt (car diffCoreImpEncButt))
	 )
   )

   ;;;;;;;;;;;;;;;;;;;;;;
   ;;; TAP LAYER IMPLANT
   ;;;;;;;;;;;;;;;;;;;;;;
   (when tapImplant
     (if inWell then
       (setq tapImplant     (cadr tapImplant))
       (setq tapImpEnc      (cadr tapImpEnc))
       (setq tapImpEncButt  (cadr tapImpEncButt))
       (setq tapImpEncNoButt  (cadr tapImpEncNoButt))
       else
       (setq tapImplant     (car tapImplant))
       (setq tapImpEnc      (car tapImpEnc))
       (setq tapImpEncButt  (car tapImpEncButt))
       (setq tapImpEncNoButt  (car tapImpEncNoButt))
       )
     )
 ) ;; end when implant
 
 ;;If user gives column as zero
 (setq via1Col (max column 1))
 
 (setq via1XPitch (plus via1Width  via1Space))
 (setq via1YPitch (plus via1Length via1Space))

 (setq via2XPitch (plus via2Width  via2Space))
 (setq via2YPitch (plus via2Length via2Space))

 ;; the tap in the center depends on the
 ;; transistor with the largest width
 (setq tranWidth (max tranWidthL tranWidthR))
 
 
 ;; calculate the bounding boxes for left, right, and center
 ;; sections of tap (also used later) and draw the tapLayer
 (setq centerTapBbox (list (list 0.0 0.0)
			   (list (plus (times 2 tapXEncVia1) (times via1Col via1Width)
				       (times (difference via1Col 1) via1Space)
				       )
				 tranWidth)))
 ;; make sure we satisfy min width of tap between two diffs
 (setq dbId (dbCreateRect tcCellView tapLayer centerTapBbox))
 (dbAddFigToNet dbId net)


 (if (equal tranWidthL tranWidthR) then
    ;; must satisfy min diffVia-tapVia spacing
    (setq extraTapC (max (difference diffTapViaSpace diffXEncVia1In) 0.0)) 
    (setq extraTapCR extraTapC)
    (setq extraTapCL extraTapC)
    (setq widthOfTap (plus extraTapL extraTapR extraTapCR extraTapCL (caadr centerTapBbox)))
   else
    ;; must satisfy min space licon-diffTap butt edge and minWidthButt
    (setq extraTapC (max (difference tapWidthButting via1Width) tapButtSpace 0.0))
    (setq extraTapCR (if (lessp tranWidthL tranWidthR) extraTapC 0.0))
    (setq extraTapCL (if (lessp tranWidthR tranWidthL) extraTapC 0.0))
    (setq widthOfTap (plus extraTapL extraTapR extraTapCL extraTapCR (caadr centerTapBbox) tapMinNarExt))
 )
 (when (lessp widthOfTap tapWidthBetween)
   (setq extraTap (times (ceiling (difference (quotient
					       (quotient
						(difference tapWidthBetween widthOfTap)
						2.0)
					       snapGrid)
					      1e-6))
			 snapGrid))
   (setq extraTapL (plus extraTapL extraTap))
   (setq extraTapR (plus extraTapR extraTap))
   )
 

 (setq leftTapBbox   (list (list (plus -extraTapL -extraTapCL 
                                       (if (lessp tranWidthL tranWidth) -tapMinNarExt 0.0))
				 0.0
				 )
			   (list 0.0
				 tranWidthL
				 )
			   )
       )
 (setq rightTapBbox  (list (caadr centerTapBbox):0.0
			   (list (plus (caadr centerTapBbox) extraTapR extraTapCR
				       (if (lessp tranWidthR tranWidth) tapMinNarExt 0.0))
				 tranWidthR
				 )
			   )
       )
 (unless (equal (caar leftTapBbox) (caadr leftTapBbox))
   ;; don't draw 0 area rects
   (setq dbId (dbCreateRect tcCellView tapLayer leftTapBbox))
   (dbAddFigToNet dbId net)
   )
 (unless (equal (caar rightTapBbox) (caadr rightTapBbox))
   ;; don't draw 0 area rects
   (setq dbId (dbCreateRect tcCellView tapLayer rightTapBbox))
   (dbAddFigToNet dbId net)
   )
 (dbCreateProp tcCellView "tapLayerBbox" "list"
	       (list (car leftTapBbox)
		     (list (caadr rightTapBbox)
			   (cadadr centerTapBbox)
			   )
		     )
	       )
 
 ;; calculate the X size of the diff
 ;; it should hold one contact if strapped,otherwise be min width.
 (if strap then
   (setq diffXSize (plus via1Width diffXEncVia1In diffXEncVia1Out))
   (setq diffWideExtraIn (max 0.0
			      (plus via1Space -tapXEncVia1 -extraTapCL -extraTapCR
				    (if extraTap -extraTap 0.0)
				    -diffXEncVia1In)
			      (difference diffSourceWidth diffXSize)
			      ))
   (setq diffNarExtraIn  (max 0.0
			      (plus via1Space -tapXEncVia1 -extraTapCL -extraTapCR
				    (if extraTap -extraTap 0.0)
				    -diffXEncVia1In -tapMinNarExt)
			      (difference diffSourceWidth diffXSize)
			      ))
   else
   (setq diffXSize diffSourceWidth)
   (setq diffWideExtraIn 0.0)
   (setq diffNarExtraIn  0.0)
   )
 
 ;; calculate the bounding boxes for left and right diff
 ;; and draw
 (when leftDiff
   (setq leftDiffBbox  (list (list (plus (caar leftTapBbox) -diffXSize -extraDiffL 
					 (if (lessp tranWidthL tranWidthR) 
					     -diffNarExtraIn -diffWideExtraIn)
					 )
				   0.0
				   )
			     (list (caar leftTapBbox)
				   tranWidthL
				   )
			     )
	 )
   (setq dbId (dbCreateRect tcCellView diffLayer leftDiffBbox))
   (dbAddFigToNet dbId net)
   (setq pinId (dbCreatePin net dbId))
   pinId~>accessDir = (list "left")
   )
 
 (when rightDiff
   (setq rightDiffBbox (list (list (caadr rightTapBbox) 0.0)
			     (list (plus (caadr rightTapBbox) diffXSize extraDiffR
					 (if (lessp tranWidthR tranWidthL) 
					     diffNarExtraIn diffWideExtraIn)
					 )
				   tranWidthR
				   )
			     )
	 )
   (setq dbId (dbCreateRect tcCellView diffLayer rightDiffBbox))
   (dbAddFigToNet dbId net)
   (setq pinId (dbCreatePin net dbId))
   pinId~>accessDir = (list "right")
   )
 
 (when implant
   (when tapImplant
     ;; we draw the tap implant all in one fell swoop with
     ;; dbCreatePolygon, rather than as three separate
     ;; rectangles. This is because the enclosures
     ;; are complex enough that this is more straightforward,
     ;; as is much simpler visually for designers
     
     ;; draw extra implant to the left of the tap if neither of these
     (setq extraLeftImpTap (not (or leftDiff noEndEnc)))
     ;; draw extra implant to the right of the tap if neither of these
     (setq extraRightImpTap (not (or rightDiff noEndEnc)))
     
     ;; make the points for the tap implant (clockwise from lower left)
     ;; the points marked are those the enclosures are generated at
     ;; f is the equivalent of c when the left transistor is wider than
     ;; the right transistor
     ;;                d---------------------------
     ;;                 |        e|f     g|       |
     ;;                 | center  | right | right |
     ;;                 |  tap    |  tap  |  diff |
     ;;         b      c|         |       |       |
     ;;  ---------------+         |       |       |
     ;;  |left | left   |         |       |       |
     ;;  |diff | tap    |         |       |       |
     ;;  |     |        |         |       |       |
     ;;  |     |        |         |       |       |
     ;;  |     |a       |         |      h|       |
     ;;  ------------------------------------------
     
     (setq point_a (list (difference (caar  leftTapBbox)
				     (if extraLeftImpTap tapImpEnc tapImpEncButt))
			 (difference (cadar leftTapBbox) tapImpEnc )
			 ))
     (setq point_b (list (difference (caar   leftTapBbox)
				     (if extraLeftImpTap  tapImpEnc tapImpEncButt))
			 (plus       (cadadr leftTapBbox) tapImpEnc)
			 ))
     (setq point_c (list (max (difference (caadr leftTapBbox) (max tapImpEncNoButt tapImpEnc))
			      (difference (caar  leftTapBbox)
					  (if extraLeftImpTap tapImpEnc tapImpEncButt))
			      )
			 (plus       (cadadr leftTapBbox)     tapImpEnc)
			 ))
     (setq point_d (list (max (difference (caar centerTapBbox) (max tapImpEncNoButt tapImpEnc))
			      (difference (caar leftTapBbox)
					  (if extraLeftImpTap tapImpEnc tapImpEncButt))
			      )
			 (plus       (cadadr centerTapBbox)   tapImpEnc)
			 ))
     (setq point_e (list (min (plus  (caadr  centerTapBbox)    (max tapImpEncNoButt tapImpEnc))
			      (plus  (caadr  rightTapBbox)
				     (if extraRightImpTap tapImpEnc tapImpEncButt))
			      )
			 (plus       (cadadr centerTapBbox)   tapImpEnc)
			 ))
     (setq point_f (list (min (plus  (caadr  centerTapBbox)  (max tapImpEncNoButt tapImpEnc))
			      (plus  (caadr  rightTapBbox)    
				     (if extraRightImpTap tapImpEnc tapImpEncButt))
			      )
			 (plus       (cadadr rightTapBbox)    tapImpEnc)
			 ))
     (setq point_g (list (plus       (caadr  rightTapBbox)    
				     (if extraRightImpTap tapImpEnc tapImpEncButt))
			 (plus       (cadadr rightTapBbox)    tapImpEnc)
			 ))
     (setq point_h (list (plus       (caadr  rightTapBbox)    
				     (if extraRightImpTap tapImpEnc tapImpEncButt))
			 (difference (cadar  rightTapBbox)    tapImpEnc)
			 ))

     (setq tapImpPoints (list point_a point_b point_c point_d point_e point_f point_g point_h))
     ;; draw the tap implant
     (setq dbId (dbCreatePolygon tcCellView tapImplant tapImpPoints))
     (dbAddFigToNet dbId net)
     ) ;; end when tapImplant
   
   (when diffImplant
     ;; draw the diff implant
     ;; this is done as two rectangles since the diff shapes are much 
     ;; simpler than the tap shapes
     (when leftDiff
       (setq dbId
	     (dbCreateRect tcCellView diffImplant
			   (list (list (if noEndEnc  (caar   leftDiffBbox)
					 (difference (caar   leftDiffBbox) diffImpEnc))
				       (difference   (cadar  leftDiffBbox) diffImpEnc)
				       )
				 (list (plus         (caadr  leftDiffBbox) diffImpEncButt)
				       (plus         (cadadr leftDiffBbox) diffImpEnc)
				       )
				 )
			   ))
       (dbAddFigToNet dbId net)
       )
     (when rightDiff
       (setq dbId 
	     (dbCreateRect tcCellView diffImplant
			   (list (list (difference  (caar   rightDiffBbox) diffImpEncButt)
				       (difference  (cadar  rightDiffBbox) diffImpEnc)
				       )
				 (list (if noEndEnc (caadr  rightDiffBbox)
					 (plus      (caadr  rightDiffBbox) diffImpEnc))
				       (plus        (cadadr rightDiffBbox) diffImpEnc)
				       )
				 )
			   ))
       (dbAddFigToNet dbId net)
       )
     ) ;; end when diffImplant



  (when diffCoreImplant
     ;; draw the diffCore implant
     ;; this is done as two rectangles since the diff shapes are much 
     ;; simpler than the tap shapes
     (when leftDiff
       (setq dbId
	     (dbCreateRect tcCellView diffCoreImplant
			   (list (list (if noEndEnc  (caar   leftDiffBbox)
					 (difference (caar   leftDiffBbox) diffCoreImpEnc))
				       (difference   (cadar  leftDiffBbox) diffCoreImpEnc)
				       )
				 (list (plus         (caadr  leftDiffBbox) diffCoreImpEncButt)
				       (plus         (cadadr leftDiffBbox) diffCoreImpEnc)
				       )
				 )
			   ))
       (dbAddFigToNet dbId net)
       )
     (when rightDiff
       (setq dbId 
	     (dbCreateRect tcCellView diffCoreImplant
			   (list (list (difference  (caar   rightDiffBbox) diffCoreImpEncButt)
				       (difference  (cadar  rightDiffBbox) diffCoreImpEnc)
				       )
				 (list (if noEndEnc (caadr  rightDiffBbox)
					 (plus      (caadr  rightDiffBbox) diffCoreImpEnc))
				       (plus        (cadadr rightDiffBbox) diffCoreImpEnc)
				       )
				 )
			   ))
       (dbAddFigToNet dbId net)
       )
     ) ;; end when diffCoreImplant


   (when (and inWell wellLayer)
     ;; we draw the nwell implant all in one fell swoop with
     ;; dbCreatePolygon, rather than as several separate
     ;; rectangles. This is because the enclosures
     ;; are complex enough that this is more straightforward,
     ;; as is much simpler visually for designers
     
     ;; make the points for the nwell implant (clockwise from lower left)
     ;; the points marked are those the enclosures are generated at
     ;; f is the equivalent of c when the left transistor is wider than
     ;; the right transistor. (a,b) and (g,h) move to the tap edge
     ;; when the corresponding diff isn't drawn. On those edges
     ;; where diff is drawn even with tap, the enclosure is the
     ;; maximum of diff enclosure and tap enclosure. On edges of
     ;; only diff or only tap, the proper enclosure is used
     ;;                d---------------------------
     ;;                 |        e|f      |      g|
     ;;                 | center  | right | right |
     ;;                 |  tap    |  tap  |  diff |
     ;;  b     c        |         |       |       |
     ;;  ---------------+         |       |       |
     ;;  |left | left   |         |       |       |
     ;;  |diff | tap    |         |       |       |
     ;;  |     |        |         |       |       |
     ;;  |     |        |         |       |       |
     ;;  |a    |        |         |       |      h|
     ;;  ------------------------------------------
     (setq point_a (list (difference (if leftDiff (caar leftDiffBbox) (caar leftTapBbox))
				     (if leftDiff wellLayerDiffEnc wellLayerTapEnc)
				     )
			 (difference (cadar leftTapBbox) 
				     (max wellLayerDiffEnc wellLayerTapEnc)
				     )
			 ))
     (setq point_b (list (difference (if leftDiff (caar leftDiffBbox) (caar leftTapBbox))
				     (if leftDiff wellLayerDiffEnc wellLayerTapEnc)
				     )
			 (max (plus       wellWidth (cadr point_a))
			      (plus       (cadadr leftTapBbox)
					  (max wellLayerDiffEnc wellLayerTapEnc)
					  )
			      )
			 ))
     (setq point_c (list (difference (caadr leftTapBbox) wellLayerTapEnc)
			 (max (plus       wellWidth (cadr point_a))
			      (plus       (cadadr leftTapBbox)(max wellLayerDiffEnc wellLayerTapEnc))
			      )
			 ))
     (setq point_d (list (difference (caar centerTapBbox) wellLayerTapEnc)
			 (max (plus       wellWidth (cadr point_a))
			      (plus       (cadadr centerTapBbox) (max wellLayerDiffEnc wellLayerTapEnc))
			      )
			 ))
     (setq point_e (list (plus       (caadr centerTapBbox) wellLayerTapEnc)
			 (max (plus       wellWidth (cadr point_a)) 
			      (plus       (cadadr centerTapBbox) (max wellLayerDiffEnc wellLayerTapEnc))
			      )
			 ))
     (setq point_f (list (plus       (caadr centerTapBbox) wellLayerTapEnc)
			 (max (plus       wellWidth (cadr point_a))
			      (plus       (cadadr rightTapBbox) (max wellLayerDiffEnc wellLayerTapEnc))
			      )
			 ))
     (setq point_g (list (plus       (if rightDiff (caadr rightDiffBbox) (caadr rightTapBbox))
				     (if rightDiff wellLayerDiffEnc wellLayerTapEnc)
				     )
			 (max (plus       wellWidth (cadr point_a))
			      (plus       (cadadr rightTapBbox) (max wellLayerDiffEnc wellLayerTapEnc))
			      )
			 ))
     (setq point_h (list (plus       (if rightDiff (caadr rightDiffBbox) (caadr rightTapBbox))
				     (if rightDiff wellLayerDiffEnc wellLayerTapEnc)
				     )
			 (difference (cadar rightTapBbox) (max wellLayerDiffEnc wellLayerTapEnc))
			 ))
     (setq wellImpPoints (list point_a point_b point_c point_d point_e point_f point_g point_h))
     ;; draw the well implant
     (setq dbId (dbCreatePolygon tcCellView wellLayer wellImpPoints))
     (dbAddFigToNet dbId net)
     (dbCreateProp tcCellView "wellLayerBbox" "list" 
		   (list point_a (list (car point_h) (cadr point_d))))
     ) ;; end when inWell and wellLayer
   ) ;; end when implant

 ;;; draw idLayer
 (when idLayer
   ;; if wellLayer exists and idEncWell then use well's points
   (if (and implant inWell wellLayer idEncWell) then
     (setq point_a (list (difference (car point_a) idLayerEncWell)
                         (difference (cadr point_a)  idLayerEncWell)))
     (setq point_b (list (difference (car point_b)  idLayerEncWell)
                         (plus (cadr point_b) idLayerEncWell)))
     (setq point_c (list (difference (car point_c)  idLayerEncWell)
                         (plus (cadr point_c) idLayerEncWell)))
     (setq point_d (list (difference (car point_d)  idLayerEncWell)
                         (plus (cadr point_d) idLayerEncWell)))
     (setq point_e (list (plus (car point_e) idLayerEncWell)
                         (plus (cadr point_e) idLayerEncWell)))
     (setq point_f (list (plus (car point_f) idLayerEncWell)
                         (plus (cadr point_f) idLayerEncWell)))
     (setq point_g (list (plus (car point_g)  idLayerEncWell)
                         (plus (cadr point_g) idLayerEncWell)))
     (setq point_h (list (plus (car point_h) idLayerEncWell)
                         (difference (cadr point_h)  idLayerEncWell)))
   else
     (setq point_a (list (difference (if leftDiff (caar leftDiffBbox) (caar leftTapBbox))
                                     (if leftDiff idLayerEncDiff idLayerEncTap))
                         (difference (cadar leftTapBbox) (max idLayerEncDiff idLayerEncTap))))
     (setq point_b (list (difference (if leftDiff (caar leftDiffBbox) (caar leftTapBbox))
                                     (if leftDiff idLayerEncDiff idLayerEncTap))
                         (plus  (cadadr leftTapBbox) (max idLayerEncDiff idLayerEncTap))))
     (setq point_c (list (difference (caadr leftTapBbox) idLayerEncTap)
                         (plus (cadadr leftTapBbox)(max idLayerEncDiff idLayerEncTap))))
     (setq point_d (list (difference (caar centerTapBbox) idLayerEncTap)
                         (plus (cadadr centerTapBbox) (max idLayerEncDiff idLayerEncTap))))
     (setq point_e (list (plus (caadr centerTapBbox) idLayerEncTap)
                         (plus (cadadr centerTapBbox) (max idLayerEncDiff idLayerEncTap))))
     (setq point_f (list (plus (caadr centerTapBbox) idLayerEncTap)
                         (plus (cadadr rightTapBbox) (max idLayerEncDiff idLayerEncTap))))
     (setq point_g (list (plus (if rightDiff (caadr rightDiffBbox) (caadr rightTapBbox))
                               (if rightDiff idLayerEncDiff idLayerEncTap))
                         (plus (cadadr rightTapBbox) (max idLayerEncDiff idLayerEncTap))))
     (setq point_h (list (plus (if rightDiff (caadr rightDiffBbox) (caadr rightTapBbox))
                               (if rightDiff idLayerEncDiff idLayerEncTap))
                         (difference (cadar rightTapBbox) (max idLayerEncDiff idLayerEncTap))))
   )
   (setq idLayerPoints (list point_a point_b point_c point_d point_e point_f point_g point_h))
   ;; draw the idLayerplant
   (setq dbId (dbCreatePolygon tcCellView idLayer idLayerPoints))
   (dbAddFigToNet dbId net)
   (dbCreateProp tcCellView "idLayerBbox" "list" (list point_a (list (car point_h) (cadr point_d))))
 ) ; end when idLayer                              


 ;; calculate the contact rows based on
 ;; the width of the largest transistor
 (if centerVia1 then
    (setq via1DrawSpaceY (difference tranWidth (times tapYEncVia1 2)))
    (setq via1Row (floor (quotient  (plus via1DrawSpaceY via1Space) via1YPitch)))
    (setq via1length (difference (times via1Row via1YPitch) via1Space))
    (setq via1Yoffset (quotient (difference via1DrawSpaceY via1length) 2))
    (setq firstVia1Y (plus tapYEncVia1 (times (fix (plus (quotient via1Yoffset snapGrid) 1e-5)) snapGrid)))
  else

    (if tranWidth > (plus via1YPitch via1Length) then
        (setq via1Row (fix (plus (quotient (plus tranWidth via1Space 
                                           (minus (times 2 tapYEncVia1))) via1YPitch) 1e-6)))
     else
        (setq via1Row 1)
    )
    (setq firstVia1Y tapYEncVia1)
 ) 
 (setq firstVia1X tapXEncVia1)
 (setq theY firstVia1Y)
 
 ;; draw the via1s
 (for r 1 via1Row
      (setq theX firstVia1X)
      (for col 1 via1Col
	   (setq dbId (dbCreateRect tcCellView via1Layer
				    (list  theX:theY
					   (plus theX via1Width):(plus theY via1Length))))
	   (dbAddFigToNet dbId net)
	   
	   (setq theX (plus theX via1XPitch))
	   )
      (setq theY (plus theY via1YPitch))
      )
 (setq via1Bbox (list (list firstVia1X firstVia1Y)
		      (cadr dbId~>bBox)))
 
 


 ;; prepare params for slotVia
 (when slotVia
    (setq contactImpParam (list "implant" "boolean" "FALSE"))
    (setq contactWellParam (list "inWell" "boolean" "FALSE"))
    (setq slotViaId (dbOpenCellView tcCellView~>lib slotVia "symbolic" nil "rn"))
    (unless slotViaId (error (sprintf nil "Cannot find/open slotVia contact cell `%s'" slotVia)))
    (unless slotViaId~>isParamCell (error (sprintf nil "Named cell is not a pcell `%s'" slotVia)))
    (setq params slotViaId~>parameters)
    (setq slotX1diffCoord (caar slotViaId~>diffLayerBbox))
    (setq slotX2diffCoord (caadr slotViaId~>diffLayerBbox))
    (setq slotLength (difference slotX2diffCoord slotX1diffCoord))
    (setq slotViaWidth (difference (caadr slotViaId~>bBoxVia1) (caar slotViaId~>bBoxVia1)))
    (setq slotViaLength (difference (cadadr slotViaId~>bBoxVia1) (cadar slotViaId~>bBoxVia1)))
    (setq slotViaEncX (difference (caar slotViaId~>bBoxVia1) slotX1diffCoord))
    (setq slotViaEncY (difference (cadar slotViaId~>bBoxVia1) (cadar slotViaId~>diffLayerBbox)))
 )

 (when strap
   (when rightDiff
      (if slotVia then
         (setq instParams (list (list "w" "float" tranWidthR)))
         (if params~>implant (setq instParams (xcons instParams contactImpParam)))
         (if params~>inWell (setq instParams (xcons instParams contactWellParam)))
         (setq slotViaR_X (difference (caadr rightDiffBbox) slotLength)) 
         (setq slotViaR_Y (cadar rightDiffBbox))

         (setq instR (dbCreateParamInst tcCellView slotViaId "c0" slotViaR_X:slotViaR_Y "R0" 1 instParams ))
         (setq slotViaRY2 (plus slotViaR_Y slotViaEncY slotViaLength))
         (setq via1BboxR (list (plus slotViaR_X slotViaEncX):(plus slotViaR_Y diffYEncVia1)
                            (plus slotViaR_X slotViaWidth slotViaEncX ):(difference tranWidthR slotViaEncY)))
       else
         ;; calculate the rows of right side via1's
         (if centerVia1 then
           (setq via1DrawSpaceY (difference tranWidthR (times diffYEncVia1 2)))
           (setq via1RowR (floor (quotient  (plus via1DrawSpaceY via1Space) via1YPitch)))
           (setq via1length (difference (times via1RowR via1YPitch) via1Space))
           (setq via1Yoffset (quotient (difference via1DrawSpaceY via1length) 2))
           (setq firstVia1Y (plus diffYEncVia1 (times (fix (plus (quotient via1Yoffset snapGrid) 1e-5)) snapGrid)))
         else
           (setq via1RowR (max 1 (fix (plus (quotient (plus tranWidthR via1Space
						    (minus (times 2 diffYEncVia1))) via1YPitch) 1e-6))))
           (setq firstVia1Y diffYEncVia1)
         ) 
         (setq firstVia1X (plus (caadr rightDiffBbox) -diffXEncVia1Out -via1Width -extraDiffR))
         (setq theY firstVia1Y)
     
         ;; draw the right side via1's
         (for r 1 via1RowR
	    (setq dbId (dbCreateRect tcCellView via1Layer
				   (list firstVia1X:theY
					 (plus firstVia1X via1Width):(plus theY via1Length))))
	    (dbAddFigToNet dbId net)
	    (setq theY (plus theY via1YPitch))
	 )
         (setq via1BboxR (list (list firstVia1X firstVia1Y) (cadr dbId~>bBox)))
      )       
   )
   (when leftDiff
      (if slotVia then
         (setq instParams (list (list "w" "float" tranWidthL)))
         (if params~>implant (setq instParams (xcons instParams contactImpParam)))
         (if params~>inWell (setq instParams (xcons instParams contactWellParam)))

         (setq slotViaL_X (caar leftDiffBbox))
         (setq slotViaL_Y (cadar leftDiffBbox))
         (setq instL (dbCreateParamInst tcCellView slotViaId "c1" slotViaL_X:slotViaL_Y "R0" 1 instParams ))
         (setq via1BboxL (list (plus slotViaL_X slotViaEncX):(plus slotViaL_Y slotViaEncY)
                             (plus slotViaL_X slotViaEncX slotViaWidth):(difference tranWidthL slotViaEncY)))

       else
         ;; calculate the rows of left side via1's
         (if centerVia1 then
           (setq via1DrawSpaceY (difference tranWidthL (times diffYEncVia1 2)))
           (setq via1RowL (floor (quotient  (plus via1DrawSpaceY via1Space) via1YPitch)))
           (setq via1length (difference (times via1RowL via1YPitch) via1Space))
           (setq via1Yoffset (quotient (difference via1DrawSpaceY via1length) 2))
           (setq firstVia1Y (plus diffYEncVia1 (times (fix (plus (quotient via1Yoffset snapGrid) 1e-5)) snapGrid)))
         else
           (setq via1RowL (max 1 (fix (plus (quotient (plus tranWidthL via1Space
						    (minus (times 2 diffYEncVia1))) via1YPitch) 1e-6))))
           (setq firstVia1Y diffYEncVia1)
         ) 
         (setq firstVia1X (plus (caar leftDiffBbox) diffXEncVia1Out extraDiffL))
         (setq theY firstVia1Y)
     
         ;; draw the left side via1's
         (for r 1 via1RowL
	     (setq dbId (dbCreateRect tcCellView via1Layer
				   (list firstVia1X:theY
					 (plus firstVia1X via1Width):(plus theY via1Length))))
	     (dbAddFigToNet dbId net)
	     (setq theY (plus theY via1YPitch))
	 )
         (setq via1BboxL (list (list firstVia1X firstVia1Y)
			   (cadr dbId~>bBox)))
       )
   )
 )

;; Calculate layer2 Bbox (layer2 drawn after layer3 section to ensure via2 enclosure)
 (setq layer2Bbox (list (list (difference (caar via1Bbox) layer2XEncVia1)
			      (difference (cadar via1Bbox) layer2YEncVia1)
			      )
			(list (plus (caadr via1Bbox) layer2XEncVia1)
                               (plus (cadadr via1Bbox) layer2YEncVia1)
			      )))

 
 (unless (or noLayer3 (null layer3))
   ;;No. of rows for via2
   (if centerVia2 then
     (setq via2Row (floor (quotient tranWidth via2YPitch)))
     (if (equal via2Row 0) (setq via2Row 1))
     (setq via2Yoffset (quotient (difference tranWidth (difference (times via2Row via2YPitch) via2Space)) 2))
     (setq firstVia2Y (times (fix (plus (quotient via2Yoffset snapGrid) 1e-6)) snapGrid))
    else
     (setq via2Row (max (fix (plus  (quotient (plus tranWidth via2Space (minus (times 2 layer2YEncVia2)))
					    via2YPitch) 1e-6)) 1 ))
     (setq firstVia2Y (plus (cadar layer2Bbox) layer2YEncVia2))
   ) 
   ;;No. of columns for via2

   (setq via2Col (max (fix (plus (quotient (plus (difference (caadr centerTapBbox) (caar centerTapBbox))
					       via2Space (minus (times 2 layer2XEncVia2))) via2XPitch)
				    1e-6)) 1 ))
   
   (setq via2XOffset (quotient (difference (difference (caadr centerTapBbox) (caar centerTapBbox))
					   (plus (minus via2Space)
						 (times via2Col via2XPitch)
						 )
					   ) 2))
   (setq via2XOffset (times (round (plus (quotient via2XOffset snapGrid) 1e-6)) snapGrid))
   
   (setq firstVia2X (plus (caar centerTapBbox) via2XOffset))
   (setq theY firstVia2Y)
   (for r 1 via2Row
	;; we center over the centerTap
	(setq theX firstVia2X)
	(for col 1 via2Col
	     (setq dbId (dbCreateRect tcCellView via2Layer
				      (list  theX:theY
					     (plus theX via2Width):(plus theY via2Length))))
	     (dbAddFigToNet dbId net)
	     (setq theX (plus theX via2XPitch))
	     )
	(setq theY (plus theY via2YPitch))
	)
   (setq via2Bbox (list (list firstVia2X firstVia2Y)
			(cadr dbId~>bBox)))
   
   ;; make sure layer2Bbox is large enough to hold via2's
   (setq layer2Bbox (list (list (min (caar layer2Bbox) 
				     (difference (caar via2Bbox) layer2XEncVia2))
				(min (cadar layer2Bbox)
				     (difference (cadar via2Bbox) layer2YEncVia2))
				)
			  (list (max (caadr layer2Bbox)
				     (plus  (caadr via2Bbox) layer2XEncVia2))
				(max (cadadr layer2Bbox)
				     (plus  (cadadr via2Bbox) layer2YEncVia2))
				)))
   
   ;;Draw layer 3
   (setq layer3Bbox (list (list (difference (caar via2Bbox) layer3XEncVia2)
				(difference (cadar via2Bbox) layer3YEncVia2)
				)
			  (list (plus (caadr via2Bbox) layer3XEncVia2)
				(plus (cadadr via2Bbox) layer3YEncVia2)
				)))
   (setq dbId (dbCreateRect tcCellView layer3 layer3Bbox))
   (dbAddFigToNet dbId net)
   (setq pinId (dbCreatePin net dbId))
   pinId~>accessDir = allDir
   (dbCreateProp tcCellView "topLayerPinBbox" "list" dbId~>bBox)
   (dbCreateProp tcCellView "topLayer" "list" layer3)
   )



 ;; draw layer2 now

 (when strap
   (when leftDiff
     ;; calculate the bounding box for the left layer2
     (setq layer2LX1 (difference (caar via1BboxL) layer2XEncVia1))
     (if emulateSlotViaEnc then
        (setq layer2LY1  (difference diffYEncVia1 layer2YEncVia1))
        (setq layer2LY2 (plus (difference tranWidthL diffYEncVia1) layer2YEncVia1))
      else
        (setq layer2LY1 (min (difference (cadar via1BboxL) layer2YEncVia1) (cadar layer2Bbox)))
        (if (equal tranWidthL tranWidth) then
            (setq layer2LY2 (max (cadadr layer2Bbox) (plus (cadadr via1BboxL) layer2YEncVia1)))
         else
            (setq layer2LY2 (plus (cadadr via1BboxL) layer2YEncVia1))
        )
     )



     (setq layer2LX2 (caadr layer2Bbox))
     
     (setq layer2BboxL (list layer2LX1:layer2LY1 layer2LX2:layer2LY2))

     ;; draw the left layer2
     (setq dbId (dbCreateRect tcCellView layer2 layer2BboxL))
     (dbAddFigToNet dbId net)
     (setq pinId (dbCreatePin net dbId))
     pinId~>accessDir = allDir

     )
   (when rightDiff
     ;; calculate the bounding box for the right layer2
     (setq layer2RX2 (plus (caadr via1BboxR) layer2XEncVia1))
     (if emulateSlotViaEnc then
        (setq layer2RY1  (difference diffYEncVia1 layer2YEncVia1))
        (setq layer2RY2 (plus (difference tranWidthR diffYEncVia1) layer2YEncVia1))
      else
        (setq layer2RY1 (min (difference (cadar via1BboxR) layer2YEncVia1) (cadar layer2Bbox)))
        (if (equal tranWidthR tranWidth) then
            (setq layer2RY2 (max (cadadr layer2Bbox) (plus (cadadr via1BboxR) layer2YEncVia1)))
         else 
            (setq layer2RY2 (plus (cadadr via1BboxR) layer2YEncVia1))
        )
     )
     (setq layer2RX1 (caar layer2Bbox))
     (setq layer2BboxR (list layer2RX1:layer2RY1 layer2RX2:layer2RY2))

     ;; draw the right layer2
     (setq dbId (dbCreateRect tcCellView layer2 layer2BboxR))
     (dbAddFigToNet dbId net)
     (setq pinId (dbCreatePin net dbId))
     pinId~>accessDir = allDir
     )
   )
 (setq dbId (dbCreateRect tcCellView layer2 layer2Bbox))
 (dbAddFigToNet dbId net)
 (setq pinId (dbCreatePin net dbId))
 pinId~>accessDir = allDir
 (unless layer3
   (dbCreateProp tcCellView "topLayerPinBbox" "list" dbId~>bBox)
   (dbCreateProp tcCellView "topLayer" "list" layer2)
   )


) ;; end of tcCreateDeviceClass


(tfcDefineDeviceClassProp
;;(viewName       devClassName           propName          propValue)
;;;-------------------------------------------------------------------
 (symbolic        enhStrap3PolImpClass  function          "contact")
)
;;; 
;;; $Id: flaredGateClass.il,v 1.6 2003/06/30 07:11:16 lpn Exp $
;;; 
;;; flaredGateClass.il
;;; 
;;; Copyright (c) 1997 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Feb 27, 1997
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This is a pcell for the device library that will create a flared gate.
;;; The "w" (width) parameter will be the width of the rgate layer.
;;; 
;;; Revision History:
;;;   gtc 04/22/97  Adding sensible default parameter values
;;;   jbq 02/16/00  Changed the rgate layer to be drawn to the diff edge
;;;   jbq 02/22/00  added 'noflarepoint' property for EsdTranClass
;;;   lpn 01/20/02  Added flareAmount_in to differentiate flareAmount inside and outside
;;;                 diff layer in Esd pcells
;;;                 Added flareGateCascode pcell
;;;   lpn 03/17/03  Fixed the bug in flareGateClass SPR 14641
;;;   lpn 06/12/03  Changed the formal parameter for gateLayer and gateRecognitionLayer
;;;

(putpropqq flaredGateClass "$Id: flaredGateClass.il,v 1.6 2003/06/30 07:11:16 lpn Exp $" SCCS)


(tcCreateDeviceClass
 "symbolic" "flaredGateClass"
 ;; Class parameters
 (
 
 )  
 ;; Formal parameters
 (
  (gateLayer            (list "poly" "drawing"))
  (gateRecognitionLayer (list "poly" "gate"))
  (w                    10.0)
  (l                    1.0)
  (flareAmount_in       0.0);; The amount of flaring inside the diff edge(top and bottom)
  (flareAmount          0.3);; The amount of flaring outside diff edge 
  (flareExtension       2.0)
  (xOffset              0.0)
 )

 ;; 6 ____________ 7
 ;;   |          |
 ;;   |          |
 ;;  5 \ a    b / 8
 ;;     \      /
 ;;    4 |    | 9
 ;;      |    |
 ;;      |    |
 ;;      |    |
 ;;    3 |    | 10
 ;;     /       ;;  2 / c    d \ 11
 ;;   |          |
 ;;   |__________|
 ;;  1            12
 ;;
 ;; There is a point at each vertex of the flared gate that will be used
 ;; to create the flared gate.  The list of points that will be used is:
 ;; (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12).
 ;;
 ;; The gate recognition layer will be created with points:  (a,b,c,d).
 ;;
 ;; The order in which it calculates the points and puts them in the array is:
 ;;
 ;;  time  --->
 ;; index   point
 ;;  [0]    1
 ;;  [1]        2
 ;;  [2]        |    3
 ;;  [3]        |         4
 ;;  [4]        |         |    5
 ;;  [5]        |         |         6
 ;;  [6]        |         |         7
 ;;  [7]        |         |    8
 ;;  [8]        |         9
 ;;  [9]        |   10
 ;; [10]       11
 ;; [11]   12
 ;; [12]             c
 ;; [13]             d
 ;; [14]                  a
 ;; [15]                  b 

 (declare thePoints[16])

 ;; x1 and x1Delta deal with the x coordinates that are flared out.
 ;; x2 and x2Delta deal with the x coordinates that are not flared out.
 
 (setq x1 (plus xOffset -flareAmount_in -flareAmount))
 (setq x2 xOffset)
 (setq x1Delta (plus (times 2.0 (plus flareAmount_in flareAmount)) l))
 (setq x2Delta l)
 
 (setq theY (plus -flareAmount -flareExtension))
 thePoints[0] = x1:theY
 thePoints[11] = (plus x1 x1Delta):theY
 
 (setq theY -flareAmount)
 thePoints[1] = x1:theY
 thePoints[10] = (plus x1 x1Delta):theY
 
 (setq theY flareAmount_in)
 thePoints[2] = x2:theY
 thePoints[9] = (plus x2 x2Delta):theY
 thePoints[12] = x2:(plus theY -flareAmount_in)
 thePoints[13] = (plus x2 x2Delta):(plus theY -flareAmount_in)
 
 (setq theY (plus w -flareAmount_in))
 thePoints[3] = x2:theY
 thePoints[8] = (plus x2 x2Delta):theY
 thePoints[14] = x2:(plus theY flareAmount_in)
 thePoints[15] = (plus x2 x2Delta):(plus theY flareAmount_in)
 
 (setq theY (plus w flareAmount))
 thePoints[4] = x1:theY
 thePoints[7] = (plus x1 x1Delta):theY
     
 (setq theY (plus w flareAmount flareExtension))
 thePoints[5] = x1:theY
 thePoints[6] = (plus x1 x1Delta):theY
 
 (setq pointList nil)
 (for i 1 16
      (setq pointList (cons thePoints[16 - i] pointList))
 )
 
 (setq pointList_12 nil)
 (for i 1 12
      (setq pointList_12 (cons thePoints[12 - i] pointList_12))
 )
 
 (when gateLayer
     (setq dbid (dbCreatePolygon tcCellView gateLayer pointList_12))
 )
     
 (when gateRecognitionLayer
     (setq dbid (dbCreateRect tcCellView gateRecognitionLayer
			      (list thePoints[12] thePoints[15])))
 )
 
 (dbCreateProp tcCellView "gatePoints" "list" pointList)
 (dbCreateProp tcCellView "rgatePoints" "list"
	       (list thePoints[12] thePoints[15]))
 (dbCreateProp tcCellView "noflarePoints" "list"
	       (list thePoints[2] thePoints[8]))
 (dbCreateProp tcCellView "topFlarePoints" "list"
	       (list thePoints[3] thePoints[4] thePoints[5]
		     thePoints[6] thePoints[7] thePoints[8]))
 (dbCreateProp tcCellView "bottomFlarePoints" "list"
	       (list thePoints[0] thePoints[1] thePoints[2]
		     thePoints[9] thePoints[10] thePoints[11]))
)


(tcCreateDeviceClass
 "symbolic" "flaredGateCascodeClass"
 ;; Class parameters
 (                      
 )
 ;; Formal parameters
 (
  (gateLayer            (list "poly" "drawing"))
  (gateRecognitionLayer (list "poly" "gate"))
  (w                    10.0)
  (l                    1.0)
  (flareAmount_in       1.0) ;; The amount of flaring inside the diff edge(top and bottom) 
  (flareAmount_out      0.3) ;; The amount of flaring outside the diff edge(top and bottom)
  (flareExtension       2.0)
  (xOffset              0.0)
  (gateToGateSpace      0.6)
 )
 
 ;; 6   ____ 7    10____ 11
 ;;    |    |      |    |
 ;;    |    |      |    |
 ;;  5  \ a |b    e|  f/ 12              a = 24
 ;;      \  |      |  /                   b = 23
 ;;    4  | |25 26 | | 13                 c = 17
 ;;       | |      | |                    d = 18
 ;;       | |      | |                    e = 22
 ;;       | |      | |                    f = 21
 ;;    3  | |27 28 | | 14                 g = 19 
 ;;      /  |      |  \                   h = 20
 ;;  2  / c |d    g| h \ 15
 ;;    |    |      |    |
 ;;    |____|      |____|
 ;;  1       8    9      16
 ;;
 ;;
 
 
 
 (declare thePoints[28])

 ;; x1 and x1Delta deal with the x coordinates that are flared out.
 ;; x2 and x2Delta deal with the x coordinates that are not flared out.
 (setq x1 (plus xOffset -flareAmount_in -flareAmount_out)) 
 (setq x2 xOffset)
 (setq x3 (plus x1 flareAmount_in flareAmount_out gateToGateSpace l)) 


 (setq x1Delta (plus flareAmount_in flareAmount_out  l))
 (setq x2Delta l)
 (setq x3Delta (plus flareAmount_in flareAmount_out l))

 (setq theY (plus -flareAmount_out -flareExtension))
 thePoints[0]  = x1:theY
 thePoints[7]  = (plus x1 x1Delta):theY
 thePoints[8]  = x3:theY
 thePoints[15] = (plus x3 x3Delta ):theY


 (setq theY -flareAmount_out)
 thePoints[1] = x1:theY
 thePoints[14] = (plus x3 x3Delta):theY


 (setq theY flareAmount_in)
 thePoints[2] = x2:theY
 thePoints[13] = (plus x3 x2Delta):theY

 thePoints[16] = x2:(plus theY -flareAmount_in)
 thePoints[17] = (plus x2 x2Delta):(plus theY -flareAmount_in)
 thePoints[18] = x3:(plus theY -flareAmount_in)
 thePoints[19] = (plus x3 x2Delta):(plus theY -flareAmount_in)

 thePoints[26] = (plus x1 x1Delta):theY  ;; point 3 --- point27
 thePoints[27] =  x3:theY                ;; point 14 --- point28

 (setq theY (plus w -flareAmount_in))
 thePoints[3] = x2:theY
 thePoints[12] = (plus x3 x2Delta):theY

 thePoints[23] = x2:(plus theY flareAmount_in)
 thePoints[22] = (plus x2 x2Delta):(plus theY flareAmount_in)
 thePoints[21] = x3:(plus theY flareAmount_in)
 thePoints[20] = (plus x3 x2Delta):(plus theY flareAmount_in)
 
 thePoints[24] = (plus x1 x1Delta):theY  ;; point 4 --- point25 
 thePoints[25] =  x3:theY                ;; point 13 --- point26

(setq theY (plus w flareAmount_out))
 thePoints[4] = x1:theY
 thePoints[11] = (plus x3 x3Delta):theY

 (setq theY (plus w flareAmount_out flareExtension))
 thePoints[5] = x1:theY
 thePoints[6] = (plus x1 x1Delta):theY
 thePoints[9] = x3:theY
 thePoints[10] = (plus x3 x3Delta):theY


(setq pointList1 nil)
(setq pointList2 nil)
(for i 1 8
     (setq pointList1 (cons thePoints[8 - i] pointList1))
     (setq pointList2 (cons thePoints[16 - i] pointList2))  
)


(when gateLayer
    (setq dbid (dbCreatePolygon tcCellView gateLayer pointList1))
    (setq dbid (dbCreatePolygon tcCellView gateLayer pointList2))
    
)

(when gateRecognitionLayer
    (setq dbid (dbCreateRect tcCellView gateRecognitionLayer
			     (list thePoints[16] thePoints[22])))
    (setq dbid (dbCreateRect tcCellView gateRecognitionLayer
			     (list thePoints[18] thePoints[20])))
    
)

(dbCreateProp tcCellView "gatePoints" "list" (append pointList1 pointList2))
(dbCreateProp tcCellView "rgatePoints" "list"
	      (list thePoints[16] thePoints[22] thePoints[18] thePoints[20] ))

(dbCreateProp tcCellView "noflarePoints" "list"
	      (list thePoints[3] thePoints[26]))
(dbCreateProp tcCellView "noflarePoints1" "list"
	      (list thePoints[25] thePoints[13]))

(dbCreateProp tcCellView "topFlarePoints" "list"
	      (list thePoints[3] thePoints[4] thePoints[5]
		    thePoints[6] thePoints[24]))
(dbCreateProp tcCellView "topFlarePoints1" "list"
	      (list thePoints[25] thePoints[9] thePoints[10]
		    thePoints[11] thePoints[12]))

(dbCreateProp tcCellView "bottomFlarePoints" "list"
	      (list thePoints[0] thePoints[1] thePoints[2]
		    thePoints[26] thePoints[7]))

(dbCreateProp tcCellView "bottomFlarePoints1" "list"
	      (list thePoints[8] thePoints[27] thePoints[13]
		    thePoints[14] thePoints[15]))

)

;;; 
;;; $Id: fuseShieldClass.il,v 1.2 2004/05/21 19:35:16 cva Exp $ %T%
;;; 
;;; fuseShieldClass.il
;;; 
;;; Copyright (c) 2001 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Oct 08, 2001
;;; Author: Kresimir Mihic (kmi) @ KYCC
;;; 
;;; Description:
;;;   This class has been developed to declare fuse devices
;;;
;;; Revision History:
;;;   kmi 10/08/01  Initial version: copied and upgraded from fuseClass.il
;;;   cva 05/21/04  updated for double vias
;;;   


;;;
;;;   NOTE: We should always use a contact for which at least one of
;;;     top and bottom layer should be the same as fuseOnLayer. i.e.,
;;;     if the fuse is on Li1, then we should use either a contact to
;;;     poly or contact to met1. The fuseSealRing should also be taken
;;;     into consideration in determining the contact and pinLayer.
;;;


(putpropqq fuseShieldClass "$Id: fuseShieldClass.il,v 1.2 2004/05/21 19:35:16 cva Exp $ %T%" SCCS)

(tcCreateDeviceClass
 "symbolic" "fuseShieldClass"
 ;; class parameters
 (
  (fuseOnLayer "hilite")                ;;; The layer on which fuse is drawn
  (fuseLayer (list "fuse" "drawing"))   ;;; the fuse recognition layer
  (targLayer (list "target" "drawing")) ;;; laser target layer
  (targWidth 0.2)                       ;;; dimension of the laser target
  (fusePadLayer nil)                    ;;; the fuse pad layer (nil) if not required (e.g., r30)
  (padXEncCenter 0.0)                   ;;; enclosure of the center of fuseOnLayer by pad.
  (padYEncFuse 0.0)                     ;;; enclosure of the fuseOnLayer by pad in Y dir.
  (contactName nil)                     ;;; The contact for the fuse.
  (pinLayer    nil)                     ;;; The layer on which pin must be drawn, if nil then
                                        ;;; topLayer of the contact will be used.
  (shieldLength	0.0)
  (shieldWidth	0.0)
 )
 ;; formal parameters
 (
  (loShieldOffset      0.0)
  (lowerShield         "FALSE")
  (upShieldOffset      0.0)
  (upperShield         "FALSE")
  (rw 0.0)
  (rl 0.0)
  (yOffset 0.0)		
 )

 (if loShieldOffset <= 0 then (error "loShieldOffset can not be smaller or equal to zero"))
 (if upShieldOffset <= 0 then (error "upShieldOffset can not be smaller or equal to zero"))
 (if ((upperShield==t) || (upperShield=="TRUE")) then upperShield = t else upperShield = nil)
 (if ((lowerShield==t) || (lowerShield=="TRUE")) then lowerShield = t else lowerShield = nil)
 
 ;; Make sure the fuseonlayer is a list. It will be compared with
 ;; the top layer of the contact later on to draw the pins properly.
 (when (stringp fuseOnLayer)
     (setq fuseOnLayer (list fuseOnLayer "drawing"))
 )

 ;; same for the pin layer
 (when (stringp pinLayer)
     (setq pinLayer (list pinLayer "drawing"))
 )

 ;; make the nets for the two terminals of the fuse.
 (setq net0 (dbMakeNet tcCellView "f0"))
 (setq net1 (dbMakeNet tcCellView "f1"))
 (setq net (dbMakeNet tcCellView "ppd"))

 ;; initialize the delta y1 and rotation of the contacts
 (setq deltaX1 0.0)
 (setq deltaY1 0.0)
 (setq orient "R0")

 ;; contactName field cannot be empty
 (when (or (null contactName) (equal contactName ""))
     (error "Contact name should always be specified\n")
 )

 ;; get the dbids of the named contact
 ;; See if the field is defined and get the id
 ;; If cannot find the cell -- error. The cell should be in the same library
 ;; as the current pcell is.
 (when (and contactName (nequal contactName ""))
     (setq contactId (dbOpenCellView tcCellView~>lib contactName "symbolic" nil "rn"))
     (unless contactId
	 (error "Cannot find/open contact contact cell `%s'\n" contactName)
     )
 )
 
 ;; Create the contact on the left.
 (setq inst0 (dbCreateParamInst tcCellView 
				contactId "f0" 
				yOffset:0.0 "R0" 1))
 (unless inst0
     (error "Cannot create an inst of `%s'\n" contactName)
 )
 

 ;; Get the master of the inst0 or inst1. Both should have the same master.
 (setq master inst0~>master)

 ;;Determine botLayer, botLayerBbox, topLayer and topLayerBbox
 (if (and master~>topLayer master~>botLayer master~>topLayerPinBbox master~>botLayerBbox) then
     (setq botLayer master~>botLayer)
     (setq topLayer master~>topLayer)
     (setq botBbox master~>botLayerBbox)
     (setq topBbox master~>topLayerPinBbox)
  else
     (error "Cannot find the proper master properties on the contact\n")
 )

 ;; If the pinLayer is not specified then the topLayer of the contact is used to
 ;; draw the contact.
 (when (or (null pinLayer) (equal pinLayer ""))
     (error "Pinlayer has not been defined\n")
 )
 

 ;; We also have to make sure that the fuseOnLayer touches the proper layer
 ;; of the contact (notch fill). Only top and bottom layers of the contact
 ;; are checked.
 
 (cond
     ((and (equal fuseOnLayer botLayer)
	   (lessp (difference (caar master~>bBox) (caar botBbox)) 1e-6))
      (setq deltaY1 (minus (caar botBbox)))
      (setq orient "R90")
      ;(setq deltaX1 (difference (caadr master~>bBox) (caar master~>bBox)))
      (setq deltaX1 (difference (cadadr master~>bBox) (cadar master~>bBox)))
     )    
     ((and (equal fuseOnLayer topLayer)
	   (lessp (difference (caar master~>bBox) (caar topBbox)) 1e-6))
      ;(setq deltaY1 (minus (caar topBbox)))
      (setq deltaY1  (minus (quotient (difference (difference (caadr master~>bBox) (caar master~>bBox)) rw) 2.0)))
      (setq orient "R90")
      ;(setq deltaX1 (difference (caadr master~>bBox) (caar master~>bBox)))
      (setq deltaX1 (difference (cadadr master~>bBox) (cadar master~>bBox)))
     )
 )

 ;; move the first contact that is placed
 (dbMoveFig inst0 nil (list 0.0:deltaY1 orient))

 ;; Create the contact on the right.
 (setq inst1 (dbCreateParamInst tcCellView contactId "f1"
				(plus rl deltaX1):deltaY1+yOffset orient 1))
 (unless inst1
     (error "Cannot create an inst of `%s'\n" contactName)
 )

 ;; Set the bounding box for the pinLayer
 (setq bBox master~>bBox)

 ;; draw the pin for the left contact set it equal to the left contact and move it the same way
 (setq dbid (dbCreateRect tcCellView pinLayer master~>bBox))

 ;; move the pin over first contact that is placed
 (dbMoveFig dbid nil (list 0.0:deltaY1 orient))

; old method 
;; draw the pin for the left contact
; (setq dbid (dbCreateRect tcCellView pinLayer
;			  (list (difference 0.0 (caar bBox)):(plus (cadar bBox) deltaY1+yOffset)
;				(difference 0.0 (caadr bBox)):(plus (cadadr bBox) deltaY1+yOffset)))
; )

 ;; make it a pin.
 (dbCreatePin net0 dbid)

; old method
;; draw the pin for right contact
; (setq dbid (dbCreateRect tcCellView pinLayer
;			  (list (plus rl (caar bBox)):(plus (cadar bBox) deltaY1+yOffset)
;				(plus rl (caadr bBox)):(plus (cadadr bBox) deltaY1+yOffset)))
; )

 ;; draw the pin for the left contact set it equal to the left contact and move it the same way
 (setq dbid (dbCreateRect tcCellView pinLayer master~>bBox))

 ;; move the pin over first contact that is placed
 (dbMoveFig dbid nil (list (plus rl deltaX1):deltaY1 orient))

 ;; make it a pin.
 (dbCreatePin net1 dbid)

 (setq fuseX1 (minus (cadadr master~>bBox)))
 (setq fuseX2 (plus rl (cadadr master~>bBox)))

 ;; draw the fuseOnLayer rectangle
 (setq dbId (dbCreateRect tcCellView fuseOnLayer
			  (list fuseX1:yOffset fuseX2:rw+yOffset))
 )
 ;; The fuse layer is put on a different net than the two terminals.
 (dbAddFigToNet dbId net)

 ;; draw the upper shield
 (when upperShield
   (setq upShieldX1 (quotient (difference rl shieldLength) 2)) 
   (setq upShieldY1 (plus yOffset (quotient rw 2) upShieldOffset))
   (setq upShieldX2 (plus (quotient (difference rl shieldLength) 2) shieldLength)) 
   (setq upShieldY2 (plus upShieldY1 shieldWidth))
   (setq dbId (dbCreateRect tcCellView fuseOnLayer
                          (list upShieldX1:upShieldY1 upShieldX2:upShieldY2)))
 )

 ;; draw the lower shield
 (when lowerShield
   (setq loShieldX1 (quotient (difference rl shieldLength) 2)) 
   (setq loShieldY1 (difference yOffset (difference loShieldOffset (quotient rw 2))))
   (setq loShieldX2 (plus (quotient (difference rl shieldLength) 2) shieldLength)) 
   (setq loShieldY2 (difference loShieldY1 shieldWidth))
   (setq dbId (dbCreateRect tcCellView fuseOnLayer
                          (list loShieldX1:loShieldY1 loShieldX2:loShieldY2)))
 )
 
 ;; draw the fuse recognition layer if defined.
 (when fuseLayer
     (setq dbId (dbCreateRect tcCellView fuseLayer (list 0.0:yOffset rl:rw+yOffset)))
 )
 
 ;; draw the laser target
 (setq x1Coord (quotient (difference rl targWidth) 2.0))
 (setq y1Coord (quotient (difference rw targWidth) 2.0)+yOffset)
 (setq dbId (dbCreateRect tcCellView targLayer
			  (list x1Coord:y1Coord
				(plus x1Coord targWidth):(plus y1Coord targWidth)))
 )
 
 ;; draw the fuse pad if defined.
 ;; For the fuse, usually minimum pad opening is provided by the technology
 (when fusePadLayer
     (dbCreateRect tcCellView fusePadLayer
		   (list (difference (quotient rl 2.0) padXEncCenter):(-padYEncFuse+yOffset)
			 (plus (quotient rl 2.0) padXEncCenter):rw+padYEncFuse+yOffset )
     )
 )
)

(tfcDefineDeviceClassProp
 ;;(viewName       devClassName  propName          propValue)
 (symbolic        fuseShieldClass     function          "transistor")
)
;;; 
;;; $Id: intRingClass.il,v 1.1 1998/02/10 13:22:15 gtc Exp $ %T%
;;; 
;;; intRingClass.il
;;; 
;;; Copyright (c) 1997 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Oct 01, 1997
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This is the device library code for a generic ring.  Many devices
;;; in the device library use a ring type of structure.  Using this device,
;;; a lot of code will not have to be rewritten.
;;;   All of the parameters are formal parameters.  This ring is not meant
;;; to be placed by designers, but by other devices in the device library.
;;; 
;;; Revision History:
;;;   gtc 04/22/97  Giving sensible default parameter values
;;;   gtc 07/25/97  Adding option to break into 4 polygons to work around
;;;                 a vampire drc bug
;;;   gtc 10/01/97  Copied from "ringClass" and modified to take integer
;;;                 arguments for the all the size arguments (w, l, etc).
;;;                 This was due to floating point precision errors
;;;                 resulting in off grid points.  The parameters will
;;;                 (eventually) be divided by dbuperuu internally.
;;;   gtc 01/22/98  Copying over from v20
;;; 
;;; 

(putpropqq intringClass "$Id: intRingClass.il,v 1.1 1998/02/10 13:22:15 gtc Exp $ %T%" SCCS)

(tcCreateDeviceClass
 "symbolic" "intRingClass"
 ;; Class parameters
 (
 )
 ;; Formal parameters
 (
  (w                      50000)
  (l                      50000)
  (xOffset                0)
  (yOffset                0)
  (ringLayer              (list "hilite" "drawing"))
  (ringWidth              4000)
  (additionalWidthInBevel 0)
  (llBevelLength          0)
  (ulBevelLength          0)
  (lrBevelLength          0)
  (urBevelLength          0)
  (bevelTheOutside        "FALSE")
  (grid                   50)
  (breakupPolygons        "FALSE")
 )

 (setq dbuperuu tcCellView~>DBUPerUU)

 ;; get the input parameters on grid
 (foreach param '(w l xOffset yOffset ringWidth additionalWidthInBevel
		    llBevelLength ulBevelLength lrBevelLength urBevelLength)
     (unless (zerop (mod (eval param) grid))
	 (set param (xtimes (xquotient (xplus (eval param) grid) grid) grid))
     )
 )

 ;; in some situations, it is desirable to bevel the inside of the corners,
 ;; but not the outside.  If so, "bevelTheOutside" should be false/nil
 (when (equal bevelTheOutside "FALSE")
     (setq bevelTheOutside nil)
 )

 ;; in some situations, vampire cannot handle the complex geometries that
 ;; this pcell can  spit out.  Therefore, we must breakup this one polygon
 ;; into four polygons that still make up the same shape.  This seems to
 ;; appease the current vampire bug
 (when (equal breakupPolygons "FALSE")
     (setq breakupPolygons nil)
 )

 ;; there is a big load of geometry/math behind this equation, but it
 ;; all boils down to the following equation.  (See the design document
 ;; for the geometry/math.)  The "bevelInsideOffset" is necessary to
 ;; maintain the minimum width throughout the bevel.  bevelInsideOffset is:
 ;;    o how much higher point 1 is wrt point 9  (points are in figure below)
 ;;    o how much further to the right point 2 is wrt point 10
 (setq s2 (sqrt 2.0))
 (setq bevelInsideOffset (plus (times ringWidth (difference s2 1.0))
			       (times s2 additionalWidthInBevel)))
 ;; get it to an integer
 (setq bevelInsideOffset (fix (plus bevelInsideOffset 0.999)))

 ;; get it on grid
 (unless (zerop (mod bevelInsideOffset grid))
     (setq bevelInsideOffset (xtimes (xquotient (xplus bevelInsideOffset grid) grid) grid))
 )


 ;; "cannotBevelLength" is the point at which the inside bevel will be
 ;; pinched off.  We do not allow bevels to occur when the bevel length
 ;; in a corner is less than this value
 (setq cannotBevelLength (xdifference ringWidth bevelInsideOffset))

 ;; determine whether it should bevel in each corner
 (cond ((setq llBevel (greaterp llBevelLength cannotBevelLength))
	(setq arraySize 4)
       )
     (t (setq arraySize 2))
 )

 (cond ((setq lrBevel (greaterp lrBevelLength cannotBevelLength))
	(setq arraySize (xplus arraySize 4))
       )
     (t (setq arraySize (xplus arraySize 2)))
 )

 (cond ((setq urBevel (greaterp urBevelLength cannotBevelLength))
	(setq arraySize (xplus arraySize 4))
       )
     (t (setq arraySize (xplus arraySize 2)))
 )

 (cond ((setq ulBevel (greaterp ulBevelLength cannotBevelLength))
	(setq arraySize (xplus arraySize 4))
       )
     (t (setq arraySize (xplus arraySize 2)))
 )

 ;;     15_____________________________14
 ;;      /                              ;;     /    _______________________     ;;    /    /7                     6\     ;; 16/    /                         \    \13
 ;;  |    /8                         5\    |
 ;;  |   |                             |   |
 ;;  |   |                             |   |
 ;;  |   |                             |   |
 ;;  |   |1                           4|   |
 ;;  | /  \                           /    |
 ;;  9\    \                         /    /12
 ;;    \    \2_____________________3/    /
 ;;     \                               /
 ;;    10\_____________________________/11
 ;;
 ;; There is a point at each vertex of the ring that will be used to create
 ;; the ring.  The list of points that will be used to create the ring is:
 ;; (1, 8, 7, 6, 5, 4, 3, 2, 1, 9, 10, 11, 12, 13, 14, 15, 16, 9, 1)
 ;; If they opt to create the ring in four sections, the sections will be:
 ;; section 1:  (1, 2, 3, 11, 10, 9)
 ;; section 2:  (3, 4, 5, 13, 12, 11)
 ;; section 3:  (5, 6, 7, 15, 14, 13)
 ;; section 4:  (7, 8, 1, 9, 16, 15)
 ;;
 ;; This will have the cut in the ring between points 1 and 9.
 ;; Whenever there is not going to be a bevel in a corner, the points
 ;; will be merged in that corner.  For example, if there was not a
 ;; bevel in the LL (lower left) corner, points 1 & 2 will become one point,
 ;; and points 9 and 10 will become one point.
 ;;
 ;; The order in which it calculates the points and puts them in the array is:
 ;; 
 ;; time   --->
 ;;index  corner
 ;;              [0]                             1
 ;;              [1]        UL                8
 ;;              [2]        UL             7
 ;;              [3]      UR            6  |
 ;;              [4]      UR         5     |
 ;;     /\       [5]    LR        4        |
 ;;     |        [6]    LR     3  |        |
 ;;     |        [7]  LL    2     |        |
 ;; insideIndex  [8]  LL 1        |        |
 ;; outsideIndex [9]  LL 9        |        |
 ;;     |        [10] LL   10     |        |
 ;;     |        [11]   LR    11  |        |
 ;;     \/       [12]   LR       12        |
 ;;              [13]     UR        13     |
 ;;              [14]     UR           14  |
 ;;              [15]       UL            15
 ;;              [16]       UL               16
 ;;              [17]                            9
 ;;              [18]                            1
 ;;
 ;; For each non-bevelled corner, the two entries for that corner in the
 ;; first half of the array will be merged, and the two entries for that
 ;; corner in the second half of the array will be merged.  For example,
 ;; if the UR (upper right) corner was not bevelled, array entries number
 ;; 3 and 4 will be merged, and entries 13 and 14 will be merged.

 ;; the insideIndex will start in the middle and count down to 0
 (setq insideIndex (xquotient arraySize 2))

 ;; the outsideIndex will start in the middle +1 and count up to arraySize
 (setq outsideIndex (xplus insideIndex 1))
 (setq arraySize (xplus arraySize 3))  ;; to handle a cut in the ring

 ;; Initialize the ring points
 (declare theRingPoints[arraySize])
 (setq theOutsideX xOffset)
 (setq theOutsideY yOffset)

 ;; Start with the lower left corner
 (cond ((null llBevel)  ;; no bevel in the ll corner
	(setq theInsideX (xplus theOutsideX ringWidth))
	(setq theInsideY (xplus theOutsideY ringWidth))

	(setq beginningInsidePoint theInsideX:theInsideY)
	(setq beginningOutsidePoint theOutsideX:theOutsideY)

	;; add the inside points to the beginning of the ring points,
	;; and the outside points to the end of the ring points
	theRingPoints[insideIndex] = beginningInsidePoint
	theRingPoints[outsideIndex] = beginningOutsidePoint
	(setq insideIndex (xdifference insideIndex 1))
	(setq outsideIndex (xplus outsideIndex 1))
       )

     (t ;; there is a bevel in the ll corner
      (setq theOutsideY (xplus theOutsideY llBevelLength))
      (setq theInsideY (xplus theOutsideY bevelInsideOffset))
      (setq theInsideX (xplus theOutsideX ringWidth))

      (setq beginningInsidePoint theInsideX:theInsideY)
      (setq beginningOutsidePoint theOutsideX:theOutsideY)

      theRingPoints[insideIndex] = beginningInsidePoint
      (setq insideIndex (xdifference insideIndex 1))
      (when bevelTheOutside
	  theRingPoints[outsideIndex] = beginningOutsidePoint
	  (setq outsideIndex (xplus outsideIndex 1))
      )

      (setq theOutsideX (xplus theOutsideX llBevelLength))
      (setq theOutsideY yOffset)
      (setq theInsideX (xplus theOutsideX bevelInsideOffset))
      (setq theInsideY (xplus theOutsideY ringWidth))

      theRingPoints[insideIndex] = theInsideX:theInsideY
      (setq insideIndex (xdifference insideIndex 1))
      (cond (bevelTheOutside
	     theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	    )
	  (t
	   theRingPoints[outsideIndex] = xOffset:theOutsideY
	   beginningOutsidePoint = theRingPoints[outsideIndex]
	  )
      )
      (setq outsideIndex (xplus outsideIndex 1))

     ) ;; done with the LL bevelled case
 ) ;; done with the LL corner

 (cond ((null lrBevel) ;; no bevel in the lr corner
	(setq theOutsideX (xplus xOffset l))
	(setq theInsideX (xdifference theOutsideX ringWidth))

	theRingPoints[insideIndex] = theInsideX:theInsideY
	theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	(setq insideIndex (xdifference insideIndex 1))
	(setq outsideIndex (xplus outsideIndex 1))
       )

     (t ;; there is a bevel in the lr corner
      (setq theOutsideX (xplus xOffset l -lrBevelLength))
      (setq theInsideX (xdifference theOutsideX bevelInsideOffset))

      theRingPoints[insideIndex] = theInsideX:theInsideY
      (setq insideIndex (xdifference insideIndex 1))
      (when bevelTheOutside
	  theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	  (setq outsideIndex (xplus outsideIndex 1))
      )

      (setq theOutsideX (xplus theOutsideX lrBevelLength))
      (setq theInsideX (xdifference theOutsideX ringWidth))
      (setq theOutsideY (xplus theOutsideY lrBevelLength))
      (setq theInsideY (xplus theOutsideY bevelInsideOffset))

      theRingPoints[insideIndex] = theInsideX:theInsideY
      (setq insideIndex (xdifference insideIndex 1))
      (cond (bevelTheOutside
	     theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	    )
	  (t
	   theRingPoints[outsideIndex] = theOutsideX:yOffset
	  )
      )
      (setq outsideIndex (xplus outsideIndex 1))
     ) ;; done with the LR bevelled case
 ) ;; done with the LR corner

 (cond ((null urBevel) ;; no bevel in the UR corner
	(setq theOutsideY (xplus yOffset w))
	(setq theInsideY (xdifference theOutsideY ringWidth))

	theRingPoints[insideIndex] = theInsideX:theInsideY
	theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	(setq insideIndex (xdifference insideIndex 1))
	(setq outsideIndex (xplus outsideIndex 1))
       )

     (t ;; there is a bevel in the UR corner
      (setq theOutsideY (xplus yOffset w -urBevelLength))
      (setq theInsideY (xdifference theOutsideY bevelInsideOffset))

      theRingPoints[insideIndex] = theInsideX:theInsideY
      (setq insideIndex (xdifference insideIndex 1))
      (when bevelTheOutside
	  theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	  (setq outsideIndex (xplus outsideIndex 1))
      )

      (setq theOutsideY (xplus yOffset w))
      (setq theInsideY (xdifference theOutsideY ringWidth))
      (setq theOutsideX (xdifference theOutsideX urBevelLength))
      (setq theInsideX (xdifference theOutsideX bevelInsideOffset))

      theRingPoints[insideIndex] = theInsideX:theInsideY
      (setq insideIndex (xdifference insideIndex 1))
      (cond (bevelTheOutside
	     theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	    )
	  (t
	   theRingPoints[outsideIndex] = (xplus xOffset l):theOutsideY
	  )
      )
      (setq outsideIndex (xplus outsideIndex 1))
     ) ;; done with the UR bevelled case
 ) ;; done with the UR corner

 (cond ((null ulBevel) ;; no bevel in the UL corner
	(setq theOutsideX xOffset)
	(setq theInsideX (xplus theOutsideX ringWidth))

	theRingPoints[insideIndex] = theInsideX:theInsideY
	theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	(setq insideIndex (xdifference insideIndex 1))
	(setq outsideIndex (xplus outsideIndex 1))
       )

     (t ;; there is a bevel in the UL corner
      (setq theOutsideX (xplus xOffset ulBevelLength))
      (setq theInsideX (xplus theOutsideX bevelInsideOffset))

      theRingPoints[insideIndex] = theInsideX:theInsideY
      (setq insideIndex (xdifference insideIndex 1))
      (when bevelTheOutside
	  theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	  (setq outsideIndex (xplus outsideIndex 1))
      )

      (setq theOutsideX xOffset)
      (setq theInsideX (xplus theOutsideX ringWidth))
      (setq theOutsideY (xdifference theOutsideY ulBevelLength))
      (setq theInsideY (xdifference theOutsideY bevelInsideOffset))

      theRingPoints[insideIndex] = theInsideX:theInsideY
      (setq insideIndex (xdifference insideIndex 1))
      (cond (bevelTheOutside
	     theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	    )
	  (t
	   theRingPoints[outsideIndex] = theOutsideX:(xplus yOffset w)
	  )
      )
      (setq outsideIndex (xplus outsideIndex 1))
     ) ;; done with the UL bevelled case
 ) ;; done with the UL corner

 theRingPoints[insideIndex] = beginningInsidePoint
 theRingPoints[outsideIndex] = beginningOutsidePoint
 (setq outsideIndex (xplus outsideIndex 1))
 theRingPoints[outsideIndex] = beginningInsidePoint

 (cond (breakupPolygons ; create four polygons for the ring shape

	;; the insideIndex will start in the middle and count down to 0
	(setq insideIndex (xquotient (xdifference arraySize 3) 2))

	;; the outsideIndex will start in the middle +1 and count up
	(setq outsideIndex (xplus insideIndex 1))

	(cond (bevelTheOutside
	       ;; LL corner is 6 points if LL is bevelled, 4 points if not
	       (cond (llBevel
		      (setq ringList1 (list theRingPoints[insideIndex]
					    theRingPoints[insideIndex - 1]
					    theRingPoints[insideIndex - 2]
					    theRingPoints[outsideIndex + 2]
					    theRingPoints[outsideIndex + 1]
					    theRingPoints[outsideIndex]))
		      (setq insideIndex (xdifference insideIndex 2))
		      (setq outsideIndex (xplus outsideIndex 2))
		     )
		   (t
		    (setq ringList1 (list theRingPoints[insideIndex]
					  theRingPoints[insideIndex - 1]
					  theRingPoints[outsideIndex + 1]
					  theRingPoints[outsideIndex]))
		    (setq insideIndex (xdifference insideIndex 1))
		    (setq outsideIndex (xplus outsideIndex 1))
		   )
	       )

	       ;; LR corner is 6 points if LR is bevelled, 4 points if not
	       (cond (lrBevel
		      (setq ringList2 (list theRingPoints[insideIndex]
					    theRingPoints[insideIndex - 1]
					    theRingPoints[insideIndex - 2]
					    theRingPoints[outsideIndex + 2]
					    theRingPoints[outsideIndex + 1]
					    theRingPoints[outsideIndex]))
		      (setq insideIndex (xdifference insideIndex 2))
		      (setq outsideIndex (xplus outsideIndex 2))
		     )
		   (t
		    (setq ringList2 (list theRingPoints[insideIndex]
					  theRingPoints[insideIndex - 1]
					  theRingPoints[outsideIndex + 1]
					  theRingPoints[outsideIndex]))
		    (setq insideIndex (xdifference insideIndex 1))
		    (setq outsideIndex (xplus outsideIndex 1))
		   )
	       )

	       ;; UR corner is 6 points if UR is bevelled, 4 points if not
	       (cond (urBevel
		      (setq ringList3 (list theRingPoints[insideIndex]
					    theRingPoints[insideIndex - 1]
					    theRingPoints[insideIndex - 2]
					    theRingPoints[outsideIndex + 2]
					    theRingPoints[outsideIndex + 1]
					    theRingPoints[outsideIndex]))
		      (setq insideIndex (xdifference insideIndex 2))
		      (setq outsideIndex (xplus outsideIndex 2))
		     )
		   (t
		    (setq ringList3 (list theRingPoints[insideIndex]
					  theRingPoints[insideIndex - 1]
					  theRingPoints[outsideIndex + 1]
					  theRingPoints[outsideIndex]))
		    (setq insideIndex (xdifference insideIndex 1))
		    (setq outsideIndex (xplus outsideIndex 1))
		   )
	       )

	       ;; UL corner is 6 points if UL is bevelled, 4 points if not
	       (cond (ulBevel
		      (setq ringList4 (list theRingPoints[insideIndex]
					    theRingPoints[insideIndex - 1]
					    theRingPoints[insideIndex - 2]
					    theRingPoints[outsideIndex + 2]
					    theRingPoints[outsideIndex + 1]
					    theRingPoints[outsideIndex]))
		      (setq insideIndex (xdifference insideIndex 2))
		      (setq outsideIndex (xplus outsideIndex 2))
		     )
		   (t
		    (setq ringList4 (list theRingPoints[insideIndex]
					  theRingPoints[insideIndex - 1]
					  theRingPoints[outsideIndex + 1]
					  theRingPoints[outsideIndex]))
		    (setq insideIndex (xdifference insideIndex 1))
		    (setq outsideIndex (xplus outsideIndex 1))
		   )
	       )

	     ;;***** no bevel in the outside corners case
	      )
	    (t ; the outside corners are not bevelled

	     ;; LL corner is 5 points if the LL is bevelled, 4 points if not
	     (cond (llBevel
		    (setq ringList1 (list theRingPoints[insideIndex]
					  theRingPoints[insideIndex - 1]
					  theRingPoints[insideIndex - 2]
					  theRingPoints[outsideIndex + 1]
					  theRingPoints[outsideIndex]))
		    (setq insideIndex (xdifference insideIndex 2))
		    (setq outsideIndex (xplus outsideIndex 1))
		   )
		 (t
		  (setq ringList1 (list theRingPoints[insideIndex]
					theRingPoints[insideIndex - 1]
					theRingPoints[outsideIndex + 1]
					theRingPoints[outsideIndex]))
		  (setq insideIndex (xdifference insideIndex 1))
		  (setq outsideIndex (xplus outsideIndex 1))
		 )
	     )

	     ;; LR corner is 5 points if the LR is bevelled, 4 points if not
	     (cond (lrBevel
		    (setq ringList2 (list theRingPoints[insideIndex]
					  theRingPoints[insideIndex - 1]
					  theRingPoints[insideIndex - 2]
					  theRingPoints[outsideIndex + 1]
					  theRingPoints[outsideIndex]))
		    (setq insideIndex (xdifference insideIndex 2))
		    (setq outsideIndex (xplus outsideIndex 1))
		   )
		 (t
		  (setq ringList2 (list theRingPoints[insideIndex]
					theRingPoints[insideIndex - 1]
					theRingPoints[outsideIndex + 1]
					theRingPoints[outsideIndex]))
		  (setq insideIndex (xdifference insideIndex 1))
		  (setq outsideIndex (xplus outsideIndex 1))
		 )
	     )

	     ;; UR corner is 5 points if the UR is bevelled, 4 points if not
	     (cond (urBevel
		    (setq ringList3 (list theRingPoints[insideIndex]
					  theRingPoints[insideIndex - 1]
					  theRingPoints[insideIndex - 2]
					  theRingPoints[outsideIndex + 1]
					  theRingPoints[outsideIndex]))
		    (setq insideIndex (xdifference insideIndex 2))
		    (setq outsideIndex (xplus outsideIndex 1))
		   )
		 (t
		  (setq ringList3 (list theRingPoints[insideIndex]
					theRingPoints[insideIndex - 1]
					theRingPoints[outsideIndex + 1]
					theRingPoints[outsideIndex]))
		  (setq insideIndex (xdifference insideIndex 1))
		  (setq outsideIndex (xplus outsideIndex 1))
		 )
	     )

	     ;; UL corner is 5 points if the UL is bevelled, 4 points if not
	     (cond (ulBevel
		    (setq ringList4 (list theRingPoints[insideIndex]
					  theRingPoints[insideIndex - 1]
					  theRingPoints[insideIndex - 2]
					  theRingPoints[outsideIndex + 1]
					  theRingPoints[outsideIndex]))
		    (setq insideIndex (xdifference insideIndex 2))
		    (setq outsideIndex (xplus outsideIndex 1))
		   )
		 (t
		  (setq ringList4 (list theRingPoints[insideIndex]
					theRingPoints[insideIndex - 1]
					theRingPoints[outsideIndex + 1]
					theRingPoints[outsideIndex]))
		  (setq insideIndex (xdifference insideIndex 1))
		  (setq outsideIndex (xplus outsideIndex 1))
		 )
	     )
	    )
	)

	;;; get the points as floats by dividing by the dbuperuu
	(foreach point ringList1
	    (setq tempRingList (cons (quotient (car point) dbuperuu):(quotient (cadr point) dbuperuu) tempRingList)))
	(setq ringList1 tempRingList)
	(setq tempRingList nil)

	(foreach point ringList2
	    (setq tempRingList (cons (quotient (car point) dbuperuu):(quotient (cadr point) dbuperuu) tempRingList)))
	(setq ringList2 tempRingList)
	(setq tempRingList nil)

	(foreach point ringList3
	    (setq tempRingList (cons (quotient (car point) dbuperuu):(quotient (cadr point) dbuperuu) tempRingList)))
	(setq ringList3 tempRingList)
	(setq tempRingList nil)

	(foreach point ringList4
	    (setq tempRingList (cons (quotient (car point) dbuperuu):(quotient (cadr point) dbuperuu) tempRingList)))
	(setq ringList4 tempRingList)
	(setq tempRingList nil)

	(when ringLayer
	    (setq net (dbMakeNet tcCellView "ppd"))
	    (dbCreateTerm net "" "inputOutput")
	    (setq dbid (dbCreatePolygon tcCellView ringLayer ringList1))
	    (dbAddFigToNet dbid net)
	    (setq dbid (dbCreatePolygon tcCellView ringLayer ringList2))
	    (dbAddFigToNet dbid net)
	    (setq dbid (dbCreatePolygon tcCellView ringLayer ringList3))
	    (dbAddFigToNet dbid net)
	    (setq dbid (dbCreatePolygon tcCellView ringLayer ringList4))
	    (dbAddFigToNet dbid net)
	)

	(dbCreateProp tcCellView "ringPoints1" "list" ringList1)
	(dbCreateProp tcCellView "ringPoints2" "list" ringList2)
	(dbCreateProp tcCellView "ringPoints3" "list" ringList3)
	(dbCreateProp tcCellView "ringPoints4" "list" ringList4)

       )

     (t ; create one complex polygon for the ring
      (setq ringList nil)
      (for i 1 outsideIndex
	   (setq ringList (cons theRingPoints[outsideIndex - i] ringList))
      )

      ;; get the points as floats by dividing by dbuperuu
      (foreach point ringList
	  (setq tempRingList (cons (quotient (car point) dbuperuu):(quotient (cadr point) dbuperuu) tempRingList)))
      (setq ringList tempRingList)
      (setq tempRingList nil)

      (when ringLayer
	  (setq net (dbMakeNet tcCellView "ppd"))
	  (dbCreateTerm net "" "inputOutput")
	  (setq dbid (dbCreatePolygon tcCellView ringLayer ringList))
	  (dbAddFigToNet dbid net)
      )

      (dbCreateProp tcCellView "ringPoints" "list" ringList)
     )
 )

)
;;; 
;;; $Id: metopClass.il,v 1.2 1998/04/23 10:31:14 gtc Exp $
;;; 
;;; metopClass.il
;;; 
;;; Copyright (c) 1996 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Nov 11, 1996
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This device class will be used to generate the metal option devices.
;;;   The metopMet1, metopMet2, etc.
;;; Revision History:
;;;   gtc 04/23/98  passing list of valid lpps for the options
;;; 
;;; 

(putpropqq metopClass "$Id: metopClass.il,v 1.2 1998/04/23 10:31:14 gtc Exp $" SCCS)

(tcCreateDeviceClass
 "symbolic" "metopClass"
 ;; class parameters
 (
  ;; list of layers that are valid options.
  ;; it does (nth metopNumber optionOnLayer) to get the metop layer
  (optionOnLayer '(nil
		   '("met1" "option1")
		   '("met1" "option2")
		   '("met1" "option3")
		   '("met1" "option4")
		   '("met1" "option5")
		   '("met1" "option6")
		   '("met1" "option7")
		   '("met1" "option8")))
  (pinLayer '("met1" "drawing")) ;; layer to draw the pins on
  (minPinWidth    0.0)      ;;; minimum width of the pin.
 )
 ;; formal parameters
 (
  (metopNumber 8)
  (w 0.0)
  (l 0.0)
 )

 (unless (setq metopLayer (nth metopNumber optionOnLayer))
     (error "metopClass:  Cannot find layer for option number %d" metopNumber)
 )

 ;;; Make the nets and the terminals for the pins.
 (setq net0 (dbMakeNet tcCellView "m0"))
 (dbCreateTerm net0 "m0" "inputOutput")
 (setq net1 (dbMakeNet tcCellView "m1"))
 (dbCreateTerm net1 "m1" "inputOutput")
 ;;; And a bogus net for the body of the metaloption.
 (setq netb (dbMakeNet tcCellView "ppd"))

 ;;; First create the metal option layer (one of metop1 thru metop8).
 dbId = (dbCreateRect tcCellView metopLayer (list 0.0:0.0 l:w))
 ;;; and add the drawn fig to the bogus net.
 (dbAddFigToNet dbId netb)

 ;;; Create the two pins on the left and right.
 ;;; first the one on the left.
 (setq dbId (dbCreateRect tcCellView pinLayer
			  (list (minus minPinWidth):0.0 0.0:w))
 )
 ;;; make this into a pin.
 (setq pinId (dbCreatePin net0 dbId))
 pinId~>accessDir = (list "top" "bottom" "left")

 ;;; then create the rectangle on the right.
 (setq dbId (dbCreateRect tcCellView pinLayer
			  (list l:0.0 (plus l minPinWidth):w))
 )
 ;;; Make the drawn figure a pin.
 (setq pinId (dbCreatePin net1 dbId))
 pinId~>accessDir = (list "top" "bottom" "right")
)
;;; 
;;; $Id: mNormTranClass.il,v 1.6 2000/10/04 11:06:00 xgs Exp $ %T%
;;; 
;;; mNormTranClass.il
;;; 
;;; Copyright (c) 1996 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Oct 23, 1996
;;; Author: Sanjay Rekhi/Senior CAD (syr) @ CSDC
;;; 
;;; Description:
;;;  Skill code for the normal topography transistors with
;;;  mfactors. This device class will be used to declare normal
;;;  topography nmos, pmos and depletion nmos transistors.
;;;
;;; Revision History:
;;;   gtc 01/23/98  Copying over from v20
;;;   dgn 12/14/98  Fixed bugs when one tip-tap specified (top or bot)
;;;   xgs 09/29/00  Changing gateExt to formal parameter ( SPR 7745 )
;;; 

(tcCreateDeviceClass
 "symbolic" "mNormTranClass"
 ;;; Class parameters
 (
  (diffLayer "hilite")   ;;; diffusion layer
  (gateLayer "marker")   ;;; poly/gate layer
  (wellLayer nil)        ;;; well layer, if nil then well is not drawn
  (depLayer nil)         ;;; depletion layer, if nil then not drawn, other wise it is drawn on gate
  (diffExt  0.0)         ;;; extension of diff beyond poly. This is drawn for end contacts
                         ;;; only, if the first/last contact are not specified.
  (wellEncDiff  0.0)     ;;; enclosure of diffusion by well.
  (wellEncTap   0.0)     ;;; enclosure of tap by well.
  (depXEnc  0.0)         ;;; enclosure of gate by dep (in X direction)
  (depYEnc  0.0)         ;;; enclosure of gate by dep (in Y direction)
  (depSpace 0.0)         ;;; depletion to depletion space, notch filling will be done to satisfy this.
          ;;; We donot specify the minWidth of the Well and minWidth of the depletion layer.
          ;;; The transistor length and depXEnc, and transistor width and depYEnc parameters
          ;;; should be used to control that.
  (labelLayer (list "text" "drawing"))       ;;; layer on which labels should be drawn, if nil labels are not drawnn
  (labelWidth 0.4)      ;;; width of the label
 )
 ;;; Formal parameters
 (
  (sourceFirst "TRUE")
  (sharedDrain "")
  (sharedSource "")
  (lastContact "")
  (firstContact "")
  (gateExt   0.0)   ;;; extension of poly beyond diff
  (srcOffset 0.0)
  (drnOffset 0.0)
  (m 1)
  (l 0.0)
  (w 0.0)
 )

 ;;; Make the nets and the terminals that will be used in the cell.
 (setq gNet (dbCreateNet tcCellView "g"))
 (dbCreateTerm gNet "g" "input")
 (setq sNet (dbCreateNet tcCellView "s"))
 (dbCreateTerm sNet "s" "inputOutput")
 (setq dNet (dbCreateNet tcCellView "d"))
 (dbCreateTerm dNet "d" "inputOutput")

 ;;; make sure the boolean parameters are set properly
 (if (equal sourceFirst "TRUE") then
     (setq cNet sNet)
     (setq netL "S")
  else
     (setq cNet dNet)
     (setq netL "D")
 )

 (when (lessp m 1) ;;; The schematic transistor can have an mfactor of 0.
     (setq m 1)    ;;; It will be enforced to a minimum of 1.
 )

 ;;; initialize the lower left corner of all geometries. The y1Coord is not
 ;;; really required, but helps in consistency.
 (setq x1Coord 0.0)
 (setq y1Coord 0.0)
 ;;; The lastx1coord is used to calculate where to place the depLayer 
 ;;; It will store the edge of the last gate.
 (setq lastX1Coord (minus (times 2.0 (plus depXEnc depSpace))))

 ;;; initialize the y coordinates for the depletion layer.
 (when depLayer
     (setq y1DepCoord (difference y1Coord depYEnc))
     (setq y2DepCoord (plus y1Coord w depYEnc))
 )

 ;;; get the dbids of the named contacts

 ;;; first the firstContact contact, see if the field is defined and get the id
 ;;; If cannot find the cell -- error. The cell should be in the same library
 ;;; as the current pcell is. Place an instance of the cell (mirrored around Y)
 (when (nequal firstContact "")
     (setq contactId (dbOpenCellView tcCellView~>lib firstContact "symbolic" nil "rn"))
     (unless contactId
	 (error (sprintf nil "Cannot find/open firstContact contact cell `%s'" firstContact))
     )
     (unless contactId~>isParamCell
	 (error (sprintf nil "Named cell is not a pcell `%s'" firstContact))
     )
     (if (equal cNet sNet) then
	 (setq offset srcOffset)
      else
	 (setq offset drnOffset)
     )
     (setq inst (dbCreateParamInst tcCellView contactId "c0"
				   (minus offset):0 "MY" 1
				   (list (list "w" "float" w)))
     )
     (unless inst
	 (error (sprintf nil "Failed to create instance of `%s'" firstContact))
     )

     ;;; Create a rectangle to fill the space between the contact and the gate,
     ;;; when offset > zero.
     
     (when (greaterp offset 1e-6)
	 (dbCreateRect tcCellView diffLayer (list (difference x1Coord offset):y1Coord
						  x1Coord:w)
	 )
     )

     ;;; Create a rectangle from the top Layer of the contact, given the
     ;;; bounding box of the top Layer. Then make this rectangle a pin
     ;;; or the appropriate net.
     (setq master inst~>master)
     (unless (and master~>topLayer master~>topLayerPinBbox)
	 (error (sprintf nil "Missing topLayer and/or topLayerPinBbox cell properties in `%s'" firstContact))
     )

     (setq bBox (list (list (minus (plus offset (caar master~>topLayerPinBbox))) (cadar master~>topLayerPinBbox))
		      (list (minus (plus offset (caadr master~>topLayerPinBbox))) (cadadr master~>topLayerPinBbox)))
     )
     
     ;;; This pin cannot be accessed from the right side.
     (setq dbid (dbCreateRect tcCellView master~>topLayer bBox))
     (setq pinid (dbCreatePin cNet dbid))
     pinid~>accessDir = (list "top" "bottom" "left")

     ;;; Draw the appropriate label
     (when labelLayer
	 (dbCreateLabel tcCellView labelLayer
			(list (plus (caar bBox) (quotient (difference (caadr bBox) (caar bBox)) 2.0))
			      (plus (cadar bBox) (quotient (difference (cadadr bBox) (cadar bBox)) 2.0)))
			netL "centerCenter" "R0" "roman" labelWidth)
     )
     
     ;;; Set the lower X and Y Coordinate for the well, when wellLayer is not nil
     (when wellLayer
	 (unless master~>diffLayerBbox
	     (error (sprintf nil "Cannot find diffLayerBbox property for `%s'" firstContact))
	 )
	 ;;; Since this contact is always mirrored, we look at the x2Coord to find how
	 ;;; much does diff Extend beyond the gate. However, the farthest point from
	 ;;; the gate could also be tap. We take the maximum overlap as calculated by
	 ;;; well overlap + (diff/tap ext) beyond the gate. The above is repeated for
	 ;;; the y1 and y2 coordinates. With the assumption, that these (y1,y2) parmaeters may
	 ;;; reset again. This will not occur for now, but it would be easier to extend
	 ;;; the present class to pass parameters for top and bottom tip-Taps, in future.
	 ;;;;;;;;;;
	 (setq x1DiffCoord (caadr master~>diffLayerBbox))
	 (setq x1TapCoord (if master~>tapLayerBbox (abs (caadr master~>tapLayerBbox)) 0.0))
	 (setq x1WellCoord (minus (plus offset (max (plus wellEncDiff x1DiffCoord)
						    (plus wellEncTap x1TapCoord))))
	 )
	 (setq y1DiffCoord (cadar master~>diffLayerBbox))
	 (setq y1TapCoord (if master~>tapLayerBbox (abs (cadar master~>tapLayerBbox)) 0.0))
	 (setq y1WellCoord (minus (max (plus wellEncDiff y1DiffCoord)
				       (plus wellEncTap y1TapCoord)))
	 )
	 (setq y2DiffCoord (cadadr master~>diffLayerBbox))
	 (setq y2TapCoord (if master~>tapLayerBbox (abs (cadadr master~>tapLayerBbox)) 0.0))
	 (setq y2WellCoord (max (plus wellEncDiff y2DiffCoord)
				(plus wellEncTap y2TapCoord))
	 )
     )
     ;;; Close the opened cell View
     (dbClose contactId)
 )

 ;;; For the first and the last diffusions we should also define a diffusion pin
 ;;; to allow parallel transistor placement.
 (setq dbid (dbCreateRect tcCellView diffLayer 
			  (list (difference x1Coord diffExt):y1Coord
				x1Coord:w)))
 (setq pinid (dbCreatePin cNet dbid))
 pinid~>accessDir = (list "top" "bottom" "left")

 ;;; Calculate the well coordinates and place label.
 (when (equal firstContact "")
     ;;; draw the appropriate label at the center of the difflayer
     (when labelLayer
	 (dbCreateLabel tcCellView labelLayer 
			(list (minus (plus x1Coord (quotient diffExt 2.0))) (plus y1Coord (quotient w 2.0)))
			netL "centerCenter" "R0" "roman" labelWidth)
     )

     ;;; When first Contact is not defined then the lower well coordinate is given by
     ;;; diffusion extension.
     (when wellLayer
	 (setq x1WellCoord (minus (plus x1Coord diffExt wellEncDiff)))
	 (setq y1WellCoord (minus (plus y1Coord wellEncDiff)))
	 (setq y2WellCoord (plus y1Coord w wellEncDiff))
     )
 )

 ;;; The following only need to be checked if m > 1 (if m == 0, we reset it to 1)
 (when (greaterp m 1)
     ;;; The shared source contact, if this field is empty -- error, get the id.
     ;;; If cannot find the cell -- error. The cell should be in the same library
     ;;; as the current pcell is.
     (when (equal sharedSource "")
	 (error "Missing shared source contact name property")
     )
     (setq sharedSrcId (dbOpenCellView tcCellView~>lib sharedSource "symbolic" nil "rn"))
     (unless sharedSrcId
	 (error (sprintf nil "Cannot find/open shared source contact cell `%s'" sharedSource))
     )
     (unless sharedSrcId~>isParamCell
	 (error (sprintf nil "Named cell is not a pcell `%s'" sharedSource))
     )
     
     ;;; The shared drain contact, if this field is empty -- error, get the id.
     ;;; If cannot find the cell -- error. The cell should be in the same library
     ;;; as the current pcell is.
     (when (equal sharedDrain "")
	 (error "Missing shared drain contact name property")
     )
     (setq sharedDrnId (dbOpenCellView tcCellView~>lib sharedDrain "symbolic" nil "rn"))
     (unless sharedDrnId
	 (error (sprintf nil "Cannot find/open shared drain contact cell `%s'" sharedDrain))
     )
     (unless sharedDrnId~>isParamCell
	 (error (sprintf nil "Named cell is not a pcell `%s'" sharedDrain))
     )
 )

 ;;; reset the current net and the label to be drawn.
 (setq cNet (if (equal cNet sNet) dNet sNet))
 (setq netL (if (equal netL "S") "D" "S"))

 ;;; now create the rest of the geometries etc.
 (for n 1 m
      ;;; Create the gate region
      (setq dbid (dbCreateRect tcCellView gateLayer (list x1Coord:(difference y1Coord gateExt)
							  (plus x1Coord l):(plus y1Coord w gateExt))
		 )
      )
      (dbAddFigToNet dbid gNet)
      
      ;;; Create the two pins (one on top and another on bottom).
      ;;; When "Automatic keepouts for MOS gates" is used with CCT, the abstract
      ;;; creation breaks the pins. However, if we use diffusion as a poly keepout
      ;;; and do not use the automatic keepouts for MOS gates, then the gate
      ;;; pin may be used as a feed through.

      ;;; First Create the top pin
      (setq dbid (dbCreateRect tcCellView gateLayer 
			       (list x1Coord:(plus y1Coord w)
				     (plus x1Coord l):(plus y1Coord w gateExt)))
      )
      (setq pinid (dbCreatePin gNet dbid))
      pinid~>accessDir = (list "top")

      ;;; Then the bottom pin.
      (setq dbid (dbCreateRect tcCellView gateLayer
			       (list x1Coord:(difference y1Coord gateExt)
				     (plus x1Coord l):y1Coord))
      )
      (setq pinid (dbCreatePin gNet dbid))
      pinid~>accessDir = (list "bottom")
      
      ;;; Create the floating diffusion under the gate region
      (dbCreateRect tcCellView diffLayer (list x1Coord:y1Coord 
					       (plus x1Coord l):(plus y1Coord w))
      )

      ;;; If the depletion layer is defined draw it on top of the gate region
      (when depLayer
	  (cond 
	      ((lessp (difference x1Coord lastX1Coord (times 2.0 depXEnc)) depSpace)
	       (setq x1DepCoord (plus lastX1Coord depXEnc))
	      )
	      (t
	       (setq x1DepCoord (difference x1Coord depXEnc))
	      )
	  )
	  (dbCreateRect tcCellView depLayer (list x1DepCoord:y1DepCoord
						  (plus x1Coord l depXEnc):y2DepCoord))
      )
      ;;; increment the x1Coord to next gate edge
      (setq x1Coord (plus x1Coord l))
      
      ;;; Create the contact for the second terminal
      (when (nequal n m)
	  (if (equal cNet sNet) then
	      (setq contactId sharedSrcId)
	      (setq offset srcOffset)
	   else
	      (setq contactId sharedDrnId)
	      (setq offset drnOffset)
	  )
	  (setq inst (dbCreateParamInst tcCellView contactId (sprintf nil "c%d" n)
					(plus offset x1Coord):y1Coord "R0" 1
					(list (list "w" "float" w)))
	  )
	  (unless inst
	      (error (sprintf nil "Failed to create instance of `%s'" contactId~>cellName))
	  )
	  ;;; Create a rectangle from the specified topLayer and topLayerPinBbox of
	  ;;; of the created instance. And put the proper pin on it
	  (setq master inst~>master)
	  (unless (and master~>topLayer master~>topLayerPinBbox)
	      (error (sprintf nil "Missing topLayer and/or topLayerPinBbox cell properties in `%s'" contactId~>cellName))
	  )
	  (setq bBox (list (list (plus (caar master~>topLayerPinBbox) x1Coord offset) (cadar master~>topLayerPinBbox))
			   (list (plus (caadr master~>topLayerPinBbox) x1Coord offset) (cadadr master~>topLayerPinBbox)))
	  )
	  
	  ;;; Since this source/drain pin is inside, it can only be accessed from top or bottom.
	  (setq dbid (dbCreateRect tcCellView master~>topLayer bBox))
	  (setq pinid (dbCreatePin cNet dbid))
	  pinid~>accessDir = (list "top" "bottom")

	  ;;; Draw the label, if allowed (The label is drawn at the center of the top layer bbox)
	  (when labelLayer
	      (dbCreateLabel tcCellView labelLayer 
			     (list (plus (caar bBox) (quotient (difference (caadr bBox) (caar bBox)) 2.0))
				   (plus (cadar bBox) (quotient (difference (cadadr bBox) (cadar bBox)) 2.0)))
			     netL "centerCenter" "R0" "roman" labelWidth)
	  )
	  ;;; Create a piece of diffusion to cover up the space between the gate and the
	  ;;; contact, if offset > zero.
	  (when (greaterp offset 1e-6)
	      (dbCreateRect tcCellView diffLayer (list x1Coord:y1Coord
						       (plus offset x1Coord):(plus y1Coord w))
	      )
	  )

	  (unless master~>diffLayerBbox
	      (error (sprintf nil "Missing diffLayerBbox cell properties in `%s'" contactId~>cellName))
	  )
	  ;;; increment x1Coord to next gate's first edge, after storing the last gate edge
	  ;;; the offset parameter in the hand of the designers, should be used to
	  ;;; satisfy any li1-li1, poly-poly spacing problems.
	  (setq lastX1Coord x1Coord)
	  (setq x1Coord (plus (times 2.0 offset)
			      (plus x1Coord (difference (caadr master~>diffLayerBbox)
							(caar master~>diffLayerBbox)))
			)
	  )
	  ;;; Create another piece of diffusion to cover up the space between the gate and the
	  ;;; contact, if offset > zero.
	  (when (greaterp offset 1e-6)
	      (dbCreateRect tcCellView diffLayer (list (difference x1Coord offset):y1Coord
						       x1Coord:(plus y1Coord w))
	      )
	  )
	  ;;; Give the master of the contact just placed, recalculate the well overlaps in 
	  ;;; y direction. The maximum well overlaps should be used.
	  (when wellLayer
	      (setq y1DiffCoord (cadar master~>diffLayerBbox))
	      (setq y1TapCoord (if master~>tapLayerBbox (abs (cadar master~>tapLayerBbox)) 0.0))
	      ;;; remember, (max (abs -1) (abs -2)) = (min -1 -2)
	      (setq y1WellCoord (min (minus (max (plus wellEncDiff y1DiffCoord)
						 (plus wellEncTap y1TapCoord)))
				     y1WellCoord)
	      )
	      (setq y2DiffCoord (cadadr master~>diffLayerBbox))
	      (setq y2TapCoord (if master~>tapLayerBbox (abs (cadadr master~>tapLayerBbox)) 0.0))
	      (setq y2WellCoord (max (plus wellEncDiff y2DiffCoord)
				     (plus wellEncTap y2TapCoord)
				     y2WellCoord)
	      )
	  )
      )
      (setq cNet (if (equal cNet sNet) dNet sNet))
      (setq netL (if (equal netL "S") "D" "S"))
 )
 
 (when (nequal m 1)
     ;;; Close the opened cell views of the shared src and drn contacts
     (dbClose sharedSrcId)
     (dbClose sharedDrnId)
 )


 ;;; reset the current net and the net labels once again.
 (setq cNet (if (equal cNet sNet) dNet sNet))
 (setq netL (if (equal netL "S") "D" "S"))

 ;;; Finally the lastContact contact, see if the field is defined and get the id.
 ;;; If cannot find the cell -- error. The cell should be in the same library
 ;;; as the current pcell is.

 (when (nequal lastContact "")
     (setq contactId (dbOpenCellView tcCellView~>lib lastContact "symbolic" nil "rn"))
     (unless contactId
	 (error (sprintf nil "Cannot find/open lastContact contact cell `%s'" lastContact))
     )
     (unless contactId~>isParamCell
	 (error (sprintf nil "Named cell is not a pcell `%s'" lastContact))
     )
     (if (equal cNet sNet) then
	 (setq offset srcOffset)
      else
	 (setq offset drnOffset)
     )
     (setq inst (dbCreateParamInst tcCellView contactId (sprintf nil "c%d" m)
				   (plus offset x1Coord):y1Coord "R0" 1
				   (list (list "w" "float" w)))
     )
     (unless inst
	 (error "Failed to create instance of first source contact")
     )

     ;;; Create a rectangle to fill the space between the contact and the gate,
     ;;; when offset > zero.
     
     (when (greaterp offset 1e-6)
	 (dbCreateRect tcCellView diffLayer (list  x1Coord:y1Coord
						  (plus offset x1Coord):(plus y1Coord w))
	 )
     )

     ;;; Create a rectangle from the top Layer of the contact, given the
     ;;; bounding box of the top Layer. Then make this rectangle a pin
     ;;; or the appropriate net.
     (setq master inst~>master)
     (unless (and master~>topLayer master~>topLayerPinBbox)
	 (error (sprintf nil "Missing topLayer and/or topLayerPinBbox cell properties in `%s'" lastContact))
     )

     (setq bBox (list (list (plus (caar master~>topLayerPinBbox) x1Coord offset) (cadar master~>topLayerPinBbox))
		      (list (plus (caadr master~>topLayerPinBbox) x1Coord offset) (cadadr master~>topLayerPinBbox)))
     )
     
     ;;; This pin can be accessed from top, bottom, and right only.
     (setq dbid (dbCreateRect tcCellView master~>topLayer bBox))
     (setq pinid (dbCreatePin cNet dbid))
     pinid~>accessDir = (list "top" "bottom" "right")

     ;;; draw the label at the center of the top layer
     (when labelLayer
	 (dbCreateLabel tcCellView labelLayer 
			(list (plus (caar bBox) (quotient (difference (caadr bBox) (caar bBox)) 2.0))
			      (plus (cadar bBox) (quotient (difference (cadadr bBox) (cadar bBox)) 2.0)))
			netL "centerCenter" "R0" "roman" labelWidth)
     )

     ;;; If wellLayer is defined, then calculate the upper coordinates of the well layer
     (when wellLayer
	 (unless master~>diffLayerBbox
	     (error (sprintf nil "Cannot find diffLayerBbox property for `%s'" lastContact))
	 )

	 ;;; Given the master of the contact just placed, recalculate the well overlaps in 
	 ;;; y direction. The maximum well overlaps should be used.
	 (setq y1DiffCoord (cadar master~>diffLayerBbox))
	 (setq y1TapCoord (if master~>tapLayerBbox (abs (cadar master~>tapLayerBbox)) 0.0))
	 ;;; remember, (max (abs -1) (abs -2)) = (min -1 -2)
	 (setq y1WellCoord (min (minus (max (plus wellEncDiff y1DiffCoord)
					    (plus wellEncTap y1TapCoord)))
				y1WellCoord)
	 )
	 (setq y2DiffCoord (cadadr master~>diffLayerBbox))
	 (setq y2TapCoord (if master~>tapLayerBbox (abs (cadadr master~>tapLayerBbox)) 0.0))
	 (setq y2WellCoord (max (plus wellEncDiff y2DiffCoord)
				(plus wellEncTap y2TapCoord)
				y2WellCoord)
	 )
	 ;;; Calculate the x2Coord of the well, from the x2Coordinates of the diffLayerBbox and
	 ;;; tapLayerBbox.
	 (setq x2DiffCoord (caadr master~>diffLayerBbox))
	 (setq x2TapCoord (if master~>tapLayerBbox (abs (caadr master~>tapLayerBbox)) 0.0))
	 (setq x2WellCoord (plus offset x1Coord (max (plus wellEncDiff x2DiffCoord)
						     (plus wellEncTap x2TapCoord)))
	 )
     )
     ;;; Close the opened cell view of the lastContact
     (dbClose contactId)
 )

 ;;; Create a diffusion pin to allow transistors to be placed in parallel.
 (setq dbid (dbCreateRect tcCellView diffLayer (list x1Coord:y1Coord
						     (plus x1Coord diffExt):(plus y1Coord w)))
 )
 (setq pinid (dbCreatePin cNet dbid))
 pinid~>accessDir = (list "top" "bottom" "right")

 ;; draw the label and calculate the well coordinates.
 (when (equal lastContact "")
     ;;; draw the label (at the center of the diff)
     (when labelLayer
	 (dbCreateLabel tcCellView labelLayer
			(list (plus x1Coord (quotient diffExt 2.0)) (plus y1Coord (quotient w 2.0)))
			netL "centerCenter" "R0" "roman" labelWidth)
     )
			
     ;;; When lastContact is not defined, the upper coordinates of the well are given by the
     ;;; diffExt.
     (when wellLayer
	 (setq x2WellCoord (plus x1Coord diffExt wellEncDiff))
	 (setq y2WellCoord (max (plus y1Coord w wellEncDiff)
				y2WellCoord)
	 )
     )
 )

 ;;; While we are at it, we could as well draw the tap contacts to satisfy the new
 ;;; latchup rules. A tap contact (provided by the user) to left/right or both
 ;;; 1. get the id of the contact
 ;;; 2. place an instance at the offset given by a class property
 ;;; 3. get the master
 ;;; 4. get the topLayerBbox and place a pin with body net
 ;;; 5. get the botLayerBbox and recalculate x1WellCoord and x2WellCoord as required
 ;;; 6. close the opened contact cell
 
 ;;; Draw the well Layer if defined, all the coordinates have already
 ;;; been defined
 
 (when wellLayer
     (dbCreateRect tcCellView wellLayer (list (list x1WellCoord y1WellCoord)
					      (list x2WellCoord y2WellCoord))
     )
 )
)

;;; Define the function of the class.

(tfcDefineDeviceClassProp
;;(viewName       devClassName      propName          propValue)
 (symbolic        mNormTranClass    function          "transistor")
)
;;; 
;;; $Id: rodTripleGuardRing.il,v 1.7 2006/08/03 21:16:02 kuc Exp $ %T%
;;; 
;;; rodTripleGuardRing.il
;;; 
;;; Copyright (c) 2005 by Cypress Semiconductor
;;; Cypress INDIA Cad Center (INDC)
;;; 
;;; Date  : NOV 11, 2005
;;; Author: Ranjit M (rnh) @ INDC
;;; 
;;; Description:
;;;  Skill code for the normal triple guardRing structure.
;;;  This device class will be used to declare normal
;;;  guardRing pcell.
;;;
;;; Revision History:
;;;  rnh 11/11/05  Initial Version.
;;;  rnh 11/21/05  Added the FullWell and DeepNwell options.
;;;  rnh 11/23/05  Changed the L/W default to 5x5.
;;;  rnh 11/25/05  Added newline at the end.
;;;  kuc 08/03/06  Implemented deep nwell for pTap option and more than 1 ring
;;; 

(tcCreateDeviceClass
 "symbolic" "rodTripleGuardRing"
 ;;; Class parameters
 (
  (tapLayer     "hilite")                      ;;; tap layer.
  (tapWidth     0.0)
  (tapImpEnc    0.0)
  (nImplant     nil)
  (pImplant     nil)
  (implantSpc   0.0)
  (wellLayer    nil)                           ;;; well layer, if nil then well is not drawn.
  (nwellWidth   0.0)
  (ntapWellSpc  0.0)
  (ptapWellSpc  0.0)
  (dnwellLayer  nil)                           ;;; deepNwell Layer, if nil then not drawn.
  (dnwellWidth  0.0)
  (dnwWellEnc   0.0)
  (conLayer     nil)
  (conWidth     0.0)
  (conLength    0.0)
  (conSpacing   0.0)
  (tapConEncX   0.0)
  (tapConEncY   0.0)
  (M0Layer      nil)                           ;;; First routing Layer.
  (M0conEncY    0.0)
  (viaLayer     nil)
  (viaWidth     0.0)
  (viaLength    0.0)
  (viaSpacing   0.0)
  (M1Layer      nil)                           ;;; Second routing Layer.
  (M1viaEncY    0.0)
  (M1viaEncX    0.0)
 )
 ;;; Formal parameters
 (
  (FullWell     t)
  (DeepNwell    nil)
  (ORingWidth   0.0)
  (MRingWidth   0.0)
  (IRingWidth   0.0)
  (Space23      0.0)
  (Space12      0.0)
  (InnerRing    "")
  (RingNum      0)
  (W            0)
  (L            0)
 )

 (if (or (W < 5) (L < 5)) then
     (setq W 5)
     (setq L 5)
 )
 (if InnerRing != "nTap" then
     (if InnerRing != "pTap" then
	 (setq InnerRing "nTap")
	 (warn "InnerRing should be either nTap or pTap. Default set to nTap")
     )
 )
 (setq tap_W (max (plus conWidth (times tapConEncX 2)) IRingWidth))
 (setq TAP_L_I (rodCreatePath
		?cvId   tcCellView
		?layer  tapLayer
		?width  tap_W
		?pts    list(0:0 0:W)
		?encSubPath list(
				 list(
				      ?layer       ,M0Layer
				      ?enclosure   ,tapConEncX
				      ?beginOffset ,tapConEncX
				      ?endOffset   ,tapConEncX
				     )
				)
		?subRect   list(
				list(
				     ?layer       ,conLayer
				     ?width       ,conWidth
				     ?length      ,conLength
				     ?beginOffset -,(plus tapImpEnc tapConEncX)
				     ?endOffset   -,(plus tapImpEnc tapConEncX)
				     ?space       ,conSpacing
				    )
			       )
	       )
 )
 (setq TAP_T_I (rodCreatePath
		?cvId   tcCellView
		?layer  tapLayer
		?width  tap_W
		?pts    list(-tap_W/2:(plus W tap_W/2)
			     (plus L tap_W/2 tap_W):(plus W tap_W/2)
			    )
		?encSubPath list(
				 list(
				      ?layer       ,M0Layer
				      ?enclosure   ,tapConEncX
				      ?beginOffset -,tapConEncX
				      ?endOffset   -,tapConEncX
				     )
				)
		?subRect   list(
				list(
				     ?layer       ,conLayer
			             ?width       ,conWidth
				     ?length      ,conLength
				     ?beginOffset -,(plus M0conEncY tapConEncY)
				     ?endOffset   -,(plus M0conEncY tapConEncY)
				     ?space       ,conSpacing
				    )
			       )
		
	       )
 )
 (setq TAP_R_I (rodCreatePath
		    ?cvId   tcCellView
		    ?layer  tapLayer
		    ?width  tap_W
		    ?pts    list((plus L tap_W):W (plus L tap_W):0)
		    ?encSubPath list(
				     list(
					  ?layer       ,M0Layer
                                          ?enclosure   ,tapConEncX
					  ?beginOffset ,tapConEncX
					  ?endOffset   ,tapConEncX
					 )
				    )
		    ?subRect   list(
				    list(
					 ?layer       ,conLayer
				         ?width       ,conWidth
					 ?length      ,conLength
					 ?beginOffset -,(plus tapImpEnc tapConEncX)
					 ?endOffset   -,(plus tapImpEnc tapConEncX)
					 ?space       ,conSpacing
					)
				   )
	       )
 )
 (setq TAP_B_I (rodCreatePath
		?cvId   tcCellView
		?layer  tapLayer
		?width  tap_W
		?pts    list((plus L tap_W tap_W/2):-tap_W/2 -tap_W/2:-tap_W/2)
		?encSubPath list(
				 list(
				      ?layer       ,M0Layer
				      ?enclosure   ,tapConEncX
				      ?beginOffset -,tapConEncX
				      ?endOffset   -,tapConEncX
				     )
				)
		?subRect   list(
				list(
				     ?layer       ,conLayer
				     ?width       ,conWidth
				     ?length      ,conLength
				     ?beginOffset -,(plus M0conEncY tapConEncY)
				     ?endOffset   -,(plus M0conEncY tapConEncY)
				     ?space       ,conSpacing
				    )
			       )
	       )
 )
 (if InnerRing == "nTap" then
     (if DeepNwell then
	 (unless FullWell
	     (setq dnwImpEnc (difference dnwWellEnc (plus ntapWellSpc tap_W/2 tapImpEnc)))
	     (setq DNW_dummy (rodCreateRect
			      ?cvId   tcCellView
			      ?layer  dnwellLayer
			      ?length W
			      ?width  ,(plus L tap_W)
			     )
	     )
	     (setq DNW (rodCreateRect
			?cvId   tcCellView
			?layer  dnwellLayer
			?length ,(plus W tap_W (times dnwImpEnc 2))
			?width  ,(plus L tap_W (times dnwImpEnc 2))
		       )
	     )
	     (rodAlign
	      ?alignObj    DNW
	      ?alignHandle "cC"
	      ?refObj      DNW_dummy
	      ?refHandle   "cC"
	     )
	 )
     )
     (if FullWell then
	 (setq dnwImpEnc (difference dnwWellEnc (plus ntapWellSpc tap_W (times tapImpEnc 2))))
	 (setq NWell_dummy (rodCreateRect
			    ?cvId   tcCellView
			    ?layer  wellLayer
			    ?length  W
			    ?width ,(plus L tap_W)
			   )
	 )
	 (setq NWell (rodCreateRect
		      ?cvId   tcCellView
		      ?layer  wellLayer
		      ?width  ,(plus L (times tap_W 2))
		      ?length ,(plus W (times tap_W 2))
		     )
	 )
	 (rodAlign
	  ?alignObj    NWell
	  ?alignHandle "cC"
	  ?refObj      NWell_dummy
	  ?refHandle   "cC"
	 )
     )
     (setq Implant_I (rodCreatePath
		      ?cvId   tcCellView
		      ?layer  ,nImplant
		      ?width  ,(plus tap_W (times tapImpEnc 2))
		      ?pts    list(0:0 0:(plus W tap_W/2)
				   0:(plus W tap_W/2) (plus L tap_W):(plus W tap_W/2)
				   (plus L tap_W):(plus W tap_W/2) (plus L tap_W):0
				  )
		     )
     )
     (setq Implant_IB (rodCreatePath
		       ?cvId   tcCellView
		       ?layer  ,nImplant
		       ?width  ,(plus tap_W (times tapImpEnc 2))
		       ?pts    list((plus L tap_W tap_W/2 tapImpEnc):-tap_W/2 -(plus tap_W/2 tapImpEnc):-tap_W/2)
		      )
     )
     (setq Well_I_LT (rodCreatePath
		      ?cvId   tcCellView
		      ?layer  ,wellLayer
		      ?width  ,(plus tap_W (times tapImpEnc 2) (times ntapWellSpc 2))
		      ?pts    list(0:0
				   0:(plus W tap_W/2)
				   (plus L tap_W):(plus W tap_W/2)
				  )
		     )
     )
     (setq Well_I_RB (rodCreatePath
		      ?cvId   tcCellView
		      ?layer  ,wellLayer
		      ?width  ,(plus tap_W (times tapImpEnc 2) (times ntapWellSpc 2))
		      ?pts    list((plus L tap_W):(plus W tap_W tapImpEnc ntapWellSpc)
				   (plus L tap_W):-tap_W/2
				   -(plus tap_W/2 tapImpEnc ntapWellSpc):-tap_W/2
				  )
		     )
     )
  else
     (setq Implant_I (rodCreatePath
		      ?cvId   tcCellView
		      ?layer  ,pImplant
		      ?width  ,(plus tap_W (times tapImpEnc 2))
		      ?pts    list(0:0 0:(plus W tap_W/2)
				   0:(plus W tap_W/2) (plus L tap_W):(plus W tap_W/2)
				   (plus L tap_W):(plus W tap_W/2) (plus L tap_W):0
				  )
		     )
     )
     (setq Implant_IB (rodCreatePath
		       ?cvId   tcCellView
		       ?layer  ,pImplant
		       ?width  ,(plus tap_W (times tapImpEnc 2))
		       ?pts    list((plus L tap_W tap_W/2 tapImpEnc):-tap_W/2 -(plus tap_W/2 tapImpEnc):-tap_W/2)
		      )
     )
 ) ;;End if InnerRing == nTap
 (when RingNum > 1
     (if RingNum > 3 then
	 (setq RingNum 3)
	 (warn "Max RingNum Should Be 3. Default set to 3")
     )
     (setq tap_W_M (max (plus conWidth (times tapConEncX 2)) MRingWidth))
     (setq Space12 (max ptapWellSpc Space12))
     (setq Mtap_x0 (plus tap_W/2 (times tapImpEnc 2) ntapWellSpc tap_W_M/2 Space12))
     (setq Mtap_y0 (plus tap_W (times tapImpEnc 2) ntapWellSpc tap_W_M/2 Space12))
     (setq Mtap_x1 (plus tap_W/2 L tap_W (times tapImpEnc 2) ntapWellSpc Space12 tap_W_M/2))
     (setq TAP_L_M (rodCreatePath
		    ?cvId   tcCellView
		    ?layer  tapLayer
		    ?width  tap_W_M
		    ?pts    list(-,Mtap_x0:-,(plus Mtap_y0 tap_W_M/2)
				 -,Mtap_x0:,(plus W Mtap_y0 tap_W_M/2)
				)
		    ?encSubPath list(
				     list(
					  ?layer       ,M0Layer
					  ?enclosure   ,tapConEncX
					  ?beginOffset -,tapConEncX
					  ?endOffset   -,tapConEncX
					 )
				    )
		    ?subRect   list(
				    list(
					 ?layer       ,conLayer
					 ?width       ,conWidth
					 ?length      ,conLength
					 ?beginOffset -,(plus conSpacing tapConEncX tap_W_M/2)
					 ?endOffset   -,(plus conSpacing tapConEncX tap_W_M/2)
					 ?space       ,conSpacing
					)
				   )
		   )
     )
     (setq TAP_T_M (rodCreatePath
		    ?cvId   tcCellView
		    ?layer  tapLayer
		    ?width  tap_W_M
		    ?pts    list(-,Mtap_x0:,(plus W Mtap_y0)
				 ,(plus Mtap_x1 tap_W_M/2):,(plus W Mtap_y0)
				)
		    ?encSubPath list(
				     list(
					  ?layer       ,M0Layer
				          ?enclosure   ,tapConEncX
					  ?beginOffset ,tapConEncX
					  ?endOffset   -,tapConEncX
					 )
				    )
		    ?subRect   list(
				    list(
					 ?layer       ,conLayer
				         ?width       ,conWidth
					 ?length      ,conLength
					 ?beginOffset -,(plus conSpacing tap_W_M/2)
					 ?endOffset   -,(plus conSpacing tap_W_M/2)
					 ?space       ,conSpacing
					)
				   )
		   )
     )
     (setq TAP_R_M (rodCreatePath
		    ?cvId   tcCellView
		    ?layer  tapLayer
		    ?width  tap_W_M
		    ?pts    list(,Mtap_x1:,(plus W Mtap_y0)
				     ,Mtap_x1:-,Mtap_y0
				)
		    ?encSubPath list(
				     list(
					  ?layer       ,M0Layer
					  ?enclosure   ,tapConEncX
					  ?beginOffset ,tapConEncX
					  ?endOffset   ,tapConEncX
					 )
				    )
		    ?subRect   list(
				    list(
					 ?layer       ,conLayer
					 ?width       ,conWidth
					 ?length      ,conLength
					 ?beginOffset -,(plus conSpacing tap_W_M/2)
					 ?endOffset   -,(plus conSpacing tap_W_M/2)
					 ?space       ,conSpacing
					)
				   )
		   )
     )
     (setq TAP_B_M (rodCreatePath
		    ?cvId   tcCellView
		    ?layer  tapLayer
		    ?width  tap_W_M
		    ?pts    list(,(plus Mtap_x1 tap_W_M/2):-,Mtap_y0
				 -,(plus Mtap_x0 tap_W_M/2):-Mtap_y0
				)
		    ?encSubPath list(
				     list(
					  ?layer       ,M0Layer
                                          ?enclosure   ,tapConEncX
					  ?beginOffset -,tapConEncX
					  ?endOffset   -,tapConEncX
					 )
				    )
		    ?subRect   list(
				    list(
					 ?layer       ,conLayer
					 ?width       ,conWidth
					 ?length      ,conLength
					 ?beginOffset -,(plus M0conEncY tapConEncY)
					 ?endOffset   -,(plus conSpacing tapConEncX tap_W_M/2)
					 ?space       ,conSpacing
					)
				   )
		   )
     )
     (if InnerRing == "nTap" then
	 (setq Mimplant pImplant)
      else
	 (setq Mimplant nImplant)
	 (setq Well_M_LT (rodCreatePath
			  ?cvId   tcCellView
			  ?layer  ,wellLayer
			  ?width  ,(plus tap_W_M (times tapImpEnc 2) (times ntapWellSpc 2))
			  ?pts    list(-,Mtap_x0:-,Mtap_y0
				       -,Mtap_x0:,(plus W Mtap_y0)
				       ,Mtap_x1:,(plus W Mtap_y0)
				       ,Mtap_x1:-,Mtap_y0
				      )
			 )
	 )
	 (setq Well_M_RB (rodCreatePath
			  ?cvId   tcCellView
			  ?layer  ,wellLayer
			  ?width  ,(plus tap_W_M (times tapImpEnc 2) (times ntapWellSpc 2))
			  ?pts    list(,(plus Mtap_x1 tap_W_M/2 tapImpEnc ntapWellSpc):-,Mtap_y0
				       -,(plus Mtap_x0 tap_W_M/2 tapImpEnc ntapWellSpc):-Mtap_y0
				      )
			 )
	 )
     ) ;;End if InnerRing == nTap
     (setq Implant_M (rodCreatePath
		      ?cvId   tcCellView
		      ?layer  ,Mimplant
		      ?width  ,(plus tap_W_M (times tapImpEnc 2))
		      ?pts    list(-,Mtap_x0:-,Mtap_y0
				   -,Mtap_x0:,(plus W Mtap_y0)
				   ,Mtap_x1:,(plus W Mtap_y0)
				   ,Mtap_x1:-,Mtap_y0
				  )
		     )
     )
     (setq Implant_MB (rodCreatePath
			   ?cvId   tcCellView
			   ?layer  ,Mimplant
			   ?width  ,(plus tap_W_M (times tapImpEnc 2))
			   ?pts    list(,(plus Mtap_x1 tap_W_M/2 tapImpEnc):-,Mtap_y0
					-,(plus Mtap_x0 tap_W_M/2 tapImpEnc):-Mtap_y0
				       )
		      )
     )
     (unless RingNum == 2
	 (setq tap_W_O (max (plus conWidth (times tapConEncX 2)) ORingWidth))
	 (setq Space23 (max ptapWellSpc Space23))
	 (setq Otap_x0 (plus tap_W/2 (times tapImpEnc 4) (times ntapWellSpc 2) Space12 tap_W_M Space23 tap_W_O/2))
	 (setq Otap_y0 (plus tap_W (times tapImpEnc 4) (times ntapWellSpc 2) Space12 tap_W_M Space23 tap_W_O/2))
	 (setq Otap_x1 (plus tap_W/2 L tap_W (times tapImpEnc 4) (times ntapWellSpc 2) Space12 tap_W_M Space23 tap_W_O/2))
	 (setq TAP_L_O (rodCreatePath
			?cvId   tcCellView
			?layer  tapLayer
			?width  tap_W_O
			?pts    list(-,Otap_x0:-,(plus Otap_y0 tap_W_O/2)
				     -,Otap_x0:,(plus W Otap_y0 tap_W_O/2)
				    )
			?encSubPath list(
					 list(
					      ?layer       ,M0Layer
		                              ?enclosure   ,tapConEncX
					      ?beginOffset -,tapConEncX
					      ?endOffset   -,tapConEncX
					     )
					)
			?subRect   list(
					list(
					     ?layer       ,conLayer
					     ?width       ,conWidth
					     ?length      ,conLength
					     ?beginOffset -,(plus conSpacing tapConEncX tap_W_O/2)
					     ?endOffset   -,(plus conSpacing tapConEncX tap_W_O/2)
					     ?space       ,conSpacing
					    )
				       )
		       )
	 )
	 (setq TAP_T_O (rodCreatePath
			?cvId   tcCellView
			?layer  tapLayer
			?width  tap_W_O
			?pts    list(-,Otap_x0:,(plus W Otap_y0)
				     ,(plus Otap_x1 tap_W_O/2):,(plus W Otap_y0)
				    )
			?encSubPath list(
					 list(
					      ?layer       ,M0Layer
					      ?enclosure   ,tapConEncX
					      ?beginOffset ,tapConEncX
					      ?endOffset   -,tapConEncX
					     )
					)
			?subRect   list(
					list(
					     ?layer       ,conLayer
			                     ?width       ,conWidth
					     ?length      ,conLength
					     ?beginOffset -,(plus conSpacing tapConEncX tap_W_O/2)
					     ?endOffset   -,(plus conSpacing tapConEncX tap_W_O/2)
					     ?space       ,conSpacing
					    )
				       )
		       )
	 )
	 (setq TAP_R_O (rodCreatePath
			?cvId   tcCellView
			?layer  tapLayer
			?width  tap_W_O
			?pts    list(,Otap_x1:,(plus W Otap_y0)
				     ,Otap_x1:-,Otap_y0
				    )
			?encSubPath list(
					 list(
					      ?layer       ,M0Layer
					      ?enclosure   ,tapConEncX
					      ?beginOffset ,tapConEncX
					      ?endOffset   ,tapConEncX
					     )
					)
			?subRect   list(
					list(
					     ?layer       ,conLayer
                                             ?width       ,conWidth
					     ?length      ,conLength
					     ?beginOffset -,(plus conSpacing tapConEncX tap_W_O/2)
					     ?endOffset   -,(plus conSpacing tapConEncX tap_W_O/2)
					     ?space       ,conSpacing
					    )
				       )
		       )
	 )
	 (setq TAP_B_O (rodCreatePath
			?cvId   tcCellView
			?layer  tapLayer
			?width  tap_W_O
			?pts    list(,(plus Otap_x1 tap_W_O/2):-,Otap_y0
				     -,(plus Otap_x0 tap_W_O/2):-Otap_y0
				    )
			?encSubPath list(
					 list(
					      ?layer       ,M0Layer
					      ?enclosure   ,tapConEncX
					      ?beginOffset -,tapConEncX
					      ?endOffset   -,tapConEncX
					     )
					)
			?subRect   list(
					list(
					     ?layer       ,conLayer
					     ?width       ,conWidth
					     ?length      ,conLength
					     ?beginOffset -,(plus M0conEncY tapConEncY)
					     ?endOffset   -,(plus conSpacing tapConEncX tap_W_O/2)
					     ?space       ,conSpacing
					    )
				       )
		       )
	 )
	 (if InnerRing == "nTap" then
	     (setq Oimplant nImplant)
	     (setq Well_O_LT (rodCreatePath
			      ?cvId   tcCellView
			      ?layer  ,wellLayer
			      ?width  ,(plus tap_W_O (times tapImpEnc 2) (times ntapWellSpc 2))
			      ?pts    list(-,Otap_x0:-,Otap_y0
					   -,Otap_x0:,(plus W Otap_y0)
					   ,Otap_x1:,(plus W Otap_y0)
					   ,Otap_x1:-,Otap_y0
					  )
			     )
	     )
	     (setq Well_O_RB (rodCreatePath
			      ?cvId   tcCellView
			      ?layer  ,wellLayer
			      ?width  ,(plus tap_W_O (times tapImpEnc 2) (times ntapWellSpc 2))
			      ?pts    list(,(plus Otap_x1 tap_W_O/2 tapImpEnc ntapWellSpc):-,Otap_y0
					   -,(plus Otap_x0 tap_W_O/2 tapImpEnc ntapWellSpc):-Otap_y0
					  )
			     )
	     )
	  else
	     (setq Oimplant pImplant)
	 ) ;;End if InnerRing == nTap
	 (setq Implant_O (rodCreatePath
			  ?cvId   tcCellView
			  ?layer  ,Oimplant
			  ?width  ,(plus tap_W_O (times tapImpEnc 2))
			  ?pts    list(-,Otap_x0:-,Otap_y0
				       -,Otap_x0:,(plus W Otap_y0)
				       ,Otap_x1:,(plus W Otap_y0)
				       ,Otap_x1:-,Otap_y0
				      )
			 )
	 )
	 (setq Implant_OB (rodCreatePath
			   ?cvId   tcCellView
			   ?layer  ,Oimplant
			   ?width  ,(plus tap_W_O (times tapImpEnc 2))
			   ?pts    list(,(plus Otap_x1 tap_W_O/2 tapImpEnc):-,Otap_y0
					-,(plus Otap_x0 tap_W_O/2 tapImpEnc):-Otap_y0
				       )
			  )
	 )
     ) ;;End unless RingNum == 2
 ) ;;End when RingNum > 1

;; draws deep nwell if there are >= 2 rings
;; and DeepNwell is specified - fullWell does nothing here
;; must have inner ring as pTap
(if InnerRing == "pTap" then
     (if DeepNwell then
       (if RingNum > 1 then
	   (setq DNW (rodCreateRect
		      ?layer dnwellLayer
		      ?fromObj (list Well_M_LT Well_M_RB)
		      ?size -((plus tap_W_M (times tapImpEnc 2) (times ntapWellSpc 2)) - dnwWellEnc)
		      ))
	   )
       )
     )
) ;;End tcCreateDeviceClass
;;; Define the function of the class.

(tfcDefineDeviceClassProp
;;(viewName       devClassName         propName          propValue)
 (symbolic    rodTripleGuardRing     function        "transistor")
)


;;; 
;;; $Id: mNormTranImpClass.il,v 1.11 2005/01/18 11:45:24 xvg Exp $ %T%
;;; 
;;; mNormTranImpClass.il
;;; 
;;; Copyright (c) 1996 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Oct 23, 1996
;;; Author: Sanjay Rekhi/Senior CAD (syr) @ CSDC
;;; 
;;; Description:
;;;  Skill code for the normal topography transistors with
;;;  mfactors and polarized implants. This device class 
;;;  will be used to declare normal topography nmos, pmos and depletion 
;;;  nmos transistors.
;;;
;;; Revision History:
;;;   gtc 01/23/98  Copying over from v20
;;;   dgn 12/14/98  Fixed bugs when one tip-tap specified (top or bot)
;;;   xgs 09/29/00  Changing gateExt to formal parameter ( SPR 7745 )
;;;   cry 07/31/01  Copied from mNormTranClass.il to make transistors with
;;;                 toggleable implants.
;;;   kmi 04/02/02  Adding the internal offset; used when spacing across a 
;;;                 gate is too small
;;;   jtv 04/24/02  Added gate enclosure ability for lvt and native devices
;;;   kmi 05/09/02  Adding hvLayer to class parameters
;;;   kmi 06/04/02  Replacing topLayerPinBbox with bBoxLayer3 to do proper
;;;                 calculations when left and right contacts are of different
;;;                 metal hiererchy (like left is DFTPL1 and right DFM1). Using
;;;                 topLayerPinBbox resulted in comparing Li to Met1.
;;;                 Corrected contact bBox reading (only X1 cordinates)
;;;   dxj 12/17/02  idLayer can be a list also
;;;                 diff/tap implant options
;;;                 contacts on diff/tap, both
;;;  lpn 07/26/03   Enhanced the class for gate to contact space SPR 16669
;;;  lpn 10/10/03   Fixed the bug in poly implant enclosure of gate SPR 17510 
;;;  kmi 07/22/04   Adding (listp idLayer) before (cadr idLayer); SPR 20837
;;;

(tcCreateDeviceClass
 "symbolic" "mNormTranImpClass"
 ;;; Class parameters
 (
  (diffLayer    "hilite") ;;; diffusion layer
  (gateLayer    "marker") ;;; poly/gate layer
  (wellLayer    nil)      ;;; well layer, if nil then well is not drawn
  (wellminWidth   0.0)    ;;; the well Layer min width
  (hvLayer      nil)      ;;; HV layer, if nill then hv layer is not drawn
  (depLayer     nil)      ;;; depletion layer, if nil then not drawn, 
                          ;;; other wise it is drawn on gate
  (diffExt      0.0)      ;;; extension of diff beyond poly. This is drawn 
                          ;;; for end contacts only, if the first/last 
                          ;;; contact are not specified.
  (wellEncDiff  0.0)      ;;; enclosure of diffusion by well.
  (wellEncTap   0.0)      ;;; enclosure of tap by well.
  (wellLayerWidth 0.0)
  (hvEnclosure  0.0)      ;;; enclosure of diffTap or nwell by hvLayer
  (depXEnc      0.0)      ;;; enclosure of gate by dep (in X direction)
  (depYEnc      0.0)      ;;; enclosure of gate by dep (in Y direction)
  (depSpace     0.0)      ;;; depletion to depletion space, notch filling 
                          ;;; will be done to satisfy this.
          ;;; We do not specify the minWidth of the Well and minWidth of the 
          ;;; depletion layer. The transistor length and depXEnc, and 
          ;;; transistor width and depYEnc parameters should be used to 
          ;;; control that.
  (labelLayer (list "text" "drawing")) ;;; layer on which labels should be 
                                       ;;; drawn, if nil labels are not drawn
  (labelWidth      0.4)   ;;; width of the label
  (diffImplant     nil)   ;;; implant layer to draw around diff
  (diffImpEnc      0.0)   ;;; enclosure of diff by implant layer
  (diffCoreImplant nil)   ;;; implant layer to draw around diff
  (diffCoreImpEnc  0.0)   ;;; enclosure of diff by implant layer
  (via1MinSpace    0.0)   ;;; first contact layer min space
  (via2MinSpace    0.0)   ;;; second contact layer min space
  (layer2MinSpace  0.0)   ;;; second layer min space
  (layer3MinSpace  0.0)   ;;; third (top) layer min space
  (noOfDecimals    3)     ;;; no# of decimals used for rules values
  (snapGrid (TECHgetProp snapGrid)) ; grid size
  (bckCompatibleOffSet nil) ;;; when nil, total offset used will be 
                            ;;; userOffset+intrnalOffset (srcOffset + 
                            ;;; minSpaceOffSet drnOffset+minSpaceOffSet)
  (polyImplant     nil)
  (polyImpXEnc     0.0)
  (polyImpYEnc     0.0)
  (hvPYMconSpace   0.0)	
  (wellEncHvLayer  0.0)	
 )
 ;;; Formal parameters
 (
  (sourceFirst    "TRUE")
  (sharedDrain    "")
  (sharedSource   "")
  (lastContact    "")
  (firstContact   "")
  (gateExt        0.0) ;;; extension of poly beyond diff
  (idLayerChoices nil) ;;; this is a list of strings
  (idLayer        nil) ;;; this is a string
  (idEncDiff      nil) ;;; this is boolean
  (idEncXL        0.0)
  (idEncXR        0.0)
  (idEncY         0.0)
  (diffImpChoices nil)
  (tapImpChoices  nil)
  (contactChoices nil)
  (diffImpChoice  nil)
  (tapImpChoice   nil)
  (contactChoice  nil)
  (srcOffset      0.0)
  (drnOffset      0.0)
  (m              1)
  (l              0.0)
  (w              0.0)
  (implant        t)
  (noEndConImpEnc t)
 )

 (setq wellEncYDiff 0.0)
 (when (nequal wellLayerWidth 0.0)
   (setq wellWidth (plus (times (max wellEncDiff wellEncTap) 2) w))
   (if (lessp wellWidth wellLayerWidth) then 
       (setq wellEncYDiff (abs (difference (max wellEncDiff wellEncTap )
                                      (quotient (difference wellLayerWidth w) 2)))))
 )

 ;; convert boolean parameters to either t or nil
 ;; this way we can use the simple (when parameter) syntax
 ;; and speed up pcell evaluation and make code simpler
 (if (or (equal implant t) (equal implant "TRUE")) then
   (setq implant t)
   else
   (setq implant nil)
   )
 (if (or (equal noEndConImpEnc t) (equal noEndConImpEnc "TRUE")) then
   (setq noEndConImpEnc t)
   else
   (setq noEndConImpEnc nil)
   )
 (if (or (null idLayer) (equal idLayer "none")  (equal idLayer "nil") 
	 (equal idLayer "FALSE")) then
   (setq idLayer nil)
   )
 (if (or (equal sourceFirst t) (equal sourceFirst "TRUE")) then
   (setq sourceFirst t)
   else
   (setq sourceFirst nil)
   )
  (if (or (equal idEncDiff t) (equal idEncDiff "TRUE")) then
   (setq idEncDiff t)
   else
   (setq idEncDiff nil)
   )

 (if (lessp gateExt 0.0)
     (error "mNormTranImpClass: gateExt (%g) must be > 0\n" gateExt)
   )
 
 ;;; Make the nets and the terminals that will be used in the cell.
 (setq gNet (dbCreateNet tcCellView "g"))
 (dbCreateTerm gNet "g" "input")
 (setq sNet (dbCreateNet tcCellView "s"))
 (dbCreateTerm sNet "s" "inputOutput")
 (setq dNet (dbCreateNet tcCellView "d"))
 (dbCreateTerm dNet "d" "inputOutput")

 ;;; make sure the boolean parameters are set properly
 (if sourceFirst then
     (setq cNet sNet)
     (setq netL "S")
  else
     (setq cNet dNet)
     (setq netL "D")
 )

 (when (lessp m 1) ;;; The schematic transistor can have an mfactor of 0.
     (setq m 1)    ;;; It will be enforced to a minimum of 1.
 )

 ;; 
 ;; The diff/tap imlant choices decide what implant enclosure of diff/tap should be used for
 ;; each choice. The user choice is propogated to the src/drn contact classes as follows.
 ;;
 ;; - The diffMatch and tapMatch variables are set to the user choice position
 ;; - This variable is passed to the src/drn contacts as diffImpChoice/tapImpChoice parameter
 ;; - Contact classes have diffImpChoice(formal param) and diffImpEncList(class param)
 ;; - The contact class uses (nth diffImpChoice diffImpEncList) to get the implant 
 ;;   enclosure corresponding to the choice
 ;; 
 (when diffImpChoices
     ;; The use of diffImpChoices implies that we need to pass a list of diffImpEnc values.
     (unless (and diffImpEnc (listp diffImpEnc) ((length diffImpEnc) == (length diffImpChoices)))
	 (error "diffImpEnc should be a list matching diffImpChoices"))

     ;; Find the implant choice match position in the list of choices
     ;; Default to something sensible if nothing is matched
     (setq i (length (or (member diffImpChoice diffImpChoices) diffImpChoices) ))
     (setq diffMatch (difference (length diffImpChoices) i ))
     (setq diffImpEnc (nth diffMatch diffImpEnc))
 )

 (when tapImpChoices
     (setq i (length (or (member tapImpChoice tapImpChoices) tapImpChoices)))
     (setq tapMatch (difference (length tapImpChoices) i ))
 )

 (when contactChoices
     (cond
	 ((contactChoice == "tap")  (setq diffConParam (list "noDiffContact" "boolean" t)))
	 ((contactChoice == "both") (setq diffConParam (list "noDiffContact" "boolean" "FALSE")))
	 (t                         (setq diffConParam (list "noDiffContact" "boolean" "FALSE")))
     )
 )

 ;; Handle the idLayerChoices as a list
 x=nil
 (if (listp (car idLayerChoices)) then
     (mapcar (lambda (x) 
		 (if (car x) == idLayer then 		     
		     (setq idLayer (cadr x))
		     (setq idEncList (caddr x))
		     (if (and idEncList (listp idEncList)) then
			 (setq idEncXL (nth 0 idEncList))
			 (setq idEncXR (nth 1 idEncList))
			 (setq idEncY  (nth 2 idEncList))
		     )
		     (setq idEncDiff (cadddr x)) 
		 )) idLayerChoices)
 )
 
;;; Deriving internal offset required to have a pcell DRC clean from the 
;;; space errors across a gate.

(when (nequal firstContact "")
      (setq contactF (dbOpenCellView tcCellView~>lib firstContact "symbolic" 
				     nil "rn")))
(when (nequal lastContact "")
      (setq contactL (dbOpenCellView tcCellView~>lib lastContact "symbolic" 
				     nil "rn")))
(when (nequal sharedDrain "")
      (setq contactD (dbOpenCellView tcCellView~>lib sharedDrain "symbolic" 
				     nil "rn")))
(when (nequal sharedSource "")
      (setq contactS (dbOpenCellView tcCellView~>lib sharedSource "symbolic"
				     nil "rn")))

     ;;; getting coordinates
     ; first and last contacts
     ; should always compare only X1 because contacts are rotated later on
     (setq via1XCrdF   (if contactF~>bBoxVia1 
			   (abs (caar contactF~>bBoxVia1)) nil))
     (setq layer2XCrdF (if contactF~>bBoxLayer2 
			   (abs (caar contactF~>bBoxLayer2)) nil))
     (setq via2XCrdF   (if contactF~>bBoxVia2 
			   (abs (caar contactF~>bBoxVia2)) nil))
     (setq layer3XCrdF (if contactF~>bBoxLayer3
			   (abs (caar contactF~>bBoxLayer3)) nil))
     (setq layer1XCrdF (if contactF~>diffLayerBbox
			   (abs (caar contactF~>diffLayerBbox)) nil))
     (setq via1XCrdL   (if contactL~>bBoxVia1 
			   (abs (caar contactL~>bBoxVia1)) nil))
     (setq layer2XCrdL (if contactL~>bBoxLayer2
			   (abs (caar contactL~>bBoxLayer2)) nil))
     (setq via2XCrdL   (if contactL~>bBoxVia2 
			   (abs (caar contactL~>bBoxVia2)) nil))
     (setq layer3XCrdL (if contactL~>bBoxLayer3
			   (abs (caar contactL~>bBoxLayer3)) nil))
     (setq layer1XCrdL (if contactL~>diffLayerBbox
			   (abs (caar contactL~>diffLayerBbox)) nil))
     ; shared source and drain contacts
     (setq via1XCrdS   (if contactS~>bBoxVia1 
			 (abs (caar contactS~>bBoxVia1)) nil))
     (setq layer2XCrdS (if contactS~>bBoxLayer2
			   (abs (caar contactS~>bBoxLayer2)) nil))
     (setq via2XCrdS   (if contactS~>bBoxVia2 
			   (abs (caar contactS~>bBoxVia2)) nil))
     (setq layer3XCrdS (if contactS~>bBoxLayer3
			   (abs (caar contactS~>bBoxLayer3)) nil))
     (setq layer1XCrdS (if contactS~>diffLayerBbox
			   (abs (caar contactS~>diffLayerBbox)) nil))
     (setq via1XCrdD   (if contactD~>bBoxVia1 
			   (abs (caar contactD~>bBoxVia1)) nil))
     (setq layer2XCrdD (if contactD~>bBoxLayer2
			   (abs (caar contactD~>bBoxLayer2)) nil))
     (setq via2XCrdD   (if contactD~>bBoxVia2 
			   (abs (caar contactD~>bBoxVia2)) nil))
     (setq layer3XCrdD (if contactD~>bBoxLayer3
			   (abs (caar contactD~>bBoxLayer3)) nil))
     (setq layer1XCrdD (if contactD~>diffLayerBbox
			   (abs (caar contactD~>diffLayerBbox)) nil))
     

     ;;; calculating enclosures
     ; first and last contacts
(if (and  layer1XCrdF via1XCrdF) then 
    (setq via1EncF    (abs (difference layer1XCrdF via1XCrdF))))
(if (and  layer1XCrdF via2XCrdF) then 
    (setq via2EncF    (abs (difference layer1XCrdF via2XCrdF))))
(if (and  layer1XCrdF layer2XCrdF) then 
    (setq layer2EncF  (abs (difference layer1XCrdF layer2XCrdF))))
(if (and  layer1XCrdF layer3XCrdF) then 
    (setq layer3EncF  (abs (difference layer1XCrdF layer3XCrdF))))
(if (and  layer1XCrdL via1XCrdL) then 
    (setq via1EncL    (abs (difference layer1XCrdL via1XCrdL))))
(if (and  layer1XCrdL via2XCrdL) then 
    (setq via2EncL    (abs (difference layer1XCrdL via2XCrdL))))
(if (and  layer1XCrdL layer2XCrdL) then 
    (setq layer2EncL  (abs (difference layer1XCrdL layer2XCrdL))))
(if (and  layer1XCrdL layer3XCrdL) then 
    (setq layer3EncL  (abs (difference layer1XCrdL layer3XCrdL))))

     ; shared source and drain contacts
(if (and  layer1XCrdS via1XCrdS) then 
    (setq via1EncS    (abs (difference layer1XCrdS via1XCrdS))))
(if (and  layer1XCrdS via2XCrdS) then 
    (setq via2EncS    (abs (difference layer1XCrdS via2XCrdS))))
(if (and  layer1XCrdS layer2XCrdS) then 
    (setq layer2EncS  (abs (difference layer1XCrdS layer2XCrdS))))
(if (and  layer1XCrdS layer3XCrdS) then 
    (setq layer3EncS  (abs (difference layer1XCrdS layer3XCrdS))))
(if (and  layer1XCrdD via1XCrdD) then 
    (setq via1EncD    (abs (difference layer1XCrdD via1XCrdD))))
(if (and  layer1XCrdD via2XCrdD) then 
    (setq via2EncD    (abs (difference layer1XCrdD via2XCrdD))))
(if (and  layer1XCrdD layer2XCrdD) then 
    (setq layer2EncD  (abs (difference layer1XCrdD layer2XCrdD))))
(if (and  layer1XCrdD layer3XCrdD) then 
    (setq layer3EncD  (abs (difference layer1XCrdD layer3XCrdD))))

     ;;; calculating space over a gate
     ;;; calculating the total offset
     ;;; if enclosures do not exist set an offset to zero
     ; First and Last contact (used when m==1)
(if (and via1EncF via1EncL) then 
     (setq via1SpaceFL (plus via1EncF via1EncL l))
     (setq via1OffSetFL (difference via1MinSpace via1SpaceFL )) 
else
     (setq via1OffSetFL 0.0)
)
(if (and via2EncF via2EncL) then 
     (setq via2SpaceFL (plus via2EncF via2EncL l))
     (setq via2OffSetFL (difference via2MinSpace via2SpaceFL)) 
else 
     (setq via2OffSetFL 0.0)
)
(if (and layer3EncF layer3EncL) then
     (setq layer3SpaceFL (plus layer3EncF layer3EncL l))
     (setq layer3OffSetFL (difference layer3MinSpace layer3SpaceFL)) 
else 
     (setq layer3OffSetFL 0.0)
)
(if (and layer2EncF layer2EncL) then
     (setq layer2SpaceFL (plus layer2EncF layer2EncL l))
     (setq layer2OffSetFL (difference layer2MinSpace layer2SpaceFL)) 
else 
     (setq layer2OffSetFL 0.0)
)
     ; First and shared Source contact 
(if (and via1EncF via1EncS) then 
     (setq via1SpaceFS (plus via1EncF via1EncS l))
     (setq via1OffSetFS (difference via1MinSpace via1SpaceFS )) 
else 
     (setq via1OffSetFS 0.0)
)
(if (and via2EncF via2EncS) then 
     (setq via2SpaceFS (plus via2EncF via2EncS l))
     (setq via2OffSetFS (difference via2MinSpace via2SpaceFS)) 
else 
     (setq via2OffSetFS 0.0)
)
(if (and layer3EncF layer3EncS) then
     (setq layer3SpaceFS (plus layer3EncF layer3EncS l))
     (setq layer3OffSetFS (difference layer3MinSpace layer3SpaceFS)) 
else 
     (setq layer3OffSetFS 0.0)
)
(if (and layer2EncF layer2EncS) then
     (setq layer2SpaceFS (plus layer2EncF layer2EncS l))
     (setq layer2OffSetFS (difference layer2MinSpace layer2SpaceFS))
else 
     (setq layer2OffSetFS 0.0)
)
     ; First and shared Drain contact 
(if (and via1EncF via1EncD) then 
     (setq via1SpaceFD (plus via1EncF via1EncD l))
     (setq via1OffSetFD (difference via1MinSpace via1SpaceFD )) 
else 
     (setq via1OffSetFD 0.0
))
(if (and via2EncF via2EncD) then 
     (setq via2SpaceFD (plus via2EncF via2EncD l))
     (setq via2OffSetFD (difference via2MinSpace via2SpaceFD)) 
else 
     (setq via2OffSetFD 0.0)
)
(if (and layer3EncF layer3EncD) then
     (setq layer3SpaceFD (plus layer3EncF layer3EncD l))
     (setq layer3OffSetFD (difference layer3MinSpace layer3SpaceFD)) 
else 
     (setq layer3OffSetFD 0.0
))
(if (and layer2EncF layer2EncD) then
     (setq layer2SpaceFD (plus layer2EncF layer2EncD l))
     (setq layer2OffSetFD (difference layer2MinSpace layer2SpaceFD)) 
else 
     (setq layer2OffSetFD 0.0)
)
     ; Last and shared Source contact 
(if (and via1EncL via1EncS) then 
     (setq via1SpaceLS (plus via1EncL via1EncS l))
     (setq via1OffSetLS (difference via1MinSpace via1SpaceLS )) 
else 
     (setq via1OffSetLS 0.0)
)
(if (and via2EncL via2EncS) then 
     (setq via2SpaceLS (plus via2EncL via2EncS l))
     (setq via2OffSetLS (difference via2MinSpace via2SpaceLS)) 
else 
     (setq via2OffSetLS 0.0)
)
(if (and layer3EncL layer3EncS) then
     (setq layer3SpaceLS (plus layer3EncL layer3EncS l))
     (setq layer3OffSetLS (difference layer3MinSpace layer3SpaceLS)) 
else 
     (setq layer3OffSetLS 0.0)
)
(if (and layer2EncL layer2EncS) then
     (setq layer2SpaceLS (plus layer2EncL layer2EncS l))
     (setq layer2OffSetLS (difference layer2MinSpace layer2SpaceLS)) 
else 
     (setq layer2OffSetLS 0.0)
)
     ; Last and shared Drain contact 
(if (and via1EncL via1EncD) then 
     (setq via1SpaceLD (plus via1EncL via1EncD l))
     (setq via1OffSetLD (difference via1MinSpace via1SpaceLD )) 
else 
     (setq via1OffSetLD 0.0)
)
(if (and via2EncL via2EncD) then 
     (setq via2SpaceLD (plus via2EncL via2EncD l))
     (setq via2OffSetLD (difference via2MinSpace via2SpaceLD)) 
else 
     (setq via2OffSetLD 0.0)
)
(if (and layer3EncL layer3EncD) then
     (setq layer3SpaceLD (plus layer3EncL layer3EncD l))
     (setq layer3OffSetLD (difference layer3MinSpace layer3SpaceLD)) 
else (setq layer3OffSetLD 0.0)
)
(if (and layer2EncL layer2EncD) then
     (setq layer2SpaceLD (plus layer2EncL layer2EncD l))
     (setq layer2OffSetLD (difference layer2MinSpace layer2SpaceLD)) 
else (setq layer2OffSetLD 0.0)
)
     ; shared Source and shared Drain contact 
(if (and via1EncS via1EncD) then 
     (setq via1SpaceSD (plus via1EncS via1EncD l))
     (setq via1OffSetSD (difference via1MinSpace via1SpaceSD )) 
else 
     (setq via1OffSetSD 0.0)
)
(if (and via2EncS via2EncD) then 
     (setq via2SpaceSD (plus via2EncS via2EncD l))
     (setq via2OffSetSD (difference via2MinSpace via2SpaceSD)) 
else 
     (setq via2OffSetSD 0.0)
)
(if (and layer3EncS layer3EncD) then
     (setq layer3SpaceSD (plus layer3EncS layer3EncD l))
     (setq layer3OffSetSD (difference layer3MinSpace layer3SpaceSD)) 
else 
     (setq layer3OffSetSD 0.0)
)
(if (and layer2EncS layer2EncD) then
     (setq layer2SpaceSD (plus layer2EncS layer2EncD l))
     (setq layer2OffSetSD (difference layer2MinSpace layer2SpaceSD)) 
else 
     (setq layer2OffSetSD 0.0)
)

     ;;; if xyzMinSpace is less then xyzSpace (no spacing error) then xyzDiff 
     ;;; will be less than zero. Therefore, max() must include 0.0 in order 
     ;;; to avoid negative offset
(if (equal m 1) then
    (setq maxOffSet (max via1OffSetFL via2OffSetFL layer2OffSetFL 
			 layer3OffSetFL 0.0))
 else
    (if (equal m 2) then
        (if sourceFirst  then
            (setq maxOffSet (max via1OffSetFD   via2OffSetFD   layer2OffSetFD 
				 layer3OffSetFD via1OffSetLD   via2OffSetLD 
				 layer2OffSetLD layer3OffSetLD 0.0))
         else
            (setq maxOffSet (max via1OffSetFS   via2OffSetFS   layer2OffSetFS 
				 layer3OffSetFS via1OffSetLS   via2OffSetLS 
				 layer2OffSetLS layer3OffSetLS 0.0))
        )
    else 
    (if (equal (mod m 2) 0) then   
      (if sourceFirst then
	(setq maxOffSet (max via1OffSetFD   via2OffSetFD   layer2OffSetFD 
			     layer3OffSetFD via1OffSetSD   via2OffSetSD 
			     layer2OffSetSD layer3OffSetSD via1OffSetLD 
			     via2OffSetLD   layer2OffSetLD layer3OffSetLD 0.0))
	else
	(setq maxOffSet (max via1OffSetFS   via2OffSetFS   layer2OffSetFS 
			     layer3OffSetFS via1OffSetSD   via2OffSetSD 
			     layer2OffSetSD layer3OffSetSD via1OffSetLS 
			     via2OffSetLS   layer2OffSetLS layer3OffSetLS 0.0))
	)
      else
      (if sourceFirst then
	(setq maxOffSet (max via1OffSetFD   via2OffSetFD   layer2OffSetFD 
			     layer3OffSetFD via1OffSetSD   via2OffSetSD 
			     layer2OffSetSD layer3OffSetSD via1OffSetLS 
			     via2OffSetLS   layer2OffSetLS layer3OffSetLS 0.0))
	else
	(setq maxOffSet (max via1OffSetFS   via2OffSetFS   layer2OffSetFS 
			     layer3OffSetFS via1OffSetSD   via2OffSetSD 
			     layer2OffSetSD layer3OffSetSD via1OffSetLD 
			     via2OffSetLD   layer2OffSetLD layer3OffSetLD 0.0))
	) 
      )
    )
    ) 

     ;;; Calculating the min offset needed to avoid spacing errors
     ; The offset for all contacts is the same because contacts are mirrored.
     (setq offsetSide (quotient maxOffSet 2.0))
     ; Offset must be on grid     
     (setq minSpaceOffSet (times (ceiling (plus 
                          (quotient offsetSide snapGrid) -1e-6)) snapGrid))

     (when ( and (listp idLayer) (equal (cadr idLayer) "hv") (greaterp  hvPYMconSpace 0.0))
         (setq minSpaceOffSet (plus minSpaceOffSet hvPYMconSpace))
     )	


     ;;; updating srcOffset and drnOffset
     ;;; normaly this should be a sum of both offsets (external, user defined 
     ;;; and internal, minSpace defines) but because of bck. compability 
     ;;; (to avoid ofset on ofset when user defined offset(s) exists)
     ;;; internal offset is enforced only when user's offset is zero.

     (if (and bckCompatibleOffSet (or (nequal srcOffset 0.0) 
				      (nequal drnOffset 0.0))) then
         (setq minSpaceOffSet 0.0)
     ) ; end internal offset

 ;; decide on the parameters to pass to the contacts based on our parameters
 ;; we do this once here rather than typing it 4 or 5 times.
 ;; since these only work if there are polarized implant contacts
 ;; we will check each time it's used to see if it's valid.
 
 ;; implant selection should pass down the hierarchy
 (if implant then
   (setq contactImpParam (list "implant" "boolean" t))
   else
   (setq contactImpParam (list "implant" "boolean" "FALSE"))
   )
 ;; well polarity is determined from class parameters. This is because
 ;; nTran and pTran are not allowed to toggle their well, so the presence
 ;; or absense is set at devLib compile time.
 (if wellLayer then
   (setq contactWellParam (list "inWell" "boolean" t))
  else
   (setq contactWellParam (list "inWell" "boolean" "FALSE"))
 )

 ;; implant choice
 (when diffImpChoices 
     (setq diffImpChoiceParam (list "diffImpChoice" "fixnum" diffMatch)))
 (when tapImpChoices 
     (setq tapImpChoiceParam  (list "tapImpChoice"  "fixnum" tapMatch)))

 ;;; initialize the lower left corner of all geometries. The y1Coord is not
 ;;; really required, but helps in consistency.
 (setq x1Coord 0.0)
 (setq y1Coord 0.0)
 ;;; The lastx1coord is used to calculate where to place the depLayer 
 ;;; It will store the edge of the last gate.
 (setq lastX1Coord (minus (times 2.0 (plus depXEnc depSpace))))

 ;;; initialize the y coordinates for the depletion layer.
 (when depLayer
     (setq y1DepCoord (difference y1Coord depYEnc))
     (setq y2DepCoord (plus y1Coord w depYEnc))
 )

 ;;; Poly implant layer initialization. Not complicated as diff implant
 ;;; but similar to depletion layer. Modelled after dep layer
 ;;; The lastPYix1coord is used to calculate where to place the implant
 ;;; It will store the edge of the last gate.
 (setq lastPYiX1Coord (minus (times 2.0 polyImpXEnc)))

 ;;; initialize the y coordinates for the depletion layer.
 (when polyImplant
     (setq y1PYiCoord (difference y1Coord polyImpYEnc gateExt))
     (setq y2PYiCoord (plus y1Coord w polyImpYEnc gateExt))
 )

(if (and idLayer (listp idLayer) (equal (cadr idLayer) "hv") (greaterp wellEncHvLayer 0.0)) then
    (setq wellEncDiffY (plus idEncY wellEncHvLayer))
    (setq wellEncTapY  (plus idEncY wellEncHvLayer))
    (setq wellEncDiffX (plus (max idEncXL idEncXR) wellEncHvLayer))
    (setq wellEncTapX (plus (max idEncXL idEncXR) wellEncHvLayer))
    
 else	
    (setq wellEncDiffY wellEncDiff)
    (setq wellEncTapY  wellEncTap)
    (setq wellEncDiffX wellEncDiff)    
    (setq wellEncTapX  wellEncTap)
) 

 ;;; get the dbids of the named contacts

 ;;; first the firstContact contact, see if the field is defined and get the id
 ;;; If cannot find the cell -- error. The cell should be in the same library
 ;;; as the current pcell is. Place an instance of the cell (mirrored around Y)
 (when (nequal firstContact "")
     (setq contactId (dbOpenCellView tcCellView~>lib firstContact 
				     "symbolic" nil "rn"))
     (unless contactId
	 (error (sprintf nil "Cannot find/open firstContact contact cell `%s'" 
			 firstContact))
     )
     (unless contactId~>isParamCell
	 (error (sprintf nil "Named cell is not a pcell `%s'" firstContact))
     )
     (if (equal cNet sNet) then
	 (setq offset (plus minSpaceOffSet srcOffset))
      else
	 (setq offset (plus minSpaceOffSet drnOffset))
     )

 
     (setq params contactId~>parameters)
     (setq instParams (list (list "w" "float" w)))
     (when params~>implant
       (setq instParams (xcons instParams contactImpParam))
       )
     (when params~>inWell
       (setq instParams (xcons instParams contactWellParam))
       )
     (when (and diffImpChoices params~>diffImpChoice)
       (setq instParams (xcons instParams diffImpChoiceParam))
       )
     (when (and tapImpChoices params~>tapImpChoice)
       (setq instParams (xcons instParams tapImpChoiceParam))
       )
     (when (and contactChoices params~>noDiffContact)
       (setq instParams (xcons instParams diffConParam))
       )
     
     (setq inst (dbCreateParamInst tcCellView contactId "c0"
				   (minus offset):0 "MY" 1 instParams )
     )
     (unless inst
	 (error (sprintf nil "Failed to create instance of `%s'" firstContact))
     )

     ;;; Create a rectangle to fill the space between the contact and the gate,
     ;;; when offset > zero.
     
     (when (greaterp offset 1e-6)
	 (dbCreateRect tcCellView diffLayer 
		       (list (difference x1Coord offset):y1Coord x1Coord:w)
	 )
	 ;; we depend on the contact to implant itself correctly, and only meet
	 ;; enclosure in the Y direction with this piece of implant
	 (when (and diffImplant implant)
	     (dbCreateRect tcCellView diffImplant 
			   (list (list (difference x1Coord offset)
				       (difference y1Coord diffImpEnc))
				 (list x1Coord
				       (plus w     diffImpEnc))
				 ))
	 )

	 ;; we depend on the contact to implant itself correctly, and only meet
	 ;; enclosure in the Y direction with this piece of implant
	 (when (and diffCoreImplant implant)
	     (dbCreateRect tcCellView diffCoreImplant 
			   (list (list (difference x1Coord offset)
				       (difference y1Coord diffCoreImpEnc))
				 (list x1Coord
				       (plus w     diffCoreImpEnc))
				 ))
	 )
	 
	 
	 
     )
     
     ;;; Create a rectangle from the top Layer of the contact, given the
     ;;; bounding box of the top Layer. Then make this rectangle a pin
     ;;; or the appropriate net.
     (setq master inst~>master)
     (unless (and master~>topLayer master~>topLayerPinBbox)
	 (error (sprintf nil 
	     "Missing topLayer and/or topLayerPinBbox cell properties in `%s'" 
	     firstContact))
     )
     
     (setq bBox (list (list (minus (plus offset 
                            (caar master~>topLayerPinBbox))) 
			    (cadar master~>topLayerPinBbox))
		      (list (minus (plus offset 
			    (caadr master~>topLayerPinBbox))) 
			    (cadadr master~>topLayerPinBbox)))
     )
     
     ;;; This pin cannot be accessed from the right side.
     (setq dbid (dbCreateRect tcCellView master~>topLayer bBox))
     (setq pinid (dbCreatePin cNet dbid))
     pinid~>accessDir = (list "top" "bottom" "left")

     ;;; Draw the appropriate label
     (when labelLayer
       (dbCreateLabel tcCellView labelLayer
		      (list (plus (caar bBox) (quotient (difference 
			    (caadr bBox) (caar bBox)) 2.0)) (plus (cadar bBox)
			    (quotient (difference (cadadr bBox) 
		            (cadar bBox)) 2.0))) netL 
			    "centerCenter" "R0" "roman" labelWidth)
     )
     
     ;;; Set the lower X and Y Coordinate for the well or id layers when 
     ;;; they are defined
     (when (or wellLayer idLayer hvLayer)
       (unless master~>diffLayerBbox
	 (error (sprintf nil "Cannot find diffLayerBbox property for `%s'" 
			 firstContact))
       )
       ;;; Since this contact is always mirrored, we look at the x2Coord to 
       ;;; find how much does diff Extend beyond the gate. However, the 
       ;;; farthest point from the gate could also be tap. We take the maximum
       ;;; overlap as calculated by well overlap + (diff/tap ext) beyond the 
       ;;; gate. The above is repeated for the y1 and y2 coordinates. With 
       ;;; the assumption, that these (y1,y2) parmaeters may reset again. 
       ;;; This will not occur for now, but it would be easier to extend the 
       ;;; present class to pass parameters for top and bottom tip-Taps, in 
       ;;; future.
       ;;;;;;;;;;
       (setq x1DiffCoord (caadr master~>diffLayerBbox))
       (setq x1TapCoord (if master~>tapLayerBbox 
			    (abs (caadr master~>tapLayerBbox)) 0.0))
       (setq y2DiffCoord (cadadr master~>diffLayerBbox))
       (setq y2TapCoord (if master~>tapLayerBbox 
			    (abs (cadadr master~>tapLayerBbox)) 0.0))
       (setq y1DiffCoord (cadar master~>diffLayerBbox))
       (setq y1TapCoord (if master~>tapLayerBbox 
			    (abs (cadar master~>tapLayerBbox)) 0.0))
       
       (when wellLayer
	
	 (setq x1WellCoord (minus (plus offset (max (plus wellEncDiffX x1DiffCoord) (plus wellEncTapX x1TapCoord)))))
	 (setq y1WellCoord (minus (max (plus wellEncDiffY y1DiffCoord) (plus wellEncTapY y1TapCoord))))
	 (setq y2WellCoord (max (plus wellEncDiffY y2DiffCoord) (plus wellEncTapY y2TapCoord)))
       ) 

       (when hvLayer 
	 (setq x1HVLayerCoord (minus (plus offset (max (plus hvEnclosure x1DiffCoord) (plus hvEnclosure x1TapCoord)))))
	 (setq y1HVLayerCoord (minus (max (plus hvEnclosure y1DiffCoord) (plus hvEnclosure y1TapCoord))))
	 (setq y2HVLayerCoord (max (plus hvEnclosure y2DiffCoord) (plus hvEnclosure y2TapCoord)))
       )

       ;;; Set the lower X and Y Coordinate for the idLayer
       (when idLayer
	 (if idEncDiff then
	   (setq x1IdCoord (minus (plus offset 
					(max   (plus idEncXL  x1DiffCoord) 
					       (plus idEncXL  x1TapCoord)))))
	   (setq y1IdCoord (minus (max  (plus  idEncY  y1DiffCoord)
				        (plus  idEncY  y1TapCoord))))
	   (setq y2IdCoord (max   (plus idEncY y2DiffCoord)
				  (plus idEncY y2TapCoord)))
	 else
	   (setq x1IdCoord (minus (plus offset idEncXL )))
	   (setq y1IdCoord (minus idEncY))
	   (setq y2IdCoord idEncY)
	 )
	 )
       )

     ;;; Close the opened cell View
     (dbClose contactId)
 ) ;; end when firstContact

 ;;; For the first and the last diffusions we should also define a 
 ;;; diffusion pin to allow parallel transistor placement.
 (setq dbid (dbCreateRect tcCellView diffLayer 
			  (list (difference x1Coord diffExt):y1Coord
				x1Coord:w)))
 (setq pinid (dbCreatePin cNet dbid))
 pinid~>accessDir = (list "top" "bottom" "left")
 
 (when (and diffImplant implant)
   ;; this shape only meets vertical enclosure to keep from overlapping the 
   ;; contact when there is no contact, we add the horizontal enclosure
   (dbCreateRect tcCellView diffImplant
		 (list
		  (list (difference x1Coord diffExt)
			(difference y1Coord diffImpEnc))
		  (list x1Coord
			(plus w       diffImpEnc)
			)
		  )
		 )
 )


 (when (and diffCoreImplant implant)
   ;; this shape only meets vertical enclosure to keep from overlapping the 
   ;; contact when there is no contact, we add the horizontal enclosure
   (dbCreateRect tcCellView diffCoreImplant
		 (list
		  (list (difference x1Coord diffExt)
			(difference y1Coord diffCoreImpEnc))
		  (list x1Coord
			(plus w       diffCoreImpEnc)
			)
		  )
		 )
 )

 ;;; Calculate the well coordinates and place label.
 (when (equal firstContact "")
     ;;; draw the appropriate label at the center of the difflayer
     (when labelLayer
	 (dbCreateLabel tcCellView labelLayer 
			(list (minus (plus x1Coord (quotient diffExt 2.0))) 
			      (plus y1Coord (quotient w 2.0))) netL 
			      "centerCenter" "R0" "roman" labelWidth)
     )

     ;;; When first Contact is not defined then the lower well coordinate is 
     ;;; given by diffusion extension.
     (when wellLayer
	 (setq x1WellCoord (minus (plus x1Coord diffExt wellEncDiffX)))
	 (setq y1WellCoord (minus (plus y1Coord wellEncDiffY)))
	 (setq y2WellCoord (plus y1Coord w wellEncDiffY))	
     )
     (when hvLayer 
	 (setq x1HVLayerCoord (minus (plus x1Coord diffExt hvEnclosure)))
	 (setq y1HVLayerCoord (minus (plus y1Coord hvEnclosure)))
	 (setq y2HVLayerCoord (plus y1Coord w hvEnclosure))
     )
     (when idLayer
       (if idEncDiff then
	 (setq x1IdCoord (minus (plus x1Coord diffExt idEncXL))) 
	 (setq y1IdCoord (minus (plus y1Coord idEncY)))
	 (setq y2IdCoord (plus y1Coord w idEncY))
	 else 
	 (setq x1IdCoord (minus idEncXL))
	 (setq y1IdCoord (minus idEncY))
	 (setq y2IdCoord (plus y1Coord w idEncY))
	)
     )
     
     
     ;;; when lastContact is not defined, we draw extra diffImplant to meet
     ;;; the horizontal enclosure of diff
     (when (and diffImplant implant noEndConImpEnc)
       (dbCreateRect tcCellView diffImplant
		     (list
		      (list (difference (difference x1Coord diffExt) 
			    diffImpEnc) (difference y1Coord diffImpEnc))
		      (list x1Coord
			    (plus w diffImpEnc))
		      )
		     )
     )
     
     (when (and diffCoreImplant implant noEndConImpEnc)
	 (dbCreateRect tcCellView diffCoreImplant
		       (list
			(list (difference (difference x1Coord diffExt) 
			      diffCoreImpEnc) (difference y1Coord 
			      diffCoreImpEnc))
		      (list   x1Coord
			      (plus w diffCoreImpEnc))
		       )
	 )
     )
     
     
     
 ) ;; end when not firstContact
 
 ;;; The following only need to be checked if m > 1 
 ;;; (if m == 0, we reset it to 1)
 (when (greaterp m 1)
   ;;; The shared source contact, if this field is empty -- error, get the id.
   ;;; If cannot find the cell -- error. The cell should be in the same library
   ;;; as the current pcell is.
     (when (equal sharedSource "")
       (error "Missing shared source contact name property")
     )
     (setq sharedSrcId (dbOpenCellView tcCellView~>lib sharedSource 
				       "symbolic" nil "rn"))
     (unless sharedSrcId
       (error (sprintf nil "Cannot find/open shared source contact cell `%s'" 
		       sharedSource))
     )
     (unless sharedSrcId~>isParamCell
       (error (sprintf nil "Named cell is not a pcell `%s'" sharedSource))
     )
     
     ;;; The shared drain contact, if this field is empty -- error, get the id.
     ;;; If cannot find the cell -- error. The cell should be in the same 
     ;;; library as the current pcell is.
     (when (equal sharedDrain "")
	 (error "Missing shared drain contact name property")
     )
     (setq sharedDrnId (dbOpenCellView tcCellView~>lib sharedDrain 
				       "symbolic" nil "rn"))
     (unless sharedDrnId
	 (error (sprintf nil "Cannot find/open shared drain contact cell `%s'" 
			 sharedDrain))
     )
     (unless sharedDrnId~>isParamCell
	 (error (sprintf nil "Named cell is not a pcell `%s'" sharedDrain))
     )
     
 )

 ;;; reset the current net and the label to be drawn.
 (setq cNet (if (equal cNet sNet) dNet sNet))
 (setq netL (if (equal netL "S") "D" "S"))

 ;;; now create the rest of the geometries etc.
 (for n 1 m
      ;;; Create the gate region
      (setq dbid (dbCreateRect tcCellView gateLayer 
			       (list x1Coord:(difference y1Coord gateExt)
				     (plus x1Coord l):(plus y1Coord w gateExt))
		 )
      )
      (dbAddFigToNet dbid gNet)
      
      ;;; Create the two pins (one on top and another on bottom).
      ;;; When "Automatic keepouts for MOS gates" is used with CCT, the 
      ;;; abstract creation breaks the pins. However, if we use diffusion 
      ;;; as a poly keepout and do not use the automatic keepouts for MOS 
      ;;; gates, then the gate pin may be used as a feed through.

      ;;; First Create the top pin
      (setq dbid (dbCreateRect tcCellView gateLayer 
			       (list x1Coord:(plus y1Coord w)
			       (plus x1Coord l):(plus y1Coord w gateExt)))
      )
      (setq pinid (dbCreatePin gNet dbid))
      pinid~>accessDir = (list "top")

      ;;; Then the bottom pin.
      (setq dbid (dbCreateRect tcCellView gateLayer
			       (list x1Coord:(difference y1Coord gateExt)
				     (plus x1Coord l):y1Coord))
      )
      (setq pinid (dbCreatePin gNet dbid))
      pinid~>accessDir = (list "bottom")
      
      ;;; Create the floating diffusion under the gate region
      (dbCreateRect tcCellView diffLayer (list x1Coord:y1Coord 
					 (plus x1Coord l):(plus y1Coord w))
      )
      
      ;;; Create the implant under this diffusion
      ;;; This implant meets enclosure in the vertical direction.
      ;;; when there is no contact on this end, we draw another
      ;;; shape to meet horizontal enclosure
      (when (and diffImplant implant)
	(dbCreateRect tcCellView diffImplant
		      (list
		       (list x1Coord
			     (difference y1Coord diffImpEnc))
		       (list (plus x1Coord l)
			     (plus (plus y1Coord w) diffImpEnc))
		       )
	)
      )


      (when (and diffCoreImplant implant)
	(dbCreateRect tcCellView diffCoreImplant
		      (list
		       (list x1Coord
			     (difference y1Coord diffCoreImpEnc))
		       (list (plus x1Coord l)
			     (plus (plus y1Coord w) diffCoreImpEnc))
		       )
	)
      )


      ;;; If the depletion layer is defined draw it on top of the gate region
      (when depLayer
	(cond 
	 ((lessp (difference x1Coord lastX1Coord (times 2.0 depXEnc)) depSpace)
	  (setq x1DepCoord (plus lastX1Coord depXEnc))
	  )
	 (t
	  (setq x1DepCoord (difference x1Coord depXEnc))
	  )
	 )
	(dbCreateRect tcCellView depLayer (list x1DepCoord:y1DepCoord
				          (plus x1Coord l depXEnc):y2DepCoord))
	)

      ;;; If the poly implant layer is defined draw it on top of the gate region
      (when (and polyImplant implant)
	  (setq x1PYiCoord (difference x1Coord polyImpXEnc))
	  (dbCreateRect tcCellView polyImplant (list x1PYiCoord:y1PYiCoord
						     (plus x1Coord l polyImpXEnc):y2PYiCoord))
      )

      ;;; increment the x1Coord to next gate edge
      (setq x1Coord (plus x1Coord l))
      
      ;;; Create the contact for the second terminal
      (when (nequal n m)
	  (if (equal cNet sNet) then
	      (setq contactId sharedSrcId)
              (setq offset (plus minSpaceOffSet srcOffset))
	   else
	      (setq contactId sharedDrnId)
              (setq offset (plus minSpaceOffSet drnOffset))
	  )
	  
	  (setq params contactId~>parameters)
	  (setq instParams (list (list "w" "float" w)))
	  (when params~>implant
	    (setq instParams (xcons instParams contactImpParam))
	    )
	  (when params~>inWell
	    (setq instParams (xcons instParams contactWellParam))
	    )
	  (when (and diffImpChoices params~>diffImpChoice)
	    (setq instParams (xcons instParams diffImpChoiceParam))
	    )
	  (when (and tapImpChoices params~>tapImpChoice)
	    (setq instParams (xcons instParams tapImpChoiceParam))
	    )
          (when (and contactChoices params~>noDiffContact)
	    (setq instParams (xcons instParams diffConParam))
	    )

	  (setq inst (dbCreateParamInst tcCellView contactId 
		     (sprintf nil "c%d" n)
		     (plus offset x1Coord):y1Coord "R0" 1 instParams)
	  )
	  (unless inst
	      (error (sprintf nil "Failed to create instance of `%s'" 
			      contactId~>cellName))
	  )
	  ;;; Create a rectangle from the specified topLayer and 
	  ;;; topLayerPinBbox of of the created instance. And put the 
	  ;;; proper pin on it
	  (setq master inst~>master)
	  (unless (and master~>topLayer master~>topLayerPinBbox)
	      (error (sprintf nil 
	      "Missing topLayer and/or topLayerPinBbox cell properties in `%s'"
	      contactId~>cellName))
	  )
	  (setq bBox (list (list (plus (caar master~>topLayerPinBbox) x1Coord 
		           offset) (cadar master~>topLayerPinBbox))
		     (list (plus (caadr master~>topLayerPinBbox) 
			   x1Coord offset) (cadadr master~>topLayerPinBbox)))
	  )
	  
	  ;;; Since this source/drain pin is inside, it can only be accessed 
	  ;;; from top or bottom.
	  (setq dbid (dbCreateRect tcCellView master~>topLayer bBox))
	  (setq pinid (dbCreatePin cNet dbid))
	  pinid~>accessDir = (list "top" "bottom")

	  ;;; Draw the label, if allowed (The label is drawn at the center of 
	  ;;; the top layer bbox)
	  (when labelLayer
	    (dbCreateLabel tcCellView labelLayer 
			   (list (plus (caar bBox) (quotient (difference 
	                   (caadr bBox) (caar bBox)) 2.0)) (plus (cadar bBox) 
			   (quotient (difference (cadadr bBox) (cadar bBox)) 
		           2.0))) 
			   netL "centerCenter" "R0" "roman" labelWidth)
	  )
	  ;;; Create a piece of diffusion to cover up the space between the 
	  ;;; gate and the contact, if offset > zero.
	  (when (greaterp offset 1e-6)
	      (dbCreateRect tcCellView diffLayer (list x1Coord:y1Coord
		            (plus offset x1Coord):(plus y1Coord w))
	      )
	      ;;; we count on the contact to correctly implant itself, and 
	      ;;; only implant to the contact-diff edge. we do meet vertical 
	      ;;; enclosure
	      (when (and diffImplant implant)
		(dbCreateRect tcCellView diffImplant
			      (list
			       (list x1Coord
				     (difference y1Coord diffImpEnc))
			       (list (plus offset x1Coord)
				     (plus (plus y1Coord w) diffImpEnc))
			       )
		)
	      )

	      (when (and diffCoreImplant implant)
		  (dbCreateRect tcCellView diffCoreImplant
				(list
			       (list x1Coord
				     (difference y1Coord diffCoreImpEnc))
			       (list (plus offset x1Coord)
				     (plus (plus y1Coord w) diffCoreImpEnc))
				)
		  )
	      )
	      

	  )


	  (unless master~>diffLayerBbox
	      (error (sprintf nil 
              "Missing diffLayerBbox cell properties in `%s'" 
	      contactId~>cellName))
	  )
	  ;;; increment x1Coord to next gate's first edge, after storing 
	  ;;; the last gate edge the offset parameter in the hand of the 
	  ;;; designers, should be used to satisfy any li1-li1, poly-poly 
	  ;;; spacing problems.
	  (setq lastX1Coord x1Coord)
	  (setq x1Coord (plus (times 2.0 offset)
			(plus x1Coord (difference (caadr master~>diffLayerBbox)
				      (caar master~>diffLayerBbox)))
			)
	  )
	  ;;; Create another piece of diffusion to cover up the space 
	  ;;; between the gate and the contact, if offset > zero.
	  (when (greaterp offset 1e-6)
	      (dbCreateRect tcCellView diffLayer 
			    (list (difference x1Coord offset):y1Coord
				  x1Coord:(plus y1Coord w))
	      )
	      ;; we count on the contact to correctly implant itself, and 
	      ;; only implant to the contact-diff edge. we do meet vertical 
	      ;; enclosure
	      (when (and diffImplant implant)
		(dbCreateRect tcCellView diffImplant 
			      (list
			       (list (difference x1Coord offset)
				     (difference y1Coord diffImpEnc))
			       (list x1Coord
				     (plus (plus y1Coord w) diffImpEnc))
			       )
		)
	      )

	      (when (and diffCoreImplant implant)
		  (dbCreateRect tcCellView diffCoreImplant 
				(list
			       (list (difference x1Coord offset)
				     (difference y1Coord diffCoreImpEnc))
			       (list x1Coord
				     (plus (plus y1Coord w) diffCoreImpEnc))
				)
		  )
	      )

	  )
	  ;;; Give the master of the contact just placed, recalculate the 
	  ;;; well overlaps in y direction. The maximum well overlaps 
	  ;;; should be used.
	  (setq y1DiffCoord (cadar master~>diffLayerBbox))
	  (setq y1TapCoord (if master~>tapLayerBbox (abs (cadar master~>tapLayerBbox)) 0.0))
	  (setq y2DiffCoord (cadadr master~>diffLayerBbox))
	  (setq y2TapCoord (if master~>tapLayerBbox (abs (cadadr master~>tapLayerBbox)) 0.0))

	  (when wellLayer
	      ;;; remember, (max (abs -1) (abs -2)) = (min -1 -2)
	      (setq y1WellCoord (min (minus (max (plus wellEncDiffY y1DiffCoord) (plus wellEncTapY y1TapCoord)))
				     y1WellCoord))
	      (setq y2WellCoord (max (plus wellEncDiffY y2DiffCoord) (plus wellEncTapY y2TapCoord) y2WellCoord))
	  )

	  (when hvLayer
	      (setq y1HVLayerCoord (min (minus (max (plus hvEnclosure y1DiffCoord) (plus hvEnclosure y1HVLayerCoord)))
				     y1HVLayerCoord))
	      (setq y2HVLayerCoord (max (plus hvEnclosure y2DiffCoord) (plus hvEnclosure y2TapCoord) y2HVLayerCoord))
	  )

	  (when idLayer
	    (if idEncDiff then
	      ;;; remember, (max (abs -1) (abs -2)) = (min -1 -2)
	      (setq y1IdCoord   (min (minus (max (plus idEncY y1DiffCoord) (plus idEncY y1TapCoord))) y1IdCoord))
	      (setq y2IdCoord	(max (plus idEncY y2DiffCoord) (plus idEncY y2TapCoord) y2IdCoord))
	    else
	      (setq y1IdCoord   (minus idEncY))
	      (setq y2IdCoord   idEncY )
	    )
	  )
      )
      (setq cNet (if (equal cNet sNet) dNet sNet))
      (setq netL (if (equal netL "S") "D" "S"))
 )
 
 (when (nequal m 1)
     ;;; Close the opened cell views of the shared src and drn contacts
     (dbClose sharedSrcId)
     (dbClose sharedDrnId)
 )


 ;;; reset the current net and the net labels once again.
 (setq cNet (if (equal cNet sNet) dNet sNet))
 (setq netL (if (equal netL "S") "D" "S"))

 ;;; Finally the lastContact contact, see if the field is defined and get the 
 ;;; id. If cannot find the cell -- error. The cell should be in the same 
 ;;; library as the current pcell is.

 (when (nequal lastContact "")
     (setq contactId (dbOpenCellView tcCellView~>lib lastContact 
				     "symbolic" nil "rn"))
     (unless contactId
	 (error (sprintf nil "Cannot find/open lastContact contact cell `%s'" 
			 lastContact))
     )
     (unless contactId~>isParamCell
	 (error (sprintf nil "Named cell is not a pcell `%s'" lastContact))
     )
     (if (equal cNet sNet) then
         (setq offset (plus minSpaceOffSet srcOffset))
      else
         (setq offset (plus minSpaceOffSet drnOffset))
     )


 
     (setq params contactId~>parameters)
     (setq instParams (list (list "w" "float" w)))
     (when params~>implant
       (setq instParams (xcons instParams contactImpParam))
       )
     (when params~>inWell
       (setq instParams (xcons instParams contactWellParam))
       )
     (when (and diffImpChoices params~>diffImpChoice)
       (setq instParams (xcons instParams diffImpChoiceParam))
       )
     (when (and tapImpChoices params~>tapImpChoice)
       (setq instParams (xcons instParams tapImpChoiceParam))
       )
     (when (and contactChoices params~>noDiffContact)
       (setq instParams (xcons instParams diffConParam))
       )
          
     (setq inst (dbCreateParamInst tcCellView contactId (sprintf nil "c%d" m)
		(plus offset x1Coord):y1Coord "R0" 1 instParams)
     )
     (unless inst
	 (error "Failed to create instance of first source contact")
     )

     ;;; Create a rectangle to fill the space between the contact and the gate,
     ;;; when offset > zero.
     
     (when (greaterp offset 1e-6)
	 (dbCreateRect tcCellView diffLayer (list  x1Coord:y1Coord
				  (plus offset x1Coord):(plus y1Coord w))
	 )
	 ;; we count on the contact to correctly implant itself, and only 
	 ;; draw horizontally to the edge of the contact. we do meet 
	 ;; vertical enclosure with this shape
	 (when (and diffImplant implant)
	   (dbCreateRect tcCellView diffImplant 
			 (list
			  (list x1Coord
				(difference y1Coord diffImpEnc))
			  (list (plus offset x1Coord)
				(plus (plus y1Coord w) diffImpEnc))
			  )
	   )
         )
	 (when (and diffCoreImplant implant)
	   (dbCreateRect tcCellView diffCoreImplant 
			 (list
			  (list x1Coord
				(difference y1Coord diffCoreImpEnc))
			  (list (plus offset x1Coord)
				(plus (plus y1Coord w) diffCoreImpEnc))
			  )
	   )
         )


  )

     ;;; Create a rectangle from the top Layer of the contact, given the
     ;;; bounding box of the top Layer. Then make this rectangle a pin
     ;;; or the appropriate net.
     (setq master inst~>master)
     (unless (and master~>topLayer master~>topLayerPinBbox)
	 (error (sprintf nil 
	  "Missing topLayer and/or topLayerPinBbox cell properties in `%s'" 
	  lastContact))
     )

     (setq bBox (list (list (plus (caar master~>topLayerPinBbox) x1Coord 
				  offset) (cadar master~>topLayerPinBbox))
		      (list (plus (caadr master~>topLayerPinBbox) x1Coord 
				  offset) (cadadr master~>topLayerPinBbox)))
     )
     
     ;;; This pin can be accessed from top, bottom, and right only.
     (setq dbid (dbCreateRect tcCellView master~>topLayer bBox))
     (setq pinid (dbCreatePin cNet dbid))
     pinid~>accessDir = (list "top" "bottom" "right")

     ;;; draw the label at the center of the top layer
     (when labelLayer
	 (dbCreateLabel tcCellView labelLayer 
			(list (plus (caar bBox) (quotient (difference 
		        (caadr bBox) (caar bBox)) 2.0)) (plus (cadar bBox) 
	                (quotient (difference (cadadr bBox) (cadar bBox)) 
		        2.0))) 
			netL "centerCenter" "R0" "roman" labelWidth)
     )

     (setq y1DiffCoord (cadar master~>diffLayerBbox))
     (setq y1TapCoord (if master~>tapLayerBbox (abs (cadar master~>tapLayerBbox)) 0.0))
     (setq y2DiffCoord (cadadr master~>diffLayerBbox))
     (setq y2TapCoord (if master~>tapLayerBbox (abs (cadadr master~>tapLayerBbox)) 0.0))
     (setq x2DiffCoord (caadr master~>diffLayerBbox))
     (setq x2TapCoord (if master~>tapLayerBbox (abs (caadr master~>tapLayerBbox)) 0.0))

     ;;; If wellLayer is defined, then calculate the upper coordinates 
     ;;; of the well layer
     (when wellLayer
	 (unless master~>diffLayerBbox (error (sprintf nil "Cannot find diffLayerBbox property for `%s'" lastContact)))
	 ;;; Given the master of the contact just placed, recalculate the 
	 ;;; well overlaps in y direction. The maximum well overlaps 
	 ;;; should be used.
	 ;;; remember, (max (abs -1) (abs -2)) = (min -1 -2)
	 (setq y1WellCoord (min (minus (max (plus wellEncDiffY y1DiffCoord) (plus wellEncTapY y1TapCoord))) y1WellCoord))
	 (setq y2WellCoord (max (plus wellEncDiffY y2DiffCoord) (plus wellEncTapY y2TapCoord) y2WellCoord))
	 ;;; Calculate the x2Coord of the well, from the x2Coordinates 
	 ;;; of the diffLayerBbox and tapLayerBbox.
	 (setq x2WellCoord (plus offset x1Coord (max (plus wellEncDiffX x2DiffCoord) (plus wellEncTapX x2TapCoord))))
     )
     (when hvLayer
         (unless master~>diffLayerBbox (error (sprintf nil "Cannot find diffLayerBbox property for `%s'" lastContact)))
         (setq y1HVLayerCoord (min (minus (max (plus hvEnclosure y1DiffCoord) (plus hvEnclosure y1TapCoord))) 
                                   y1HVLayerCoord))
         (setq y2HVLayerCoord (max (plus hvEnclosure y2DiffCoord) (plus hvEnclosure y2TapCoord) y2HVLayerCoord))
         (setq x2HVLayerCoord (plus offset x1Coord (max (plus hvEnclosure x2DiffCoord) (plus hvEnclosure x2TapCoord))))
     )
     ;;; If idLayer is defined, then calculate the upper coordinates 
     ;;; of the id layer
     (when idLayer
	 (unless master~>diffLayerBbox (error (sprintf nil "Cannot find diffLayerBbox property for `%s'" lastContact)))

	 ;;; Given the master of the contact just placed, recalculate the 
	 ;;; id overlaps in y direction. The maximum id overlaps should 
	 ;;; be used.
	 (if idEncDiff then
	   (setq y1IdCoord   (min    (minus (max (plus idEncY y1DiffCoord) (plus idEncY y1TapCoord))) y1IdCoord))
	   (setq y2IdCoord   (max    (plus idEncY y2DiffCoord) (plus idEncY y2TapCoord) y2IdCoord))
	   (setq x2IdCoord   (plus   offset x1Coord (max (plus idEncXR x2DiffCoord) (plus idEncXR x2TapCoord))))
	 else
	   (setq y1IdCoord (plus (minus idEncY) y1DiffCoord)) 
	   (setq y2IdCoord (max (plus  idEncY y2DiffCoord) y2TapCoord y2IdCoord))
	   ;;; Calculate the x2Coord of the id, from the x2Coordinates of 
	   ;;; the diffLayerBbox and tapLayerBbox.
	   (setq x2IdCoord   (plus  offset x1Coord idEncXR))
	   )
	 )
     ;;; Close the opened cell view of the lastContact
     (dbClose contactId)
     ) ;; end lastContact

 ;;; Create a diffusion pin to allow transistors to be placed in parallel.
 (setq dbid (dbCreateRect tcCellView diffLayer (list x1Coord:y1Coord
  		          (plus x1Coord diffExt):(plus y1Coord w)))
 )
 (setq pinid (dbCreatePin cNet dbid))
 pinid~>accessDir = (list "top" "bottom" "right")
 
 ;;; Create the implant under this diffusion
 ;;; This implant meets enclosure in the vertical direction.
 ;;; when there is no contact on this end, we draw another
 ;;; shape to meet horizontal enclosure
 (when (and diffImplant implant)
     (dbCreateRect tcCellView diffImplant
		   (list
		    (list x1Coord
			  (difference y1Coord diffImpEnc))
		    (list (plus x1Coord diffExt)
			  (plus (plus y1Coord w) diffImpEnc))
		   )
     )
 )
 
 (when (and diffCoreImplant implant)
     (dbCreateRect tcCellView diffCoreImplant
		   (list
		    (list x1Coord
			  (difference y1Coord diffCoreImpEnc))
		    (list (plus x1Coord diffExt)
			  (plus (plus y1Coord w) diffCoreImpEnc))
		   )
     )
 )
 
 

 ;; draw the label and calculate the well coordinates.
 (when (equal lastContact "")
     ;;; draw the label (at the center of the diff)
     (when labelLayer
	 (dbCreateLabel tcCellView labelLayer
			(list (plus x1Coord (quotient diffExt 2.0)) 
			      (plus y1Coord (quotient w 2.0)))
			netL "centerCenter" "R0" "roman" labelWidth)
     )
			
     ;;; When lastContact is not defined, the upper coordinates of the well 
     ;;; are given by the diffExt.
     (when wellLayer
	 (setq x2WellCoord (plus x1Coord diffExt wellEncDiffX))
	 (setq y2WellCoord (max (plus y1Coord w wellEncDiffY) y2WellCoord)
	 )
     )
     (when hvLayer
	 (setq x2HVLayerCoord (plus x1Coord diffExt hvEnclosure))
	 (setq y2HVLayerCoord (max (plus y1Coord w hvEnclosure) y2HVLayerCoord)
	 )
     )
     ;;; When lastContact is not defined, the upper coordinates of the idLayer
     ;;; are given by the diffExt.
     (when idLayer
       (if idEncDiff then
	 (setq x2IdCoord (plus x1Coord diffExt   idEncXR))
	 (setq y2IdCoord (max  (plus   y1Coord w idEncY) y2IdCoord))
       else
	 (setq x2IdCoord (plus x1Coord idEncXR))
	 (setq y2IdCoord (max  (plus   y1Coord w idEncY) y2IdCoord))
       )
     )
     
     ;;; when lastContact is not defined, we draw extra diffImplant to meet
     ;;; the horizontal enclosure of diff
     (when (and diffImplant implant noEndConImpEnc)
       (dbCreateRect tcCellView diffImplant
		     (list
		      (list (plus x1Coord diffExt)
			    (difference y1Coord diffImpEnc))
		      (list (plus (plus x1Coord diffExt) diffImpEnc)
			    (plus (plus y1Coord w) diffImpEnc))
		      )
		     )
     )
   
     (when (and diffCoreImplant implant noEndConImpEnc)
	 (dbCreateRect tcCellView diffCoreImplant
		       (list
			(list (plus x1Coord diffExt)
			      (difference y1Coord diffCoreImpEnc))
			(list (plus (plus x1Coord diffExt) diffCoreImpEnc)
			      (plus (plus y1Coord w) diffCoreImpEnc))
		       )
	 )
     )
   )

 ;;; While we are at it, we could as well draw the tap contacts to satisfy 
 ;;; the new latchup rules. A tap contact (provided by the user) to left/right
 ;;; or both
 ;;; 1. get the id of the contact
 ;;; 2. place an instance at the offset given by a class property
 ;;; 3. get the master
 ;;; 4. get the topLayerBbox and place a pin with body net
 ;;; 5. get the botLayerBbox and recalculate x1WellCoord and x2WellCoord as 
 ;;;    required
 ;;; 6. close the opened contact cell
 
 ;;; Draw the well Layer if defined, all the coordinates have already
 ;;; been defined
 
 (when  wellLayer
 wellLayer_Xorigin = x1WellCoord
  wellLayer_Yorigin = (plus y1WellCoord -wellEncYDiff)
  wellLayer_Xend = x2WellCoord
  wellLayer_Yend = (plus y2WellCoord  wellEncYDiff)

    	(when (wellLayer_Xend-wellLayer_Xorigin)< wellminWidth
		Diff_well_width = wellminWidth - (wellLayer_Xend-wellLayer_Xorigin)
		x2WellCoord = x2WellCoord + (Diff_well_width/2)
		x1WellCoord = x1WellCoord - (Diff_well_width/2)
	)
	(when (wellLayer_Yend-wellLayer_Yorigin)< wellminWidth
		Diff_well_width = wellminWidth - (wellLayer_Yend-wellLayer_Yorigin)
		y1WellCoord = y1WellCoord - (Diff_well_width/2)
		y2WellCoord = y2WellCoord + (Diff_well_width/2)
	)
 

     (dbCreateRect tcCellView wellLayer (list x1WellCoord:(plus y1WellCoord -wellEncYDiff)
                                             x2WellCoord:(plus y2WellCoord  wellEncYDiff)))
  )
 (when idLayer
     (dbCreateRect tcCellView idLayer (list (list x1IdCoord y1IdCoord) (list x2IdCoord y2IdCoord)))
  )
 (when hvLayer
     (when wellLayer 
         ;;; Well coordinates might be +/- so plain adding is not propper.
         ;;; To ensure proper adding without "if (x<0) then y=x-z else y=x+z" here is some math:
         ;;; Y = ( abs(x) + z ) * sign(x)
         ;;; sign(x) = x/abs(x)
         (setq signX1 (quotient x1WellCoord (abs x1WellCoord)))      
         (setq signX2 (quotient x2WellCoord (abs x2WellCoord)))      
         (setq signY1 (quotient y1WellCoord (abs y1WellCoord)))      
         (setq signY2 (quotient y2WellCoord (abs y2WellCoord)))      
         (setq x1HVLayerCoord (times (plus (abs x1WellCoord) hvEnclosure) signX1))
         (setq x2HVLayerCoord (times (plus (abs x2WellCoord) hvEnclosure) signX2))
         (setq y1HVLayerCoord (times (plus (abs y1WellCoord) hvEnclosure) signY1))
         (setq y2HVLayerCoord (times (plus (abs y2WellCoord) hvEnclosure) signY2))
     )
     (dbCreateRect tcCellView hvLayer (list (list x1HVLayerCoord y1HVLayerCoord)
                                            (list x2HVLayerCoord y2HVLayerCoord)))
 )


 
)

;;; Define the function of the class.

(tfcDefineDeviceClassProp
;;(viewName       devClassName      propName          propValue)
 (symbolic        mNormTranImpClass    function          "transistor")
)

;;; 
;;; $Id: nEsdTranImpClass.il,v 1.6 2008/04/01 20:51:16 kuc Exp $
;;; 
;;; nEsdTranImpClass.il
;;; 
;;; Copyright (c) 1997 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Feb 27, 1997
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This is an variant on the transistor for the device library.  It will
;;; provide ESD protection.  This should be used as the N ESD transistor for
;;; nwell technologies, and as the P ESD transistor for pwell technologies.
;;; 
;;; Revision History:
;;;   gtc 07/18/97  Growing the viaExtDiff when shrinkPercent is used
;;;   gtc 09/12/97  Breaking rings up into four shapes
;;;   gtc 11/19/97  Not scaling some parameters
;;;   gtc 06/12/98  checking layer3-layer3 spacing, aligning via1 & via2
;;;                 contacts, not putting contacts in corners of outer
;;;                 guard ring, not always putting the same number of
;;;                 via2 contacts on s/d as via1 contacts, instead, fitting
;;;                 as many via2 contacts as can fit in the via1 space
;;;   dgn 02/23/99  made drnViaYspaceRingViaTop and Bot formal params.
;;;   dgn 03/09/99  Centered contacts in the rings
;;;   dgn 03/12/99  Fixed some more things suggested by RDA
;;;   jbq 02/17/00  Changed the fundamental way that width was derived(no longer depends on flare)
;;;   jbq 02/22/00  Fixed error message 
;;;   xgs 08/22/00  Added via1Via2Space layer2Width layer3Width innerRingMetalWidth ESDnwEncVia1 and ESDnwGateSp
;;;   xgs 08/30/00  Added edgesAt45 class parameter
;;;   xgs 09/11/00  Corrections for edgesAt45 
;;;   xgs 10/25/00  Changed innerRingMetalWidth to final value
;;;   xgs 11/08/00  Added option for drawing tap at 45 degrees in inner and outer guard rings 
;;;   jfe 11/14/00  Modified sanity checks for diffusion width, rather than minL to minL width
;;;                  and to add correct number of vias (licons)
;;;   gtc 12/29/00  in the outer guard ring, made sure that the tap and layer3
;;;                 were even multiples of their snap grid in order to enable
;;;                 multiple pcells to share the outer guard ring.
;;;   gtc 12/29/00  above change only works if the contact itself is an even
;;;                 multiple of the snap grid.  Fixed to work whether the
;;;                 contact is either an even or odd multiple of the grid.
;;;   dxj 02/07/01  Changing orirLayer3Space from a class parameter to a user parameter
;;;   kmi 06/28/01  fullyStrap option for ram7* technologies now removes only metal over
;;;                 guard rings, i.e. metal over diff is always 'on'
;;;   kmi 07/25/01  moving (TECHgetProp "technology") to the Class parameters definition
;;;                 due the DRC evaluation error
;;;   cry 08/08/01  copied from nEsdTranClass.il, adding implant layers
;;;                 and other options making it impractical to keep in same class
;;;   lpn 02/08/02  Added an option to draw diffCoreImplant layer enclosing Diff layer
;;;                 Fixed bug in extraSrcSpace and extraDrnSpace formal parameter
;;;   ymx 02/21/03  Updates for hv nmos (TCS 544)
;;;   kuc 02/07/06  updates for semi-scalable models
;;;   kuc 03/25/08  guard ring updates
;;;

(tcCreateDeviceClass
 "symbolic" "nEsdTranImpClass"
 ;; Class parameters
 (
  (diffLayer            "y0")
  (gateLayer            "y1")
  (rgateLayer           "y2")
  (wellLayer            "y3")
  (tapLayer             "y4")
  (via1Layer            "y5")
  (layer2               "y6")
  (via2Layer            "y7")
  (layer3               "y8")
  (idLayer              "y9")
  (maxvLayer            nil)
  (hvDiffEnclosure      0.0) ;;;enclosure of diff by hv id layer.
  (diffImplant          nil)
  (diffImpEnc           0.0)
  (diffCoreImplant      nil)
  (diffCoreImpEnc       0.0)
  (tapWellImplant       nil)
  (tapWellImpEnc        0.0)
  (tapSubImplant        nil)
  (tapSubImpEnc         0.0)
  (srcViaGateSpace      0.0)
  (drnViaGateSpace      0.0)
  (viaExtDiffY          0.0)
  (minDiffTapRingSpace  0.0)
  (flareYamount_in      0.0)
  (flareYamount         0.0)
  (flareYextension      0.0)
  (via1Width            0.0)
  (via1Space            0.0)
  (tapEncVia1           0.0)
  (innerRingTapEncVia1  0.0)
  (outerRingTapEncVia1  0.0)
  (wellEncTap           0.0)
  (ESDnwEncVia1         0.0)
  (ESDnwGateSp          0.0)
  (innerRingTapWidth    0.0)
  (outerRingTapWidth    0.0)
  (wellTapSpace         0.0)
  (layer2EncVia1        0.0)
  (via2Width            0.0)
  (via2Space            0.0)
  (via1Via2Space        0.0)
  (layer2EncVia2        0.0)
  (layer2Width          0.0)
  (layer3EncVia2        0.0)
  (layer3Width          0.0)
  (innerRingMetalWidth  0.0)
  (irLayer3EncVia2      0.0)
  (orLayer3Width        0.0)
  (minW                 0.0)
  (maxW                 0.0)
  (minTotalW            0.0)
  (genericRingName      "ring")
  (rivetedRingName      "rivetRing")
  (flaredGateName       "flaredGate")
  (diffGrid             0.00)
  (tapGrid              0.00)
  (wellGrid             0.00)
  (polyGrid             0.00)
  (via1grid             0.00)
  (layer2grid           0.00)
  (via2grid             0.00)
  (layer3grid           0.00)
  (tapEdgesAt45         nil)
  (layer2EdgesAt45      nil)
  (layer3EdgesAt45      nil)
  (modelTextLayer       (list "hilite" "drawing"))
  (modelTextLayerSize   0.2)
  (modelText            "")
  (modelWmax            0.0)
  (modelWmin            0.0)
  (modelLmax            0.0)
  (modelLmin            0.0)
  (filledRings          nil) ;; guard rings filled with vias (SPR 44283)
 )
 ;; Formal parameters
 (
  (w                0.0)
  (l                0.0)
  (m                0)
  (extraLeftSpace   0.0)
  (extraRightSpace  0.0)
  (shrinkPercent    0.0)
  (extraSrcSpace    0.0)
  (extraDrnSpace    0.0)
  (fullyStrap	    "FALSE")
  (drnViaYspaceRingViaTop  0.0)
  (drnViaYspaceRingViaBot  0.0)
  (viaExtDiffX          0.0)
  (orirLayer3Space      0.0)
 )

 (if (w > modelWmax) then
   (error "%f is greater than allowable maximum width %f for model %L" w modelWmax modelText))
 (if (w < modelWmin) then
   (error "%f is less than allowable minimum width %f for model %L" w modelWmin modelText))
 (if (l > modelLmax) then
   (error "%f is greater than allowable length %f for model %L" l modelLmax modelText))
 (if (l < modelLmin) then
   (error "%f is less than allowable minimum length %f for model %L" l modelLmin modelText))

 ;; make the nets and the terminals that will be used in the cell
 (setq gNet (dbCreateNet tcCellView "g"))
 (dbCreateTerm gNet "g" "input")
 (setq sNet (dbCreateNet tcCellView "s"))
 (dbCreateTerm sNet "s" "inputOutput")
 (setq dNet (dbCreateNet tcCellView "d"))
 (dbCreateTerm dNet "d" "inputOutput")
 (setq irNet (dbCreateNet tcCellView "ir"))
 (dbCreateTerm irNet "ir" "inputOutput")
 (setq orNet (dbCreateNet tcCellView "or"))
 (dbCreateTerm orNet "or" "inputOutput")
 

 (when (flareYamount_in == 0.0)
    (setq flareYamount_in flareYamount)
 )

 ;; massage all parameters to their scaled counterparts
 (cond ((equal shrinkPercent 0.0)
	(setq scaleMult 1.0)
      ) 
     (t
      (setq scaleMult (quotient 100.0 (difference 100.0 shrinkPercent)))
      (setq via1PolyGrid (max via1grid polyGrid))

      ;;
      ;; foreach doesn't work as it ought to here.  Another Cadence feature
      ;;
      (foreach sizeAndGrid (list (list 'srcViaGateSpace via1PolyGrid)
				 (list 'drnViaGateSpace via1PolyGrid)
				 (list 'drnViaYspaceRingViaTop via1grid)
				 (list 'drnViaYspaceRingViaBot via1grid)
				 (list 'ESDnwEncVia1 tapGrid)
				 (list 'ESDnwGateSp tapGrid)
				 (list 'innerRingTapWidth tapGrid)
				 (list 'outerRingTapWidth tapGrid)
				 (list 'innerRingMetalWidth layer2grid)
				 (list 'via1Via2Space via1grid)
				 (list 'layer2Width layer2grid)
				 (list 'layer3Width layer3grid)
				 (list 'orLayer3Width layer3grid)
				 (list 'minW diffGrid)
				 (list 'maxW diffGrid)
				 (list 'minTotalW diffGrid)
				 (list 'viaExtDiffY diffGrid)
			   )

	  (setq theSize (car sizeAndGrid))
	  (setq theGrid (cadr sizeAndGrid))

	  (setq tempSize (quotient (times (eval theSize) scaleMult) theGrid))
	  (set theSize (times (fix (plus tempSize 0.999)) theGrid))
      )

     ) ;; end massaging the variables to account for the scale
 )

 ;; we want to be able to share the outer guard ring between to pcell
 ;; instances placed side by side.  In order to do this, we need to have
 ;; the contacts in the outer ring centered and on grid.  This might be a
 ;; bit confusing, but this means:
 ;;
 ;;   If the contact is an odd integer multiple of the snap grid, the width of
 ;;   the ring enclosing it must be an odd integer multiple of the snap grid.
 ;;   This will keep the enclosure the same to the inside and outside of the
 ;;   contact.
 ;;
 ;;   If the contact is an even integer multiple of the snap grid, the width
 ;;   of the ring enclosing it must be an even integer multiple of the snap
 ;;   grid.  This will keep the enclosure the same to the inside and outside
 ;;   of the contact.
 ;;
 (foreach kludge (list (list 'orLayer3Width layer3grid via2Width via2grid)
		       (list 'outerRingTapWidth tapGrid via1Width via1grid)
		 )
     (setq tmpOrLayerWidth (nth 0 kludge))
     (setq tmpOrLayerGrid (nth 1 kludge))
     (setq tmpViaWidth (nth 2 kludge))
     (setq tmpViaGrid (nth 3 kludge))

     (setq tempSize (quotient tmpViaWidth tmpViaGrid))
     (cond
	 ((oddp (fix (plus tempSize 0.999)))
	  ;; make sure that tmpOrLayerWidth is an odd multiple of the grid
	  (setq tempSize (quotient (eval tmpOrLayerWidth) tmpOrLayerGrid))
	  (when (evenp (fix (plus tempSize 0.999)))
	      (set tmpOrLayerWidth (plus (eval tmpOrLayerWidth) layer3grid))
	  )
	 )
	 (t
	  ;; make sure that tmpOrLayerWidth is an even multiple of the grid
	  (setq tempSize (quotient (eval tmpOrLayerWidth) tmpOrLayerGrid))
	  (when (oddp (fix (plus tempSize 0.999)))
	      (set tmpOrLayerWidth (plus (eval tmpOrLayerWidth) layer3grid))
	  )
	 )
     )
 )

 ;;
 ;; do sanity checks on the width
 ;; Sub sanity check on width:  It is an integral multiple of the via pitch
 ;;
 (setq via1Pitch (plus via1Width via1Space))

 ;; targetRows is a floating point number that represents the number of rows
 ;; of via1's that can fit within the width
 (setq targetRows (quotient (plus w (times -2.0 viaExtDiffY) via1Space) via1Pitch))

 ;; rowsOfContacts is an integer version of targetRows
 (setq rowsOfContacts (fix (plus 0.999 targetRows)))

 ;; targetRows and rowsOfContacts must be the same to satisfy the via pitch
 ;; requirement of the ESD transistor
 (when (greaterp (abs (difference rowsOfContacts targetRows)) 1e-4)
     (error "nEsdTranImpClass: w (%f) does not satisfy via pitch requirements.  Try either %f or %f\n" w
	    (plus (times rowsOfContacts via1Pitch) -via1Space (times 2.0 viaExtDiffY ))
	    (plus (times (difference rowsOfContacts 1) via1Pitch) -via1Space (times 2.0 viaExtDiffY ))
     )
 )

 ;;
 ;; Sub sanity check on width:  It is between the minimum and maximum width
 ;;
 (when (lessp (difference w 1e-6) minW)
     (error "nEsdTranImpClass:  w (%f) is less than minimum allowable width per leg (%f)\n" w minW)
 )

 (when (greaterp (difference w 1e-6) maxW )
     (error "nEsdTranImpClass:  w (%f) is greater than maximum allowable width per leg (%f)\n" w maxW)
 )

 (when (lessp (times w  m) minTotalW)
     (error "nEsdTranImpClass:  total w (%f) is less than the minimum total width (%f)\n"
	    (times w m) minTotalW)
 )

 ;; 
 ;; Sanity check on drnViaYspaceRingViaTop
 (when (lessp drnViaYspaceRingViaTop (plus srcViaGateSpace drnViaGateSpace l extraDrnSpace extraSrcSpace))
     (error "nEsdTranImpClass:  drnViaYspaceRingViaTop (%f) is less than minimum allowable (%f)\n"
	    drnViaYspaceRingViaTop (plus srcViaGateSpace drnViaGateSpace l extraDrnSpace extraSrcSpace))
 )

 ;; Sanity check on drnViaYspaceRingViaBot
 (when (lessp drnViaYspaceRingViaBot (plus srcViaGateSpace drnViaGateSpace l extraDrnSpace extraSrcSpace))
     (error "nEsdTranImpClass:  drnViaYspaceRingViaBot (%f) is less than minimum allowable (%f)\n"
	    drnViaYspaceRingViaBot (plus srcViaGateSpace drnViaGateSpace l extraDrnSpace extraSrcSpace))
 )

 ;;
 ;; do a sanity check on the number of legs
 ;;
 (unless (and (null (floatp m)) (numberp m))
     (error "nEsdTranImpClass:  m must be an even integer, not a float\n")
 )

 (when (oddp m)
     (error "nEsdTranImpClass:  m (number of legs) must be an even integer\n")
 )

 ;;
 ;; do a sanity check that the sub-pcells exist
 ;; 1.  verify that the flared gate pcell exists & is a pcell
 ;;
 (setq flaredGateId (dbOpenCellView tcCellView~>lib flaredGateName "symbolic" nil "rn"))
 (unless flaredGateId
     (error "nEsdTranImpClass:  Cannot find/open flared gate %s\n" flaredGateName)
 )
 (unless flaredGateId~>isParamCell
     (error "nEsdTranImpClass:  Flared gate %s is not a pcell\n" flaredGateName)
 )

 ;;
 ;; 2.  verify that the generic ring exists & is a pcell
 ;;
 (setq ringId (dbOpenCellView tcCellView~>lib genericRingName "symbolic" nil "rn"))
 (unless ringId
     (error "nEsdTranImpClass:  Cannot find/open ring %s\n" genericRingName)
 )
 (unless ringId~>isParamCell
     (error "nEsdTranImpClass:  Ring %s is not a pcell\n" genericRingName)
 )

 ;;
 ;; 3.  verify that the riveted ring exists & is a pcell
 ;;
 (setq rivetedRingId (dbOpenCellView tcCellView~>lib rivetedRingName "symbolic" nil "rn"))
 (unless rivetedRingId
     (error "nEsdTranImpClass:  Cannot find/open riveted ring %s\n" rivetedRingName)
 )
 (unless rivetedRingId~>isParamCell
     (error "nEsdTranImpClass:  Riveted ring %s is not a pcell\n" rivetedRingName)
 )

 ;;
 ;; create the diffusion.
 ;;
 (setq diffXorigin (plus -viaExtDiffX -via1Width -srcViaGateSpace -extraSrcSpace))
 (setq diffYorigin 0.0)

 ;; totalDrnLength is the gate to gate length of a drain region
 ;; totalSrcLength is the gate to gate length of a source region
 (setq totalDrnLength (plus (times 2.0 (plus drnViaGateSpace extraDrnSpace))
			    via1Width))
 (setq totalSrcLength (plus (times 2.0 (plus srcViaGateSpace extraSrcSpace))
			    via1Width))

 (setq diffXend (plus diffXorigin
		      (times -2.0 diffXorigin)
		      (times l m)
		      (times (xquotient m 2) totalDrnLength)
		      (times (difference (xquotient m 2) 1) totalSrcLength)
		)
 )
 ;;(setq diffYend (plus w (times 2 flareYamount)))
 (setq diffYend w)

 ;; define parameters for ESD nwell tap
 (when (and (greaterp ESDnwEncVia1 0.0) (greaterp ESDnwGateSp 0.0))
     ;; (setq ESDnwTWidth   (difference totalDrnLength (times 2.0 ESDnwGateSp)))
     (setq ESDnwTWidthDrn   (difference (plus (times 2.0 drnViaGateSpace) via1Width) (times 2.0 ESDnwGateSp)))
     (setq ESDnwTWidthSrc   (difference (plus (times 2.0 srcViaGateSpace) via1Width) (times 2.0 ESDnwGateSp)))
     (setq ESDnwTXorigin (plus -ESDnwGateSp -ESDnwTWidthSrc))
     (setq ESDnwTYorigin (difference viaExtDiffY ESDnwEncVia1))
     (setq ESDnwTYend    (plus viaExtDiffY (times rowsOfContacts via1Width) (times (difference rowsOfContacts 1) via1Space) ESDnwEncVia1))
 )

 ;; if ESDnwEncVia1 and ESDnwGateSp parameters are defined then source/drain diffusion has to be drawn with a hole and
 ;; also need to draw  ESD nwell tap in this hole region

 (if (and (greaterp ESDnwEncVia1 0.0) (greaterp ESDnwGateSp 0.0)) then 

     ;; draw the diffusion for the first source region & attach to source net
     (setq diffXloop (quotient l 2.0))

     (setq dbid (dbCreatePolygon tcCellView diffLayer
				 (list diffXorigin:diffYorigin
				       diffXorigin:diffYend
				       diffXloop:diffYend
				       diffXloop:ESDnwTYend
				       (plus ESDnwTXorigin -extraSrcSpace):ESDnwTYend
				       (plus ESDnwTXorigin -extraSrcSpace):diffYorigin)))
				   
     (dbAddFigToNet dbid sNet)  
     (setq dbid (dbCreatePolygon tcCellView diffLayer
				 (list (plus ESDnwTXorigin -extraSrcSpace):diffYorigin
				       diffXloop:diffYorigin
				       diffXloop:ESDnwTYend
				       (plus ESDnwTXorigin -extraSrcSpace ESDnwTWidthSrc):ESDnwTYend
				       (plus ESDnwTXorigin -extraSrcSpace ESDnwTWidthSrc):ESDnwTYorigin
				  (plus ESDnwTXorigin -extraSrcSpace):ESDnwTYorigin)))
     (dbAddFigToNet dbid sNet)  

      ;; draw ESD nwell tap region

     (setq dbid (dbCreateRect tcCellView tapLayer
			      (list (plus ESDnwTXorigin -extraSrcSpace):ESDnwTYorigin
				  (plus ESDnwTXorigin -extraSrcSpace ESDnwTWidthSrc):ESDnwTYend)))
     (dbAddFigToNet dbid sNet)
     
     (setq dbid (dbCreateRect tcCellView wellLayer
			      (list (plus ESDnwTXorigin -extraSrcSpace):ESDnwTYorigin
				    (plus ESDnwTXorigin -extraSrcSpace ESDnwTWidthSrc):ESDnwTYend)))
     
     (setq ESDnwTXorigin (plus ESDnwTXorigin ESDnwTWidthSrc (times 2.0 ESDnwGateSp) l extraDrnSpace))

     ;; loop through all the inside source/drain regions, draw the diffusion
     ;; and attach to correct net
     (for section 1 (xquotient m 2)
	  ;; draw the drain region
	  (setq drnDiffXend (plus diffXloop totalDrnLength l))

	  (setq dbid (dbCreatePolygon tcCellView diffLayer
				      (list diffXloop:diffYorigin
					    diffXloop:diffYend
					    drnDiffXend:diffYend
					    drnDiffXend:ESDnwTYend
					    ESDnwTXorigin:ESDnwTYend
					    ESDnwTXorigin:diffYorigin)))
	  
	  (dbAddFigToNet dbid dNet)  
	  (setq dbid (dbCreatePolygon tcCellView diffLayer
				      (list ESDnwTXorigin:diffYorigin
					    drnDiffXend:diffYorigin
					    drnDiffXend:ESDnwTYend
					    (plus ESDnwTXorigin ESDnwTWidthDrn):ESDnwTYend
					    (plus ESDnwTXorigin ESDnwTWidthDrn):ESDnwTYorigin
					    ESDnwTXorigin:ESDnwTYorigin)))
	  (dbAddFigToNet dbid dNet)    
      
	  ;; draw ESD nwell tap regions

	  (setq dbid (dbCreateRect tcCellView tapLayer
				   (list ESDnwTXorigin:ESDnwTYorigin
					 (plus ESDnwTXorigin ESDnwTWidthDrn):ESDnwTYend)))
	  (dbAddFigToNet dbid dNet)
	  
	  (setq dbid (dbCreateRect tcCellView wellLayer
				   (list ESDnwTXorigin:ESDnwTYorigin
					 (plus ESDnwTXorigin ESDnwTWidthDrn):ESDnwTYend)))
	  
	  (setq ESDnwTXorigin (plus ESDnwTXorigin ESDnwTWidthDrn (times 2.0 ESDnwGateSp) l extraSrcSpace extraDrnSpace))


	  (setq diffXloop drnDiffXend)

	  (unless (equal section (xquotient m 2))
	      (setq srcDiffXend (plus diffXloop totalSrcLength l))
	      
	      (setq dbid (dbCreatePolygon tcCellView diffLayer
					  (list diffXloop:diffYorigin
						diffXloop:diffYend
						srcDiffXend:diffYend
						srcDiffXend:ESDnwTYend
						ESDnwTXorigin:ESDnwTYend
						ESDnwTXorigin:diffYorigin)))
	      
	      (dbAddFigToNet dbid sNet)  
	      (setq dbid (dbCreatePolygon tcCellView diffLayer
					  (list ESDnwTXorigin:diffYorigin
						srcDiffXend:diffYorigin
						srcDiffXend:ESDnwTYend
						(plus ESDnwTXorigin ESDnwTWidthSrc):ESDnwTYend
						(plus ESDnwTXorigin ESDnwTWidthSrc):ESDnwTYorigin
						ESDnwTXorigin:ESDnwTYorigin)))
	      (dbAddFigToNet dbid sNet)  
	  
	  ;; draw ESD nwell tap regions

	      (setq dbid (dbCreateRect tcCellView tapLayer
				       (list ESDnwTXorigin:ESDnwTYorigin
					     (plus ESDnwTXorigin ESDnwTWidthSrc):ESDnwTYend)))
	      (dbAddFigToNet dbid sNet)
	      
	      (setq dbid (dbCreateRect tcCellView wellLayer
				       (list ESDnwTXorigin:ESDnwTYorigin
					     (plus ESDnwTXorigin ESDnwTWidthSrc):ESDnwTYend)))
	      
	      (setq ESDnwTXorigin (plus ESDnwTXorigin ESDnwTWidthSrc extraSrcSpace (times 2.0 ESDnwGateSp) l extraDrnSpace))
	  
	      (setq diffXloop srcDiffXend)
	  )
     )

 ;; draw the diffusion for the last source region & attach to source net

     (setq dbid (dbCreatePolygon tcCellView diffLayer
				 (list diffXloop:diffYorigin
				       diffXloop:diffYend
				       diffXend:diffYend
				       diffXend:ESDnwTYend
				       ESDnwTXorigin:ESDnwTYend
				       ESDnwTXorigin:diffYorigin)))
				   
     (dbAddFigToNet dbid sNet)  
     (setq dbid (dbCreatePolygon tcCellView diffLayer
				 (list ESDnwTXorigin:diffYorigin
				       diffXend:diffYorigin
				       diffXend:ESDnwTYend
				       (plus ESDnwTXorigin ESDnwTWidthSrc):ESDnwTYend
				       (plus ESDnwTXorigin ESDnwTWidthSrc):ESDnwTYorigin
				       ESDnwTXorigin:ESDnwTYorigin)))
     (dbAddFigToNet dbid sNet)  

      ;; draw ESD nwell tap regions

     (setq dbid (dbCreateRect tcCellView tapLayer
			      (list ESDnwTXorigin:ESDnwTYorigin
				    (plus ESDnwTXorigin ESDnwTWidthSrc):ESDnwTYend)))
     (dbAddFigToNet dbid sNet)

     (setq dbid (dbCreateRect tcCellView wellLayer
			      (list ESDnwTXorigin:ESDnwTYorigin
				    (plus ESDnwTXorigin ESDnwTWidthSrc):ESDnwTYend)))

     (setq ESDnwTXorigin (plus ESDnwTXorigin ESDnwTWidthSrc (times 2.0 ESDnwGateSp) l))
 
  else

     ;; draw the diffusion for the first source region & attach to source net
     (setq diffXloop (quotient l 2.0))
     (setq dbid (dbCreateRect tcCellView diffLayer (list diffXorigin:diffYorigin
							 diffXloop:diffYend)))
     (dbAddFigToNet dbid sNet)

     ;; loop through all the inside source/drain regions, draw the diffusion
     ;; and attach to correct net
     (for section 1 (xquotient m 2)
	  ;; draw the drain region
	  (setq drnDiffXend (plus diffXloop totalDrnLength l))
	  (setq dbid (dbCreateRect tcCellView diffLayer (list diffXloop:diffYorigin
							      drnDiffXend:diffYend)))
	  (dbAddFigToNet dbid dNet)
	  (setq diffXloop drnDiffXend)

	  (unless (equal section (xquotient m 2))
	      (setq srcDiffXend (plus diffXloop totalSrcLength l))
	      (setq dbid (dbCreateRect tcCellView diffLayer (list diffXloop:diffYorigin
								  srcDiffXend:diffYend)))
	      (dbAddFigToNet dbid sNet)
	      (setq diffXloop srcDiffXend)
	  )
     )

     ;; draw the diffusion for the last source region & attach to source net
     (setq dbid (dbCreateRect tcCellView diffLayer (list diffXloop:diffYorigin
							 diffXend:diffYend)))
     (dbAddFigToNet dbid sNet)
     
 )

 ;; draw the id layer (esd) around the diffusion
 (dbCreateRect tcCellView idLayer (list diffXorigin:diffYorigin diffXend:diffYend))
 
 ;; draw the diff implant
 (when diffImplant
     (dbCreateRect tcCellView diffImplant (list (list (difference diffXorigin diffImpEnc)
						      (difference diffYorigin diffImpEnc)
						)
						(list (plus       diffXend    diffImpEnc)
						      (plus       diffYend    diffImpEnc)
						  )
					  )
     )
 )
 
 ;; draw the diff Core implant
 (when diffCoreImplant
     (dbCreateRect tcCellView diffCoreImplant (list (list (difference diffXorigin diffCoreImpEnc)
						      (difference diffYorigin diffCoreImpEnc)
						)
						(list (plus       diffXend    diffCoreImpEnc)
						      (plus       diffYend    diffCoreImpEnc)
						  )
					  )
     )
 )
 

 (when maxvLayer
     ;;;The hvi layer must enclose the diff layer ,so we can draw the hvi layer here
     ;;;Create the lowerLeft and upperRight corners of the hvi rectangle.
     ;;;The ll corner is x:(diffXorigin - hvDiffEnclosure), y:(diffYorigin - hvDiffEnclosure)
     (setq hvllx (difference diffXorigin hvDiffEnclosure))
     (setq hvlly (difference diffYorigin hvDiffEnclosure))
     ;;;The ur corner is x:(diffXend + hvDiffEnclosure), y:(diffYend + hvDiffEnclosure)
     (setq hvurx (plus diffXend hvDiffEnclosure))
     (setq hvury (plus diffYend hvDiffEnclosure))
     (dbCreateRect tcCellView maxvLayer list(hvllx:hvlly hvurx:hvury))
 )

 ;;
 ;; create the flared gates
 ;;
 (setq gateXoffset 0.0)
 (for gateNum 1 m

      ;; instantiate the flared gate
      (setq inst (dbCreateParamInst tcCellView flaredGateId (sprintf nil "g%d" gateNum)
				    0.0:0.0 "R0" 1
				    (list (list "gateLayer" "list" nil)
					  (list "gateRecognitionLayer" "list" rgateLayer)
					  (list "w" "float" w)
					  (list "l" "float" l)
					  (list "flareAmount_in" "float" flareYamount_in)
					  (list "flareAmount" "float" flareYamount)
					  (list "flareExtension" "float" flareYextension)
					  (list "xOffset" "float" gateXoffset)
				    )
		 ))
      (unless inst
	  (error "nEsdTranImpClass:  Failed to create instance of flared gate %s" flaredGateName)
      )
      
      ;; add the gate to net, and create pins out of the flared regions
      (setq master inst~>master)
      (setq dbid (dbCreateRect tcCellView gateLayer master~>noflarePoints))
      (dbAddFigToNet dbid gNet)

      (setq modelTextX (plus gateXoffset (quotient (difference (caadr master~>noflarePoints) (caar master~>noflarePoints)) 2)))
      (setq modelTextY (quotient (difference (cadadr master~>noflarePoints) (cadar master~>noflarePoints)) 2))
      (dbCreateLabel tcCellView modelTextLayer (list modelTextX modelTextY) modelText "centerCenter" "R0" "stick" modelTextLayerSize)

      (setq dbid (dbCreatePolygon tcCellView gateLayer master~>topFlarePoints))
      (setq pinid (dbCreatePin gNet dbid))
      (pinid~>accessDir = (list "top"))

      (setq dbid (dbCreatePolygon tcCellView gateLayer master~>bottomFlarePoints))
      (setq pinid (dbCreatePin gNet dbid))
      (pinid~>accessDir = (list "bottom"))

      ;; add the correct x offset whether the next region is a source or drain
      (cond ((oddp gateNum)
	     (setq gateXoffset (plus gateXoffset l totalDrnLength))
	    )
	  (t
	   (setq gateXoffset (plus gateXoffset l totalSrcLength))
	  )
      )
 )

 ;;
 ;; create the contacts
 ;;
 (setq via1Xorigin (plus -srcViaGateSpace -extraSrcSpace -via1Width))
 (setq via1Yorigin viaExtDiffY)
 (setq via1Xdelta (plus via1Width extraSrcSpace srcViaGateSpace l drnViaGateSpace extraDrnSpace))
 (setq theNet sNet)

 ;; make sure that the L of layer2 can handle both a via1 and a via2
 ;; target variables set are:
 ;;   layer2DeltaVia1 = how far offset layer2 is from via1 in the X
 ;;   layer2L = the length of layer2 to enclose the vias
 ;; auxillary variables used are:
 ;;   layer2L = layer2 length enclosing via1
 ;;   layer2La = layer2 length enclosing via2
 ;;   delta, when layer2La > layer2L, is layer2La - layer2L
 ;;
 (cond ((greaterp (setq layer2L (plus layer2EncVia1 via1Width layer2EncVia1))
		  (setq layer2La (plus layer2EncVia2 via2Width layer2EncVia2)))
	(setq layer2DeltaVia1 layer2EncVia1)
       )
     (t
      (setq delta (quotient (difference layer2La layer2L) 2.0))
      (setq layer2DeltaVia1 (plus layer2EncVia1 (times (fix (plus 0.999 (quotient delta layer2grid))) layer2grid)))
      (setq layer2L layer2La)
     )
 )

 (setq via2Pitch (plus via2Width via2Space))

 ;; calculate how many via2 contacts we can fit
 ;; target variables set:
 ;;   layer2YDeltaVia1 = how far offset layer2 is from via1 in the Y
 ;;   layer2W - the width of layer2 to enclose the vias
 ;;   rowsOfContacts2 - the number of rows of via2 contacts
 ;; auxillary variables used are:
 ;;   layer2W = the width of layer2 to encloseing via1
 ;;   layer2Wa = the width of layer2 to enclosing via2
 ;;   delta, when layer2Wa > layer2W, is layer2Wa - layer2W
 ;;
 (setq layer2W (plus (times 2.0 layer2EncVia1) (times rowsOfContacts via1Pitch) -via1Space))
 (setq layer2Wa (difference (times 2.0 layer2EncVia2) via2Space))
 (setq rowsOfContacts2 0)
 (while (lessp (difference layer2Wa 1e-5) layer2W)
     (setq layer2Wa (plus layer2Wa via2Pitch))
     (setq rowsOfContacts2 (plus rowsOfContacts2 1))
 )
 (setq layer2Wa (difference layer2Wa via2Pitch))
 (setq rowsOfContacts2 (difference rowsOfContacts2 1))
 (setq layer2YDeltaVia1 layer2EncVia1)

 ;; loop through all of the source and drain regions while drawing
 ;; 1.  via1s
 ;; 2.  layer2
 ;; 3.  via2s
 ;; 4.  layer3
 ;;
 (for column 0 m

      ;; set "theNet" to the proper source or drain net for this region
      (cond ((evenp column)
	     (setq theNet sNet)
	    )
	  (t
	   (setq theNet dNet)
	  )
      )

      ;;
      ;; 1.  Draw the via1s
      ;;
      (setq via1Xend (plus via1Xorigin via1Width))
      (setq via1Yloop via1Yorigin)
      (for row 1 rowsOfContacts
	   (setq dbid (dbCreateRect tcCellView via1Layer
				    (list via1Xorigin:via1Yloop
					  via1Xend:(plus via1Yloop via1Width))))
	   (dbAddFigToNet dbid theNet)
	   (setq via1Yloop (plus via1Yloop via1Pitch))
      )

      ;;
      ;; 2.  Draw layer2
      ;;

      ;; draw layer2 with a width of layer2Width if this parameter is > 0.0
      (if (greaterp layer2Width 0.0) then
	  (setq layer2Xorigin (min (plus (difference via1Xorigin (times 0.5 layer2Width)) (times 0.5 via1Width)) (plus via1Xorigin -via1Via2Space -via2Width -layer2EncVia2)))
	  ;; make sure layer2Xorigin is on grid
	  (setq layer2Xorigin (times (round (plus (quotient layer2Xorigin layer2grid) 0.001)) layer2grid))
       else
	  (setq layer2Xorigin (difference via1Xorigin layer2DeltaVia1))
      )
      (setq layer2Yorigin (difference via1Yorigin layer2YDeltaVia1))
      (setq layer2Yend (plus layer2Yorigin layer2W))

      (if (greaterp layer2Width 0.0) then
	(if layer2EdgesAt45 then
	  ;; set parameter to control the length of bevel at 45 degrees 
	  (setq l2bvlCntrl (quotient layer2Width 3.0))
	  ;; snap l2bvlCntrl to grid
	  (setq l2bvlCntrl (times (round (plus (quotient l2bvlCntrl layer2grid) 0.001)) layer2grid))
	  
	  (setq dbid (dbCreatePolygon tcCellView layer2
				      (list (list (plus layer2Xorigin l2bvlCntrl)
						  (plus layer2Yorigin -l2bvlCntrl)
						  )
					    (list layer2Xorigin layer2Yorigin)
					    (list layer2Xorigin layer2Yend)
					    (list (plus layer2Xorigin l2bvlCntrl) (plus layer2Yend l2bvlCntrl))
					    (list (plus layer2Xorigin 
							(max layer2Width 
							     (plus (times 2.0 via2Width) 
								   (times 2.0 via1Via2Space)
								   via1Width 
								   (times 2.0 layer2EncVia2)
								   )
							     )
							-l2bvlCntrl
							)
						  (plus layer2Yend l2bvlCntrl)
						  )
					    (list (plus layer2Xorigin 
							(max layer2Width 
							     (plus (times 2.0 via2Width)
								   (times 2.0 via1Via2Space)
								   via1Width
								   (times 2.0 layer2EncVia2)
								   )
							     )
							)
						  layer2Yend
						  )
					    (list (plus layer2Xorigin 
							(max layer2Width 
							     (plus (times 2.0 via2Width)
								   (times 2.0 via1Via2Space)
								   via1Width
								   (times 2.0 layer2EncVia2)
								   )
							     )
							)
						  layer2Yorigin
						  )
					    (list (plus layer2Xorigin 
							(max layer2Width
							     (plus (times 2.0 via2Width)
								   (times 2.0 via1Via2Space)
								   via1Width
								   (times 2.0 layer2EncVia2)
								   )
							     )
							-l2bvlCntrl)
						  (plus layer2Yorigin -l2bvlCntrl)
						  )
					    )
				      )
		)
	  (dbAddFigToNet dbid theNet)
	 else
	  ;; don't bevel layer2 edges
	  (setq dbid (dbCreateRect tcCellView layer2
				  (list (list layer2Xorigin
					      layer2Yorigin
					      )
					(list (plus layer2Xorigin 
						    (max layer2Width 
							 (plus (times 2.0 via2Width)
							       (times 2.0 via1Via2Space)
							       via1Width
							       (times 2.0 layer2EncVia2)
							       )
							 )
						    )
					      layer2Yend
					      )
					)
				  ))
	  (dbAddFigToNet dbid theNet)
	  ) ;; end if layer2EdgesAt45
       else
	  (setq dbid (dbCreateRect tcCellView layer2
				   (list layer2Xorigin:layer2Yorigin
					 (plus layer2Xorigin layer2L):layer2Yend)))
	  (dbAddFigToNet dbid theNet)
      ) ;; end if layer2Width > 0

      ;;
      ;; 3.  Draw the via2s
      ;;
      
      ;; draw 2 columns of via2s on either side of via1s if parameter via1Via2Space > 0.0
      (if (greaterp via1Via2Space 0.0) then
	(setq via2Xorigin (plus via1Xorigin via1Width via1Via2Space))	
	else
	(setq via2Xorigin (plus layer2Xorigin layer2EncVia2))
	)
      (setq via2Xend (plus via2Xorigin via2Width))
      (setq via2Yorigin (plus layer2Yorigin layer2EncVia2))
      (setq via2Yloop via2Yorigin)
      
      (for row 1 rowsOfContacts2
	   (setq dbid (dbCreateRect tcCellView via2Layer
				    (list via2Xorigin:via2Yloop
					  via2Xend:(plus via2Yloop via2Width))))
	   (dbAddFigToNet dbid theNet)
	   
	   ;; draw additional column only when via1Via2Space > 0.0
	   (when (greaterp via1Via2Space 0.0) 
	     (setq dbid (dbCreateRect tcCellView via2Layer
				      (list (plus via1Xorigin -via1Via2Space -via2Width):via2Yloop
					    (plus via1Xorigin -via1Via2Space):(plus via2Yloop via2Width))))
	     (dbAddFigToNet dbid theNet)
	     )
	   
	   (setq via2Yloop (plus via2Yloop via2Pitch))
	   )
      
      ;;
      ;; 4.  Draw layer3
      ;;
      
      ;; draw layer3 with a width of layer3Width if this parameter is > 0.0
      (if (greaterp layer3Width 0.0) then
	(setq layer3Xorigin (plus (difference via1Xorigin (times 0.5 layer3Width)) (times 0.5 via1Width)))
	;; make sure layer3Xorigin is on grid
	(setq layer3Xorigin (times (round (plus (quotient layer3Xorigin layer3grid) 0.001)) layer3grid))
	
	(if layer3EdgesAt45 then
	  ;; set parameter to control the length of bevel at 45 degrees 
	  (setq l3bvlCntrl (quotient layer3Width 3.0))
	  ;; snap l3bvlCntrl to grid
	  (setq l3bvlCntrl (times (round (plus (quotient l3bvlCntrl layer2grid) 0.001)) layer2grid))
	  
	  (setq dbid (dbCreatePolygon tcCellView layer3
				      (list (list (plus layer3Xorigin l3bvlCntrl)
						  (plus via2Yorigin -layer3EncVia2 -l3bvlCntrl)
						  )
					    (list layer3Xorigin (plus via2Yorigin -layer3EncVia2))
					    (list layer3Xorigin (plus via2Yloop -via2Space layer3EncVia2))
					    (list (plus layer3Xorigin l3bvlCntrl)
						  (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrl)
						  )
					    (list (plus layer3Xorigin layer3Width -l3bvlCntrl)
						  (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrl)
						  )
					    (list (plus layer3Xorigin layer3Width)
						  (plus via2Yloop -via2Space layer3EncVia2)
						  )
					    (list (plus layer3Xorigin layer3Width)
						  (plus via2Yorigin -layer3EncVia2)
						  )
					    (list (plus layer3Xorigin layer3Width -l3bvlCntrl)
						  (plus via2Yorigin -layer3EncVia2 -l3bvlCntrl)
						  )
					    )
				      )
		)
	  else
	  ;; don't bevel layer3 edges
	  (setq dbid (dbCreateRect tcCellView layer3
				  (list (list layer3Xorigin
					      (plus via2Yorigin -layer3EncVia2)
					      )
					(list (plus layer3Xorigin layer3Width)
					      (plus via2Yloop -via2Space layer3EncVia2)
					      )
					)
				  )
		)
	  (dbAddFigToNet dbid theNet)
	  );; end if layer3EdgesAt45
	else
	(setq dbid (dbCreateRect tcCellView layer3
				 (list (difference via2Xorigin layer3EncVia2):(difference via2Yorigin layer3EncVia2)
				       (plus via2Xend layer3EncVia2):(plus via2Yloop -via2Space layer3EncVia2))))
	)
      
      
      (setq pinid (dbCreatePin theNet dbid))

      ;; set pin access dir depending on if this is the first, last
      ;; or middle source/drain area
      (cond ((equal column 0)
	     pinid~>accessDir = (list "top" "bottom" "left")
	    )
	  ((equal column m)
	   pinid~>accessDir = (list "top" "bottom" "right")
	  )
	  (t
	   pinid~>accessDir = (list "top" "bottom")
	  )
      )

      (setq via1Xorigin (plus via1Xorigin via1Xdelta))
 ) ; end drawing the source/drain contacts

 ;;
 ;; create the inner guard ring in 6 steps:
 ;; 1.  create the inner ring of tap
 ;;   1a. create the inner ring tap implant if required
 ;; 2.  create the inner riveted ring of via1's
 ;; 3.  create the inner ring of layer2
 ;; *4.  create the inner riveted ring of via2's
 ;; *5.  create the inner ring of layer3
 ;; 6.  create a terminal out of the topmost layer
 ;; (* = if necessary)
 ;;

 ;;
 ;; 1.  create the tap in the inner guard ring
 ;; target variables set:
 ;;   tapWidthInIR = the ring width of tap in the inner guard ring
 ;;   irViaOffset = offset needed to center contacts in tap
 ;;   irTapXorigin = the X origin (LL corner) of the inner tap guard ring
 ;;   irTapYorigin = the Y origin (LL corner) of the inner tap guard ring
 ;;   irTapL = the total length of the inner tap guard ring
 ;;   irTapW = the total width of the inner tap guard ring
 (setq tapWidthInIR (max innerRingTapWidth (plus via1Width (times 2.0 innerRingTapEncVia1))))
 (setq irViaOffset (times (fix (plus (quotient (difference (quotient tapWidthInIR 2.0) (quotient via1Width 2.0)) via1grid) 0.999)) via1grid))
 (setq irTapXorigin (difference diffXorigin minDiffTapRingSpace extraLeftSpace tapWidthInIR))
 (setq irTapYorigin (difference via1Yorigin drnViaYspaceRingViaBot via1Width (max irViaOffset innerRingTapEncVia1)))

 (setq irTapL (difference (plus diffXend minDiffTapRingSpace extraRightSpace tapWidthInIR) irTapXorigin))
 (setq irTapW  (difference (plus via1Yloop -via1Space drnViaYspaceRingViaTop via1Width (max irViaOffset innerRingTapEncVia1)) irTapYorigin))

 ;; draw tap corners at 45 degrees if tapEdgesAt45 is set
 (if tapEdgesAt45 then
     (setq bevelLength (times 0.6 tapWidthInIR))
     ;; snap this to grid
     (setq bevelLength (times (round (plus (quotient bevelLength tapGrid) 0.001)) tapGrid))

     (setq lowerLeftBL  bevelLength)
     (setq upperLeftBL  bevelLength)
     (setq lowerRightBL bevelLength)
     (setq upperRightBL bevelLength)
  else
     (setq lowerLeftBL  0.0)
     (setq upperLeftBL  0.0)
     (setq lowerRightBL 0.0)
     (setq upperRightBL 0.0)
 )
     
 (setq dbid (dbCreateParamInst tcCellView ringId "itr" 0.0:0.0 "R0" 1
			       (list (list "w" "float" irTapW)
				     (list "l" "float" irTapL)
				     (list "xOffset" "float" irTapXorigin)
				     (list "yOffset" "float" irTapYorigin)
				     (list "ringLayer" "list" tapLayer)
				     (list "ringWidth" "float" tapWidthInIR)
				     (list "additionalWidthInBevel" "float" 0.0)
				     (list "llBevelLength" "float" lowerLeftBL)
				     (list "ulBevelLength" "float" upperLeftBL)
				     (list "lrBevelLength" "float" lowerRightBL)
				     (list "urBevelLength" "float" upperRightBL)
				     (list "bevelTheOutside" "boolean" t)
				     (list "grid" "float" tapGrid)
				     (list "breakupPolygons" "boolean" "TRUE")
			       )))
 (setq theMaster dbid~>master)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints1))
 (dbAddFigToNet dbid irNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints2))
 (dbAddFigToNet dbid irNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints3))
 (dbAddFigToNet dbid irNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints4))
 (dbAddFigToNet dbid irNet)
 (when tapSubImplant
   (setq itriXorigin   (difference irTapXorigin tapSubImpEnc))
   (setq itriYorigin   (difference irTapYorigin tapSubImpEnc))
   (setq itriRingWidth (plus tapWidthInIR tapSubImpEnc tapSubImpEnc))
   (setq itriW         (plus irTapW tapSubImpEnc tapSubImpEnc))
   (setq itriL         (plus irTapL tapSubImpEnc tapSubImpEnc))
   (dbCreateParamInst tcCellView ringId "itri" 0.0:0.0 "R0" 1
		      (list (list "w" "float" itriW)
			    (list "l" "float" itriL)
			    (list "xOffset"   "float"     itriXorigin)
			    (list "yOffset"   "float"     itriYorigin)
			    (list "ringLayer" "list"      tapSubImplant)
			    (list "ringWidth" "float"     itriRingWidth)
			    (list "additionalWidthInBevel" "float" 0.0)
			    (list "llBevelLength" "float" 0.0)
			    (list "ulBevelLength" "float" 0.0)
			    (list "lrBevelLength" "float" 0.0)
			    (list "urBevelLength" "float" 0.0)
			    (list "bevelTheOutside" "boolean" nil)
			    (list "grid" "float" tapGrid)
			    (list "breakupPolygons" "boolean" "TRUE")
			    ))
 )
 ;;
 ;; 2.  create the inner riveted ring of via1's
 ;;
 (setq xCoord   (plus irTapXorigin (max irViaOffset innerRingTapEncVia1)))
 (setq yCoord   (plus irTapYorigin (max irViaOffset innerRingTapEncVia1)))

 (if layer2EdgesAt45 then
     (setq lowerLeftBL  (times 3.0 via1Space))
     (setq upperLeftBL  (times 3.0 via1Space))
     (setq lowerRightBL (times 3.0 via1Space))
     (setq upperRightBL (times 3.0 via1Space))
  else
     (setq lowerLeftBL  0.0)
     (setq upperLeftBL  0.0)
     (setq lowerRightBL 0.0)
     (setq upperRightBL 0.0)
 )     

 (when filledRings 
   (setq via1WidthInIR (difference tapWidthInIR innerRingTapEncVia1))
   (setq via1Xorigin (plus irTapXorigin innerRingTapEncVia1))
   (setq via1Yorigin (plus irTapYorigin innerRingTapEncVia1))
   )
 (dbCreateParamInst tcCellView rivetedRingId "iv1r" 0.0:0.0 "R0" 1
		    (list (list "w" "float" ,(if filledRings
						 (difference irTapW (times 2.0 innerRingTapEncVia1))
					       (difference irTapW (times 2.0 (max irViaOffset innerRingTapEncVia1)))))
			  (list "l" "float" ,(if filledRings
						 (difference irTapL (times 2.0 innerRingTapEncVia1))
					       (difference irTapL (times 2.0 (max irViaOffset innerRingTapEncVia1)))))
			  (list "xOffset" "float" ,(if filledRings via1Xorigin xCoord))
			  (list "yOffset" "float" ,(if filledRings via1Yorigin yCoord))
			  (list "rivetLayer" "list" via1Layer)
			  (list "ringWidth" "float" ,(if filledRings via1WidthInIR via1Width))
			  (list "rivetWidth" "float" via1Width)
			  (list "rivetSpace" "float" via1Space)
			  (list "llBevelLength" "float" lowerLeftBL)
			  (list "ulBevelLength" "float" upperLeftBL)
			  (list "lrBevelLength" "float" lowerRightBL)
			  (list "urBevelLength" "float" upperRightBL)
			  (list "autoIncreaseBevelWidth" "boolean" "FALSE")
			  (list "grid" "float" via1grid)))


 ;;
 ;; 3.  create the inner ring of layer2
 ;; target variables set:
 ;;   irL2w = the total width of the inner layer2 guard ring
 ;;   irL2l = the total length of the inner layer2 guard ring
 ;;   irL2xDelta = the x offset of the inner guard ring's layer2 x origin
 ;;   irL2yDelta = the y offset of the inner guard ring's layer2 y origin
 ;;   irL2ringW = the width of the layer2 in the inner guard ring
 ;;

 (if (greaterp innerRingMetalWidth 0.0) then
     (setq irL2w irTapW)
     (setq irL2l irTapL)
     (setq irL2xDelta irTapXorigin)
     (setq irL2yDelta irTapYorigin)
     (setq irL2ringW (max (plus (times 2.0 layer2EncVia1) via1Width)
			  (plus (times 2.0 layer2EncVia2) via2Width)
			  innerRingMetalWidth))
  else
     (setq irL2w (plus irTapW (times -2.0 (max irViaOffset innerRingTapEncVia1)) (times 2.0 layer2EncVia1)))
     (setq irL2l (plus irTapL (times -2.0 (max irViaOffset innerRingTapEncVia1)) (times 2.0 layer2EncVia1)))
     (setq irL2xDelta (plus xCoord -layer2EncVia1))
     (setq irL2yDelta (plus yCoord -layer2EncVia1))
     (setq irL2ringW (max (plus (times 2.0 layer2EncVia1) via1Width)
			  (plus (times 2.0 layer2EncVia2) via2Width)))
 )
 (if layer2EdgesAt45 then
     (setq lowerLeftBL  irL2ringW)
     (setq upperLeftBL  irL2ringW)
     (setq lowerRightBL irL2ringW)
     (setq upperRightBL irL2ringW)
  else
     (setq lowerLeftBL  0.0)
     (setq upperLeftBL  0.0)
     (setq lowerRightBL 0.0)
     (setq upperRightBL 0.0)
 ) 
 (setq dbid (dbCreateParamInst tcCellView ringId "il2r" 0.0:0.0 "R0" 1
			       (list (list "w" "float" ,(if filledRings irTapW irL2w))
				     (list "l" "float" ,(if filledRings irTapL irL2l))
				     (list "xOffset" "float" ,(if filledRings irTapXorigin irL2xDelta))
				     (list "yOffset" "float" ,(if filledRings irTapYorigin irL2yDelta))
				     (list "ringLayer" "list" nil)
				     (list "ringWidth" "float" ,(if filledRings tapWidthInIR irL2ringW))
				     (list "additionalWidthInBevel" "float" 0.0)
				     (list "llBevelLength" "float" lowerLeftBL)
				     (list "ulBevelLength" "float" upperLeftBL)
				     (list "lrBevelLength" "float" lowerRightBL)
				     (list "urBevelLength" "float" upperRightBL)
				     (list "bevelTheOutside" "boolean" t)
				     (list "grid" "float" layer2grid)
				     (list "breakupPolygons" "boolean" "TRUE")
			       )))


 (setq theMaster dbid~>master)
 (setq dbid1 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints1))
 (setq dbid2 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints2))
 (setq dbid3 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints3))
 (setq dbid4 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints4))
 (dbAddFigToNet dbid1 irNet)
 (dbAddFigToNet dbid2 irNet)
 (dbAddFigToNet dbid3 irNet)
 (dbAddFigToNet dbid4 irNet)

 ;; if we must go to layer3, create the via2's and then create layer3
 (when  (and layer3 fullyStrap (nequal fullyStrap "FALSE"))  

     ;;
     ;; 4.  create the inner riveted ring of via2's
     ;;

     (when filledRings
       (setq via2Enc (max layer2EncVia2 layer3EncVia2))
       (setq via2WidthIR (difference innerRingMetalWidth (times 2.0 via2Enc)))
       (setq via2BL (plus via2WidthIR via2Space))
       )

     ;; center the via2's in the middle of layer2
     (setq iv2rEnc (quotient (difference irL2ringW ,(if filledRings via2WidthIR via2Width)) 2.0))
     ;; snap iv2rEnc to grid
     (setq tempSize (quotient iv2rEnc via2grid))
     (setq iv2rEnc (times (fix (plus tempSize 0.999)) via2grid))

     (if layer3EdgesAt45 then
	 (setq lowerLeftBL  (times 2.0 via2Space))
	 (setq upperLeftBL  (times 2.0 via2Space))
	 (setq lowerRightBL (times 2.0 via2Space))
	 (setq upperRightBL (times 2.0 via2Space))
      else
	 (setq lowerLeftBL  0.0)
	 (setq upperLeftBL  0.0)
	 (setq lowerRightBL 0.0)
	 (setq upperRightBL 0.0)
     )     

     (dbCreateParamInst tcCellView rivetedRingId "iv2r" (plus irL2xDelta iv2rEnc):(plus irL2yDelta iv2rEnc) "R0" 1
			(list (list "w" "float" (difference irL2w (times 2.0 iv2rEnc)))
			      (list "l" "float" (difference irL2l (times 2.0 iv2rEnc)))
			      (list "xOffset" "float" 0.0)
			      (list "yOffset" "float" 0.0)
			      (list "rivetLayer" "list" via2Layer)
			      (list "ringWidth" "float" ,(if filledRings via2WidthIR via2Width))
			      (list "rivetWidth" "float" via2Width)
			      (list "rivetSpace" "float" via2Space)
			      (list "llBevelLength" "float" ,(if filledRings via2BL lowerLeftBL))
			      (list "ulBevelLength" "float" ,(if filledRings via2BL upperLeftBL))
			      (list "lrBevelLength" "float" ,(if filledRings via2BL lowerRightBL))
			      (list "urBevelLength" "float" ,(if filledRings via2BL upperRightBL))
			      (list "autoIncreaseBevelWidth" "boolean" "FALSE")
			      (list "grid" "float" via2grid)))
     

     ;;
     ;; 5.  create the inner ring of layer3
     ;; target variables set:
     ;;   irL3w = the total width of the inner guard ring of layer3
     ;;   irL3l = the total length of the inner guard ring of layer3
     ;;   irL3xDelta = the x offset of the inner guard ring's layer3 x origin
     ;;   irL3yDelta = the y offset of the inner guard ring's layer3 y origin
     ;;

     (if (greaterp innerRingMetalWidth 0.0) then
	 (setq irL3w irL2w)
	 (setq irL3l irL2l)
	 (setq irL3xDelta irL2xDelta)
	 (setq irL3yDelta irL2yDelta)
	 (setq irL3ringW (max (plus (times 2.0 irLayer3EncVia2) via2Width)
			      innerRingMetalWidth))
      else
	 (setq irL3w (plus irL2w (times -2.0 iv2rEnc) (times 2.0 irLayer3EncVia2)))
	 (setq irL3l (plus irL2l (times -2.0 iv2rEnc) (times 2.0 irLayer3EncVia2)))
	 (setq irL3xDelta (plus irL2xDelta iv2rEnc -irLayer3EncVia2))
	 (setq irL3yDelta (plus irL2yDelta iv2rEnc -irLayer3EncVia2))
	 (setq irL3ringW  (plus (times 2.0 irLayer3EncVia2) via2Width))
     )
	 
     (if layer3EdgesAt45 then
	 (setq lowerLeftBL  irL3ringW)
	 (setq upperLeftBL  irL3ringW)
	 (setq lowerRightBL irL3ringW)
	 (setq upperRightBL irL3ringW)
      else
	 (setq lowerLeftBL  0.0)
	 (setq upperLeftBL  0.0)
	 (setq lowerRightBL 0.0)
	 (setq upperRightBL 0.0)
     )

     (setq dbid (dbCreateParamInst tcCellView ringId "il3r" 0.0:0.0 "R0" 1
				   (list (list "w" "float" irL3w)
					 (list "l" "float" irL3l)
					 (list "xOffset" "float" irL3xDelta)
					 (list "yOffset" "float" irL3yDelta)
					 (list "ringLayer" "list" nil)
					 (list "ringWidth" "float" irL3ringW)
					 (list "additionalWidthInBevel" "float" 0.0)
					 (list "llBevelLength" "float" lowerLeftBL)
					 (list "ulBevelLength" "float" upperLeftBL)
					 (list "lrBevelLength" "float" lowerRightBL)
					 (list "urBevelLength" "float" upperRightBL)
					 (list "bevelTheOutside" "boolean" t)
					 (list "grid" "float" layer3grid)
					 (list "breakupPolygons" "boolean" t)
				   )))

     (setq theMaster dbid~>master)
     (setq dbid1 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints1))
     (setq dbid2 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints2))
     (setq dbid3 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints3))
     (setq dbid4 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints4))
     (dbAddFigToNet dbid1 irNet)
     (dbAddFigToNet dbid2 irNet)
     (dbAddFigToNet dbid3 irNet)
     (dbAddFigToNet dbid4 irNet)
 )

 ;; 6.  create a terminal out of the topmost layer.  This could be layer2 or 3
 (setq pin (dbCreatePin irNet dbid1))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pin (dbCreatePin irNet dbid2))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pin (dbCreatePin irNet dbid3))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pin (dbCreatePin irNet dbid4))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))

 ;;
 ;; create the outer guard ring in 7 steps:
 ;; 1.  create the outer ring of well
 ;; 2.  create the outer ring of tap
 ;;  2a. create the outer ring tap implant if required
 ;; 3.  create the outer riveted ring of via1's
 ;; 4.  create the outer ring of layer2
 ;; *5.  create the outer riveted ring of via2's
 ;; *6.  create the outer ring of layer3
 ;; 7.  create a terminal out of the topmost layer
 ;; (* = if necessary)
 ;;

 ;; set up the tap variables in the outer guard ring:
 ;;  tapWidthInOR = the width of the tap in the outer guard ring
 ;;  outerTapDelta = the offset between the inner and outer tap guard rings
 ;;  orTapXorigin = the x origin for the outer tap guard ring
 ;;  orTapYorigin = the y origin for the outer tap guard ring
 ;;  orTapW = the total width for the outer tap guard ring
 ;;  orTapL = the total length for the outer tap guard ring
 (setq tapWidthInOR (max outerRingTapWidth (plus (times 2.0 outerRingTapEncVia1) via1Width)))
 (setq outerTapDelta (plus wellTapSpace wellEncTap tapWidthInOR))
 (setq orTapXorigin (difference irTapXorigin outerTapDelta))
 (setq orTapYorigin (difference irTapYorigin outerTapDelta))
 (setq orTapW (plus irTapW (times 2.0 outerTapDelta)))
 (setq orTapL (plus irTapL (times 2.0 outerTapDelta)))

 ;;
 ;; first, make sure that we will not create a spacing error for layer3
 ;;
 (when  (and layer3 fullyStrap (nequal fullyStrap "FALSE")) 
     ;; this just satisfies the min spacing of layer3 from inner ring to outer
     (setq orLayer3XoriginA (difference irL3xDelta orirLayer3Space orLayer3Width))

     ;; this will be where layer3 has its origin when it just satisfies the
     ;; spacing of tap in the inner ring to the well in the outer ring
     (setq orLayer3XoriginB (plus orTapXorigin (quotient tapWidthInOR 2.0) (quotient orLayer3Width -2.0)))

     ;; when the layer3 spacing is not going to be satisfied when the at the
     ;; specified spacing of tap in the inner ring to well in outer ring,
     ;; we need to push out the outer guard ring
     (when (lessp orLayer3XoriginA orLayer3XoriginB)
	 (setq extraSpace (difference orLayer3XoriginB orLayer3XoriginA))
	 (setq tempSize (quotient extraSpace tapGrid))
	 (setq extraSpace (times (fix (plus tempSize 0.999)) tapGrid))

	 (setq orTapXorigin (difference orTapXorigin extraSpace))
	 (setq orTapYorigin (difference orTapYorigin extraSpace))
	 (setq orTapW (plus orTapW (times 2.0 extraSpace)))
	 (setq orTapL (plus orTapL (times 2.0 extraSpace)))
     )
 )

 ;;
 ;; 1.  create the well in the outer guard ring
 ;;
 (setq dbid (dbCreateParamInst tcCellView ringId "owr" 0.0:0.0 "R0" 1
			       (list (list "w" "float" (plus orTapW (times 2.0 wellEncTap)))
				     (list "l" "float" (plus orTapL (times 2.0 wellEncTap)))
				     (list "xOffset" "float" (difference orTapXorigin wellEncTap))
				     (list "yOffset" "float" (difference orTapYorigin wellEncTap))
				     (list "ringLayer" "list" nil)
				     (list "ringWidth" "float" (plus tapWidthInOR (times 2.0 wellEncTap)))
				     (list "additionalWidthInBevel" "float" 0.0)
				     (list "llBevelLength" "float" 0.0)
				     (list "ulBevelLength" "float" 0.0)
				     (list "lrBevelLength" "float" 0.0)
				     (list "urBevelLength" "float" 0.0)
				     (list "bevelTheOutside" "boolean" t)
				     (list "grid" "float" wellGrid)
				     (list "breakupPolygons" "boolean" "TRUE"))))
 (setq theMaster dbid~>master)
 (setq dbid1 (dbCreatePolygon tcCellView wellLayer theMaster~>ringPoints1))
 (setq dbid2 (dbCreatePolygon tcCellView wellLayer theMaster~>ringPoints2))
 (setq dbid3 (dbCreatePolygon tcCellView wellLayer theMaster~>ringPoints3))
 (setq dbid4 (dbCreatePolygon tcCellView wellLayer theMaster~>ringPoints4))


 ;;
 ;; 2.  create the outer ring of tap
 ;;

 ;; draw tap corners at 45 degrees if tapEedgesAt45 is set
 (if tapEdgesAt45 then
     (setq bevelLength (times 0.6 tapWidthInOR))
     ;; snap this to grid
     (setq bevelLength (times (round (plus (quotient bevelLength tapGrid) 0.001)) tapGrid))
     
     (setq lowerLeftBL  bevelLength)
     (setq upperLeftBL  bevelLength)
     (setq lowerRightBL bevelLength)
     (setq upperRightBL bevelLength)
  else
     (setq lowerLeftBL  0.0)
     (setq upperLeftBL  0.0)
     (setq lowerRightBL 0.0)
     (setq upperRightBL 0.0)
 )  
     
 (setq dbid (dbCreateParamInst tcCellView ringId "otr" 0.0:0.0 "R0" 1
			       (list (list "w" "float" orTapW)
				     (list "l" "float" orTapL)
				     (list "xOffset" "float" orTapXorigin)
				     (list "yOffset" "float" orTapYorigin)
				     (list "ringLayer" "list" nil)
				     (list "ringWidth" "float" tapWidthInOR)
				     (list "additionalWidthInBevel" "float" 0.0)
				     (list "llBevelLength" "float" lowerLeftBL)
				     (list "ulBevelLength" "float" upperLeftBL)
				     (list "lrBevelLength" "float" lowerRightBL)
				     (list "urBevelLength" "float" upperRightBL)
				     (list "bevelTheOutside" "boolean" t)
				     (list "grid" "float" tapGrid)
				     (list "breakupPolygons" "boolean" "TRUE")
			       )))
 (setq theMaster dbid~>master)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints1))
 (dbAddFigToNet dbid orNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints2))
 (dbAddFigToNet dbid orNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints3))
 (dbAddFigToNet dbid orNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints4))
 (dbAddFigToNet dbid orNet)
 (when tapWellImplant
   (setq otriXorigin   (difference orTapXorigin tapWellImpEnc))
   (setq otriYorigin   (difference orTapYorigin tapWellImpEnc))
   (setq otriRingWidth (plus tapWidthInOR tapWellImpEnc tapWellImpEnc))
   (setq otriW         (plus orTapW tapWellImpEnc tapWellImpEnc))
   (setq otriL         (plus orTapL tapWellImpEnc tapWellImpEnc))
   (setq dbid (dbCreateParamInst tcCellView ringId "otri" 0.0:0.0 "R0" 1
				 (list (list "w" "float" otriW)
				       (list "l" "float" otriL)
				       (list "xOffset" "float" otriXorigin)
				       (list "yOffset" "float" otriYorigin)
				       (list "ringLayer" "list" tapWellImplant)
				       (list "ringWidth" "float" otriRingWidth)
				       (list "additionalWidthInBevel" "float" 0.0)
				       (list "llBevelLength" "float" 0.0)
				       (list "ulBevelLength" "float" 0.0)
				       (list "lrBevelLength" "float" 0.0)
				       (list "urBevelLength" "float" 0.0)
				       (list "bevelTheOutside" "boolean" nil)
				       (list "grid" "float" tapGrid)
				       (list "breakupPolygons" "boolean" "TRUE")
				       )))
 )

 ;;
 ;; 3.  create the outer riveted ring of via1's
 ;;
 (setq orViaOffset (times (fix (plus (quotient (difference (quotient tapWidthInOR 2.0) (quotient via1Width 2.0)) via1grid) 0.999)) via1grid))
 (setq xCoord   (plus orTapXorigin (max orViaOffset outerRingTapEncVia1)))
 (setq yCoord   (plus orTapYorigin (max orViaOffset outerRingTapEncVia1)))

 (setq lowerLeftBL  (times 3.0 via1Space))
 (setq upperLeftBL  (times 3.0 via1Space))
 (setq lowerRightBL (times 3.0 via1Space))
 (setq upperRightBL (times 3.0 via1Space))

 (unless (or filledRings layer2EdgesAt45 tapEdgesAt45)
   ;; draw an extra via1 in each corner
   (setq extraVia1RightOrigin (plus xCoord
				    (difference orTapL (times 2.0 (max orViaOffset outerRingTapEncVia1)))
				    (minus via1Width)))
   (setq extraVia1TopOrigin   (plus yCoord
				    (difference orTapW (times 2.0 (max orViaOffset outerRingTapEncVia1)))
				    (minus via1Width)))
   
   (dbCreateRect tcCellView via1Layer
		 (list (list xCoord yCoord )
		       (list (plus  xCoord via1Width)
			     (plus  yCoord via1Width)
			     )))
   (dbCreateRect tcCellView via1Layer
		 (list (list extraVia1RightOrigin yCoord )
		       (list (plus  extraVia1RightOrigin via1Width )
			     (plus  yCoord via1Width)
			     )))
   (dbCreateRect tcCellView via1Layer
		 (list (list xCoord extraVia1TopOrigin)
		       (list (plus xCoord via1Width)
			     (plus extraVia1TopOrigin via1Width)
			     )))
   (dbCreateRect tcCellView via1Layer
		 (list (list extraVia1RightOrigin extraVia1TopOrigin)
		       (list (plus extraVia1RightOrigin via1Width)
			     (plus extraVia1TopOrigin via1Width)
			     )))
   )
 ;; actual ring is created in 4.

 ;;
 ;; 4.  create the outer ring of layer2.  target variables set:
 ;;   orL2w = the total width of the outer layer2 guard ring
 ;;   orL2l = the total length of the outer layer2 guard ring
 ;;   orL2xDelta = the x origin of the outer layer2 guard ring
 ;;   orL2yDelta = the y origin of the outer layer2 guard ring
 ;;   orL2ringW = the ring width of layer2 in the outer guard ring
 ;;

 (if layer3 then
     ;; draw layer2 with the same width as of layer3
     (setq orLayer3EncVia2 (quotient (difference orLayer3Width via2Width) 2.0))
     ;; snap orLayer3EncVia2 to grid
     (setq tempSize (quotient orLayer3EncVia2 layer3grid))
     (setq orLayer3EncVia2 (times (fix (plus tempSize 0.999)) layer3grid))
     (setq outerRingMetalWidth (plus (times 2.0 orLayer3EncVia2) via2Width))
     
     (setq orL2w (plus orTapW -tapWidthInOR outerRingMetalWidth))
     (setq orL2l (plus orTapL -tapWidthInOR outerRingMetalWidth))

     (setq orL2xDelta (plus orTapXorigin (quotient (plus tapWidthInOR -outerRingMetalWidth) 2.0)))
     ;; snap orL2xDelta to grid
     (setq orL2xDelta (times (fix (plus (quotient orL2xDelta layer2grid) 0.999)) layer2grid))

     (setq orL2yDelta (plus orTapYorigin (quotient (plus tapWidthInOR -outerRingMetalWidth) 2.0)))
     ;; snap orL2yDelta to grid
     (setq orL2yDelta (times (fix (plus (quotient orL2yDelta layer2grid) 0.999)) layer2grid))

     (setq orL2ringW (max (plus (times 2.0 layer2EncVia1) via1Width)
			  (plus (times 2.0 layer2EncVia2) via2Width)
			  orLayer3Width))
    else
     (setq orL2w (plus orTapW (times -2.0 (max orViaOffset outerRingTapEncVia1)) (times 2.0 layer2EncVia1)))
     (setq orL2l (plus orTapL (times -2.0 (max orViaOffset outerRingTapEncVia1)) (times 2.0 layer2EncVia1)))
     (setq orL2xDelta (plus xCoord -layer2EncVia1))
     (setq orL2yDelta (plus yCoord -layer2EncVia1))
     (setq orL2ringW (max (plus (times 2.0 layer2EncVia1) via1Width)
			  (plus (times 2.0 layer2EncVia2) via2Width)))
 )

 ;; create the ring of via1's here, since we need orL2ringW defined before creation
 ;; create riveted ring if no filledRings, otherwise create generic ring
 (unless filledRings
   (dbCreateParamInst tcCellView rivetedRingId "ov1r" xCoord:yCoord "R0" 1
		      (list (list "w" "float" (difference orTapW (times 2.0 (max orViaOffset outerRingTapEncVia1))))
			    (list "l" "float" (difference orTapL (times 2.0 (max orViaOffset outerRingTapEncVia1))))
			    (list "xOffset" "float" 0.0)
			    (list "yOffset" "float" 0.0)
			    (list "rivetLayer" "list" via1Layer)
			    (list "ringWidth" "float" via1Width)
			    (list "rivetWidth" "float" via1Width)
			    (list "rivetSpace" "float" via1Space)
			    (list "llBevelLength" "float" lowerLeftBL)
			    (list "ulBevelLength" "float" upperLeftBL)
			    (list "lrBevelLength" "float" lowerRightBL)
			    (list "urBevelLength" "float" upperRightBL)
			    (list "autoIncreaseBevelWidth" "boolean" "FALSE")
			    (list "grid" "float" via1grid)))
   )
 (when filledRings
   (dbCreateParamInst tcCellView rivetedRingId "ov1r" 0:0 "R0" 1
		      (list (list "w" "float" (difference orTapW (times 2.0 outerRingTapEncVia1) (times 2.0 innerRingTapEncVia1)))
			    (list "l" "float" (difference orTapL (times 2.0 outerRingTapEncVia1) (times 2.0 innerRingTapEncVia1)))
			    (list "xOffset" "float" (plus orTapXorigin outerRingTapEncVia1 innerRingTapEncVia1))
			    (list "yOffset" "float" (plus orTapYorigin outerRingTapEncVia1 innerRingTapEncVia1))
			    (list "rivetLayer" "list" via1Layer)
			    (list "ringWidth" "float" (difference tapWidthInOR outerRingTapEncVia1 (times 2.0 innerRingTapEncVia1)))
			    (list "rivetWidth" "float" via1Width)
			    (list "rivetSpace" "float" via1Space)
			    (list "llBevelLength" "float" 0.0)
			    (list "ulBevelLength" "float" 0.0)
			    (list "lrBevelLength" "float" 0.0)
			    (list "urBevelLength" "float" 0.0)
			    (list "autoIncreaseBevelWidth" "boolean" "FALSE")
			    (list "grid" "float" via1grid)))
   )

 (if layer2EdgesAt45 then
     
     (setq lowerLeftBL  orL2ringW)
     (setq upperLeftBL  orL2ringW)
     (setq lowerRightBL orL2ringW)
     (setq upperRightBL orL2ringW)
  else

     (setq lowerLeftBL  0.0)
     (setq upperLeftBL  0.0)
     (setq lowerRightBL 0.0)
     (setq upperRightBL 0.0)
 )

     (setq dbid (dbCreateParamInst tcCellView ringId "ol2r" 0.0:0.0 "R0" 1
				   (list (list "w" "float" ,(if filledRings
								(difference orTapW (times 2.0 outerRingTapEncVia1))
							      orL2w))
					 (list "l" "float" ,(if filledRings
								(difference orTapL (times 2.0 outerRingTapEncVia1))
							      orL2l))
					 (list "xOffset" "float" ,(if filledRings (plus orTapXorigin outerRingTapEncVia1) orL2xDelta))
					 (list "yOffset" "float" ,(if filledRings (plus orTapYorigin outerRingTapEncVia1) orL2yDelta))
					 (list "ringLayer" "list" layer2)
					 (list "ringWidth" "float" ,(if filledRings (difference tapWidthInOR outerRingTapEncVia1) orL2ringW))
					 (list "additionalWidthInBevel" "float" 0.0)
					 (list "llBevelLength" "float" lowerLeftBL)
					 (list "ulBevelLength" "float" upperLeftBL)
					 (list "lrBevelLength" "float" lowerRightBL)
					 (list "urBevelLength" "float" upperRightBL)
					 (list "bevelTheOutside" "boolean" t)
					 (list "grid" "float" layer2grid)
					 (list "breakupPolygons" "boolean" "TRUE")
				   )))
 
 (setq theMaster dbid~>master)
 (setq dbid1 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints1))
 (setq dbid2 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints2))
 (setq dbid3 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints3))
 (setq dbid4 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints4))
 (dbAddFigToNet dbid1 orNet)
 (dbAddFigToNet dbid2 orNet)
 (dbAddFigToNet dbid3 orNet)
 (dbAddFigToNet dbid4 orNet)

 ;; when layer2 is the topmost layer, create a terminal out of it
 (when  (and layer3 fullyStrap (nequal fullyStrap "FALSE")) 

     ;;
     ;; 5.  if we must go to layer3, create the via2's and then create layer3
     ;;
     ;; center the via2's in the middle of layer2
     (setq ov2rEnc (quotient (difference orL2ringW via2Width) 2.0))
     ;; snap ov2rEnc to grid
     (setq tempSize (quotient ov2rEnc via2grid))
     (setq ov2rEnc (times (fix (plus tempSize 0.999)) via2grid))

     (if layer3EdgesAt45 then
	 (setq lowerLeftBL  (times 2.0 via2Space))
	 (setq upperLeftBL  (times 2.0 via2Space))
	 (setq lowerRightBL (times 2.0 via2Space))
	 (setq upperRightBL (times 2.0 via2Space))
      else
	 (setq lowerLeftBL  via2Space)
	 (setq upperLeftBL  via2Space)
	 (setq lowerRightBL via2Space)
	 (setq upperRightBL via2Space)
     )    

     (when filledRings
       (setq via2WidthOR (difference orLayer3Width (times 2.0 via2Enc)))
       (setq via2BL (plus via2WidthOR via2Space))

       (dbCreateParamInst tcCellView rivetedRingId "ov2r" 0:0 "R0" 1
			  (list (list "w" "float" (difference orTapW (times 2.0 (plus via2Enc outerRingTapEncVia1))))
				(list "l" "float" (difference orTapL (times 2.0 (plus via2Enc outerRingTapEncVia1))))
				(list "xOffset" "float" (plus orTapXorigin outerRingTapEncVia1 via2Enc))
				(list "yOffset" "float" (plus orTapYorigin outerRingTapEncVia1 via2Enc))
				(list "rivetLayer" "list" via2Layer)
				(list "ringWidth" "float" via2WidthOR)
				(list "rivetWidth" "float" via2Width)
				(list "rivetSpace" "float" via2Space)
				(list "llBevelLength" "float" via2BL)
				(list "ulBevelLength" "float" via2BL)
				(list "lrBevelLength" "float" via2BL)
				(list "urBevelLength" "float" via2BL)
				(list "autoIncreaseBevelWidth" "boolean" "FALSE")
				(list "grid" "float" via2grid)))
       )
     (unless filledRings
       (dbCreateParamInst tcCellView rivetedRingId "ov2r" (plus orL2xDelta ov2rEnc):(plus orL2yDelta ov2rEnc) "R0" 1
			  (list (list "w" "float" (difference orL2w (times 2.0 ov2rEnc)))
				(list "l" "float" (difference orL2l (times 2.0 ov2rEnc)))
				(list "xOffset" "float" 0.0)
				(list "yOffset" "float" 0.0)
				(list "rivetLayer" "list" via2Layer)
				(list "ringWidth" "float" via2Width)
				(list "rivetWidth" "float" via2Width) 
				(list "rivetSpace" "float" via2Space)
				(list "llBevelLength" "float" lowerLeftBL)
				(list "ulBevelLength" "float" upperLeftBL)
				(list "lrBevelLength" "float" lowerRightBL)
				(list "urBevelLength" "float" upperRightBL)
				(list "autoIncreaseBevelWidth" "boolean" "FALSE")
				(list "grid" "float" via2grid)))
       )
     
     
     ;; 6.  create the outer ring of layer3.  target variables set:
     ;;   orL3w = the total width of the outer layer3 guard ring
     ;;   orL3l = the total length of the outer layer3 guard ring
     ;;   orL3xDelta = the x origin of the outer layer3 guard ring
     ;;   orL3yDelta = the y origin of the outer layer3 guard ring
     ;;
     (setq orL3w (plus orL2w (times -2.0 ov2rEnc) (times 2.0 orLayer3EncVia2)))
     (setq orL3l (plus orL2l (times -2.0 ov2rEnc) (times 2.0 orLayer3EncVia2)))
     (setq orL3xDelta (plus orL2xDelta ov2rEnc -orLayer3EncVia2))
     (setq orL3yDelta (plus orL2yDelta ov2rEnc -orLayer3EncVia2))

     (if layer3EdgesAt45 then
	 (setq lowerLeftBL  orLayer3Width)
	 (setq upperLeftBL  orLayer3Width)
	 (setq lowerRightBL orLayer3Width)
	 (setq upperRightBL orLayer3Width)
      else
	 (setq lowerLeftBL  0.0)
	 (setq upperLeftBL  0.0)
	 (setq lowerRightBL 0.0)
	 (setq upperRightBL 0.0)
     )
     
     (setq dbid (dbCreateParamInst tcCellView ringId "ol3r" 0.0:0.0 "R0" 1
				   (list (list "w" "float" ,(if filledRings
								(difference orTapW (times 2.0 outerRingTapEncVia1))
								orL3w))
					 (list "l" "float" ,(if filledRings
								(difference orTapL (times 2.0 outerRingTapEncVia1))
							      orL3l))
					 (list "xOffset" "float" ,(if filledRings (plus orTapXorigin outerRingTapEncVia1) orL3xDelta))
					 (list "yOffset" "float" ,(if filledRings (plus orTapYorigin outerRingTapEncVia1) orL3yDelta))
					 (list "ringLayer" "list" nil)
					 (list "ringWidth" "float" orLayer3Width) ;;;(plus (times 2.0 orLayer3EncVia2) via2Width)
					 (list "additionalWidthInBevel" "float" 0.0)
					 (list "llBevelLength" "float" lowerLeftBL)
					 (list "ulBevelLength" "float" upperLeftBL)
					 (list "lrBevelLength" "float" lowerRightBL)
					 (list "urBevelLength" "float" upperRightBL)
					 (list "bevelTheOutside" "boolean" t)
					 (list "grid" "float" layer3grid)
					 (list "breakupPolygons" "boolean" t)
				   )))

     (setq theMaster dbid~>master)
     (setq dbid1 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints1))
     (setq dbid2 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints2))
     (setq dbid3 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints3))
     (setq dbid4 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints4))
     (dbAddFigToNet dbid1 orNet)
     (dbAddFigToNet dbid2 orNet)
     (dbAddFigToNet dbid3 orNet)
     (dbAddFigToNet dbid4 orNet)

 )

 ;; 7.  create a terminal out of the topmost layer.  This could be layer2 or 3
 (setq pin (dbCreatePin orNet dbid1))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pin (dbCreatePin orNet dbid2))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pin (dbCreatePin orNet dbid3))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pin (dbCreatePin orNet dbid4))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))

)
;;; 
;;; $Id: nikonCrossClass.il,v 1.4 2002/10/07 20:26:02 kgr Exp $ %T%
;;; 
;;; nikonCrossClass.il
;;; 
;;; Copyright (c) 1997 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Mar 07, 1997
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This is the source code for the Nikon Cross.  The parameters for
;;; this device are all set by the technology.  This will be used by the
;;; die seal ring.
;;; 
;;; Revision History:
;;;   gtc 04/03/97  Reversing "width" and "legWidth" parameters to be correct
;;;   gtc 04/17/97  adding an outer ring option
;;;   gtc 01/22/98  Copying over from v20
;;;   jtv 04/11/02  Included layer offset parameter to allow over/under 
;;;                 enclosure by layers in the Nikon Cross
;;;   kgr 07/03/02  Added second layer offset option to nikon (b55*)
;;;   kgr 10/07/02  Corrected unbalenced parenthesis in comment line (SPR 13680)
;;; 

(putpropqq nikonCrossClass "$Id: nikonCrossClass.il,v 1.4 2002/10/07 20:26:02 kgr Exp $ %T%" SCCS)

(tcCreateDeviceClass
 "symbolic" "nikonCrossClass"
 ;; Class parameters
 (
  (legWidth    0.0)
  (legLength   0.0)
  (width       0.0)
  (cutOffset   0.0)
  ;; each item is a list of type '(layer digitized (optional crossWidth))
  ;; the third field can be either nil or a crossWidth.  This is not the
  ;; actual offset value so using 0.0 for no offset would be an error.
  (theLayers '('(("cnwm" "mask") nil )
	       '(("cfom" "mask") t   )
	       '(("cp1m" "mask") t   nil)))
;;  (outerRingLayers '('("cmm1" "mask")
;;		     '("cmm2" "mask")))
  (outerRingLayers nil)
  (outerRingExtension 0.0)
  (outerRingWidth 0.0)
  (outerGrid 0.0)
 )
 ;; Formal parameters
 (
 )

 ;; Create the list of points for the positive layer points
 (setq xOrigin width)
 (setq yOrigin (plus width legLength))

 (setq crossPoints (list xOrigin:yOrigin
			 xOrigin:(plus yOrigin legWidth)
			 (plus xOrigin legLength):(plus yOrigin legWidth)
			 (plus xOrigin legLength):(plus yOrigin legWidth 
							legLength)
			 (plus xOrigin legLength legWidth):
			       (plus yOrigin legWidth legLength)
			 (plus xOrigin legLength legWidth):
			       (plus yOrigin legWidth)
			 (plus xOrigin legLength legWidth legLength):
			       (plus yOrigin legWidth)
			 (plus xOrigin legLength legWidth legLength):yOrigin
			 (plus xOrigin legLength legWidth):yOrigin
			 (plus xOrigin legLength legWidth):
			       (plus yOrigin -legLength)
			 (plus xOrigin legLength):(plus yOrigin -legLength)
			 (plus xOrigin legLength):yOrigin))



 ;; Calculate the values for the reversed layer points
 (setq reverseLength (plus legWidth (times 2.0 (plus width legLength))))
 (setq reverseSide (difference reverseLength (times 2.0 cutOffset)))

 (setq reversePoints (list 0.0:cutOffset
			   cutOffset:0.0
			   (plus cutOffset reverseSide):0.0
			   reverseLength:cutOffset
			   reverseLength:(plus cutOffset reverseSide)
			   (plus cutOffset reverseSide):reverseLength
			   cutOffset:reverseLength
			   0.0:(plus cutOffset reverseSide)
			   0.0:yOrigin
		     ))

 (when outerRingLayers

     ;; the following equation is identical to that used in the padClass,
     ;; which is described in detail in the design document

     (setq s2 (sqrt 2.0))
     (setq extraOffset (quotient (times outerRingExtension 
					(difference 2.0 s2)) outerGrid))
     (setq extraOffset (times outerGrid (plus -1 (fix 
					(plus extraOffset 0.999)))))
     (setq outerCutOffset (plus extraOffset cutOffset))

     (setq outerRingLength (plus reverseLength (times 2.0 outerRingExtension)))
     (setq outerSide (difference outerRingLength (times 2.0 outerCutOffset)))
     (setq outerOutsidePoints
	   (list -outerRingExtension:(plus outerCutOffset -outerRingExtension)
		 (plus outerCutOffset -outerRingExtension):-outerRingExtension
		 (plus outerCutOffset -outerRingExtension outerSide):
		       -outerRingExtension
		 (plus outerRingLength -outerRingExtension):
		       (plus outerCutOffset -outerRingExtension)
		 (plus outerRingLength -outerRingExtension):
		       (plus outerCutOffset -outerRingExtension outerSide)
		 (plus outerCutOffset -outerRingExtension outerSide):
		       (plus outerRingLength -outerRingExtension)
		 (plus outerCutOffset -outerRingExtension):
		       (plus outerRingLength -outerRingExtension)
		 -outerRingExtension:
		       (plus outerCutOffset -outerRingExtension outerSide)
		 -outerRingExtension:yOrigin
	   ))
     (dbCreateProp tcCellView "outerOutlinePoints" "list" outerOutsidePoints)

     ;; the following equation is identical to that used in the ringClass,
     ;; which is described in detail in the design document
     (setq insideOffset 
	   (quotient (times outerRingWidth (difference s2 1.0)) outerGrid))
     (setq insideOffset (times (fix (plus 0.999 insideOffset)) outerGrid))

     (setq outerInsidePoints
	   (list
	    (plus -outerRingExtension outerRingWidth):yOrigin
	    (plus -outerRingExtension outerRingWidth):
	          (plus outerCutOffset -outerRingExtension outerSide 
			-insideOffset)
	    (plus outerCutOffset -outerRingExtension insideOffset):
	          (plus outerRingLength -outerRingExtension -outerRingWidth)
	    (plus outerCutOffset -outerRingExtension outerSide -insideOffset):
	          (plus outerRingLength -outerRingExtension -outerRingWidth)
	    (plus outerRingLength -outerRingExtension -outerRingWidth):
	          (plus outerCutOffset -outerRingExtension outerSide 
			-insideOffset)
	    (plus outerRingLength -outerRingExtension -outerRingWidth):
	          (plus outerCutOffset -outerRingExtension insideOffset)
	    (plus outerCutOffset -outerRingExtension outerSide -insideOffset):
	          (plus -outerRingExtension outerRingWidth)
	    (plus outerCutOffset -outerRingExtension insideOffset):
	          (plus -outerRingExtension outerRingWidth)
	    (plus -outerRingExtension outerRingWidth):
	          (plus outerCutOffset -outerRingExtension insideOffset)
	    (plus -outerRingExtension outerRingWidth):yOrigin
	   ))

     (setq outerRingPoints (append outerOutsidePoints outerInsidePoints))
     (setq outerRingPoints (cons -outerRingExtension:yOrigin outerRingPoints))

     (foreach layer outerRingLayers
	 (dbCreatePolygon tcCellView layer outerRingPoints)
     )
      
 )

 (unless outerRingLayers
     (dbCreateProp tcCellView "outerOutlinePoints" "list" reversePoints))

 (dbCreateProp tcCellView "outlinePoints" "list" reversePoints)

 (setq reversePoints (append reversePoints crossPoints))
 (setq reversePoints (cons 0.0:yOrigin reversePoints))

 (foreach layer theLayers
     (cond ((cadr layer)  ;; if the layer is digitized (cadr layer) == (t)
	  (cond ((caddr layer)  ;; if the layer has an offset defined 
		                ;; (caddr layer) == (t)
	       ;; standard crossWidth drawn = (plus (times 2.0 legLength) legWidth)
	       ;; when user enters offsetLayers value, we set layerOffset to
	       ;; ( new crossWidth - standard crossWidth)/2
	       (setq layerOffset (quotient ((caddr layer) - 
				 (plus (times 2.0 legLength) legWidth)) 2.0 ))
	       ;; Create the list of points for the positive layer points
	       (setq xOrigin width - layerOffset )
	       (setq yOrigin (plus width legLength - layerOffset ))
	       
	       (setq crossPointsOff 
		 (list
		  xOrigin:yOrigin
		  xOrigin:(plus yOrigin legWidth (times 2 layerOffset) )
		  (plus xOrigin legLength):(plus yOrigin legWidth 
						 (times 2 layerOffset) )
		  (plus xOrigin legLength):(plus yOrigin legWidth legLength
						 (times 2 layerOffset))
		  (plus xOrigin legLength legWidth (times 2 layerOffset)):
		        (plus yOrigin legWidth legLength (times 2 layerOffset))
		  (plus xOrigin legLength legWidth (times 2 layerOffset)):
		        (plus yOrigin legWidth (times 2 layerOffset))
		  (plus xOrigin legLength legWidth legLength 
			(times 2 layerOffset)):
			(plus yOrigin legWidth (times 2 layerOffset))
		  (plus xOrigin legLength legWidth legLength 
			(times 2 layerOffset)):
			yOrigin
		  (plus xOrigin legLength legWidth (times 2 layerOffset)):
		        yOrigin
		  (plus xOrigin legLength legWidth (times 2 layerOffset)):
		        (plus yOrigin -legLength)
		  (plus xOrigin legLength):(plus yOrigin -legLength)
		  (plus xOrigin legLength):yOrigin))

	       (cond ( (cadddr layer)

		 (setq layerOffset2 (quotient ((cadddr layer) - 
				(plus (times 2.0 legLength) legWidth)) 2.0 ))
		 (setq xOrigin2 width - layerOffset2 )
		 (setq yOrigin2 (plus width legLength - layerOffset2 ))

		 (setq crossPointsOff2 
		 (list
		  xOrigin2:yOrigin2
		  xOrigin2:(plus yOrigin2 legWidth (times 2 layerOffset2) )
		  (plus xOrigin2 legLength):(plus yOrigin2 legWidth 
						 (times 2 layerOffset2) )
		  (plus xOrigin2 legLength):(plus yOrigin2 legWidth legLength
						 (times 2 layerOffset2))
		  (plus xOrigin2 legLength legWidth (times 2 layerOffset2)):
		        (plus yOrigin2 legWidth legLength (times 2 layerOffset2))
		  (plus xOrigin2 legLength legWidth (times 2 layerOffset2)):
		        (plus yOrigin2 legWidth (times 2 layerOffset2))
		  (plus xOrigin2 legLength legWidth legLength 
			(times 2 layerOffset2)):
			(plus yOrigin2 legWidth (times 2 layerOffset2))
		  (plus xOrigin2 legLength legWidth legLength 
			(times 2 layerOffset2)):
			yOrigin2
		  (plus xOrigin2 legLength legWidth (times 2 layerOffset2)):
		        yOrigin2
		  (plus xOrigin2 legLength legWidth (times 2 layerOffset2)):
		        (plus yOrigin2 -legLength)
		  (plus xOrigin2 legLength):(plus yOrigin2 -legLength)
		  (plus xOrigin2 legLength):yOrigin2))

		 (setq crossPointsOff2 (reverse crossPointsOff2))
		 (setq crossPointsOff (cdr crossPointsOff))
		 (setq crossPointsOff (append crossPointsOff (list 
					xOrigin:yOrigin xOrigin:yOrigin2)))
		 (setq crossPointsOff (append (list xOrigin:yOrigin2) crossPointsOff))
		 (setq crossPointsOff (append crossPointsOff crossPointsOff2))
		 (dbCreatePolygon tcCellView (car layer) crossPointsOff)
	       )
		 (t
		  (dbCreatePolygon tcCellView (car layer) crossPointsOff)
		 )
	       ) ;;end cond
	      ) ;;end cond
	      (t ;; if there is no offset defined for the layer 
	         ;; (caddr layer) == (nil)
	       (dbCreatePolygon tcCellView (car layer) crossPoints)
	       )
	      )
	)
	 (t   ; if the layer is reversed (cadr layer) == (nil)
	  (cond ((caddr layer) ;; if there is an offset defined for the layer 
		               ;; (caddr layer) == t
	  ;; standard crossWidth drawn = (plus (times 2.0 legLength) legWidth)
	  ;; when user enters non standard crossWidth, we set layerOffset to
	  ;; be ( new crossWidth - standard crossWidth)/2
             (setq layerOffset (quotient ((caddr layer) - 
			       (plus (times 2.0 legLength) legWidth)) 2.0 ))
	     ;; Create the list of points for the positive layer points
	     (setq xOrigin width - layerOffset )
	     (setq yOrigin (plus width legLength - layerOffset ))
	     
	     (setq crossPointsOff 
		 (list
		  xOrigin:yOrigin
		  xOrigin:(plus yOrigin legWidth (times 2 layerOffset) )
		  (plus xOrigin legLength):(plus yOrigin legWidth 
						 (times 2 layerOffset))
		  (plus xOrigin legLength):(plus yOrigin legWidth legLength 
						 (times 2 layerOffset))
		  (plus xOrigin legLength legWidth (times 2 layerOffset)):
		        (plus yOrigin legWidth legLength (times 2 layerOffset))
	          (plus xOrigin legLength legWidth (times 2 layerOffset)):
		        (plus yOrigin legWidth (times 2 layerOffset))
		  (plus xOrigin legLength legWidth legLength 
			(times 2 layerOffset)):
			(plus yOrigin legWidth (times 2 layerOffset))
		  (plus xOrigin legLength legWidth legLength 
			(times 2 layerOffset)):
			yOrigin
		  (plus xOrigin legLength legWidth (times 2 layerOffset)):
		  yOrigin
		  (plus xOrigin legLength legWidth (times 2 layerOffset)):
		  (plus yOrigin -legLength)
		  (plus xOrigin legLength):(plus yOrigin -legLength)
		  (plus xOrigin legLength):yOrigin)) 
	     
	     (setq reversePointsOff (list 0.0:cutOffset
		   cutOffset:0.0
		   (plus cutOffset reverseSide):0.0
		   reverseLength:cutOffset
		   reverseLength:(plus cutOffset reverseSide)
		   (plus cutOffset reverseSide):reverseLength
		   cutOffset:reverseLength
		   0.0:(plus cutOffset reverseSide)
		   0.0:yOrigin
		   ))
	     (setq reversePointsOff (append reversePointsOff crossPointsOff))
	     (setq reversePointsOff (cons 0.0:yOrigin reversePointsOff))
	     (dbCreatePolygon tcCellView (car layer) reversePointsOff)
	     )
		(t ;; if there is no offset defined for the layer 
		   ;; (caddr layer) == (nil)
		 (dbCreatePolygon tcCellView (car layer) reversePoints)
		 )
		) ; end offset condition
	  ) 
	 ) ; end digitized condition
   ) ; end foreach
 ) ; end tcCreateDeviceClass
;;; 
;;; $Id: pEsdTranImpClass.il,v 1.10 2008/04/01 20:51:16 kuc Exp $
;;; 
;;; pEsdTranImpClass.il
;;; 
;;; Copyright (c) 1997 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Mar 03, 1997
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This is an variant on the transistor for the device library.  It will
;;; provide ESD protection.  This should be used as the P ESD transistor for
;;; nwell technologies, and as the N ESD transistor for pwell technologies.
;;; 
;;; Revision History:
;;;   gtc 07/18/97  Growing the viaExtDiff when shrinkPercent is used
;;;   gtc 09/12/97  Breaking rings up into four shapes
;;;   gtc 11/19/97  Making drnViaYspaceRingVia a formal param; not scaling
;;;                 all the same parameters as before
;;;   gtc 12/01/97  Fixed bug in layer2 Y enclosure when not fully strapped
;;;   gtc 06/12/98  checking layer3-layer3 spacing, aligning via1 & via2
;;;                 contacts, not putting contacts in corners of outer
;;;                 guard ring, not always putting the same number of
;;;                 via2 contacts on s/d as via1 contacts, instead, fitting
;;;                 as many via2 contacts as can fit in the via1 space
;;;   dgn 02/23/99  changed drnViaYspaceRingVia to drnViaYspaceRingViaTop and Bot
;;;   dgn 03/09/99  Centered contacts on the outer ring
;;;   jbq 02/17/00  Changed the fundamental way that width was derived
;;;                 (no longer depends on flare)
;;;   jbq 02/22/00  Fixed error message 
;;;   xgs 08/22/00  Added via1Via2Space layer2Width layer3Width 
;;;                 layer3Width_outside and innerRingMetalWidth
;;;   xgs 08/30/00  Added edgesAt45 class parameter
;;;   xgs 09/11/00  Corrections for edgesAt45
;;;   xgs 10/14/00  Fixed bug in drawing layer2 in drain region 
;;;   xgs 10/25/00  Changed innerRingMetalWidth to final value
;;;   xgs 11/07/00  Draw layer3 on diffTap in end source regions
;;;   xgs 11/08/00  Added option for drawing tap at 45 degrees in inner 
;;;                 and outer guard rings
;;;   xgs 11/09/00  Draw via1 with proper overlap with diff in shared source region
;;;   jfe 11/14/00  Modify sanity checks for diff width, rather than minL to minL,
;;;                  and to add the correct number of vias (licons)
;;;   gtc 12/29/00  tweaked so that the outer guard contacts line up in order
;;;                 that the outer guard rings can be shared for two devices
;;;   dxj 02/07/01  Changing orirLayer3Space from a class parameter to a 
;;;                 user parameter. For providing user control to meet stress 
;;;                 rules in critical region
;;;   kmi 06/28/01  fullyStrap option for ram7* technologies now removes only 
;;;                 metal over guard rings, i.e. metal over diff is always 'on'
;;;   kmi 07/25/01  moving (TECHgetProp "technology") to the Class parameters 
;;;                 definition due the DRC evaluation error
;;;   cry 08/09/01  copied from pEsdTranClass.il
;;;                 adding implants and other changes making it difficult to 
;;;                 share with older class
;;;   lpn 02/06/02  Added an option to draw diffCoreImplant layer enclosing Diff layer 
;;;   ymx 02/21/03  Updates for hv pmos (TCS 544)
;;;   kmi 04/22/03  Updates for floatNwell
;;;   kmi 02/12/04  Updates for splitSource
;;;   kuc 02/07/06  updates for semi-scalable models
;;;   cva 02/01/07  updates for bevel width for stress violations
;;;   kuc 03/26/08  guard ring updates
;;;


(tcCreateDeviceClass
 "symbolic" "pEsdTranImpClass"
 ;; Class parameters
 (
  (diffLayer            "y0")
  (gateLayer            "y1")
  (rgateLayer           "y2")
  (wellLayer            "y3")
  (tapLayer             "y4")
  (via1Layer            "y5")
  (layer2               "y6")
  (via2Layer            "y7")
  (layer3               "y8")
  (idLayer              "y9")
  (maxvLayer            nil)
  (hvWellEnclosure      0.0) ;;;enclosure of nwell by hv id layer.
  (diffImplant          nil)
  (diffImpEnc           0.0)
  (diffCoreImplant      nil)
  (diffCoreImpEnc       0.0)
  (tapWellImplant       nil)
  (tapWellImpEnc        0.0)
  (tapSubImplant        nil)
  (tapSubImpEnc         0.0)
  (tapWidth             0.0)
  (srcViaGateSpace      0.0)
  (srcViaTapSpace       0.0)
  (drnViaGateSpace      0.0)
  (viaExtDiff           0.0)
  (minDiffTapRingSpace  0.0)
  (flareYamount_in      0.0)
  (flareYamount         0.0)
  (flareYextension      0.0)
  (via1Width            0.0)
  (via1Space            0.0)
  (tapEncVia1           0.0)
  (wellEncTap           0.0)
  (innerRingTapWidth    0.0)
  (outerRingTapWidth    0.0)
  (wellTapSpace         0.0)  ;;; space btw ring2 and nwell
  (layer2EncVia1        0.0)
  (via2Width            0.0)
  (via2Space            0.0)
  (via1Via2Space        0.0)
  (layer2EncVia2        0.0)
  (layer2Width          0.0)
  (layer3EncVia2        0.0)
  (layer3Width          0.0)
  (layer3Width_outside  0.0)
  (innerRingMetalWidth  0.0)
  (irLayer3EncVia2      0.0)
  (irLayer3AddWidthBvl  0.0)  ;;; bevelWidth addition, 45degree Length Stress Violations
  (orLayer3Width        0.0)
  (minW                 0.0)
  (maxW                 0.0)
  (minTotalW            0.0)
  (genericRingName      "ring")
  (rivetedRingName      "rivetRing")
  (flaredGateName       "flaredGate")
  (diffGrid             0.00)
  (tapGrid              0.00)
  (wellGrid             0.00)
  (polyGrid             0.00)
  (via1grid             0.00)
  (layer2grid           0.00)
  (via2grid             0.00)
  (layer3grid           0.00)
  (tapEdgesAt45         nil)
  (layer2EdgesAt45      nil)
  (layer3EdgesAt45      nil)
  (endTapMetInsideOut   nil)
  (srcViaToDiffEdgSpace 0.00)   ; enclosure of via1 by diff
  (thirdRing            nil)    ; third ring on/off
  (floatNwell           nil)    ; float nwell cell (no srcTap) on/off
  (nWellSw              nil)    ; enables NwellconnectToIOpad switch
  (thirdRingTapWidth    0.0)    ; third ring tap width
  (trLayer3Width        0.0)    ; third ring layer3 width
  (thirdRingTapWidth2   0.0)    ; third ring tap width (second set)
  (trLayer3Width2       0.0)    ; third ring layer3 width (second set)

  (splitSource          nil)
  (stripTapToDiffSpace  0.0)
  (minExtraLRspace      0.0)
  (tapLay2Width         0.0)
  (tapLay3Width         0.0)
  (sourceLay2Via1Enc    0.0)
  (sourceLay3Via2Enc    0.0)
  (tapLay2OffsetY       0.0)
  (tapLay3OffsetY       0.0)    
  (layer2WidthS         0.0)
  (layer2WidthD         0.0)
  (layer3WidthS         0.0)
  (layer3WidthD         0.0)
  (modelTextLayer       (list "hilite" "drawing"))
  (modelTextLayerSize   0.2)
  (modelText            "")
  (modelWmax            0.0)
  (modelWmin            0.0)
  (modelLmax            0.0)
  (modelLmin            0.0)
  (filledRings          nil)
 )
 ;; Formal parameters
 (
  (w                0.0)
  (l                0.0)
  (m                0)
  (extraLeftSpace   0.0)
  (extraRightSpace  0.0)
  (shrinkPercent    0.0)
  (extraSrcSpace    0.0)
  (extraDrnSpace    0.0)
  (NwellconnectToIOpad "FALSE")
  (fullyStrap	    "FALSE")
  (drnViaYspaceRingViaTop  0.0)
  (drnViaYspaceRingViaBot  0.0)
  (orirLayer3Space      0.0)
 )

 (when (w > modelWmax)
   (error "%f is greater than allowable maximum width %f for model %L" w modelWmax modelText))
 (when (w < modelWmin)
   (error "%f is less than allowable minimum width %f for model %L" w modelWmin modelText))
 (when (l > modelLmax)
   (error "%f is greater than allowable length %f for model %L" l modelLmax modelText))
 (when (l < modelLmin)
   (error "%f is less than allowable minimum length %f for model %L" l modelLmin modelText))

 ;;; this values should be set to zero in rawtech file
 ;;; setting them again, just in case
 (when floatNwell 
    (setq tapWidth 0.0)
    (setq srcViaToSrcTapSpace 0.0)
    (setq srcViaTapSpace 0.0)
 )
 (if (or (equal splitSource t) (equal splitSource "TRUE")) then
    (setq splitSource t)
    (setq srcViaTapSpace 0.0)
  else
    (setq stripTapToDiffSpace 0.0)
 )
 (when splitSource
  (if extraLeftSpace < minExtraLRspace then
    (setq extraLeftSpace minDiffTapRingSpace)
    (setq leftEndTap       nil)
   else
    (setq leftEndTap       t)
  )
  (if extraRightSpace < minExtraLRspace  then
    (setq extraRightSpace minDiffTapRingSpace)
    (setq rightEndTap       nil)
   else
    (setq rightEndTap       t)
  )
  (setq minDiffTapRingSpace 0.0)
  (when (or layer3WidthD <= 0.0 layer3WidthS <= 0.0)
     (error "pEsdTranImpClass: Class params layer3WidthD or layer3WidthS smaller than 0.0"))
  (setq layer3Width layer3WidthD)
  (when (or layer2WidthD <= 0.0 layer2WidthS <= 0.0)
     (error "pEsdTranImpClass: Class params layer2WidthD or layer2WidthS smaller than 0.0"))
  (setq layer2Width layer2WidthD)
  (when (or tapWidth <= 0.0 tapLay2Width <= 0.0 tapLay3Width <= 0.0)
     (error "pEsdTranImpClass: Class params tapWidth or tapLay2Width or tapLay3Width smaller than 0.0"))
  (when innerRingMetalWidth <= 0.0 
     (error "pEsdTranImpClass: Class params innerRingMetalWidth smaller than 0.0"))
  (setq tapLay2Via1Enc (quotient (difference tapLay2Width via1Width) 2))
  (setq tapLay2Via1Enc (times (fix (plus (quotient tapLay2Via1Enc layer2grid) 1e-6)) layer2grid)) 
  (setq tapLay3Via2Enc (quotient (difference tapLay3Width via2Width) 2))
  (setq tapLay3Via2Enc (times (fix (plus (quotient tapLay3Via2Enc layer3grid) 1e-6)) layer3grid)) 
 )
 (if (and nWellSw thirdRing) then
     (dbCreateProp tcCellView "nWellSw" "boolean" t)
  else
     (setq NwellconnectToIOpad nil)
 )


 ;; make the nets and the terminals that will be used in the cell
 (setq gNet (dbCreateNet tcCellView "g"))
 (dbCreateTerm gNet "g" "input")
 (setq sNet (dbCreateNet tcCellView "s"))
 (dbCreateTerm sNet "s" "inputOutput")
 (setq dNet (dbCreateNet tcCellView "d"))
 (dbCreateTerm dNet "d" "inputOutput")
 (setq irNet (dbCreateNet tcCellView "ir"))
 (dbCreateTerm irNet "ir" "inputOutput")
 (setq orNet (dbCreateNet tcCellView "or"))
 (dbCreateTerm orNet "or" "inputOutput")
 (setq trNet (dbCreateNet tcCellView "tr"))
 (dbCreateTerm trNet "tr" "inputOutput")
 

 (when (flareYamount_in == 0.0)
     (setq flareYamount_in flareYamount)
 )
 
 ;; massage all parameters to their scaled counterparts
 (cond ((equal shrinkPercent 0.0)
	(setq scaleMult 1.0)
      ) 
     (t
      (setq scaleMult (quotient 100.0 (difference 100.0 shrinkPercent)))
      (setq via1PolyGrid (max via1grid polyGrid))

      ;;
      ;; foreach doesn't work as it ought to here.  Another Cadence feature
      ;;
      (foreach sizeAndGrid (list (list 'srcViaGateSpace via1PolyGrid)
				 (list 'drnViaGateSpace via1PolyGrid)
				 (list 'drnViaYspaceRingViaTop via1grid)
				 (list 'drnViaYspaceRingViaBot via1grid)
				 (list 'innerRingTapWidth tapGrid)
				 (list 'outerRingTapWidth tapGrid)
				 (list 'innerRingMetalWidth layer2grid)
				 (list 'via1Via2Space via1grid)
				 (list 'layer2Width layer2grid)
				 (list 'layer3Width layer3grid)
				 (list 'orLayer3Width layer3grid)
				 (list 'minW diffGrid)
				 (list 'maxW diffGrid)
				 (list 'minTotalW diffGrid)
			   )

	  (setq theSize (car sizeAndGrid))
	  (setq theGrid (cadr sizeAndGrid))

	  (setq tempSize (quotient (times (eval theSize) scaleMult) theGrid))
	  (set theSize (times (fix (plus tempSize 0.999)) theGrid))
      )

     ) ;; end massaging the variables to account for the scale
 )

 ;; we want to be able to share the outer guard ring between to pcell
 ;; instances placed side by side.  In order to do this, we need to have
 ;; the contacts in the outer ring centered and on grid.  This might be a
 ;; bit confusing, but this means:
 ;;
 ;;   If the contact is an odd integer multiple of the snap grid, the width of
 ;;   the ring enclosing it must be an odd integer multiple of the snap grid.
 ;;   This will keep the enclosure the same to the inside and outside of the
 ;;   contact.
 ;;
 ;;   If the contact is an even integer multiple of the snap grid, the width
 ;;   of the ring enclosing it must be an even integer multiple of the snap
 ;;   grid.  This will keep the enclosure the same to the inside and outside
 ;;   of the contact.
 ;;
 (foreach kludge (list (list 'orLayer3Width layer3grid via2Width via2grid)
		       (list 'outerRingTapWidth tapGrid via1Width via1grid)
		 )
     (setq tmpOrLayerWidth (nth 0 kludge))
     (setq tmpOrLayerGrid (nth 1 kludge))
     (setq tmpViaWidth (nth 2 kludge))
     (setq tmpViaGrid (nth 3 kludge))

     (setq tempSize (quotient tmpViaWidth tmpViaGrid))
     (cond
	 ((oddp (fix (plus tempSize 0.999)))
	  ;; make sure that tmpOrLayerWidth is an odd multiple of the grid
	  (setq tempSize (quotient (eval tmpOrLayerWidth) tmpOrLayerGrid))
	  (when (evenp (fix (plus tempSize 0.999)))
	      (set tmpOrLayerWidth (plus (eval tmpOrLayerWidth) layer3grid))
	  )
	 )
	 (t
	  ;; make sure that tmpOrLayerWidth is an even multiple of the grid
	  (setq tempSize (quotient (eval tmpOrLayerWidth) tmpOrLayerGrid))
	  (when (oddp (fix (plus tempSize 0.999)))
	      (set tmpOrLayerWidth (plus (eval tmpOrLayerWidth) layer3grid))
	  )
	 )
     )
 )

 ;;
 ;; do sanity checks on the width
 ;; Sub sanity check on width:  It is an integral multiple of the via pitch
 ;;
 (setq via1Pitch (plus via1Width via1Space))
 (setq via2Pitch (plus via2Width via2Space))

 ;; targetRows is a floating point number that represents the number of rows
 ;; of via1's that can fit within the width

 (setq targetRows (quotient (plus w (times -2.0 viaExtDiff) via1Space) via1Pitch))

 ;; rowsOfContacts is an integer version of targetRows
 (setq rowsOfContacts (fix (plus 0.999 targetRows)))

 ;; targetRows and rowsOfContacts must be the same to satisfy the via pitch
 ;; requirement of the ESD transistor
 (when (greaterp (abs (difference rowsOfContacts targetRows)) 1e-4)
     (error "pEsdTranImpClass: w (%f) does not satisfy via pitch requirements.  Try either %f or %f\n" w
	    (plus (times rowsOfContacts via1Pitch) -via1Space (times 2.0 viaExtDiff ))
	    (plus (times (difference rowsOfContacts 1) via1Pitch) -via1Space (times 2.0 viaExtDiff )))
 )

;; (setq rowsOfContacts (difference rowsOfContacts 1))
 
 ;;
 ;; Sub sanity check on width:  It is between the minimum and maximum width
 ;;
 
 (when (lessp (difference w 1e-6) minW )
     (error "pEsdTranImpClass:  w (%f) is less than minimum allowable width per leg (%f)\n" w minW)
 )

 (when (greaterp (difference w 1e-6) maxW )
     (error "pEsdTranImpClass:  w (%f) is greater than maximum allowable width per leg (%f)\n" w maxW)
 )

 (when (lessp (times w m) minTotalW)
     (error "pEsdTranImpClass:  total w (%f) is less than the minimum total width (%f)\n"
	    (times w m) minTotalW)
 )

 ;;
 ;; do a sanity check on the number of legs
 ;;
 (unless (and (null (floatp m)) (numberp m))
     (error "pEsdTranImpClass:  m must be an even integer, not a float\n")
 )

 (when (oddp m)
     (error "pEsdTranImpClass:  m (number of legs) must be an even integer\n")
 )

 ;;
 ;; do a sanity check that the sub-pcells exist
 ;; 1.  verify that the flared gate pcell exists & is a pcell
 ;;
 (setq flaredGateId (dbOpenCellView tcCellView~>lib flaredGateName "symbolic" nil "rn"))
 (unless flaredGateId
     (error "pEsdTranImpClass:  Cannot find/open flared gate %s\n" flaredGateName)
 )
 (unless flaredGateId~>isParamCell
     (error "pEsdTranImpClass:  Flared gate %s is not a pcell\n" flaredGateName)
 )

 ;;
 ;; 2.  verify that the generic ring exists & is a pcell
 ;;
 (setq ringId (dbOpenCellView tcCellView~>lib genericRingName "symbolic" nil "rn"))
 (unless ringId
     (error "pEsdTranImpClass:  Cannot find/open ring %s\n" genericRingName)
 )
 (unless ringId~>isParamCell
     (error "pEsdTranImpClass:  Ring %s is not a pcell\n" genericRingName)
 )

 ;;
 ;; 3.  verify that the riveted ring exists & is a pcell
 ;;
 (setq rivetedRingId (dbOpenCellView tcCellView~>lib rivetedRingName "symbolic" nil "rn"))
 (unless rivetedRingId
     (error "pEsdTranImpClass:  Cannot find/open riveted ring %s\n" rivetedRingName)
 )
 (unless rivetedRingId~>isParamCell
     (error "pEsdTranImpClass:  Riveted ring %s is not a pcell\n" rivetedRingName)
 )

 ;;
 ;; create the diffusion and tap.  Target variables set are:
 ;;   srcViaToSrcTapSpace = the space between a source diffusion via to the
 ;;                         tap in the same source region
 ;;   diffXorigin = the X origin of the diff/tap regions
 ;;   diffYorigin = the Y origin of the diff/tap regions
 ;;   totalDrnLength = the gate to gate length of a drain region
 ;;   totalSrcDiffLength = the gate to gate length of a source region minus
 ;;                        the length of the tap in the source region
 ;;   diffYend = the Y end of the diff/tap regions
 ;;   diffXloop = the X origin of the next diffusion region to draw
 ;;
 (cond
   (splitSource
    (if leftEndTap
     (setq diffXorigin (plus -srcViaGateSpace -extraSrcSpace -via1Width -srcViaToDiffEdgSpace -stripTapToDiffSpace -tapWidth))
     (setq diffXorigin (plus -srcViaGateSpace -extraSrcSpace -via1Width -srcViaToDiffEdgSpace))
    )
    (setq halfSrcDiffLength (plus srcViaGateSpace extraSrcSpace via1Width srcViaToDiffEdgSpace))
    (setq srcViaToSrcTapSpace 0.0)
   )
   (!floatNwell
    (setq srcViaToSrcTapSpace (max 0.0
                                (difference via1Space
                                            (quotient (difference tapWidth via1Width) 2.0))
                                srcViaTapSpace
                                ))
    (setq diffXorigin (plus -tapWidth -srcViaToSrcTapSpace -via1Width -srcViaGateSpace -extraSrcSpace))
    (setq halfSrcDiffLength (plus srcViaGateSpace extraSrcSpace via1Width srcViaToSrcTapSpace))
   )
   (t
    (setq diffXorigin (plus -via1Width -srcViaGateSpace -extraSrcSpace -srcViaToDiffEdgSpace))
    (setq halfSrcDiffLength (plus srcViaGateSpace extraSrcSpace via1Width/2))
   )
 )

 (setq totalDrnLength (plus (times 2.0 (plus drnViaGateSpace extraDrnSpace)) via1Width))
 (setq totalSrcDiffLength (times 2.0 halfSrcDiffLength))
 (setq halfL (quotient l 2.0))

 (setq diffYend w)
 (setq diffYorigin 0.0)
 
 (setq diffImpYend    (plus       diffYend    diffImpEnc))
 (setq diffImpYorigin (difference diffYorigin diffImpEnc))
 
 (if (or splitSource !floatNwell) then
; FIRST TAP
    (setq dbidTapL (dbCreateRect tcCellView tapLayer (list diffXorigin:diffYorigin
						    (plus diffXorigin tapWidth):diffYend)))
    (dbAddFigToNet dbidTapL sNet)
    (setq dbid (dbCreateRect tcCellView tapWellImplant
			  (list (list (difference diffXorigin tapWellImpEnc)
				      (difference diffYorigin tapWellImpEnc)
				      )
				(list (plus diffXorigin tapWidth (if splitSource tapWellImpEnc 0.0))
				      (plus diffYend tapWellImpEnc)
				      )
				)
			  )
    )
    (dbAddFigToNet dbid sNet)
    (setq diffXloop (plus diffXorigin tapWidth stripTapToDiffSpace))
    (when (and splitSource !leftEndTap)
       (dbDeleteObject dbidTapL)
       (dbDeleteObject dbid)
       (setq diffXloop diffXorigin)
    )
       
 else
      (setq dbid (dbCreateRect tcCellView diffLayer (list diffXorigin:diffYorigin
                                                    (plus diffXorigin srcViaToDiffEdgSpace):diffYend)))
      (dbAddFigToNet dbid sNet)
      (setq dbid (dbCreateRect tcCellView diffImplant
                               (list (list (difference diffXorigin diffImpEnc) diffImpYorigin)
                                     (list (plus diffXorigin  srcViaToDiffEdgSpace) diffImpYend))))
      (dbAddFigToNet dbid sNet)
      (setq diffXloop (plus diffXorigin srcViaToDiffEdgSpace))
 )



 ;; draw the middle drains/sources and the last source
 (for section 1 (xquotient m 2)
      (setq srcDiffXend (plus diffXloop halfSrcDiffLength halfL))
      (setq dbid (dbCreateRect tcCellView diffLayer (list diffXloop:diffYorigin
							  srcDiffXend:diffYend)))
      (dbAddFigToNet dbid sNet)
      (setq dbid (dbCreateRect tcCellView diffImplant 
			       (list (list (if splitSource (difference diffXloop diffImpEnc) diffXloop)
                                           diffImpYorigin)
				     (list srcDiffXend diffImpYend))))
      (dbAddFigToNet dbid sNet)
      
   
      
      (setq diffXloop srcDiffXend)

      (setq drnDiffXend (plus diffXloop totalDrnLength l))
      (setq dbid (dbCreateRect tcCellView diffLayer (list diffXloop:diffYorigin
							  drnDiffXend:diffYend)))
      (dbAddFigToNet dbid dNet)
      (setq dbid (dbCreateRect tcCellView diffImplant
			       (list (list diffXloop diffImpYorigin)
				     (list drnDiffXend diffImpYend))))
      (dbAddFigToNet dbid dNet)
 
    
      (setq diffXloop drnDiffXend)

      (setq srcDiffXend (plus diffXloop halfSrcDiffLength halfL))
      (setq dbid (dbCreateRect tcCellView diffLayer (list diffXloop:diffYorigin
							  srcDiffXend:diffYend)))
      (dbAddFigToNet dbid sNet)
      (setq dbid (dbCreateRect tcCellView diffImplant 
			       (list (list diffXloop diffImpYorigin)
				     (list (if splitSource (plus srcDiffXend diffImpEnc) srcDiffXend) 
                                           diffImpYend))))
      (dbAddFigToNet dbid sNet)
      
    (when !floatNwell
; OTHER TAPS
      (setq tapX0 (plus srcDiffXend stripTapToDiffSpace))
      (setq tapX1 (plus tapX0 tapWidth))
      (setq dbidTap (dbCreateRect tcCellView tapLayer (list tapX0:diffYorigin
							 tapX1:diffYend)))
      (dbAddFigToNet dbidTap sNet)
      (cond
       (splitSource
 	 (setq dbid (dbCreateRect tcCellView tapWellImplant
				 (list (list (difference tapX0 tapWellImpEnc)
					     (difference diffYorigin tapWellImpEnc))
				       (list (plus tapX1 tapWellImpEnc)
					     (plus diffYend tapWellImpEnc)))))
       )
       ((equal section (xquotient m 2))
	 ;; implant for last piece meets enclosure
 	 (setq dbid (dbCreateRect tcCellView tapWellImplant
				 (list (list tapX0
					     (difference diffYorigin tapWellImpEnc))
				       (list (plus tapX1 tapWellImpEnc)
					     (plus diffYend tapWellImpEnc)))))
       )
       (t
	 ;; this is drawn the rest of the time
	 (setq dbid (dbCreateRect tcCellView tapWellImplant
				 (list (list tapX0
					     (difference diffYorigin tapWellImpEnc))
				       (list tapX1
					     (plus diffYend tapWellImpEnc)))))
       )
      )
      (dbAddFigToNet dbid sNet)
    )
    (setq diffXloop (plus srcDiffXend tapWidth (times 2 stripTapToDiffSpace)))
 )

 (setq diffXend (difference diffXloop stripTapToDiffSpace))

 ;; remove the last tap if !rightEndTap
 (when (and splitSource !rightEndTap )
   (dbDeleteObject dbidTap)
   (dbDeleteObject dbid)
   (setq diffXloop srcDiffXend)
   (setq diffXend  diffXloop)
 )

 (when floatNwell
      ;; diffXorigin is pushed left by via1Width
      ;; adding via1Width to the right side
      (setq diffXend (plus diffXloop via1Width srcViaToDiffEdgSpace))
      (setq dbid (dbCreateRect tcCellView diffLayer (list diffXloop:diffYorigin
                                                          diffXend:diffYend)))
      (dbAddFigToNet dbid sNet)
      (setq dbid (dbCreateRect tcCellView diffImplant
                               (list (list diffXloop diffImpYorigin)
                                     (list (plus diffXend diffImpEnc) diffImpYend))))
      (dbAddFigToNet dbid sNet)
 )

 ;; draw the id layer (esd) around the diffusion
 (dbCreateRect tcCellView idLayer (list diffXorigin:diffYorigin diffXend:diffYend))

 ;; draw the core Implant  around the diffusion
; DO NOT FORGET TO UPDATE THIS
 (when diffCoreImplant
     (dbCreateRect tcCellView diffCoreImplant (list (plus diffXorigin (plus stripTapToDiffSpace tapWidth) -diffCoreImpEnc) 
						    : (plus diffYorigin -diffCoreImpEnc)
						    
						    (plus diffXend -(plus stripTapToDiffSpace tapWidth) diffCoreImpEnc) 
						    : (plus diffYend diffCoreImpEnc)
					      )
     )
 ) 


 ;;
 ;; create the flared gates
 ;;
 (setq gateXoffset 0.0)
 (for gateNum 1 m

      ;; instantiate the flared gate
      (setq inst (dbCreateParamInst tcCellView flaredGateId (sprintf nil "g%d" gateNum)
				    0.0:0.0 "R0" 1
				    (list (list "gateLayer" "list" nil)
					  (list "gateRecognitionLayer" "list" rgateLayer)
					  (list "w" "float" w)
					  (list "l" "float" l)
					  (list "flareAmount_in" "float" flareYamount_in)
					  (list "flareAmount" "float" flareYamount  )
					  (list "flareExtension" "float" flareYextension)
					  (list "xOffset" "float" gateXoffset)
				    )
		 ))
      (unless inst
	  (error "pEsdTranImpClass:  Failed to create instance of flared gate %s" flaredGateName)
      )

      ;; add the gate to net, and create pins out of the flared regions
      (setq master inst~>master)
      (setq dbid (dbCreateRect tcCellView gateLayer master~>noflarePoints))
      (dbAddFigToNet dbid gNet)

      (setq modelTextX (plus gateXoffset (quotient (difference (caadr master~>noflarePoints) (caar master~>noflarePoints)) 2)))
      (setq modelTextY (quotient (difference (cadadr master~>noflarePoints) (cadar master~>noflarePoints)) 2))
      (dbCreateLabel tcCellView modelTextLayer (list modelTextX modelTextY) modelText "centerCenter" "R0" "stick" modelTextLayerSize)

      (setq dbid (dbCreatePolygon tcCellView gateLayer master~>topFlarePoints))
      (dbAddFigToNet dbid gNet)
      (setq pinid (dbCreatePin gNet dbid))
      (pinid~>accessDir = (list "top"))

      (setq dbid (dbCreatePolygon tcCellView gateLayer master~>bottomFlarePoints))
      (dbAddFigToNet dbid gNet)
      (setq pinid (dbCreatePin gNet dbid))
      (pinid~>accessDir = (list "bottom"))

      ;; add the correct x offset whether the next region is a source or drain
      (cond ((equal (mod gateNum 2) 1)
	     (setq gateXoffset (plus gateXoffset l totalDrnLength))
	    )
	  (t
	   (setq gateXoffset (plus gateXoffset l totalSrcDiffLength tapWidth (times 2 stripTapToDiffSpace)))
	  )
      )
 )

 ;;
 ;; create the contacts
 ;; 1.  calculate the coordinates for the drain contacts
 ;;       these variables will have a "drn_" prefix
 ;;
 ;; 2.  calculate the coordinates for the end source contacts
 ;;       these variables will have a "es_" prefix
 ;;
 ;; 3.  (if needed) calculate the coordinates for the shared source contacts
 ;;       these variables will have a "ss_" prefix
 ;;

 ;; target variables set:  drn_via1Xorigin, drain via1 X origin
 ;;                        drn_via1Xend,    drain via1 X end
 (setq drn_via1Xorigin 0.0)
 (setq drn_via1Xend via1Width)

 ;; calculate the correct L of layer2 for the drain contacts
 ;; target variables set:  drn_layer2L,         length of layer2
 ;;                        drn_layer2DeltaVia1, offset of layer2 from via1
 ;;
 (cond ((greaterp (setq drn_layer2L (plus layer2EncVia1 via1Width layer2EncVia1))
		      (setq drn_layer2La (plus layer2EncVia2 via2Width layer2EncVia2)))
	(setq drn_layer2DeltaVia1 layer2EncVia1)
       )
     (t
      (setq delta (quotient (difference drn_layer2La drn_layer2L) 2.0))
      (setq drn_layer2DeltaVia1 (plus layer2EncVia1 (times (fix (plus 1e-6 (quotient delta layer2grid))) layer2grid)))
      (setq drn_layer2L drn_layer2La)
     )
 )

 ;; calculate the correct W of layer2 (Y values are the same for all contacts)
 ;; target variables set:  layer2W and layer2YDeltaVia1
 ;;
 (setq layer2W (plus (times 2.0 layer2EncVia1) (times rowsOfContacts via1Pitch) -via1Space))
 (setq layer2Wa (difference (times 2.0 layer2EncVia2) via2Space))
 (setq rowsOfContacts2 0)
 (while (lessp (difference layer2Wa 1e-5) layer2W)
     (setq layer2Wa (plus layer2Wa via2Pitch))
     (setq rowsOfContacts2 (plus rowsOfContacts2 1))
 )
 (setq layer2Wa (difference layer2Wa via2Pitch))
 (setq rowsOfContacts2 (difference rowsOfContacts2 1))
 (setq layer2YDeltaVia1 layer2EncVia1)

 ;; calculate the via origins for the left end source  (mirror for the right)
 ;; target variables set:  es_tvia1Xorigin, tap via1 X origin
 ;;                        es_tvia1Xend,    tap via1 X end
 ;;                        es_dvia1Xorigin, diffusion via1 X origin
 ;;                        es_dvia1Xorigin, diffusion via1 X end
 ;;
 (setq es_dvia1Xorigin srcViaToSrcTapSpace)
 (setq es_dvia1Xend (plus es_dvia1Xorigin via1Width))
 (setq es_tvia1Xorigin (difference es_dvia1Xorigin via1Pitch))
 (setq es_tvia1Xend (plus es_tvia1Xorigin via1Width))

 ;; calculate the correct L of layer2 for the end source contacts
 ;; target variables set:  es_layer2L,         length of layer2
 ;;                        es_layer2DeltaVia1, offset of layer2 from via1
 ;;
 (cond ((greaterp (setq es_layer2L (plus (times 2.0 (plus layer2EncVia1 via1Width)) via1Space))
		      (setq es_layer2La (plus (times 2.0 (plus layer2EncVia2 via2Width)) via2Space)))
	(setq es_layer2DeltaVia1 layer2EncVia1)
       )
     (t
      (setq delta (quotient (difference es_layer2La es_layer2L) 2.0))
      (setq es_layer2DeltaVia1 (plus layer2EncVia1 (times (fix (plus 1e-6 (quotient delta layer2grid))) layer2grid)))
      (setq es_layer2L es_layer2La)
     )
 )

 ;; calculate the via2 origins for the left end source
 ;; Target variables set:  es_tvia2Xorigin, tap via2 X origin
 ;;                        es_tvia2Xend,    tap via2 X end
 ;;                        es_dvia2Xorigin, diffusion via2 X origin
 ;;                        es_dvia2Xend,    diffusion via2 X end
 ;;
 (setq es_tvia2Xorigin (difference es_tvia1Xorigin es_layer2DeltaVia1))
 (setq es_tvia2Xend (plus es_tvia2Xorigin via2Width))
 (setq es_dvia2Xorigin (plus es_tvia2Xend via2Space))
 (setq es_dvia2Xend (plus es_dvia2Xorigin via2Width))

 ;; calculate the correct L of layer2 for the shared source contacts
 ;; target variables set:  ss_layer2L,         length of layer2
 ;;                        ss_layer2DeltaVia1, offset of layer2 from via1
 ;;
 (cond ((greaterp (setq ss_layer2L (plus (times 2.0 (plus layer2EncVia1 via1Space)) (times 3.0 via1Width)))
		  (setq ss_layer2La (plus (times 2.0 (plus layer2EncVia2 via2Space)) (times 3.0 via2Width))))
	(setq ss_layer2DeltaVia1 layer2EncVia1)
       )
     (t
      (setq delta (quotient (difference ss_layer2La ss_layer2L) 2.0))
      (setq ss_layer2DeltaVia1 (plus layer2EncVia1 (times (round (plus 1e-6 (quotient delta layer2grid))) layer2grid)))
      (setq ss_layer2L ss_layer2La)
     )
 )
 (if splitSource
   (setq contactXloop (plus diffXorigin srcViaToDiffEdgSpace (if leftEndTap (plus tapWidth stripTapToDiffSpace) 0.0)))
   (setq contactXloop (plus diffXorigin tapWidth))
 )
 (setq via1Yorigin viaExtDiff)
 (setq layer2Yorigin (difference via1Yorigin layer2YDeltaVia1))
 (setq via2Yorigin (plus layer2Yorigin layer2EncVia2))
 (setq layer2Yend (plus layer2Yorigin (times rowsOfContacts via1Pitch) -via1Space (times 2.0 layer2EncVia1)))
 (when splitSource
  (setq tapXoffsetV1 (quotient (difference tapWidth via1Width) 2))
  (setq tapXoffsetV1 (times (fix (plus (quotient tapXoffsetV1 tapGrid) 1e-6)) tapGrid))
  ;; center via2 also
  (setq tapXoffsetV2 (quotient (difference tapWidth via2Width) 2))
  (setq tapXoffsetV2 (times (fix (plus (quotient tapXoffsetV2 tapGrid) 1e-6)) tapGrid))
  ;; via1/2 Y is directed by layer2 
  (setq via1W (difference w (times 2 (plus tapLay2OffsetY layer2EncVia1))))
  ;; 1e-6 added because of opus skill bug: fix() rounds incorrectly
  (setq via1TapRows (max 1 (fix (plus (quotient (plus via1W via1Space) via1Pitch) 1e-6))))
  (setq via1Wa (plus via1Width  (times (difference via1TapRows 1) via1Pitch)))
  (setq via1YOff (max 0.0 (difference via1W via1Wa)))
  (setq via1Yoffset (times (fix (plus (quotient (quotient via1YOff 2) layer2grid) 1e-6)) layer2grid))
  (setq via2W (difference via1W (times 2 (plus tapLay3OffsetY layer3EncVia2))))
  ;; 1e-6 added because of opus skill bug: fix() rounds incorrectly
  (setq via2TapRows (max 1 (fix (plus (quotient (plus via2W via2Space) via2Pitch) 1e-6))))
  (setq via2Wa (plus via2Width  (times (difference via2TapRows 1) via2Pitch)))
  (setq via2YOff (max 0.0 (difference via2W via2Wa)))
  (setq via2Yoffset (times (fix (plus (quotient (quotient via2YOff 2) layer2grid) 1e-6)) layer2grid))

  (setq layer2TapY0 (plus diffYorigin tapLay2OffsetY))
  (setq layer2TapY1 (difference diffYend tapLay2OffsetY))
  (setq via1TapY0 (plus layer2TapY0 layer2EncVia1))
  (setq layer3TapY0 (plus layer2TapY0 tapLay3OffsetY)) 
  (setq layer3TapY1 (difference layer2TapY1 tapLay3OffsetY)) 
  (setq via2TapY0 (plus layer3TapY0 layer3EncVia2 via2Yoffset))
  ;; set parameter to control the length of bevel at 45 degrees
  (setq l2bvlCntrl (quotient layer2WidthD 3.0))
  (setq l2bvlCntrl (times (round (plus (quotient l2bvlCntrl layer2grid) 0.001)) layer2grid))	
  (setq l2bvlCntrlS (quotient layer2WidthS 3.0))
  (setq l2bvlCntrlS (times (round (plus (quotient l2bvlCntrlS layer2grid) 0.001)) layer2grid))	

  (setq l3bvlCntrl (quotient layer3WidthD 3.0))
  (setq l3bvlCntrl (times (round (plus (quotient l3bvlCntrl layer3grid) 0.001)) layer3grid))
  (setq l3bvlCntrlS (quotient layer3WidthS 3.0))
  (setq l3bvlCntrlS (times (round (plus (quotient l3bvlCntrlS layer3grid) 0.001)) layer3grid))
)
 ;; loop through each source/drain region and draw the appropriate contacts
 ;; Determine if this source/drain region is:
 ;;   1.  the left end source region
 ;;   2.  the right end source region
 ;;   3.  the drain regions
 ;;   4.  the shared source regions
 ;;   In all of the 4 cases, it will 
 ;;       1.  draw the via1s
 ;;       2.  draw layer2
 ;;       3.  draw the via2s
 ;;       4.  draw layer3
 ;;
 (for region 0 m

      (setq via1Yloop via1Yorigin)

      ;;
      ;; case 1:  this is the left end source region
      ;;
      (cond ((equal region 0)

	     ;; target variables set:  dvxo, drain via1 X origin
	     ;;                        dvxe, drain via1 X end
	     ;;                        tvxo, tap via1 X origin
	     ;;                        tvxe, tap via1 X end
	     ;;
             (cond
               (splitSource
	        (setq dvxo contactXloop)
	        (setq dvxe (plus dvxo via1Width))
	        (setq tvxo (plus diffXorigin tapXoffsetV1))
	        (setq tvxe (plus tvxo via1Width))
               ) 
               (!floatNwell
	        (setq dvxo (plus contactXloop srcViaToSrcTapSpace))
	        (setq dvxe (plus dvxo via1Width))
	        (setq tvxo (difference dvxo via1Pitch))
	        (setq tvxe (plus tvxo via1Width))
               )
               (t
	        (setq dvxo (plus diffXorigin srcViaToDiffEdgSpace)) 
	        (setq dvxe (plus dvxo via1Width))
                (setq tvxo dvxo)
                (setq tvxe dvxe)
               )
             )

	     ;;
	     ;; 1.  Draw the via1s
	     ;;
	     (for row 1 rowsOfContacts
	       (setq dbid (dbCreateRect tcCellView via1Layer
					   (list dvxo:via1Yloop
						 dvxe:(plus via1Yloop via1Width))))
	       (dbAddFigToNet dbid sNet)
               (when (and !splitSource !floatNwell)
		  (setq dbid (dbCreateRect tcCellView via1Layer
					   (list tvxo:via1Yloop
						 tvxe:(plus via1Yloop via1Width))))
		  (dbAddFigToNet dbid sNet)
               )

	       (setq via1Yloop (plus via1Yloop via1Pitch))
	     )
             (when (and splitSource leftEndTap)
	       (setq via1YloopT (plus via1Yoffset via1TapY0))
	       (for row 1 via1TapRows
	          (setq dbid (dbCreateRect tcCellView via1Layer
					   (list tvxo:via1YloopT
						 tvxe:(plus via1YloopT via1Width))))
		  (dbAddFigToNet dbid sNet)
	          (setq via1YloopT (plus via1YloopT via1Pitch))
               )
             )

	     ;;
	     ;; 2.  Draw layer2
	     ;;
	     (if endTapMetInsideOut then
	       ;; if layer 2 will overlap the gate, pull it back to the edge
	       (setq endTapLayer2XOffset (minus (max (plus tvxo -layer2EncVia1 layer2Width) 0.0)))
	       else
	       (setq endTapLayer2XOffset 0.0)
	       )
	     ;; draw layer2 with width = layer2Width if this parameter is > 0.0
             (if splitSource then
              (if layer2EdgesAt45 then
               (setq layer2Y0d (plus layer2Yorigin -l2bvlCntrlS))
               (setq layer2Y1d layer2Yorigin )
               (setq layer2Y2d (plus via1Yloop -via1Space layer2EncVia1))
               (setq layer2Y3d (plus via1Yloop -via1Space layer2EncVia1 l2bvlCntrlS))
               (setq layer2Y4d (plus via1Yloop -via1Space layer2EncVia1 l2bvlCntrlS))
               (setq layer2Y5d (plus via1Yloop -via1Space layer2EncVia1))
               (setq layer2Y6d layer2Yorigin)
               (setq layer2Y7d (plus layer2Yorigin -l2bvlCntrlS))

               (setq layer2XLenc sourceLay2Via1Enc)
               (setq layer2XRenc (difference layer2WidthS (plus via1Width layer2XLenc)))
               (setq layer2X0d (plus (difference dvxo layer2XLenc) l2bvlCntrlS))
               (setq layer2X1d (difference dvxo layer2XLenc))
               (setq layer2X2d (difference dvxo layer2XLenc))
               (setq layer2X3d (plus (difference dvxo layer2XLenc) l2bvlCntrlS))
               (setq layer2X4d (plus dvxe layer2XRenc -l2bvlCntrlS))
               (setq layer2X5d (plus dvxe layer2XRenc))
               (setq layer2X6d (plus dvxe layer2XRenc))
               (setq layer2X7d (plus dvxe layer2XRenc -l2bvlCntrlS))
               (setq dbid (dbCreatePolygon tcCellView layer2
                                           (list (list layer2X0d layer2Y0d)
                                                 (list layer2X1d layer2Y1d)
                                                 (list layer2X2d layer2Y2d)
                                                 (list layer2X3d layer2Y3d)
                                                 (list layer2X4d layer2Y4d)
                                                 (list layer2X5d layer2Y5d)
                                                 (list layer2X6d layer2Y6d)
                                                 (list layer2X7d layer2Y7d))))
              else
               (setq layer2X0d (difference dvxo sourceLay2Via1Enc))
               (setq layer2X1d (plus layer2X0d layer2WidthS))
               (setq dbid (dbCreateRect tcCellView layer2 (list (list layer2X0d layer2Yorigin) 
                                                                (list layer2X1d layer2Yend))))
              )
              (when leftEndTap
                (setq layer2X0t (difference tvxo tapLay2Via1Enc))
                (setq layer2X1t (plus layer2X0t tapLay2Width))
                (setq dbid (dbCreateRect tcCellView layer2 (list (list layer2X0t layer2TapY0) 
                                                                 (list layer2X1t layer2TapY1))))
              )
             else
	      (if (greaterp layer2Width 0.0) then
	       (if layer2EdgesAt45 then
		 ;; set parameter to control the length of bevel at 45 degrees 
		 (setq l2bvlCntrl (quotient layer2Width 3.0))
		 ;; snap l2bvlCntrl to grid
		 (setq l2bvlCntrl (times (round (plus (quotient l2bvlCntrl layer2grid) 0.001)) layer2grid))	
		 
		 (setq dbid (dbCreatePolygon tcCellView layer2
					     (list (list (plus tvxo -layer2EncVia1 l2bvlCntrl endTapLayer2XOffset)
							 (plus layer2Yorigin -l2bvlCntrl)
							 )
						   (list (plus tvxo -layer2EncVia1 endTapLayer2XOffset) layer2Yorigin)
						   (list (plus tvxo -layer2EncVia1 endTapLayer2XOffset) layer2Yend)
						   (list (plus tvxo -layer2EncVia1 l2bvlCntrl endTapLayer2XOffset)
							 (plus layer2Yend l2bvlCntrl)
							 )
						   (list (plus tvxo 
							       endTapLayer2XOffset
							       -layer2EncVia1
							       (max layer2Width  
								    (plus (times 2.0 via1Width)
									  via2Width
									  via1Via2Space
									  via1Space
									  layer2EncVia1
									  layer2EncVia2)
								    )
							       -l2bvlCntrl
							       )
							 (plus layer2Yend l2bvlCntrl)
							 )
						   (list (plus tvxo
							       endTapLayer2XOffset
							       -layer2EncVia1
							       (max layer2Width
								    (plus (times 2.0 via1Width)
									  via2Width
									  via1Via2Space
									  via1Space
									  layer2EncVia1
									  layer2EncVia2
									  )
								    )
							       )
							 layer2Yend
							 )
						   (list (plus tvxo 
							       endTapLayer2XOffset
							       -layer2EncVia1
							       (max layer2Width
								    (plus (times 2.0 via1Width)
									  via2Width
									  via1Via2Space
									  via1Space
									  layer2EncVia1
									  layer2EncVia2
									  )
								    )
							       )
							 layer2Yorigin
							 )
						   (list (plus tvxo 
							       endTapLayer2XOffset
							       -layer2EncVia1
							       (max layer2Width
								    (plus (times 2.0 via1Width)
									  via2Width
									  via1Via2Space
									  via1Space
									  layer2EncVia1
									  layer2EncVia2
									  )
								    )
							       -l2bvlCntrl
							       )
							 (plus layer2Yorigin -l2bvlCntrl)
							 )
						   )
					     )
		       )
		 else
		 (setq dbid (dbCreateRect tcCellView layer2
					  (list (list (plus tvxo -layer2EncVia1 endTapLayer2XOffset) layer2Yorigin)
						(list (plus tvxo
							    endTapLayer2XOffset
							    -layer2EncVia1
							    (max layer2Width
								 (plus (times 2.0 via1Width)
								       via2Width
								       via1Via2Space
								       via1Space
								       layer2EncVia1
								       layer2EncVia2
								       )
								 )
							    )
						      layer2Yend
						      )
						)
					  )
		       )
		 )
	       else
		 (setq dbid (dbCreateRect tcCellView layer2
					  (list (plus tvxo -es_layer2DeltaVia1):layer2Yorigin
						(plus tvxo -es_layer2DeltaVia1 es_layer2L):layer2Yend)))
	      )
             )

	     (dbAddFigToNet dbid sNet)
		 
	     ;; target variables set:  tvxo, tap via2 X origin
	     ;;                        tvxe, tap via2 X end
	     ;;                        dvxo, diffusion via2 X origin
	     ;;                        dvxe, diffusion via2 X end
	     ;;
             (if splitSource then   
                ; allign via2 with via1 for diff contacts
                (setq dvxo (difference dvxe via2Width))
                (setq dvxe dvxe)
                (setq tvxo (plus diffXorigin tapXoffsetV2))
                (setq tvxe (plus tvxo via2Width))
              else
	       (unless (greaterp via1Via2Space 0.0)
	         (setq tvxo (plus tvxo -es_layer2DeltaVia1 layer2EncVia2))
	         (setq tvxe (plus tvxo via2Width))
	       )
	       (if (greaterp via1Via2Space 0.0) then
	         (setq dvxo (plus dvxe via1Via2Space))
	       else
	         (setq dvxo (plus tvxe via2Space))
	       )
	       (setq dvxe (plus dvxo via2Width))
             )
	     (setq via2Yloop (plus layer2Yorigin layer2EncVia2))
	     
	     ;;
	     ;; 3.  Draw the via2s
	     ;;
	     (for row 1 rowsOfContacts2
		  (setq dbid (dbCreateRect tcCellView via2Layer
					   (list dvxo:via2Yloop
						 dvxe:(plus via2Yloop via2Width))))
		  (dbAddFigToNet dbid sNet)
		  (unless (or splitSource (greaterp via1Via2Space 0.0))
		      (setq dbid (dbCreateRect tcCellView via2Layer
					     (list tvxo:via2Yloop
						   tvxe:(plus via2Yloop via2Width))))
		      (dbAddFigToNet dbid sNet)
		    )
		  (setq via2Yloop (plus via2Yloop via2Pitch))
	     )
             (when (and splitSource leftEndTap)
               (setq via2YloopT via2TapY0)
               (for row 1 via2TapRows
                  (setq dbid (dbCreateRect tcCellView via2Layer
                                           (list tvxo:via2YloopT
                                                 tvxe:(plus via2YloopT via2Width))))
                  (dbAddFigToNet dbid sNet)
                  (setq via2YloopT (plus via2YloopT via2Pitch))
               )
             )
	     
	     ;;
	     ;; 4.  Draw layer3
	     ;;
	     
	     ;; draw layer3 with width = layer3Width_outside if layer3Width_outside > 0 
	     ;;                        = layer3Width if layer3Width > 0
	     (if splitSource then
	      (if layer3EdgesAt45 then
               (setq layer3Y0d (plus layer2Yorigin layer2EncVia2 -layer3EncVia2 -l3bvlCntrlS))
               (setq layer3Y1d (plus layer2Yorigin layer2EncVia2 -layer3EncVia2))
               (setq layer3Y2d (plus via2Yloop -via2Space layer3EncVia2))
               (setq layer3Y3d (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrlS))
               (setq layer3Y4d (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrlS))
               (setq layer3Y5d (plus via2Yloop -via2Space layer3EncVia2))
               (setq layer3Y6d (plus layer2Yorigin layer2EncVia2 -layer3EncVia2))
               (setq layer3Y7d (plus layer2Yorigin layer2EncVia2 -layer3EncVia2 -l3bvlCntrlS))

               (setq layer3XLenc sourceLay3Via2Enc)
               (setq layer3XRenc (difference layer3WidthS (plus via2Width layer3XLenc)))
               (setq layer3X0d (plus (difference dvxo layer3XLenc) l3bvlCntrlS))
               (setq layer3X1d  (difference dvxo layer3XLenc))
               (setq layer3X2d (difference dvxo layer3XLenc))
               (setq layer3X3d (plus (difference dvxo layer3XLenc) l3bvlCntrlS))
               (setq layer3X4d (plus dvxe layer3XRenc -l3bvlCntrlS))
               (setq layer3X5d (plus dvxe layer3XRenc))
               (setq layer3X6d (plus dvxe layer3XRenc))
               (setq layer3X7d (plus dvxe layer3XRenc -l3bvlCntrlS))
               (setq dbid (dbCreatePolygon tcCellView layer3
                                           (list (list layer3X0d layer3Y0d)
                                                 (list layer3X1d layer3Y1d)
                                                 (list layer3X2d layer3Y2d)
                                                 (list layer3X3d layer3Y3d)
                                                 (list layer3X4d layer3Y4d)
                                                 (list layer3X5d layer3Y5d)
                                                 (list layer3X6d layer3Y6d)
                                                 (list layer3X7d layer3Y7d))))
              else
               (setq layer3X0d (difference dvxo sourceLay3Via2Enc))
               (setq layer3X1d (plus layer3X0d layer3WidthS))
               (setq layer3Y0d (plus layer2Yorigin layer2EncVia2 -layer3EncVia2))
               (setq layer3Y1d (plus via2Yloop -via2Space layer3EncVia2))
               (setq dbid (dbCreateRect tcCellView layer3 (list (list layer3X0d layer3Y0d)
                                                                (list layer3X1d layer3Y1d))))
              )
              (when leftEndTap
                 (setq layer3X0t (difference tvxo tapLay3Via2Enc))
                 (setq layer3X1t (plus layer3X0t tapLay3Width))
                 (setq dbid (dbCreateRect tcCellView layer3 (list (list layer3X0t layer3TapY0)
                                                                  (list layer3X1t layer3TapY1))))
              )
             else 
	      (if (greaterp layer3Width 0.0) then
	       (if (greaterp layer3Width_outside 0.0) then
		 (setq widthTobeDrawn (max layer3Width_outside 
					   (plus (times 2.0 via1Width)
						 via2Width
						 via1Space
						 via1Via2Space
						 layer2EncVia1
						 layer3EncVia2
						 )
					   )
		       )
		 else
		 (setq widthTobeDrawn (max layer3Width
					   (plus (times 2.0 via1Width)
						 via2Width
						 via1Space
						 via1Via2Space
						 layer2EncVia1
						 layer3EncVia2
						 )
					   )
		       )
		 )
	       (if endTapMetInsideOut then
		 (setq endTapLayer3XOffset (plus layer2Width -widthTobeDrawn endTapLayer2XOffset))
		 else
		 (setq endTapLayer3XOffset 0.0)
		 )
	       
	       (if layer3EdgesAt45 then
		 ;; set parameter to control the length of bevel at 45 degrees 
		 (setq l3bvlCntrl (quotient widthTobeDrawn 3.0))
		 ;; snap l3bvlCntrl to grid
		 (setq l3bvlCntrl (times (round (plus (quotient l3bvlCntrl layer3grid) 0.001)) layer3grid))
		 
		 (setq dbid 
		       (dbCreatePolygon tcCellView layer3
					  (list (list (plus tvxo -layer2EncVia1 l3bvlCntrl endTapLayer3XOffset)
						      (plus layer2Yorigin layer2EncVia2 -layer3EncVia2 -l3bvlCntrl)
						      )
						(list (plus tvxo -layer2EncVia1 endTapLayer3XOffset)
						      (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
						      )
						(list (plus tvxo -layer2EncVia1 endTapLayer3XOffset)
						      (plus via2Yloop -via2Space layer3EncVia2)
						      )
						(list (plus tvxo -layer2EncVia1 l3bvlCntrl endTapLayer3XOffset)
						      (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrl))
						(list (plus tvxo -layer2EncVia1 widthTobeDrawn 
							    -l3bvlCntrl endTapLayer3XOffset)
						      (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrl))
						(list (plus tvxo -layer2EncVia1 widthTobeDrawn endTapLayer3XOffset)
						      (plus via2Yloop -via2Space layer3EncVia2))
						(list (plus tvxo -layer2EncVia1 widthTobeDrawn endTapLayer3XOffset)
						      (plus layer2Yorigin layer2EncVia2 -layer3EncVia2))
						(list (plus tvxo -layer2EncVia1 widthTobeDrawn 
							    -l3bvlCntrl endTapLayer3XOffset)
						      (plus layer2Yorigin layer2EncVia2 -layer3EncVia2 -l3bvlCntrl)))
					  ))
		 else
		 (setq dbid (dbCreateRect tcCellView layer3
					    (list (list (plus tvxo -layer2EncVia1 endTapLayer3XOffset)
							(plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
							)
						  (list (plus tvxo -layer2EncVia1 widthTobeDrawn endTapLayer3XOffset)
							(plus via2Yloop -via2Space layer3EncVia2)
							)
						  )
					  )
		       )
		 )
	       else
	       (setq dbid 
		     (dbCreateRect tcCellView layer3
				   (list (list (difference tvxo layer3EncVia2)
					       (plus layer2Yorigin layer2EncVia2 -layer3EncVia2))
					 (list (plus dvxe layer3EncVia2)
					       (plus via2Yloop -via2Space layer3EncVia2)))))
	       )
             )
	     (dbAddFigToNet dbid sNet)
	     
	     (setq pinid (dbCreatePin sNet dbid))
	     pinid~>accessDir = (list "top" "bottom" "left")
	    )

	  ;;
	  ;; case 2:  this is the right end source region
	  ;;
	  ((equal region m)

           (if splitSource then
              (setq contactXloop (plus contactXloop via1Width drnViaGateSpace extraDrnSpace
                                       l extraSrcSpace srcViaGateSpace))
            else
              (setq contactXloop (plus contactXloop via1Width drnViaGateSpace extraDrnSpace
                                    l extraSrcSpace srcViaGateSpace via1Width srcViaToSrcTapSpace))
           )
	   ;; target variables set:  dvxo, drain via1 X origin
	   ;;                        dvxe, drain via1 X end
	   ;;                        tvxo, tap via1 X origin
	   ;;                        tvxe, tap via1 X end
	   ;;
           (cond
            (splitSource
	      (setq dvxo contactXloop)
	      (setq dvxe (plus dvxo via1Width))
              (setq tvxo (plus diffXend -tapXoffsetV1 -via1Width))
              (setq tvxe (plus tvxo via1Width))
            )
            (!floatNwell
	      (setq dvxo (plus contactXloop -srcViaToSrcTapSpace -via1Width))
	      (setq dvxe (plus dvxo via1Width))
	      (setq tvxo (plus dvxo via1Pitch))
	      (setq tvxe (plus tvxo via1Width))
            )
            (t
	      (setq dvxo (plus diffXend -via1Width -srcViaToDiffEdgSpace)) 
	      (setq dvxe (plus dvxo via1Width))
	      (setq tvxo dvxo)
	      (setq tvxe dvxe)
            )
           )
	   ;;
	   ;; 1.  draw the via1s
	   ;;
	   (for row 1 rowsOfContacts
		(setq dbid (dbCreateRect tcCellView via1Layer
					 (list dvxo:via1Yloop
					       dvxe:(plus via1Yloop via1Width))))
		(dbAddFigToNet dbid sNet)
               (when (and !splitSource !floatNwell)
		(setq dbid (dbCreateRect tcCellView via1Layer
					 (list tvxo:via1Yloop
					       tvxe:(plus via1Yloop via1Width))))
		(dbAddFigToNet dbid sNet)
               )

		(setq via1Yloop (plus via1Yloop via1Pitch))
	   )
           (when (and splitSource rightEndTap)
             (setq via1YloopT (plus via1Yoffset via1TapY0))
             (for row 1 via1TapRows
                (setq dbid (dbCreateRect tcCellView via1Layer
                                         (list tvxo:via1YloopT
                                               tvxe:(plus via1YloopT via1Width))))
                (dbAddFigToNet dbid sNet)
                (setq via1YloopT (plus via1YloopT via1Pitch))
             )
           )
	   ;;
	   ;; 2.  draw layer2
	   ;;
	   (if endTapMetInsideOut then
	     ;; if layer 2 will overlap the gate, pull it back to the edge
	     (setq endTapLayer2XOffset (max (difference  
					     (plus (times m l)
						   (times (quotient m 2) totalDrnLength)
						   (times (difference (quotient m 2) 1)
							  (plus tapWidth totalSrcDiffLength)
							  )
						   )
					     ;; normal layer2 right edge
					     (plus tvxe layer2EncVia1 -layer2Width)
					     )
					    0.0)
		   )
	     else
	     (setq endTapLayer2XOffset 0.0)
	   )
           (if splitSource then
              (if layer2EdgesAt45 then
               (setq layer2Y0d (plus layer2Yorigin -l2bvlCntrlS))
               (setq layer2Y1d layer2Yorigin )
               (setq layer2Y2d (plus via1Yloop -via1Space layer2EncVia1))
               (setq layer2Y3d (plus via1Yloop -via1Space layer2EncVia1 l2bvlCntrlS))
               (setq layer2Y4d (plus via1Yloop -via1Space layer2EncVia1 l2bvlCntrlS))
               (setq layer2Y5d (plus via1Yloop -via1Space layer2EncVia1))
               (setq layer2Y6d layer2Yorigin)
               (setq layer2Y7d (plus layer2Yorigin -l2bvlCntrlS))

               (setq layer2XRenc sourceLay2Via1Enc)
               (setq layer2XLenc (difference layer2WidthS (plus via2Width layer2XRenc)))
               (setq layer2X0d (plus (difference dvxo layer2XLenc) l2bvlCntrlS))
               (setq layer2X1d (difference dvxo layer2XLenc))
               (setq layer2X2d (difference dvxo layer2XLenc))
               (setq layer2X3d (plus (difference dvxo layer2XLenc) l2bvlCntrlS))
               (setq layer2X4d (plus dvxe layer2XRenc -l2bvlCntrlS))
               (setq layer2X5d (plus dvxe layer2XRenc))
               (setq layer2X6d (plus dvxe layer2XRenc))
               (setq layer2X7d (plus dvxe layer2XRenc -l2bvlCntrlS))

               (setq dbid (dbCreatePolygon tcCellView layer2
                                           (list (list layer2X0d layer2Y0d)
                                                 (list layer2X1d layer2Y1d)
                                                 (list layer2X2d layer2Y2d)
                                                 (list layer2X3d layer2Y3d)
                                                 (list layer2X4d layer2Y4d)
                                                 (list layer2X5d layer2Y5d)
                                                 (list layer2X6d layer2Y6d)
                                                 (list layer2X7d layer2Y7d))))


              else
               (setq layer2X0d (plus dvxe sourceLay2Via1Enc))
               (setq layer2X1d (difference layer2X0d layer2WidthS))
               (setq dbid (dbCreateRect tcCellView layer2 (list (list layer2X1d layer2Yorigin) 
                                                                (list layer2X0d layer2Yend))))
              )
              (when rightEndTap
               (setq layer2X0t (difference tvxo tapLay2Via1Enc))
               (setq layer2X1t (plus layer2X0t tapLay2Width))
               (setq dbid (dbCreateRect tcCellView layer2 (list (list layer2X0t layer2TapY0)
                                                                (list layer2X1t layer2TapY1))))
              )
             else
	     ;; draw layer2 with width = layer2Width if this parameter > 0.0
	     (if (greaterp layer2Width 0.0) then
	      (if layer2EdgesAt45 then
	       (setq dbid (dbCreatePolygon tcCellView layer2
					   (list (list (plus tvxe layer2EncVia1 -l2bvlCntrl endTapLayer2XOffset)
						       (plus layer2Yorigin -l2bvlCntrl)
						       )
						 (list (plus tvxe layer2EncVia1 endTapLayer2XOffset) layer2Yorigin)
						 (list (plus tvxe layer2EncVia1 endTapLayer2XOffset) layer2Yend)
						 (list (plus tvxe layer2EncVia1 -l2bvlCntrl endTapLayer2XOffset) 
						       (plus layer2Yend l2bvlCntrl)
						       )
						 (list (plus tvxe 
							     endTapLayer2XOffset
							     layer2EncVia1
							     -(max layer2Width 
								   (plus (times 2.0 via1Width)
									 via2Width
									 via1Via2Space
									 via1Space
									 layer2EncVia1
									 layer2EncVia2
									 )
								   )
							     l2bvlCntrl
							     )
						       (plus layer2Yend l2bvlCntrl)
						       )
						 (list (plus tvxe 
							     endTapLayer2XOffset
							     layer2EncVia1
							     -(max layer2Width 
								   (plus (times 2.0 via1Width)
									 via2Width
									 via1Via2Space
									 via1Space
									 layer2EncVia1
									 layer2EncVia2
									 )
								   )
							     )
						       layer2Yend
						       )
						 (list (plus tvxe 
							     endTapLayer2XOffset
							     layer2EncVia1
							     -(max layer2Width 
								   (plus (times 2.0 via1Width)
									 via2Width
									 via1Via2Space
									 via1Space
									 layer2EncVia1
									 layer2EncVia2
									 )
								   )
							     )
						       layer2Yorigin
						       )
						 (list (plus tvxe 
							     endTapLayer2XOffset
							     layer2EncVia1
							     -(max layer2Width
								   (plus (times 2.0 via1Width)
									 via2Width
									 via1Via2Space
									 via1Space
									 layer2EncVia1
									 layer2EncVia2
									 )
								   )
							     l2bvlCntrl
							     )
						       (plus layer2Yorigin -l2bvlCntrl))))
		     )
	       else
	       (setq dbid (dbCreateRect tcCellView layer2
					(list (list (plus tvxe layer2EncVia1 endTapLayer2XOffset) layer2Yorigin)
					      (list (plus tvxe 
							  endTapLayer2XOffset
							  layer2EncVia1
							  -(max layer2Width 
								(plus (times 2.0 via1Width)
								      via2Width
								      via1Via2Space
								      via1Space
								      layer2EncVia1
								      layer2EncVia2
								      )
								)
							  )
						    layer2Yend
						    )
					      )
					)
		     )
	       )
	     else
	       (setq dbid (dbCreateRect tcCellView layer2
					(list (plus dvxo -es_layer2DeltaVia1):layer2Yorigin
					      (plus dvxo -es_layer2DeltaVia1 es_layer2L):layer2Yend)))
	    )
           )

	   ;; target variables set:  tvxo, tap via2 X origin
	   ;;                        tvxe, tap via2 X end
	   ;;                        dvxo, diffusion via2 X origin
	   ;;                        dvxe, diffusion via2 X end
	   ;;
           (if splitSource then
                ; allign via2 with via1 for diff contacts
                (setq dvxo dvxo)
                (setq dvxe (plus dvxo via2Width))
                (setq tvxo (plus diffXend -tapXoffsetV2 -via2Width))
                (setq tvxe (plus tvxo via2Width))
            else
	     (if (greaterp via1Via2Space 0.0) then
	       (setq dvxo (difference dvxo (plus via2Width via1Via2Space)))
	      else
	       (setq dvxo (plus dvxo -es_layer2DeltaVia1 layer2EncVia2))
	     )
	     (setq dvxe (plus dvxo via2Width))
	   
	     (unless (greaterp via1Via2Space 0.0)
	       (setq tvxo (plus dvxe via2Space))
	       (setq tvxe (plus tvxo via2Width))
	     )
	   ) 
	   (setq via2Yloop (plus layer2Yorigin layer2EncVia2))
	   
	   ;;
	   ;; 3.  draw the via2s
	   ;;
	   (for row 1 rowsOfContacts2
		(setq dbid (dbCreateRect tcCellView via2Layer
					 (list dvxo:via2Yloop
					       dvxe:(plus via2Yloop via2Width))))
		(dbAddFigToNet dbid sNet)
		(unless (or splitSource (greaterp via1Via2Space 0.0))
		    (setq dbid (dbCreateRect tcCellView via2Layer
					   (list tvxo:via2Yloop
						 tvxe:(plus via2Yloop via2Width))))
		    (dbAddFigToNet dbid sNet)
		  )
		(setq via2Yloop (plus via2Yloop via2Pitch))
	    )
	    (when (and splitSource rightEndTap)
               (setq via2YloopT via2TapY0)
               (for row 1 via2TapRows
                  (setq dbid (dbCreateRect tcCellView via2Layer
                                           (list tvxo:via2YloopT
                                                 tvxe:(plus via2YloopT via2Width))))
                  (dbAddFigToNet dbid sNet)
                  (setq via2YloopT (plus via2YloopT via2Pitch))
               )
            ) 
	   ;;
	   ;; 4.  draw layer3
	   ;;
	   
	   ;; draw layer3 with width = layer3Width_outside if this parameter > 0.0
	   ;;                        = layer3Width if this parameter > 0.0 
             (if splitSource then
              (if layer3EdgesAt45 then
               (setq layer3Y0d (plus layer2Yorigin layer2EncVia2 -layer3EncVia2 -l3bvlCntrlS))
               (setq layer3Y1d (plus layer2Yorigin layer2EncVia2 -layer3EncVia2))
               (setq layer3Y2d (plus via2Yloop -via2Space layer3EncVia2))
               (setq layer3Y3d (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrlS))
               (setq layer3Y4d (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrlS))
               (setq layer3Y5d (plus via2Yloop -via2Space layer3EncVia2))
               (setq layer3Y6d (plus layer2Yorigin layer2EncVia2 -layer3EncVia2))
               (setq layer3Y7d (plus layer2Yorigin layer2EncVia2 -layer3EncVia2 -l3bvlCntrlS))

               (setq layer3XRenc sourceLay3Via2Enc)
               (setq layer3XLenc (difference layer3WidthS (plus via2Width layer3XLenc)))
               (setq layer3X0d (plus (difference dvxo layer3XLenc) l3bvlCntrlS))
               (setq layer3X1d  (difference dvxo layer3XLenc))
               (setq layer3X2d (difference dvxo layer3XLenc))
               (setq layer3X3d (plus (difference dvxo layer3XLenc) l3bvlCntrlS))
               (setq layer3X4d (plus dvxe layer3XRenc -l3bvlCntrlS))
               (setq layer3X5d (plus dvxe layer3XRenc))
               (setq layer3X6d (plus dvxe layer3XRenc))
               (setq layer3X7d (plus dvxe layer3XRenc -l3bvlCntrlS))

               (setq dbid (dbCreatePolygon tcCellView layer3
                                           (list (list layer3X0d layer3Y0d)
                                                 (list layer3X1d layer3Y1d)
                                                 (list layer3X2d layer3Y2d)
                                                 (list layer3X3d layer3Y3d)
                                                 (list layer3X4d layer3Y4d)
                                                 (list layer3X5d layer3Y5d)
                                                 (list layer3X6d layer3Y6d)
                                                 (list layer3X7d layer3Y7d))))
              else
               (setq layer3X0d (plus dvxe sourceLay3Via2Enc))
               (setq layer3X1d (difference layer3X0d layer3WidthS))
               (setq layer3Y0d (plus layer2Yorigin layer2EncVia2 -layer3EncVia2))
               (setq layer3Y1d (plus via2Yloop -via2Space layer3EncVia2))
               (setq dbid (dbCreateRect tcCellView layer3 (list (list layer3X1d layer3Y0d)
                                                                (list layer3X0d layer3Y1d))))
              )
              (when rightEndTap
                (setq layer3X0t (difference tvxo tapLay3Via2Enc))
                (setq layer3X1t (plus layer3X0t tapLay3Width))
                (setq dbid (dbCreateRect tcCellView layer3 (list (list layer3X0t layer3TapY0)
                                                                  (list layer3X1t layer3TapY1))))
              )
             else
	     (if (greaterp layer3Width 0.0) then
	      (if (greaterp layer3Width_outside 0.0) then 
	       (setq widthTobeDrawn (max layer3Width_outside 
					 (plus (times 2.0 via1Width)
					       via2Width
					       via1Space
					       via1Via2Space
					       layer2EncVia1
					       layer3EncVia2)))
	       else
	       (setq widthTobeDrawn (max layer3Width 
					 (plus (times 2.0 via1Width)
					       via2Width
					       via1Space
					       via1Via2Space
					       layer2EncVia1
					       layer3EncVia2)))
	       )
	     
	     (if endTapMetInsideOut then
	       (setq endTapLayer3XOffset (plus -layer2Width widthTobeDrawn endTapLayer2XOffset))
	       else
	       (setq endTapLayer3XOffset 0.0)
	       )
	     
	     (if layer3EdgesAt45 then
	       ;; set parameter to control the length of bevel at 45 degrees 
	       (setq l3bvlCntrl (quotient widthTobeDrawn 3.0))
	       ;; snap l3bvlCntrl to grid
	       (setq l3bvlCntrl (times (round (plus (quotient l3bvlCntrl layer3grid) 0.001)) layer3grid))
	       
	       (setq dbid (dbCreatePolygon tcCellView layer3
					   (list (list (plus tvxe 
							     layer2EncVia1
							     -widthTobeDrawn
							     l3bvlCntrl
							     endTapLayer3XOffset
							     )
						       (plus layer2Yorigin
							     layer2EncVia2
							     -layer3EncVia2
							     -l3bvlCntrl
							     )
						       )
						 (list (plus tvxe layer2EncVia1 -widthTobeDrawn endTapLayer3XOffset)
						       (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
						       )
						 (list (plus tvxe layer2EncVia1 -widthTobeDrawn endTapLayer3XOffset)
						       (plus via2Yloop -via2Space layer3EncVia2)
						       )
						 (list (plus tvxe layer2EncVia1 -widthTobeDrawn 
							     l3bvlCntrl endTapLayer3XOffset)
						       (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrl)
						       )
						 (list (plus tvxe layer2EncVia1 -l3bvlCntrl endTapLayer3XOffset)
						       (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrl)
						       )
						 (list (plus tvxe layer2EncVia1 endTapLayer3XOffset)
						       (plus via2Yloop -via2Space layer3EncVia2)
						       )
						 (list (plus tvxe layer2EncVia1 endTapLayer3XOffset)
						       (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
						       )
						 (list (plus tvxe layer2EncVia1 -l3bvlCntrl endTapLayer3XOffset)
						       (plus layer2Yorigin layer2EncVia2 -layer3EncVia2 -l3bvlCntrl)
						       )
						 )
					   )
		     )
	       else
	       (setq dbid (dbCreateRect tcCellView layer3
					(list (list (plus tvxe layer2EncVia1 -widthTobeDrawn endTapLayer3XOffset)
						    (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
						    )
					      (list (plus tvxe layer2EncVia1 endTapLayer3XOffset)
						    (plus via2Yloop -via2Space layer3EncVia2)
						    )
					      )
					)
		     )
	       )
	     else
	     (setq dbid (dbCreateRect tcCellView layer3
				      (list (difference dvxo layer3EncVia2):(plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
					    (plus tvxe layer3EncVia2):(plus via2Yloop -via2Space layer3EncVia2))))
	     )
           )
	   (dbAddFigToNet dbid sNet)
	   
	   (setq pinid (dbCreatePin sNet dbid))
	   pinid~>accessDir = (list "top" "bottom" "right")
	   
	  )

	  ;;
	  ;; case 3:  this is a drain region
	  ;;
	  ((or floatNwell (equal 1 (mod region 2)))  
           (if !floatNwell then
              (if splitSource then
                (setq contactXloop (plus contactXloop via1Width srcViaGateSpace extraSrcSpace
                                         l drnViaGateSpace extraDrnSpace))
               else
                (setq contactXloop (plus contactXloop srcViaToSrcTapSpace via1Width srcViaGateSpace
                                       extraSrcSpace l extraDrnSpace drnViaGateSpace))
              )
            else
              (if (equal region 1) then
	          (setq contactXloop (plus contactXloop srcViaGateSpace extraSrcSpace
                                           l extraDrnSpace drnViaGateSpace via1Width srcViaToDiffEdgSpace ))
               else
                  (setq contactXloop (plus contactXloop drnViaGateSpace extraDrnSpace 
                                           l extraSrcSpace srcViaGateSpace via1Width ))
              )

           )

	   ;; target variables set:  dvxo, diffusion via2 X origin
	   ;;                        dvxe, diffusion via2 X end
	   ;;
	   (setq dvxo contactXloop)
	   (setq dvxe (plus dvxo via1Width))

	   ;;
	   ;; 1.  draw the via1s
	   ;;
	   (for row 1 rowsOfContacts
		(setq dbid (dbCreateRect tcCellView via1Layer
					 (list dvxo:via1Yloop
					       dvxe:(plus via1Yloop via1Width))))
		(dbAddFigToNet dbid dNet)
		(setq via1Yloop (plus via1Yloop via1Pitch))
	   )

	   ;;
	   ;; 2.  draw layer2
	   ;;
	   (if (greaterp layer2Width 0.0) then
	       (if (greaterp layer2Width (plus (times 2.0 via1Via2Space) 
					       (times 2.0 via2Width)
					       via1Width
					       (times 2.0 layer2EncVia2))) then
		 (setq layer2Xorigin_dr (difference dvxo (times (difference layer2Width via1Width) 0.5)))
		 ;; make sure layer2Xorigin_dr is on grid
		 (setq layer2Xorigin_dr (times (round (plus (quotient layer2Xorigin_dr layer2grid) 0.001)) layer2grid))
		 (if layer2EdgesAt45 then
		   (setq dbid (dbCreatePolygon tcCellView layer2
					       (list (list (plus layer2Xorigin_dr l2bvlCntrl)
							   (plus layer2Yorigin -l2bvlCntrl)
							   )
						     (list layer2Xorigin_dr layer2Yorigin)
						     (list layer2Xorigin_dr layer2Yend)
						     (list (plus layer2Xorigin_dr l2bvlCntrl)
							   (plus layer2Yend l2bvlCntrl)
							   )
						     (list (plus layer2Xorigin_dr layer2Width -l2bvlCntrl)
							   (plus layer2Yend l2bvlCntrl)
							   )
						     (list (plus layer2Xorigin_dr layer2Width) layer2Yend)
						     (list (plus layer2Xorigin_dr layer2Width) layer2Yorigin)
						     (list (plus layer2Xorigin_dr layer2Width -l2bvlCntrl)
							   (plus layer2Yorigin -l2bvlCntrl)
							   )
						     )
					       )
			 )
		   else
		   (setq dbid (dbCreateRect tcCellView layer2
					    (list (list layer2Xorigin_dr layer2Yorigin)
						  (list (plus layer2Xorigin_dr layer2Width) layer2Yend)
						  )
					    )
			 )
		   )
		 else
		 (if layer2EdgesAt45 then
		   (setq dbid (dbCreatePolygon tcCellView layer2
					       (list (list (plus (difference dvxo 
									     (plus via1Via2Space
										   via2Width
										   layer2EncVia2
										   )
									     )
								 l2bvlCntrl)
							   (plus layer2Yorigin -l2bvlCntrl)
							   )
						     (list (difference dvxo 
								       (plus via1Via2Space
									     via2Width
									     layer2EncVia2
									     )
								       )
							   layer2Yorigin
							   )
						     (list (difference dvxo 
								       (plus via1Via2Space
									     via2Width
									     layer2EncVia2
									     )
								       )
							   layer2Yend
							   )
						     (list (plus (difference dvxo
									     (plus via1Via2Space
										   via2Width
										   layer2EncVia2
										   )
									     )
								 l2bvlCntrl)
							   (plus layer2Yend l2bvlCntrl)
							   )
						     (list (plus dvxe 
								 via1Via2Space
								 via2Width
								 layer2EncVia2
								 -l2bvlCntrl
								 )
							   (plus layer2Yend l2bvlCntrl)
							   )
						     (list (plus dvxe 
								 via1Via2Space
								 via2Width
								 layer2EncVia2
								 )
							   layer2Yend
							   )
						     (list (plus dvxe via1Via2Space via2Width layer2EncVia2)
							   layer2Yorigin
							   )
						     (list (plus dvxe via1Via2Space via2Width layer2EncVia2 -l2bvlCntrl)
							   (plus layer2Yorigin -l2bvlCntrl)
							   )
						     )
					       )
			 )
		   else
		   (setq dbid (dbCreateRect tcCellView layer2
					    (list (list (difference dvxo 
								    (plus via1Via2Space
									  via2Width
									  layer2EncVia2
									  )
								    )
							layer2Yorigin
							)
						  (list (plus dvxe 
							      via1Via2Space
							      via2Width
							      layer2EncVia2
							      )
							layer2Yend
							)						  )
					    )
			 )
		   )
		 )
	    else
	       (setq dbid (dbCreateRect tcCellView layer2
					(list (difference dvxo drn_layer2DeltaVia1):layer2Yorigin
					      (plus dvxe drn_layer2DeltaVia1):layer2Yend)))
	   )
	   (dbAddFigToNet dbid dNet)
	   
	   ;; target variables set:  dvxo, diffusion via2 X origin
	   ;;                        dvxe, diffusion via2 X end
	   ;;
	   (if (greaterp via1Via2Space 0.0) then
	     (setq dvxo (plus dvxo -via1Via2Space -via2Width))
	     else
	     (setq dvxo (plus dvxo -drn_layer2DeltaVia1 layer2EncVia2))
	     )
	   (setq dvxe (plus dvxo via2Width))
	   (setq via2Yloop (plus layer2Yorigin layer2EncVia2))
	   
	   ;;
	   ;; 3.  draw the via2s
	   ;;
	   (for row 1 rowsOfContacts2
		(setq dbid (dbCreateRect tcCellView via2Layer
					 (list dvxo:via2Yloop
					       dvxe:(plus via2Yloop via2Width))))
		(dbAddFigToNet dbid dNet)
		
		(when (greaterp via1Via2Space 0.0) 
		  (setq dbid (dbCreateRect tcCellView via2Layer
					   (list (plus dvxo (times 2.0 via1Via2Space) via1Width via2Width):via2Yloop
						 (plus dvxo (times 2.0 via1Via2Space) via1Width (times 2.0 via2Width)):(plus via2Yloop via2Width))))
		  (dbAddFigToNet dbid dNet)
		  )
		
		(setq via2Yloop (plus via2Yloop via2Pitch))
		)
	   
	   ;;
	   ;; 4.  draw layer3
	   ;;
	   
	   ;; draw layer3 with width = layer3Width if this parameter > 0.0
	   (if (greaterp layer3Width 0.0) then
	     ;; set parameter to control the length of bevel at 45 degrees 
	     (setq l3bvlCntrl (quotient layer3Width 3.0))
	     ;; snap l3bvlCntrl to grid
	     (setq l3bvlCntrl (times (round (plus (quotient l3bvlCntrl layer2grid) 0.001)) layer2grid))
	     
	     (if (greaterp layer3Width (plus (times 2.0 via2Width) via1Width (times 2.0 via1Via2Space) (times 2.0 layer3EncVia2))) then
	       (setq layer3Xorigin_dr (difference contactXloop (times (difference layer3Width via2Width) 0.5)))
	       ;; make sure layer3Xorigin_dr is on grid
	       (setq layer3Xorigin_dr (times (round (plus (quotient layer3Xorigin_dr layer3grid) 0.001)) layer3grid)) 
	       (if layer3EdgesAt45 then
		 (setq dbid (dbCreatePolygon tcCellView layer3
					     (list (list (plus layer3Xorigin_dr l3bvlCntrl)
							 (plus layer2Yorigin layer2EncVia2 -layer3EncVia2 -l3bvlCntrl)
							 )
						   (list layer3Xorigin_dr
							 (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
							 )
						   (list layer3Xorigin_dr
							 (plus via2Yloop -via2Space layer3EncVia2)
							 )
						   (list (plus layer3Xorigin_dr l3bvlCntrl)
							 (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrl)
							 )
						   (list (plus layer3Xorigin_dr layer3Width -l3bvlCntrl)
							 (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrl)
							 )
						   (list (plus layer3Xorigin_dr layer3Width)
							 (plus via2Yloop -via2Space layer3EncVia2)
							 )
						   (list (plus layer3Xorigin_dr layer3Width)
							 (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
							 )
						   (list (plus layer3Xorigin_dr layer3Width -l3bvlCntrl)
							 (plus layer2Yorigin layer2EncVia2 -layer3EncVia2 -l3bvlCntrl)
							 )
						   )
					     )
		       )
		 else
		 (setq dbid (dbCreateRect tcCellView layer3
					  (list (list layer3Xorigin_dr
						      (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
						      )
						(list (plus layer3Xorigin_dr layer3Width)
						      (plus via2Yloop -via2Space layer3EncVia2)
						      )
						)
					  )
		       )
		 )
	       else
	       (if layer3EdgesAt45 then
		 (setq dbid (dbCreatePolygon tcCellView layer3
					     (list (list (plus dvxo -layer3EncVia2 l3bvlCntrl)
							 (plus layer2Yorigin layer2EncVia2 -layer3EncVia2 -l3bvlCntrl)
							 )
						   (list (plus dvxo -layer3EncVia2)
							 (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
							 )
						   (list (plus dvxo -layer3EncVia2)
							 (plus via2Yloop -via2Space layer3EncVia2)
							 )
						   (list (plus dvxo -layer3EncVia2 l3bvlCntrl)
							 (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrl)
							 )
						   (list (plus dvxo 
							       (times 2.0 via2Width)
							       via1Width
							       (times 2.0 via1Via2Space)
							       layer3EncVia2
							       -l3bvlCntrl
							       )
							 (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrl)
							 )
						   (list (plus dvxo 
							       (times 2.0 via2Width)
							       via1Width
							       (times 2.0 via1Via2Space)
							       layer3EncVia2
							       )
							 (plus via2Yloop -via2Space layer3EncVia2)
							 )
						   (list (plus dvxo
							       (times 2.0 via2Width)
							       via1Width
							       (times 2.0 via1Via2Space)
							       layer3EncVia2
							       )
							 (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
							 )
						   (list (plus dvxo 
							       (times 2.0 via2Width)
							       via1Width
							       (times 2.0 via1Via2Space)
							       layer3EncVia2
							       -l3bvlCntrl
							       )
							 (plus layer2Yorigin layer2EncVia2 -layer3EncVia2 -l3bvlCntrl)
							 )
						   )
					     )
		       )
		 else
		 (setq dbid (dbCreateRect tcCellView layer3
					  (list (list (plus dvxo -layer3EncVia2)
							 (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
							 )
						(list (plus dvxo 
							    (times 2.0 via2Width)
							    via1Width
							    (times 2.0 via1Via2Space)
							    layer3EncVia2
							    )
						      (plus via2Yloop -via2Space layer3EncVia2)
						      )
						)
					  )
		       )
		 )
	       )
	     else
	     (setq dbid (dbCreateRect tcCellView layer3
				      (list (difference dvxo layer3EncVia2):(plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
					    (plus dvxe layer3EncVia2):(plus via2Yloop -via2Space layer3EncVia2))))
	     )
	   (dbAddFigToNet dbid dNet)
	   
	   (setq pinid (dbCreatePin dNet dbid))
	   pinid~>accessDir = (list "top" "bottom")
	  )

	  ;;
	  ;; case 4:  this is a shared source region
	  ;;
	  (!floatNwell

	   ;; target variables set:  rdvxo, right diffusion x origin
	   ;;                        rdvxe, right diffusion x end
	   ;;                        tvxo,  center tap via2 X origin
	   ;;                        tvxe,  center tap via2 X end
	   ;;                        ldvxo, left diffusion via2 X origin
	   ;;                        ldvxe, left diffusion via2 X end
	   ;;
           (if splitSource then
             (setq ldvxo (plus contactXloop  via1Width drnViaGateSpace extraDrnSpace l srcViaGateSpace extraSrcSpace))
	     (setq ldvxe (plus ldvxo via1Width))
             (setq tvxo (plus ldvxe srcViaToDiffEdgSpace stripTapToDiffSpace tapXoffsetV1))
	     (setq tvxe (plus tvxo via1Width))
	     (setq rdvxo (plus ldvxe tapWidth (times 2 (plus stripTapToDiffSpace srcViaToDiffEdgSpace))))
	     (setq rdvxe (plus rdvxo via1Width))
             (setq contactXloop rdvxo)
            else
             (setq contactXloop (plus contactXloop via1Width drnViaGateSpace extraDrnSpace
                                      l extraSrcSpace srcViaGateSpace via1Width srcViaToSrcTapSpace tapWidth))
             (setq rdvxo (plus contactXloop srcViaToSrcTapSpace))
             (setq rdvxe (plus rdvxo via1Width))
	     (if (greaterp tapWidth (plus via1Width (times 2.0 tapEncVia1))) then
	         (setq tvxo (difference (difference (difference rdvxo 
							      (times 0.5 (difference tapWidth via1Width))
							      ) via1Width) srcViaTapSpace))
	         ;; snap this to grid
	         (setq tvxo (times (round (plus (quotient tvxo via1grid) 0.001)) via1grid))
	      else
	         (setq tvxo (plus rdvxo -via1Pitch))
	     )
	     (setq tvxe (plus tvxo via1Width))
	     (setq ldvxo (min (plus tvxo -via1Pitch) (plus contactXloop -tapWidth -via1Width -srcViaTapSpace)))
	     (setq ldvxe (plus ldvxo via1Width))
           )

	   ;;
	   ;; 1.  Draw the via1s
	   ;;
	   (for row 1 rowsOfContacts
                (when !splitSource
		  (setq dbid (dbCreateRect tcCellView via1Layer
		  			 (list tvxo:via1Yloop
					       tvxe:(plus via1Yloop via1Width))))
		  (dbAddFigToNet dbid sNet)
                )
		(setq dbid (dbCreateRect tcCellView via1Layer
					 (list rdvxo:via1Yloop
					       rdvxe:(plus via1Yloop via1Width))))
		(dbAddFigToNet dbid sNet)
		(setq dbid (dbCreateRect tcCellView via1Layer
					 (list ldvxo:via1Yloop
					       ldvxe:(plus via1Yloop via1Width))))
		(dbAddFigToNet dbid sNet)

		(setq via1Yloop (plus via1Yloop via1Pitch))
	   )
           (when splitSource
                (setq via1YloopT (plus via1Yoffset via1TapY0))
                (for row 1 via1TapRows
                  (setq dbid (dbCreateRect tcCellView via1Layer
                                           (list tvxo:via1YloopT
                                                 tvxe:(plus via1YloopT via1Width))))
                  (dbAddFigToNet dbid sNet)
                  (setq via1YloopT (plus via1YloopT via1Pitch))
                )
           )

	   ;;
	   ;; 2.  Draw layer2
	   ;;
           (if splitSource then
             (if layer2EdgesAt45 then
               (setq layer2Y0d (plus layer2Yorigin -l2bvlCntrlS))
               (setq layer2Y1d layer2Yorigin )
               (setq layer2Y2d (plus via1Yloop -via1Space layer2EncVia1))
               (setq layer2Y3d (plus via1Yloop -via1Space layer2EncVia1 l2bvlCntrlS))
               (setq layer2Y4d (plus via1Yloop -via1Space layer2EncVia1 l2bvlCntrlS))
               (setq layer2Y5d (plus via1Yloop -via1Space layer2EncVia1))
               (setq layer2Y6d layer2Yorigin)
               (setq layer2Y7d (plus layer2Yorigin -l2bvlCntrlS))

               (setq layer2XLenc sourceLay2Via1Enc)
               (setq layer2XRenc (difference layer2WidthS (plus via1Width layer2XLenc)))
               (setq layer2X0rd (plus (difference rdvxo layer2XLenc) l2bvlCntrlS))
               (setq layer2X1rd (difference rdvxo layer2XLenc))
               (setq layer2X2rd (difference rdvxo layer2XLenc))
               (setq layer2X3rd (plus (difference rdvxo layer2XLenc) l2bvlCntrlS))
               (setq layer2X4rd (plus rdvxe layer2XRenc -l2bvlCntrlS))
               (setq layer2X5rd (plus rdvxe layer2XRenc))
               (setq layer2X6rd (plus rdvxe layer2XRenc))
               (setq layer2X7rd (plus rdvxe layer2XRenc -l2bvlCntrlS))

               (setq layer2XRenc sourceLay2Via1Enc)
               (setq layer2XLenc (difference layer2WidthS (plus via2Width layer2XRenc)))
               (setq layer2X0ld (plus (difference ldvxo layer2XLenc) l2bvlCntrlS))
               (setq layer2X1ld (difference ldvxo layer2XLenc))
               (setq layer2X2ld (difference ldvxo layer2XLenc))
               (setq layer2X3ld (plus (difference ldvxo layer2XLenc) l2bvlCntrlS))
               (setq layer2X4ld (plus ldvxe layer2XRenc -l2bvlCntrlS))
               (setq layer2X5ld (plus ldvxe layer2XRenc))
               (setq layer2X6ld (plus ldvxe layer2XRenc))
               (setq layer2X7ld (plus ldvxe layer2XRenc -l2bvlCntrlS))

               (setq dbid (dbCreatePolygon tcCellView layer2
                                           (list (list layer2X0rd layer2Y0d)
                                                 (list layer2X1rd layer2Y1d)
                                                 (list layer2X2rd layer2Y2d)
                                                 (list layer2X3rd layer2Y3d)
                                                 (list layer2X4rd layer2Y4d)
                                                 (list layer2X5rd layer2Y5d)
                                                 (list layer2X6rd layer2Y6d)
                                                 (list layer2X7rd layer2Y7d))))
               (setq dbid (dbCreatePolygon tcCellView layer2
                                           (list (list layer2X0ld layer2Y0d)
                                                 (list layer2X1ld layer2Y1d)
                                                 (list layer2X2ld layer2Y2d)
                                                 (list layer2X3ld layer2Y3d)
                                                 (list layer2X4ld layer2Y4d)
                                                 (list layer2X5ld layer2Y5d)
                                                 (list layer2X6ld layer2Y6d)
                                                 (list layer2X7ld layer2Y7d))))
              else

               (setq layer2X0ld (plus ldvxe sourceLay2Via1Enc))
               (setq layer2X1ld (difference layer2X0ld layer2WidthS))
               (setq dbid (dbCreateRect tcCellView layer2 (list (list layer2X1ld layer2Yorigin)
                                                                (list layer2X0ld layer2Yend))))
               (setq layer2X0rd (difference rdvxo sourceLay2Via1Enc))
               (setq layer2X1rd (plus  layer2X0rd layer2WidthS))
               (setq dbid (dbCreateRect tcCellView layer2 (list (list layer2X0rd layer2Yorigin)
                                                                (list layer2X1rd layer2Yend))))
             )
             (setq layer2X0t (difference tvxo tapLay2Via1Enc))
             (setq layer2X1t (plus layer2X0t tapLay2Width))
             (setq dbid (dbCreateRect tcCellView layer2 (list (list layer2X0t layer2TapY0)
                                                              (list layer2X1t layer2TapY1))))
            else
	     (if (greaterp layer2Width 0.0) then
	      (if layer2EdgesAt45 then
	       (setq dbid (dbCreatePolygon tcCellView layer2
					   (list (list (plus (difference ldvxo 
									 (plus via1Via2Space
									       via2Width
									       layer2EncVia2
									       )
									 )
							     l2bvlCntrl
							     )
						       (plus layer2Yorigin -l2bvlCntrl)
						       )
						 (list (difference ldvxo 
								   (plus via1Via2Space via2Width layer2EncVia2)
								   )
						       layer2Yorigin
						       )
						 (list (difference ldvxo 
								   (plus via1Via2Space via2Width layer2EncVia2)
								   )
						       layer2Yend
						       )
						 (list (plus (difference ldvxo 
									 (plus via1Via2Space via2Width layer2EncVia2)
									 )
							     l2bvlCntrl
							     )
						       (plus layer2Yend l2bvlCntrl)
						       )
						 (list (plus rdvxe via1Via2Space via2Width layer2EncVia2 -l2bvlCntrl)
						       (plus layer2Yend l2bvlCntrl)
						       )
						 (list (plus rdvxe via1Via2Space via2Width layer2EncVia2)
						       layer2Yend
						       )
						 (list (plus rdvxe via1Via2Space via2Width layer2EncVia2)
						       layer2Yorigin
						       )
						 (list (plus rdvxe via1Via2Space via2Width layer2EncVia2 -l2bvlCntrl)
						       (plus layer2Yorigin -l2bvlCntrl)))))
	       else
	       (setq dbid (dbCreateRect tcCellView layer2
					(list (list (difference ldvxo 
								(plus via1Via2Space via2Width layer2EncVia2)
								)
						    layer2Yorigin
						    )
					      (list (plus rdvxe via1Via2Space via2Width layer2EncVia2)
						    layer2Yend
						    )
					      )
					)
		     )
	       )
	    else
	       (setq dbid (dbCreateRect tcCellView layer2
					(list (difference ldvxo ss_layer2DeltaVia1):layer2Yorigin
					      (plus ldvxo -ss_layer2DeltaVia1 ss_layer2L):layer2Yend)))
	    )
           )
	   (dbAddFigToNet dbid sNet)

	   ;; target variables set:  rdvxo, right diffusion x origin
	   ;;                        rdvxe, right diffusion x end
	   ;;                        tvxo,  center tap via2 X origin
	   ;;                        tvxe,  center tap via2 X end
	   ;;                        ldvxo, left diffusion via2 X origin
	   ;;                        ldvxe, left diffusion via2 X end
	   ;;
           (if splitSource then
             (setq ldvxo ldvxo)
             (setq ldvxe (plus ldvxo via2Width))
             (setq rdvxo (difference rdvxe via2Width))
             (setq rdvxe (plus rdvxo via2Width))
             (setq tvxo (difference contactXloop (plus stripTapToDiffSpace via2Width tapXoffsetV2 srcViaToDiffEdgSpace)))
             (setq tvxe (plus tvxo via2Width))
            else
	     (if (greaterp via1Via2Space 0.0) then
	       (setq ldvxo (plus ldvxo -via1Via2Space -via2Width))
	     else
	       (setq ldvxo (plus ldvxo -ss_layer2DeltaVia1 layer2EncVia2))
	     )
	     (setq ldvxe (plus ldvxo via2Width))
	     (setq tvxo (plus ldvxe via2Space))
	     (setq tvxe (plus tvxo via2Width))
	     (if (greaterp via1Via2Space 0.0) then
	       (setq rdvxo (plus rdvxe via1Via2Space))
	     else
	       (setq rdvxo (plus tvxe via2Space))
	     )
	     (setq rdvxe (plus rdvxo via2Width))
	   ) 
	   (setq via2Yloop (plus layer2Yorigin layer2EncVia2))
	   ;;
	   ;; 3.  Draw the via2s
	   ;;
	   (for row 1 rowsOfContacts2
	      (setq dbid (dbCreateRect tcCellView via2Layer
					 (list ldvxo:via2Yloop
					       ldvxe:(plus via2Yloop via2Width))))
	      (dbAddFigToNet dbid sNet)
	      (unless (or splitSource (greaterp via1Via2Space 0.0))
		  (setq dbid (dbCreateRect tcCellView via2Layer
					   (list tvxo:via2Yloop
						 tvxe:(plus via2Yloop via2Width))))
		  (dbAddFigToNet dbid sNet)
		)
	      (setq dbid (dbCreateRect tcCellView via2Layer
					 (list rdvxo:via2Yloop
					       rdvxe:(plus via2Yloop via2Width))))
	      (dbAddFigToNet dbid sNet)
	      (setq via2Yloop (plus via2Yloop via2Pitch))
           )
           (when splitSource
               (setq via2YloopT via2TapY0)
               (for row 1 via2TapRows
                  (setq dbid (dbCreateRect tcCellView via2Layer
                                           (list tvxo:via2YloopT
                                                 tvxe:(plus via2YloopT via2Width))))
                  (dbAddFigToNet dbid sNet)
                  (setq via2YloopT (plus via2YloopT via2Pitch))
               )
           )
	   
	   ;;
	   ;; 4.  Draw layer3
	   ;;
           (if splitSource then
             (if layer3EdgesAt45 then
               (setq layer3Y0d (plus layer2Yorigin layer2EncVia2 -layer3EncVia2 -l3bvlCntrlS))
               (setq layer3Y1d (plus layer2Yorigin layer2EncVia2 -layer3EncVia2))
               (setq layer3Y2d (plus via2Yloop -via2Space layer3EncVia2))
               (setq layer3Y3d (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrlS))
               (setq layer3Y4d (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrlS))
               (setq layer3Y5d (plus via2Yloop -via2Space layer3EncVia2))
               (setq layer3Y6d (plus layer2Yorigin layer2EncVia2 -layer3EncVia2))
               (setq layer3Y7d (plus layer2Yorigin layer2EncVia2 -layer3EncVia2 -l3bvlCntrlS))

               (setq layer3XRenc sourceLay3Via2Enc)
               (setq layer3XLenc (difference layer3WidthS (plus via2Width layer3XRenc)))
               (setq layer3X0ld (plus (difference ldvxo layer3XLenc) l3bvlCntrlS))
               (setq layer3X1ld  (difference ldvxo layer3XLenc))
               (setq layer3X2ld (difference ldvxo layer3XLenc))
               (setq layer3X3ld (plus (difference ldvxo layer3XLenc) l3bvlCntrlS))
               (setq layer3X4ld (plus ldvxe layer3XRenc -l3bvlCntrlS))
               (setq layer3X5ld (plus ldvxe layer3XRenc))
               (setq layer3X6ld (plus ldvxe layer3XRenc))
               (setq layer3X7ld (plus ldvxe layer3XRenc -l3bvlCntrlS))

               (setq layer3XLenc sourceLay3Via2Enc)
               (setq layer3XRenc (difference layer3WidthS (plus via2Width layer3XLenc)))
               (setq layer3X0rd (plus (difference rdvxo layer3XLenc) l3bvlCntrlS))
               (setq layer3X1rd  (difference rdvxo layer3XLenc))
               (setq layer3X2rd (difference rdvxo layer3XLenc))
               (setq layer3X3rd (plus (difference rdvxo layer3XLenc) l3bvlCntrlS))
               (setq layer3X4rd (plus rdvxe layer3XRenc -l3bvlCntrlS))
               (setq layer3X5rd (plus rdvxe layer3XRenc))
               (setq layer3X6rd (plus rdvxe layer3XRenc))
               (setq layer3X7rd (plus rdvxe layer3XRenc -l3bvlCntrlS))

               (setq dbid (dbCreatePolygon tcCellView layer3 
                                           (list (list layer3X0ld layer3Y0d)
                                                 (list layer3X1ld layer3Y1d)
                                                 (list layer3X2ld layer3Y2d)
                                                 (list layer3X3ld layer3Y3d)
                                                 (list layer3X4ld layer3Y4d)
                                                 (list layer3X5ld layer3Y5d)
                                                 (list layer3X6ld layer3Y6d)
                                                 (list layer3X7ld layer3Y7d))))
               (setq dbid (dbCreatePolygon tcCellView layer3 
                                           (list (list layer3X0rd layer3Y0d)
                                                 (list layer3X1rd layer3Y1d)
                                                 (list layer3X2rd layer3Y2d)
                                                 (list layer3X3rd layer3Y3d)
                                                 (list layer3X4rd layer3Y4d)
                                                 (list layer3X5rd layer3Y5d)
                                                 (list layer3X6rd layer3Y6d)
                                                 (list layer3X7rd layer3Y7d))))
                           

              else
               (setq layer3Y0d (plus layer2Yorigin layer2EncVia2 -layer3EncVia2))
               (setq layer3Y1d (plus via2Yloop -via2Space layer3EncVia2))
               (setq layer3X0ld (plus ldvxe sourceLay3Via2Enc))
               (setq layer3X1ld (difference layer3X0ld layer3WidthS))
               (setq dbid (dbCreateRect tcCellView layer3 (list (list layer3X1ld layer3Y0d)
                                                                (list layer3X0ld layer3Y1d))))
               (setq layer3X0rd (difference rdvxo sourceLay3Via2Enc))
               (setq layer3X1rd (plus  layer3X0rd layer3WidthS))
               (setq dbid (dbCreateRect tcCellView layer3 (list (list layer3X0rd layer3Y0d)
                                                                (list layer3X1rd layer3Y1d))))
            )
            (setq layer3X0t (difference tvxo tapLay3Via2Enc))
            (setq layer3X1t (plus layer3X0t tapLay3Width))
            (setq dbid (dbCreateRect tcCellView layer3 (list (list layer3X0t layer3TapY0)
                                                             (list layer3X1t layer3TapY1))))
           else
 	    (if (greaterp layer3Width 0.0) then
	     (if layer3EdgesAt45 then
	       (setq dbid (dbCreatePolygon tcCellView layer3
					   (list (list (plus (difference ldvxo layer3EncVia2) l3bvlCntrl)
						       (plus layer2Yorigin layer2EncVia2 -layer3EncVia2 -l3bvlCntrl)
						       )
						 (list (difference ldvxo layer3EncVia2)
						       (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
						       )
						 (list (difference ldvxo layer3EncVia2)
						       (plus via2Yloop -via2Space layer3EncVia2)
						       )
						 (list (plus (difference ldvxo layer3EncVia2) l3bvlCntrl)
						       (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrl)
						       )
						 (list (plus rdvxe layer3EncVia2 -l3bvlCntrl)
						       (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrl)
						       )
						 (list (plus rdvxe layer3EncVia2)
						       (plus via2Yloop -via2Space layer3EncVia2)
						       )
						 (list (plus rdvxe layer3EncVia2)
						       (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
						       )
						 (list (plus rdvxe layer3EncVia2 -l3bvlCntrl)
						       (plus layer2Yorigin layer2EncVia2 -layer3EncVia2 -l3bvlCntrl)
						       )
						 )
					   )
		     )
	       else
	       (setq dbid (dbCreateRect tcCellView layer3
					(list (list (difference ldvxo layer3EncVia2)
						    (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
						    )
					      (list (plus rdvxe layer3EncVia2)
						    (plus via2Yloop -via2Space layer3EncVia2)
						    )
					      )
					)
		     )
	       )
	     else
	     (setq dbid (dbCreateRect tcCellView layer3
				      (list (difference ldvxo layer3EncVia2):(plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
					    (plus rdvxe layer3EncVia2):(plus via2Yloop -via2Space layer3EncVia2))))
	     )
           )
	   (dbAddFigToNet dbid sNet)
	   
	   (setq pinid (dbCreatePin sNet dbid))
	   pinid~>accessDir = (list "top" "bottom")
	   )
	  )
      )
 
 ;;
 ;; create the inner guard ring in 7 steps:
 ;; 1.  create the inner ring of tap
 ;; 2.  create the well enclosing the tap and transistor
 ;; 3.  create the inner riveted ring of via1's
 ;; 4.  create the inner ring of layer2
 ;; *5.  create the inner riveted ring of via2's
 ;; *6.  create the inner ring of layer3
 ;; 7.  create a terminal out of the topmost layer
 ;; (* = if necessary)
 ;;
 ;; All of the variables that start with "ir" deal with the inner guard ring

 ;; 1.  create the tap in the inner guard ring
 ;; target variables set:
 ;;   tapWidthInIR = the ring width of tap in the inner guard ring
 ;;   irTapXorigin = the X origin (LL corner) of the inner tap guard ring
 ;;   irTapYorigin = the Y origin (LL corner) of the inner tap guard ring
 ;;   irTapL = the total length of the inner tap guard ring
 ;;   irTapW = the total width of the inner tap guard ring
 (setq tapWidthInIR (max innerRingTapWidth (plus via1Width (times 2.0 tapEncVia1))))
 (setq irTapXorigin (difference diffXorigin minDiffTapRingSpace extraLeftSpace tapWidthInIR))

 (if (greaterp innerRingMetalWidth 0.0) then
     (setq irViaOffset (times (fix (plus (quotient (difference (quotient innerRingMetalWidth 2.0) (quotient via1Width 2.0)) via1grid) 0.999)) via1grid))
     (setq irTapYorigin (difference via1Yorigin drnViaYspaceRingViaBot via1Width irViaOffset))
  else
     (setq irTapYorigin (difference via1Yorigin drnViaYspaceRingViaBot via1Width tapEncVia1))
 )

 (setq irTapL (difference (plus diffXend minDiffTapRingSpace extraRightSpace tapWidthInIR) irTapXorigin))

 (if (greaterp innerRingMetalWidth 0.0) then 
     (setq irTapW (difference (plus via1Yloop -via1Space drnViaYspaceRingViaTop via1Width irViaOffset) irTapYorigin))
  else
     (setq irTapW  (difference (plus via1Yloop -via1Space drnViaYspaceRingViaTop via1Width tapEncVia1) irTapYorigin))
 )

 ;; draw tap corners at 45 degrees if tapEdgesAt45 is set
 (if tapEdgesAt45 then
     (setq bevelLength (times 0.6 tapWidthInIR))
     ;; snap this to grid
     (setq bevelLength (times (round (plus (quotient bevelLength tapGrid) 0.001)) tapGrid))

     (setq lowerLeftBL  bevelLength)
     (setq upperLeftBL  bevelLength)
     (setq lowerRightBL bevelLength)
     (setq upperRightBL bevelLength)
  else
     (setq lowerLeftBL  0.0)
     (setq upperLeftBL  0.0)
     (setq lowerRightBL 0.0)
     (setq upperRightBL 0.0)
 )
     
 (setq dbid (dbCreateParamInst tcCellView ringId "itr" 0.0:0.0 "R0" 1
			       (list (list "w" "float" irTapW)
				     (list "l" "float" irTapL)
				     (list "xOffset" "float" irTapXorigin)
				     (list "yOffset" "float" irTapYorigin)
				     (list "ringLayer" "list" nil)
				     (list "ringWidth" "float" tapWidthInIR)
				     (list "additionalWidthInBevel" "float" 0.0)
				     (list "llBevelLength" "float" lowerLeftBL)
				     (list "ulBevelLength" "float" upperLeftBL)
				     (list "lrBevelLength" "float" lowerRightBL)
				     (list "urBevelLength" "float" upperRightBL)
				     (list "bevelTheOutside" "boolean" t)
				     (list "grid" "float" tapGrid)
				     (list "breakupPolygons" "boolean" "TRUE")
			       )))
 (setq theMaster dbid~>master)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints1))
 (dbAddFigToNet dbid irNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints2))
 (dbAddFigToNet dbid irNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints3))
 (dbAddFigToNet dbid irNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints4))
 (dbAddFigToNet dbid irNet)
 
 (when tapWellImplant
   (setq itriXorigin   (difference irTapXorigin tapWellImpEnc))
   (setq itriYorigin   (difference irTapYorigin tapWellImpEnc))
   (setq itriRingWidth (plus tapWidthInIR tapWellImpEnc tapWellImpEnc))
   (setq itriW         (plus irTapW tapWellImpEnc tapWellImpEnc))
   (setq itriL         (plus irTapL tapWellImpEnc tapWellImpEnc))
   (setq dbid (dbCreateParamInst tcCellView ringId "itri" 0.0:0.0 "R0" 1
				 (list (list "w" "float" itriW)
				       (list "l" "float" itriL)
				       (list "xOffset" "float" itriXorigin)
				       (list "yOffset" "float" itriYorigin)
				       (list "ringLayer" "list" tapWellImplant)
				       (list "ringWidth" "float" itriRingWidth)
				       (list "additionalWidthInBevel" "float" 0.0)
				       (list "llBevelLength" "float" 0.0)
				       (list "ulBevelLength" "float" 0.0)
				       (list "lrBevelLength" "float" 0.0)
				       (list "urBevelLength" "float" 0.0)
				       (list "bevelTheOutside" "boolean" nil)
				       (list "grid" "float" tapGrid)
				       (list "breakupPolygons" "boolean" "TRUE")
				       )))
 )

 ;; 2.  create the well enclosing the tap and transistor
 (setq wellXorigin (difference irTapXorigin wellEncTap))
 (setq wellYorigin (difference irTapYorigin wellEncTap))

 (dbCreateRect tcCellView wellLayer (list wellXorigin:wellYorigin
					  (plus wellXorigin irTapL (times 2.0 wellEncTap)):(plus wellYorigin irTapW (times 2.0 wellEncTap))))

 ;;;Create the hvi layer if this is a hv device.
 ;;;Using the enclosure of hnwell by hvi (hvWellEnclosure).
 (when maxvLayer
    ;;The hvi layer must enclose the nwell layer. In some tech. like c8q-3r this enclosure is zero.
    ;;So the hvi layer will be co-incident with nwell.
    ;;For some techs. like c9, the hvi encloses the hnwell by some amount.
    ;;Starting with the co-ordinates of the nwell, create the hv coordinates.
    ;;The ll (lower left) corner is x:(wellXorigin-hvWellEnclosure), y:(wellYorigin-hvWellEnclosure)
    (setq hvllx (difference wellXorigin hvWellEnclosure))
    (setq hvlly (difference wellYorigin hvWellEnclosure))
    ;;Similarly, the ur (upper right) corner
    (setq hvurx (plus wellXorigin irTapL (times 2.0 wellEncTap) hvWellEnclosure))
    (setq hvury (plus wellYorigin irTapW (times 2.0 wellEncTap) hvWellEnclosure))
    ;;Draw the hv layer
    (dbCreateRect tcCellView maxvLayer list(hvllx:hvlly hvurx:hvury))
  )


 ;; 3.  create the inner riveted ring of via1's
 (if (greaterp innerRingMetalWidth 0.0) then
     (setq xCoord   (plus irTapXorigin (max irViaOffset tapEncVia1)))
     (setq yCoord   (plus irTapYorigin (max irViaOffset tapEncVia1)))
     (setq modW     (difference irTapW (times 2.0 (max irViaOffset tapEncVia1))))
     (setq modL     (difference irTapL (times 2.0 (max irViaOffset tapEncVia1))))
  else
     (setq xCoord   (plus irTapXorigin tapEncVia1))
     (setq yCoord   (plus irTapYorigin tapEncVia1))
     (setq modW     (difference irTapW (times 2.0 tapEncVia1)))
     (setq modL     (difference irTapL (times 2.0 tapEncVia1)))
 )
 (if layer2EdgesAt45 then
     (setq lowerLeftBL  (times 2.0 via1Space))
     (setq upperLeftBL  (times 2.0 via1Space))
     (setq lowerRightBL (times 2.0 via1Space))
     (setq upperRightBL (times 2.0 via1Space))
  else
     (setq lowerLeftBL  0.0)
     (setq upperLeftBL  0.0)
     (setq lowerRightBL 0.0)
     (setq upperRightBL 0.0)
 )     

 (when filledRings
    (setq via1Enc (max layer2EncVia1 tapEncVia1))
    (setq via1WidthInIR (difference tapWidthInIR (times 2.0 via1Enc)))
    (setq via1Xorigin (plus irTapXorigin via1Enc))
    (setq via1Yorigin (plus irTapYorigin via1Enc))
    )
 
 (dbCreateParamInst tcCellView rivetedRingId "iv1r" ,(if filledRings 0:0 xCoord:yCoord) "R0" 1
		    (list (list "w" "float" ,(if filledRings
						 (difference irTapW (times 2.0 via1Enc))
					       modW))
			  (list "l" "float" ,(if filledRings
						 (difference irTapL (times 2.0 via1Enc))
					       modL))
			  (list "xOffset" "float" ,(if filledRings via1Xorigin 0.0))
			  (list "yOffset" "float" ,(if filledRings via1Yorigin 0.0))
			  (list "rivetLayer" "list" via1Layer)
			  (list "ringWidth" "float" ,(if filledRings via1WidthInIR via1Width))
			  (list "rivetWidth" "float" via1Width)
			  (list "rivetSpace" "float" via1Space)
			  (list "llBevelLength" "float" lowerLeftBL)
			  (list "ulBevelLength" "float" upperLeftBL)
			  (list "lrBevelLength" "float" lowerRightBL)
			  (list "urBevelLength" "float" upperRightBL)
			  (list "autoIncreaseBevelWidth" "boolean" "FALSE")
			  (list "grid" "float" via1grid)))

 ;; 4.  create the inner ring of layer2
 ;; target variables set:
 ;;   irL2w = the total width of the inner layer2 guard ring
 ;;   irL2l = the total length of the inner layer2 guard ring
 ;;   irL2xDelta = the x offset of the inner guard ring's layer2 x origin
 ;;   irL2yDelta = the y offset of the inner guard ring's layer2 y origin
 ;;   irL2ringW = the width of the layer2 in the inner guard ring
 ;;

 (if splitSource then
   (setq irL2ringW innerRingMetalWidth)
   ; via1 is centered in tapLayer
   ; center layer2 arund via1 (i.e. center layer2 around tapLayer)
   (setq irL2Off (difference innerRingTapWidth innerRingMetalWidth)) 
   (setq irL2Off (times (fix (plus (quotient (quotient irL2Off 2) layer2grid) 1e-6)) layer2grid))
   (setq irL2xDelta (plus irTapXorigin irL2Off))
   (setq irL2yDelta (plus irTapYorigin irL2Off))
   (setq irL2w (plus irTapW (times -2.0 irL2Off)))
   (setq irL2l (plus irTapL (times -2.0 irL2Off)))
 else
   (setq irL2w (plus irTapW (times -2.0 tapEncVia1) (times 2.0 layer2EncVia1)))
   (setq irL2l (plus irTapL (times -2.0 tapEncVia1) (times 2.0 layer2EncVia1)))
   (setq irL2xDelta (plus irTapXorigin tapEncVia1 -layer2EncVia1))
   (setq irL2yDelta (plus irTapYorigin tapEncVia1 -layer2EncVia1))
   (if (greaterp innerRingMetalWidth 0.0) then
     (setq irL2ringW (max (plus (times 2.0 layer2EncVia1) via1Width)
			  (plus (times 2.0 layer2EncVia2) via2Width)
			  innerRingMetalWidth))
     else
     (setq irL2ringW (max (plus (times 2.0 layer2EncVia1) via1Width)
			  (plus (times 2.0 layer2EncVia2) via2Width)))
   )     
 )

 (if layer2EdgesAt45 then
     (setq lowerLeftBL  irL2ringW)
     (setq upperLeftBL  irL2ringW)
     (setq lowerRightBL irL2ringW)
     (setq upperRightBL irL2ringW)
  else
     (setq lowerLeftBL  0.0)
     (setq upperLeftBL  0.0)
     (setq lowerRightBL 0.0)
     (setq upperRightBL 0.0)
 )

 (setq dbid (dbCreateParamInst tcCellView ringId "il2r" 0.0:0.0 "R0" 1
			       (list (list "w" "float" ,(if filledRings irTapW irL2w))
				     (list "l" "float" ,(if filledRings irTapL irL2l))
				     (list "xOffset" "float" ,(if filledRings irTapXorigin irL2xDelta))
				     (list "yOffset" "float" ,(if filledRings irTapYorigin irL2yDelta))
				     (list "ringLayer" "list" nil)
				     (list "ringWidth" "float" ,(if filledRings tapWidthInIR irL2ringW))
				     (list "additionalWidthInBevel" "float" 0.0)
				     (list "llBevelLength" "float" lowerLeftBL)
				     (list "ulBevelLength" "float" upperLeftBL)
				     (list "lrBevelLength" "float" lowerRightBL)
				     (list "urBevelLength" "float" upperRightBL)
				     (list "bevelTheOutside" "boolean" t)
				     (list "grid" "float" layer2grid)
				     (list "breakupPolygons" "boolean" "TRUE")
			       )))
 
 (setq theMaster dbid~>master)
 (setq dbid1 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints1))
 (setq dbid2 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints2))
 (setq dbid3 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints3))
 (setq dbid4 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints4))
 (dbAddFigToNet dbid1 irNet)
 (dbAddFigToNet dbid2 irNet)
 (dbAddFigToNet dbid3 irNet)
 (dbAddFigToNet dbid4 irNet)

 (when (and layer3 fullyStrap (nequal fullyStrap "FALSE"))

     ;; if we must go to layer3, create the via2's and then create layer3

     ;;
     ;; 5.  create the inner riveted ring of via2's
     ;;
     ;; center the via2's in the middle of layer2
     (setq iv2rEnc (quotient (difference irL2ringW via2Width) 2.0))
     ;; snap iv2rEnc to grid
     (setq tempSize (quotient iv2rEnc via2grid))
     (setq iv2rEnc (times (fix (plus tempSize 0.999)) via2grid))

     (if layer3EdgesAt45 then
	 (setq lowerLeftBL   (times 2.0 via2Space))
	 (setq upperLeftBL   (times 2.0 via2Space))
	 (setq lowerRightBL  (times 2.0 via2Space))
	 (setq upperRightBL  (times 2.0 via2Space))
      else
	 (setq lowerLeftBL  0.0)
	 (setq upperLeftBL  0.0)
	 (setq lowerRightBL 0.0)
	 (setq upperRightBL 0.0)
     )    
     (unless filledRings
     (dbCreateParamInst tcCellView rivetedRingId "iv2r" (plus irL2xDelta iv2rEnc):(plus irL2yDelta iv2rEnc) "R0" 1
			(list (list "w" "float" (difference irL2w (times 2.0 iv2rEnc)))
			      (list "l" "float" (difference irL2l (times 2.0 iv2rEnc)))
			      (list "xOffset" "float" 0.0)
			      (list "yOffset" "float" 0.0)
			      (list "rivetLayer" "list" via2Layer)
			      (list "ringWidth" "float" via2Width)
			      (list "rivetWidth" "float" via2Width)
			      (list "rivetSpace" "float" via2Space)
			      (list "llBevelLength" "float" lowerLeftBL)
			      (list "ulBevelLength" "float" upperLeftBL)
			      (list "lrBevelLength" "float" lowerRightBL)
			      (list "urBevelLength" "float" upperRightBL)
			      (list "autoIncreaseBevelWidth" "boolean" "FALSE")
			      (list "grid" "float" via2grid)))
     )
     (when filledRings
     (setq via2Enc (max layer2EncVia2 layer3EncVia2))
     (setq via2WidthInIR (difference tapWidthInIR (times 2.0 via2Enc)))
     (setq via2Xorigin (plus irTapXorigin via2Enc))
     (setq via2Yorigin (plus irTapYorigin via2Enc))
     (setq via2Bevel (plus via2WidthInIR (times 2.0 via2Enc)))
     (dbCreateParamInst tcCellView rivetedRingId "iv2r" 0:0 "R0" 1
			(list (list "w" "float" (difference irTapW (times 2.0 via2Enc)))
			      (list "l" "float" (difference irTapL (times 2.0 via2Enc)))
			      (list "xOffset" "float" via2Xorigin)
			      (list "yOffset" "float" via2Yorigin)
			      (list "rivetLayer" "list" via2Layer)
			      (list "ringWidth" "float" via2WidthInIR)
			      (list "rivetWidth" "float" via2Width)
			      (list "rivetSpace" "float" via2Space)
			      (list "llBevelLength" "float" via2Bevel)
			      (list "ulBevelLength" "float" via2Bevel)
			      (list "lrBevelLength" "float" via2Bevel)
			      (list "urBevelLength" "float" via2Bevel)
			      (list "autoIncreaseBevelWidth" "boolean" "FALSE")
			      (list "grid" "float" via2grid)))
     )

     ;; 6.  create the inner ring of layer3
     ;; target variables set:
     ;;   irL3w = the total width of the inner guard ring of layer3
     ;;   irL3l = the total length of the inner guard ring of layer3
     ;;   irL3xDelta = the x offset of the inner guard ring's layer3 x origin
     ;;   irL3yDelta = the y offset of the inner guard ring's layer3 y origin
     ;;

     (if (greaterp innerRingMetalWidth 0.0) then
	 (setq irL3w irL2w)
	 (setq irL3l irL2l)
	 (setq irL3xDelta irL2xDelta)
	 (setq irL3yDelta irL2yDelta)
	 (setq irL3ringW (max (plus (times 2.0 irLayer3EncVia2) via2Width)
			      innerRingMetalWidth))
      else
	 (setq irL3w (plus irL2w (times -2.0 iv2rEnc) (times 2.0 irLayer3EncVia2)))
	 (setq irL3l (plus irL2l (times -2.0 iv2rEnc) (times 2.0 irLayer3EncVia2)))
	 (setq irL3xDelta (plus irL2xDelta iv2rEnc -irLayer3EncVia2))
	 (setq irL3yDelta (plus irL2yDelta iv2rEnc -irLayer3EncVia2))
	 (setq irL3ringW (plus (times 2.0 irLayer3EncVia2) via2Width))
     )

     (setq topLayer layer3)
     (if layer3EdgesAt45 then
	 (setq lowerLeftBL  irL3ringW)
	 (setq upperLeftBL  irL3ringW)
	 (setq lowerRightBL irL3ringW)
	 (setq upperRightBL irL3ringW)
      else
	 (setq lowerLeftBL  0.0)
	 (setq upperLeftBL  0.0)
	 (setq lowerRightBL 0.0)
	 (setq upperRightBL 0.0)
     )

     (setq dbid (dbCreateParamInst tcCellView ringId "il3r" 0.0:0.0 "R0" 1
				   (list (list "w" "float" ,(if filledRings irTapW irL3w))
					 (list "l" "float" ,(if filledRings irTapL irL3l))
					 (list "xOffset" "float" ,(if filledRings irTapXorigin irL3xDelta))
					 (list "yOffset" "float" ,(if filledRings irTapYorigin irL3yDelta))
					 (list "ringLayer" "list" nil)
					 (list "ringWidth" "float" ,(if filledRings tapWidthInIR irL3ringW))
					 (list "additionalWidthInBevel" "float" irLayer3AddWidthBvl)
					 (list "llBevelLength" "float" ,(if filledRings tapWidthInIR lowerLeftBL))
					 (list "ulBevelLength" "float" ,(if filledRings tapWidthInIR upperLeftBL))
					 (list "lrBevelLength" "float" ,(if filledRings tapWidthInIR lowerRightBL))
					 (list "urBevelLength" "float" ,(if filledRings tapWidthInIR upperRightBL))
					 (list "bevelTheOutside" "boolean" t)
					 (list "grid" "float" layer3grid)
					 (list "breakupPolygons" "boolean" t)
				   )))
     (setq theMaster dbid~>master)
     (setq dbid1 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints1))
     (setq dbid2 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints2))
     (setq dbid3 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints3))
     (setq dbid4 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints4))
     (dbAddFigToNet dbid1 irNet)
     (dbAddFigToNet dbid2 irNet)
     (dbAddFigToNet dbid3 irNet)
     (dbAddFigToNet dbid4 irNet)
 )

 ;; 7.  create a terminal out of the topmost layer
 (setq pinid (dbCreatePin irNet dbid1))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pinid (dbCreatePin irNet dbid2))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pinid (dbCreatePin irNet dbid3))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pinid (dbCreatePin irNet dbid4))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))

 ;;
 ;; create the outer guard ring in 7 steps:
 ;; 1.  create the outer ring of tap
 ;; 2.  create the outer riveted ring of via1's
 ;; 3.  create the outer ring of layer2
 ;; *4.  create the outer riveted ring of via2's
 ;; *5.  create the outer ring of layer3
 ;; 6.  create a terminal out of the topmost layer
 ;; (* = if necessary)
 ;;
 ;; All of the variables that start with "or" deal with the outer guard ring

 ;; set up the tap variables in the outer guard ring:
 ;;  tapWidthInOR = the width of the tap in the outer guard ring
 ;;  outerTapDelta = the offset between the inner and outer tap guard rings
 ;;  orTapXorigin = the x origin for the outer tap guard ring
 ;;  orTapYorigin = the y origin for the outer tap guard ring
 ;;  orTapW = the total width for the outer tap guard ring
 ;;  orTapL = the total length for the outer tap guard ring
 (setq tapWidthInOR (max outerRingTapWidth (plus (times 2.0 tapEncVia1) via1Width)))
 (setq outerTapDelta (plus wellTapSpace tapWidthInOR))
 (setq orTapXorigin (difference wellXorigin outerTapDelta))
 (setq orTapYorigin (difference wellYorigin outerTapDelta))
 (setq orTapW (plus irTapW (times 2.0 (plus outerTapDelta wellEncTap))))
 (setq orTapL (plus irTapL (times 2.0 (plus outerTapDelta wellEncTap))))

 ;;
 ;; first, make sure that we will not create a spacing error for layer3
 ;;
 (when (and layer3 fullyStrap (nequal fullyStrap "FALSE")) 
     ;; this just satisfies the min spacing of layer3 from inner ring to outer
     (setq orLayer3XoriginA (difference irL3xDelta orirLayer3Space orLayer3Width))

     ;; this will be where layer3 has its origin when it just satisfies the
     ;; spacing of tap in the inner ring to the well in the outer ring
     (setq orLayer3XoriginB (plus orTapXorigin (quotient tapWidthInOR 2.0) (quotient orLayer3Width -2.0)))

     ;; when the layer3 spacing is not going to be satisfied when the at the
     ;; specified spacing of tap in the inner ring to well in outer ring,
     ;; we need to push out the outer guard ring
     (when (lessp orLayer3XoriginA orLayer3XoriginB)
	 (setq extraSpace (difference orLayer3XoriginB orLayer3XoriginA))
	 (setq tempSize (quotient extraSpace tapGrid))
	 (setq extraSpace (times (fix (plus tempSize 0.999)) tapGrid))

	 (setq orTapXorigin (difference orTapXorigin extraSpace))
	 (setq orTapYorigin (difference orTapYorigin extraSpace))
	 (setq orTapW (plus orTapW (times 2.0 extraSpace)))
	 (setq orTapL (plus orTapL (times 2.0 extraSpace)))
     )
 )

 ;; 1.  create the outer ring of tap

 ;; draw tap corners at 45 degrees if tapEdgesAt45 is set
 (if tapEdgesAt45 then
     (setq bevelLength (times 0.6 tapWidthInOR))
     ;; snap this to grid
     (setq bevelLength (times (round (plus (quotient bevelLength tapGrid) 0.001)) tapGrid))
     
     (setq lowerLeftBL  bevelLength)
     (setq upperLeftBL  bevelLength)
     (setq lowerRightBL bevelLength)
     (setq upperRightBL bevelLength)
  else
     (setq lowerLeftBL  0.0)
     (setq upperLeftBL  0.0)
     (setq lowerRightBL 0.0)
     (setq upperRightBL 0.0)
 )  

 (setq dbid (dbCreateParamInst tcCellView ringId "otr" 0.0:0.0 "R0" 1
			       (list (list "w" "float" orTapW)
				     (list "l" "float" orTapL)
				     (list "xOffset" "float" orTapXorigin)
				     (list "yOffset" "float" orTapYorigin)
				     (list "ringLayer" "list" nil)
				     (list "ringWidth" "float" tapWidthInOR)
				     (list "additionalWidthInBevel" "float" 0.0)
				     (list "llBevelLength" "float" lowerLeftBL)
				     (list "ulBevelLength" "float" upperLeftBL)
				     (list "lrBevelLength" "float" lowerRightBL)
				     (list "urBevelLength" "float" upperRightBL)
				     (list "bevelTheOutside" "boolean" t)
				     (list "grid" "float" tapGrid)
				     (list "breakupPolygons" "boolean" "TRUE")
			       )))
 (setq theMaster dbid~>master)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints1))
 (dbAddFigToNet dbid orNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints2))
 (dbAddFigToNet dbid orNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints3))
 (dbAddFigToNet dbid orNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints4))
 (dbAddFigToNet dbid orNet)
 (when tapSubImplant
   (setq otriXorigin   (difference orTapXorigin tapSubImpEnc))
   (setq otriYorigin   (difference orTapYorigin tapSubImpEnc))
   (setq otriRingWidth (plus tapWidthInOR tapSubImpEnc tapSubImpEnc))
   (setq otriW         (plus orTapW tapSubImpEnc tapSubImpEnc))
   (setq otriL         (plus orTapL tapSubImpEnc tapSubImpEnc))
   (setq dbid (dbCreateParamInst tcCellView ringId "otri" 0.0:0.0 "R0" 1
				 (list (list "w" "float" otriW)
				       (list "l" "float" otriL)
				       (list "xOffset" "float" otriXorigin)
				       (list "yOffset" "float" otriYorigin)
				       (list "ringLayer" "list" tapSubImplant)
				       (list "ringWidth" "float" otriRingWidth)
				       (list "additionalWidthInBevel" "float" 0.0)
				       (list "llBevelLength" "float" 0.0)
				       (list "ulBevelLength" "float" 0.0)
				       (list "lrBevelLength" "float" 0.0)
				       (list "urBevelLength" "float" 0.0)
				       (list "bevelTheOutside" "boolean" nil)
				       (list "grid" "float" tapGrid)
				       (list "breakupPolygons" "boolean" "TRUE")
				       )))
 )
 ;; 2.  create the outer riveted ring of via1's
 (setq orViaOffset (times (fix (plus (quotient (difference (quotient tapWidthInOR 2.0) (quotient via1Width 2.0)) via1grid) 0.999)) via1grid))
 (setq xCoord   (plus orTapXorigin (max orViaOffset tapEncVia1)))
 (setq yCoord   (plus orTapYorigin (max orViaOffset tapEncVia1)))

 (setq lowerLeftBL  (times 3.0 via1Space))
 (setq upperLeftBL  (times 3.0 via1Space))
 (setq lowerRightBL (times 3.0 via1Space))
 (setq upperRightBL (times 3.0 via1Space))

 (when filledRings
   (setq orTapEncVia1 (difference tapWidthInOR orLayer3Width))
   (setq via1WidthInOR (difference orLayer3Width (times 2.0 via1Enc)))
   )
 (dbCreateParamInst tcCellView rivetedRingId "ov1r" ,(if filledRings orTapXorigin:orTapYorigin xCoord:yCoord) "R0" 1
		    (list (list "w" "float" ,(if filledRings
						 (difference orTapW (times 2.0 (plus orTapEncVia1 via1Enc)))
					       (difference orTapW (times 2.0 (max orViaOffset tapEncVia1)))))
			  (list "l" "float" ,(if filledRings
						 (difference orTapL (times 2.0 (plus orTapEncVia1 via1Enc)))
					       (difference orTapL (times 2.0 (max orViaOffset tapEncVia1)))))
			  (list "xOffset" "float" ,(if filledRings (plus orTapEncVia1 via1Enc) 0.0))
			  (list "yOffset" "float" ,(if filledRings (plus orTapEncVia1 via1Enc) 0.0))
			  (list "rivetLayer" "list" via1Layer)
			  (list "ringWidth" "float" ,(if filledRings via1WidthInOR via1Width))
			  (list "rivetWidth" "float" via1Width)
			  (list "rivetSpace" "float" via1Space)
			  (list "llBevelLength" "float" ,(if filledRings 0.0 lowerLeftBL))
			  (list "ulBevelLength" "float" ,(if filledRings 0.0 upperLeftBL))
			  (list "lrBevelLength" "float" ,(if filledRings 0.0 lowerRightBL))
			  (list "urBevelLength" "float" ,(if filledRings 0.0 upperRightBL))
			  (list "autoIncreaseBevelWidth" "boolean" "FALSE")
			  (list "grid" "float" via1grid)))

 (unless (or filledRings layer2EdgesAt45 tapEdgesAt45)
   ;; draw an extra via1 in each corner
   (setq extraVia1RightOrigin (plus xCoord
				    (difference orTapL (times 2.0 (max orViaOffset tapEncVia1)))
				    (minus via1Width)))
   (setq extraVia1TopOrigin   (plus yCoord
				    (difference orTapW (times 2.0 (max orViaOffset tapEncVia1)))
				    (minus via1Width)))
   
   (dbCreateRect tcCellView via1Layer
		 (list (list xCoord yCoord )
		       (list (plus  xCoord via1Width)
			     (plus  yCoord via1Width)
			     )))
   (dbCreateRect tcCellView via1Layer
		 (list (list extraVia1RightOrigin yCoord )
		       (list (plus  extraVia1RightOrigin via1Width )
			     (plus  yCoord via1Width)
			     )))
   (dbCreateRect tcCellView via1Layer
		 (list (list xCoord extraVia1TopOrigin)
		       (list (plus xCoord via1Width)
			     (plus extraVia1TopOrigin via1Width)
			     )))
   (dbCreateRect tcCellView via1Layer
		 (list (list extraVia1RightOrigin extraVia1TopOrigin)
		       (list (plus extraVia1RightOrigin via1Width)
			     (plus extraVia1TopOrigin via1Width)
			     )))
   )

 ;; 3.  create the outer ring of layer2.  target variables set:
 ;;   orL2w = the total width of the outer layer2 guard ring
 ;;   orL2l = the total length of the outer layer2 guard ring
 ;;   orL2xDelta = the x origin of the outer layer2 guard ring
 ;;   orL2yDelta = the y origin of the outer layer2 guard ring
 ;;   orL2ringW = the ring width of layer2 in the outer guard ring
 ;;
 (if layer3 then
   ;; draw layer2 with the same width as of layer3
   (setq orLayer3EncVia2 (quotient (difference orLayer3Width via2Width) 2.0))
   ;; snap orLayer3EncVia2 to grid
   (setq tempSize (quotient orLayer3EncVia2 layer3grid))
   (setq orLayer3EncVia2 (times (fix (plus tempSize 0.999)) layer3grid))
   (setq outerRingMetalWidth (plus (times 2.0 orLayer3EncVia2) via2Width))
   
   (setq orL2w (plus orTapW -tapWidthInOR outerRingMetalWidth))
   (setq orL2l (plus orTapL -tapWidthInOR outerRingMetalWidth))
   (setq orL2xDelta (plus orTapXorigin (quotient (plus tapWidthInOR -outerRingMetalWidth) 2.0)))
   ;; snap orL2xDelta to grid
   (setq orL2xDelta (times (fix (plus (quotient orL2xDelta layer2grid) 0.999)) layer2grid))
   (setq orL2yDelta (plus orTapYorigin (quotient (plus tapWidthInOR -outerRingMetalWidth) 2.0)))
   ;; snap orL2yDelta to grid
   (setq orL2yDelta (times (fix (plus (quotient orL2yDelta layer2grid) 0.999)) layer2grid))
   (setq orL2ringW (max (plus (times 2.0 layer2EncVia1) via1Width)
			(plus (times 2.0 layer2EncVia2) via2Width)
			outerRingMetalWidth))
  else
   (setq orL2w (plus orTapW (times -2.0 (max orViaOffset tapEncVia1)) (times 2.0 layer2EncVia1)))
   (setq orL2l (plus orTapL (times -2.0 (max orViaOffset tapEncVia1)) (times 2.0 layer2EncVia1)))
   (setq orL2xDelta (plus xCoord -layer2EncVia1))
   (setq orL2yDelta (plus yCoord -layer2EncVia1))
   (setq orL2ringW (max (plus (times 2.0 layer2EncVia1) via1Width)
			(plus (times 2.0 layer2EncVia2) via2Width)))
 )

 (if layer2EdgesAt45 then
   (setq lowerLeftBL  orL2ringW)
   (setq upperLeftBL  orL2ringW)
   (setq lowerRightBL orL2ringW)
   (setq upperRightBL orL2ringW)
  else
   (setq lowerLeftBL  0.0)
   (setq upperLeftBL  0.0)
   (setq lowerRightBL 0.0)
   (setq upperRightBL 0.0)
 )  
   
 (setq dbid (dbCreateParamInst tcCellView ringId "ol2r" 0.0:0.0 "R0" 1
			       (list (list "w" "float" ,(if filledRings
							    (difference orTapW (times 2.0 orTapEncVia1))
							  orL2w))
				     (list "l" "float" ,(if filledRings
							    (difference orTapL (times 2.0 orTapEncVia1))
							  orL2l))
				     (list "xOffset" "float" ,(if filledRings (plus orTapXorigin orTapEncVia1) orL2xDelta))
				     (list "yOffset" "float" ,(if filledRings (plus orTapYorigin orTapEncVia1) orL2yDelta))
				     (list "ringLayer" "list" nil)
				     (list "ringWidth" "float" ,(if filledRings orLayer3Width orL2ringW))
				     (list "additionalWidthInBevel" "float" 0.0)
				     (list "llBevelLength" "float" ,(if filledRings 0.0 lowerLeftBL))
				     (list "ulBevelLength" "float" ,(if filledRings 0.0 upperLeftBL))
				     (list "lrBevelLength" "float" ,(if filledRings 0.0 lowerRightBL))
				     (list "urBevelLength" "float" ,(if filledRings 0.0 upperRightBL))
				     (list "bevelTheOutside" "boolean" t)
				     (list "grid" "float" layer2grid)
				     (list "breakupPolygons" "boolean" "TRUE")
			       )))

 (setq theMaster dbid~>master)
 (setq dbid1 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints1))
 (setq dbid2 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints2))
 (setq dbid3 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints3))
 (setq dbid4 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints4))
 (dbAddFigToNet dbid1 orNet)
 (dbAddFigToNet dbid2 orNet)
 (dbAddFigToNet dbid3 orNet)
 (dbAddFigToNet dbid4 orNet)

 (when (and layer3 fullyStrap (nequal fullyStrap "FALSE"))

     ;;
     ;; 4.  if we must go to layer3, create the via2's and then create layer3
     ;;
     ;; center the via2's in the middle of layer2
     (setq ov2rEnc (quotient (difference orL2ringW via2Width) 2.0))
     ;; snap ov2rEnc to grid
     (setq tempSize (quotient ov2rEnc via2grid))
     (setq ov2rEnc (times (fix (plus tempSize 0.999)) via2grid))

     (if layer3EdgesAt45 then
	 (setq lowerLeftBL   (times 2.0 via2Space))
	 (setq upperLeftBL   (times 2.0 via2Space))
	 (setq lowerRightBL  (times 2.0 via2Space))
	 (setq upperRightBL  (times 2.0 via2Space))
      else
	 (setq lowerLeftBL   via2Space)
	 (setq upperLeftBL   via2Space)
	 (setq lowerRightBL  via2Space)
	 (setq upperRightBL  via2Space)
     )

     (when filledRings
       (setq via2WidthInOR (difference orLayer3Width (times 2.0 via2Enc)))
       )
     (when filledRings
     (dbCreateParamInst tcCellView rivetedRingId "ov2r" orTapXorigin:orTapYorigin "R0" 1
			(list (list "w" "float" (difference orTapW (times 2.0 (plus via2Enc orTapEncVia1))))
			      (list "l" "float" (difference orTapL (times 2.0 (plus via2Enc orTapEncVia1))))
			      (list "xOffset" "float" (plus orTapEncVia1 via2Enc))
			      (list "yOffset" "float" (plus orTapEncVia1 via2Enc))
			      (list "rivetLayer" "list" via2Layer)
			      (list "ringWidth" "float" via2WidthInOR)
			      (list "rivetWidth" "float" via2Width)
			      (list "rivetSpace" "float" via2Space)
			      (list "llBevelLength" "float" (plus via2Enc (plus -0.50 orLayer3Width)))
			      (list "ulBevelLength" "float" (plus via2Enc (plus -0.50 orLayer3Width)))
			      (list "lrBevelLength" "float" (plus via2Enc (plus -0.50 orLayer3Width)))
			      (list "urBevelLength" "float" (plus via2Enc (plus -0.50 orLayer3Width)))
			      (list "autoIncreaseBevelWidth" "boolean" "FALSE")
			      (list "grid" "float" via2grid)))
     )
     (unless filledRings
     (dbCreateParamInst tcCellView rivetedRingId "ov2r" (plus orL2xDelta ov2rEnc):(plus orL2yDelta ov2rEnc) "R0" 1
			(list (list "w" "float" (difference orL2w (times 2.0 ov2rEnc)))
			      (list "l" "float" (difference orL2l (times 2.0 ov2rEnc)))
			      (list "xOffset" "float" 0.0)
			      (list "yOffset" "float" 0.0)
			      (list "rivetLayer" "list" via2Layer)
			      (list "ringWidth" "float" via2Width)
			      (list "rivetWidth" "float" via2Width)
			      (list "rivetSpace" "float" via2Space)
			      (list "llBevelLength" "float" lowerLeftBL)
			      (list "ulBevelLength" "float" upperLeftBL)
			      (list "lrBevelLength" "float" lowerRightBL)
			      (list "urBevelLength" "float" upperRightBL)
			      (list "autoIncreaseBevelWidth" "boolean" "FALSE")
			      (list "grid" "float" via2grid)))
     )

     ;; 5.  create the outer ring of layer3.  target variables set:
     ;;   orL3w = the total width of the outer layer3 guard ring
     ;;   orL3l = the total length of the outer layer3 guard ring
     ;;   orL3xDelta = the x origin of the outer layer3 guard ring
     ;;   orL3yDelta = the y origin of the outer layer3 guard ring
     ;;

     (setq orL3w (plus orL2w (times -2.0 ov2rEnc) (times 2.0 orLayer3EncVia2)))
     (setq orL3l (plus orL2l (times -2.0 ov2rEnc) (times 2.0 orLayer3EncVia2)))
     (setq orL3xDelta (plus orL2xDelta ov2rEnc -orLayer3EncVia2))
     (setq orL3yDelta (plus orL2yDelta ov2rEnc -orLayer3EncVia2))

     (if layer3EdgesAt45 then
	 (setq lowerLeftBL  (plus (times 2.0 orLayer3EncVia2) via2Width))
	 (setq upperLeftBL  (plus (times 2.0 orLayer3EncVia2) via2Width))
	 (setq lowerRightBL (plus (times 2.0 orLayer3EncVia2) via2Width))
	 (setq upperRightBL (plus (times 2.0 orLayer3EncVia2) via2Width))
      else
	 (setq lowerLeftBL  0.0)
	 (setq upperLeftBL  0.0)
	 (setq lowerRightBL 0.0)
	 (setq upperRightBL 0.0)
     )

     (setq dbid (dbCreateParamInst tcCellView ringId "ol3r" 0.0:0.0 "R0" 1
				   (list (list "w" "float" ,(if filledRings
								(difference orTapW (times 2.0 orTapEncVia1))
							      orL3w))
					 (list "l" "float" ,(if filledRings
								(difference orTapL (times 2.0 orTapEncVia1))
							      orL3l))
					 (list "xOffset" "float" ,(if filledRings (plus orTapXorigin orTapEncVia1) orL3xDelta))
					 (list "yOffset" "float" ,(if filledRings (plus orTapYorigin orTapEncVia1) orL3yDelta))
					 (list "ringLayer" "list" nil)
					 (list "ringWidth" "float" ,(if filledRings
									orLayer3Width
								      (plus (times 2.0 orLayer3EncVia2) via2Width)))
					 (list "additionalWidthInBevel" "float" 0.0)
					 (list "llBevelLength" "float" ,(if filledRings (plus -0.50 orLayer3Width) lowerLeftBL))
					 (list "ulBevelLength" "float" ,(if filledRings (plus -0.50 orLayer3Width) upperLeftBL))
					 (list "lrBevelLength" "float" ,(if filledRings (plus -0.50 orLayer3Width) lowerRightBL))
					 (list "urBevelLength" "float" ,(if filledRings (plus -0.50 orLayer3Width) upperRightBL))
					 (list "bevelTheOutside" "boolean" t)
					 (list "grid" "float" layer3grid)
					 (list "breakupPolygons" "boolean" t)
				   )))
	 
     (setq theMaster dbid~>master)
     (setq dbid1 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints1))
     (setq dbid2 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints2))
     (setq dbid3 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints3))
     (setq dbid4 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints4))
     (dbAddFigToNet dbid1 orNet)
     (dbAddFigToNet dbid2 orNet)
     (dbAddFigToNet dbid3 orNet)
     (dbAddFigToNet dbid4 orNet)
 )

 ;; 6.  create a terminal out of the topmost layer
 (setq pin (dbCreatePin orNet dbid1))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pin (dbCreatePin orNet dbid2))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pin (dbCreatePin orNet dbid3))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pin (dbCreatePin orNet dbid4))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))

 ;; third ring
 (when thirdRing

 ;;
 ;; create the third guard ring in 7 steps:
 ;; 1.  create the third ring of well
 ;; 2.  create the third ring of tap
 ;;  2a. create the third ring tap implant if required
 ;; 3.  create the third riveted ring of via1's
 ;; 4.  create the third ring of layer2
 ;; *5.  create the third riveted ring of via2's
 ;; *6.  create the third ring of layer3
 ;; 7.  create a terminal out of the topmost layer
 ;; (* = if necessary)
 ;;

 ;;The new class params. that had to be defined for third ring:
 ;;thirdRingTapWidth: tap width in third ring
 ;;trLayer3Width: width of layer3 (met1 in most cases) for third ring.

 ;; set up the tap variables in the third guard ring:
 ;;  tapWidthInTR = the width of the tap in the third guard ring
 ;;  thirdTapDelta = the offset between the inner and third tap guard rings
 ;;  trTapXorigin = the x origin for the third tap guard ring
 ;;  trTapYorigin = the y origin for the third tap guard ring
 ;;  trTapW = the total width for the third tap guard ring
 ;;  trTapL = the total length for the third tap guard ring

 (setq thirdRingTapEncVia1 tapEncVia1)
 ;;when user selects "NwellconnectToIOpad" then use the other width of third ring
 (when (and NwellconnectToIOpad (nequal  NwellconnectToIOpad "FALSE"))
   (setq thirdRingTapWidth thirdRingTapWidth2)
   (setq trLayer3Width     trLayer3Width2)
 )

 (setq tapWidthInTR (max thirdRingTapWidth (plus (times 2.0 thirdRingTapEncVia1) via1Width)))
 (setq thirdTapDelta (plus wellTapSpace wellEncTap tapWidthInTR))
 (setq trTapXorigin (difference orTapXorigin thirdTapDelta))
 (setq trTapYorigin (difference orTapYorigin thirdTapDelta))
 (setq trTapW (plus orTapW (times 2.0 thirdTapDelta)))
 (setq trTapL (plus orTapL (times 2.0 thirdTapDelta)))

 ;;
 ;; first, make sure that we will not create a spacing error for layer3
 ;;
 (when  (and layer3 fullyStrap (nequal fullyStrap "FALSE"))
     ;; this just satisfies the min spacing of layer3 from inner ring to third
     (setq trLayer3XoriginA (difference orL3xDelta orirLayer3Space trLayer3Width))
     ;; this will be where layer3 has its origin when it just satisfies the
     ;; spacing of tap in the inner ring to the well in the third ring
     (setq trLayer3XoriginB (plus trTapXorigin (quotient tapWidthInTR 2.0) (quotient trLayer3Width -2.0)))
     ;; when the layer3 spacing is not going to be satisfied when the at the
     ;; specified spacing of tap in the inner ring to well in third ring,
     ;; we need to push out the third guard ring
     (when (lessp trLayer3XoriginA trLayer3XoriginB)
         (setq extraSpace (difference trLayer3XoriginB trLayer3XoriginA))
         (setq tempSize (quotient extraSpace tapGrid))
         (setq extraSpace (times (fix (plus tempSize 0.999)) tapGrid))

         (setq trTapXorigin (difference trTapXorigin extraSpace))
         (setq trTapYorigin (difference trTapYorigin extraSpace))
         (setq trTapW (plus trTapW (times 2.0 extraSpace)))
         (setq trTapL (plus trTapL (times 2.0 extraSpace)))
     )
 )

 ;;
 ;; 1.  create the well in the third guard ring
 ;;
 (setq dbid (dbCreateParamInst tcCellView ringId "owr" 0.0:0.0 "R0" 1
                               (list (list "w" "float" (plus trTapW (times 2.0 wellEncTap)))
                                     (list "l" "float" (plus trTapL (times 2.0 wellEncTap)))
                                     (list "xOffset" "float" (difference trTapXorigin wellEncTap))
                                     (list "yOffset" "float" (difference trTapYorigin wellEncTap))
                                     (list "ringLayer" "list" nil)
                                     (list "ringWidth" "float" (plus tapWidthInTR (times 2.0 wellEncTap)))
                                     (list "additionalWidthInBevel" "float" 0.0)
                                     (list "llBevelLength" "float" 0.0)
                                     (list "ulBevelLength" "float" 0.0)
                                     (list "lrBevelLength" "float" 0.0)
                                     (list "urBevelLength" "float" 0.0)
                                     (list "bevelTheOutside" "boolean" t)
                                     (list "grid" "float" wellGrid)
                                     (list "breakupPolygons" "boolean" "TRUE"))))
 (setq theMaster dbid~>master)

 (setq dbid1 (dbCreatePolygon tcCellView wellLayer theMaster~>ringPoints1))
 (setq dbid2 (dbCreatePolygon tcCellView wellLayer theMaster~>ringPoints2))
 (setq dbid3 (dbCreatePolygon tcCellView wellLayer theMaster~>ringPoints3))
 (setq dbid4 (dbCreatePolygon tcCellView wellLayer theMaster~>ringPoints4))


 ;;
 ;; 2.  create the third ring of tap
 ;;

 ;; draw tap corners at 45 degrees if tapEedgesAt45 is set
 (if tapEdgesAt45 then
     (setq bevelLength (times 0.6 tapWidthInTR))
     ;; snap this to grid
     (setq bevelLength (times (round (plus (quotient bevelLength tapGrid) 0.001)) tapGrid))

     (setq lowerLeftBL  bevelLength)
     (setq upperLeftBL  bevelLength)
     (setq lowerRightBL bevelLength)
     (setq upperRightBL bevelLength)
  else
     (setq lowerLeftBL  0.0)
     (setq upperLeftBL  0.0)
     (setq lowerRightBL 0.0)
     (setq upperRightBL 0.0)
 )

 (setq dbid (dbCreateParamInst tcCellView ringId "otr_third" 0.0:0.0 "R0" 1
                               (list (list "w" "float" trTapW)
                                     (list "l" "float" trTapL)
                                     (list "xOffset" "float" trTapXorigin)
                                     (list "yOffset" "float" trTapYorigin)
                                     (list "ringLayer" "list" nil)
                                     (list "ringWidth" "float" tapWidthInTR)
                                     (list "additionalWidthInBevel" "float" 0.0)
                                     (list "llBevelLength" "float" lowerLeftBL)
                                     (list "ulBevelLength" "float" upperLeftBL)
                                     (list "lrBevelLength" "float" lowerRightBL)
                                     (list "urBevelLength" "float" upperRightBL)
                                     (list "bevelTheOutside" "boolean" t)
                                     (list "grid" "float" tapGrid)
                                     (list "breakupPolygons" "boolean" "TRUE")
                               )))
 (setq theMaster dbid~>master)

 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints1))
 (dbAddFigToNet dbid trNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints2))
 (dbAddFigToNet dbid trNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints3))
 (dbAddFigToNet dbid trNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints4))
 (dbAddFigToNet dbid trNet)
 (when tapWellImplant
   (setq otriXorigin   (difference trTapXorigin tapWellImpEnc))
   (setq otriYorigin   (difference trTapYorigin tapWellImpEnc))
   (setq otriRingWidth (plus tapWidthInTR tapWellImpEnc tapWellImpEnc))
   (setq otriW         (plus trTapW tapWellImpEnc tapWellImpEnc))
   (setq otriL         (plus trTapL tapWellImpEnc tapWellImpEnc))
   (setq dbid (dbCreateParamInst tcCellView ringId "otri_third" 0.0:0.0 "R0" 1
                                 (list (list "w" "float" otriW)
                                       (list "l" "float" otriL)
                                       (list "xOffset" "float" otriXorigin)
                                       (list "yOffset" "float" otriYorigin)
                                       (list "ringLayer" "list" tapWellImplant)
                                       (list "ringWidth" "float" otriRingWidth)
                                       (list "additionalWidthInBevel" "float" 0.0)
                                       (list "llBevelLength" "float" 0.0)
                                       (list "ulBevelLength" "float" 0.0)
                                       (list "lrBevelLength" "float" 0.0)
                                       (list "urBevelLength" "float" 0.0)
                                       (list "bevelTheOutside" "boolean" nil)
                                       (list "grid" "float" tapGrid)
                                       (list "breakupPolygons" "boolean" "TRUE")
                                       )))
 )

 ;;
 ;; 3.  create the third riveted ring of via1's
 ;;
 (setq trViaOffset (times (fix (plus (quotient (difference (quotient tapWidthInTR 2.0) (quotient via1Width 2.0))
via1grid) 0.999)) via1grid))
 (setq xCoord   (plus trTapXorigin (max trViaOffset thirdRingTapEncVia1)))
 (setq yCoord   (plus trTapYorigin (max trViaOffset thirdRingTapEncVia1)))

 (setq lowerLeftBL  (times 3.0 via1Space))
 (setq upperLeftBL  (times 3.0 via1Space))
 (setq lowerRightBL (times 3.0 via1Space))
 (setq upperRightBL (times 3.0 via1Space))

 (dbCreateParamInst tcCellView rivetedRingId "ov1r_third" xCoord:yCoord "R0" 1
                    (list (list "w" "float" (difference trTapW (times 2.0 (max trViaOffset thirdRingTapEncVia1)))
)
                          (list "l" "float" (difference trTapL (times 2.0 (max trViaOffset thirdRingTapEncVia1)))
)
                          (list "xOffset" "float" 0.0)
                          (list "yOffset" "float" 0.0)
                          (list "rivetLayer" "list" via1Layer)
                          (list "ringWidth" "float" via1Width)
                          (list "rivetWidth" "float" via1Width)
                          (list "rivetSpace" "float" via1Space)
                          (list "llBevelLength" "float" lowerLeftBL)
                          (list "ulBevelLength" "float" upperLeftBL)
                          (list "lrBevelLength" "float" lowerRightBL)
                          (list "urBevelLength" "float" upperRightBL)
                          (list "autoIncreaseBevelWidth" "boolean" "FALSE")
                          (list "grid" "float" via1grid)))

 (unless (or layer2EdgesAt45 tapEdgesAt45)
   ;; draw an extra via1 in each corner
   (setq extraVia1RightOrigin (plus xCoord
                                    (difference trTapL (times 2.0 (max trViaOffset thirdRingTapEncVia1)))
                                    (minus via1Width)))
   (setq extraVia1TopOrigin   (plus yCoord
                                    (difference trTapW (times 2.0 (max trViaOffset thirdRingTapEncVia1)))
                                    (minus via1Width)))
 
   (dbCreateRect tcCellView via1Layer
                 (list (list xCoord yCoord )
                       (list (plus  xCoord via1Width)
                             (plus  yCoord via1Width)
                             )))
   (dbCreateRect tcCellView via1Layer
                 (list (list extraVia1RightOrigin yCoord )
                       (list (plus  extraVia1RightOrigin via1Width )
                             (plus  yCoord via1Width)
                             )))
   (dbCreateRect tcCellView via1Layer
                 (list (list xCoord extraVia1TopOrigin)
                       (list (plus xCoord via1Width)
                             (plus extraVia1TopOrigin via1Width)
                             )))
   (dbCreateRect tcCellView via1Layer
                 (list (list extraVia1RightOrigin extraVia1TopOrigin)
                       (list (plus extraVia1RightOrigin via1Width)
                             (plus extraVia1TopOrigin via1Width)
                             )))
   )

 ;;
 ;; 4.  create the third ring of layer2.  target variables set:
 ;;   trL2w = the total width of the third layer2 guard ring
 ;;   trL2l = the total length of the third layer2 guard ring
 ;;   trL2xDelta = the x origin of the third layer2 guard ring
 ;;   trL2yDelta = the y origin of the third layer2 guard ring
 ;;   trL2ringW = the ring width of layer2 in the third guard ring
 ;;



 (if layer3 then
     ;; draw layer2 with the same width as of layer3
     (setq trLayer3EncVia2 (quotient (difference trLayer3Width via2Width) 2.0))
     ;; snap trLayer3EncVia2 to grid
     (setq tempSize (quotient trLayer3EncVia2 layer3grid))
     (setq trLayer3EncVia2 (times (fix (plus tempSize 0.999)) layer3grid))
     (setq thirdRingMetalWidth (plus (times 2.0 trLayer3EncVia2) via2Width))

     (setq trL2w (plus trTapW -tapWidthInTR thirdRingMetalWidth))
     (setq trL2l (plus trTapL -tapWidthInTR thirdRingMetalWidth))

     (setq trL2xDelta (plus trTapXorigin (quotient (plus tapWidthInTR -thirdRingMetalWidth) 2.0)))
     ;; snap trL2xDelta to grid
     (setq trL2xDelta (times (fix (plus (quotient trL2xDelta layer2grid) 0.999)) layer2grid))

     (setq trL2yDelta (plus trTapYorigin (quotient (plus tapWidthInTR -thirdRingMetalWidth) 2.0)))
     ;; snap trL2yDelta to grid
     (setq trL2yDelta (times (fix (plus (quotient trL2yDelta layer2grid) 0.999)) layer2grid))

     (setq trL2ringW (max (plus (times 2.0 layer2EncVia1) via1Width)
                          (plus (times 2.0 layer2EncVia2) via2Width)
                          trLayer3Width))
    else
     (setq trL2w (plus trTapW (times -2.0 (max trViaOffset thirdRingTapEncVia1)) (times 2.0 layer2EncVia1)))
     (setq trL2l (plus trTapL (times -2.0 (max trViaOffset thirdRingTapEncVia1)) (times 2.0 layer2EncVia1)))
     (setq trL2xDelta (plus xCoord -layer2EncVia1))
     (setq trL2yDelta (plus yCoord -layer2EncVia1))
     (setq trL2ringW (max (plus (times 2.0 layer2EncVia1) via1Width)
                          (plus (times 2.0 layer2EncVia2) via2Width)))
 )


 
 (if layer2EdgesAt45 then

     (setq lowerLeftBL  trL2ringW)
     (setq upperLeftBL  trL2ringW)
     (setq lowerRightBL trL2ringW)
     (setq upperRightBL trL2ringW)
  else

     (setq lowerLeftBL  0.0)
     (setq upperLeftBL  0.0)
     (setq lowerRightBL 0.0)
     (setq upperRightBL 0.0)
 )
     (setq dbid (dbCreateParamInst tcCellView ringId "ol2r_third" 0.0:0.0 "R0" 1
                                   (list (list "w" "float" trL2w)
                                         (list "l" "float" trL2l)
                                         (list "xOffset" "float" trL2xDelta)
                                         (list "yOffset" "float" trL2yDelta)
                                         (list "ringLayer" "list" layer2)
                                         (list "ringWidth" "float" trL2ringW)
                                         (list "additionalWidthInBevel" "float" 0.0)
                                         (list "llBevelLength" "float" lowerLeftBL)
                                         (list "ulBevelLength" "float" upperLeftBL)
                                         (list "lrBevelLength" "float" lowerRightBL)
                                         (list "urBevelLength" "float" upperRightBL)
                                         (list "bevelTheOutside" "boolean" t)
                                         (list "grid" "float" layer2grid)
                                         (list "breakupPolygons" "boolean" "TRUE")
                                   )))
 (setq theMaster dbid~>master)

 (setq dbid1 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints1))
 (setq dbid2 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints2))
 (setq dbid3 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints3))
 (setq dbid4 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints4))
 (dbAddFigToNet dbid1 trNet)
 (dbAddFigToNet dbid2 trNet)
 (dbAddFigToNet dbid3 trNet)
 (dbAddFigToNet dbid4 trNet)

 ;; when layer2 is the topmost layer, create a terminal out of it
 (when  (and layer3 fullyStrap (nequal fullyStrap "FALSE"))

     ;;
     ;; 5.  if we must go to layer3, create the via2's and then create layer3
     ;;
     ;; center the via2's in the middle of layer2
     (setq tv2rEnc (quotient (difference trL2ringW via2Width) 2.0))
     ;; snap tv2rEnc to grid
     (setq tempSize (quotient tv2rEnc via2grid))
     (setq tv2rEnc (times (fix (plus tempSize 0.999)) via2grid))

     (if layer3EdgesAt45 then
         (setq lowerLeftBL  (times 2.0 via2Space))
         (setq upperLeftBL  (times 2.0 via2Space))
         (setq lowerRightBL (times 2.0 via2Space))
         (setq upperRightBL (times 2.0 via2Space))
      else
         (setq lowerLeftBL  via2Space)
         (setq upperLeftBL  via2Space)
         (setq lowerRightBL via2Space)
         (setq upperRightBL via2Space)
     )

     (dbCreateParamInst tcCellView rivetedRingId "ov2r_third" (plus trL2xDelta tv2rEnc):(plus trL2yDelta tv2rEnc)
 "R0" 1
                        (list (list "w" "float" (difference trL2w (times 2.0 tv2rEnc)))
                              (list "l" "float" (difference trL2l (times 2.0 tv2rEnc)))
                              (list "xOffset" "float" 0.0)
                              (list "yOffset" "float" 0.0)
                              (list "rivetLayer" "list" via2Layer)
                              (list "ringWidth" "float" via2Width)
                              (list "rivetWidth" "float" via2Width)
                              (list "rivetSpace" "float" via2Space)
                              (list "llBevelLength" "float" lowerLeftBL)
                              (list "ulBevelLength" "float" upperLeftBL)
                              (list "lrBevelLength" "float" lowerRightBL)
                              (list "urBevelLength" "float" upperRightBL)
                              (list "autoIncreaseBevelWidth" "boolean" "FALSE")
                              (list "grid" "float" via2grid)))
 


     ;; 6.  create the third ring of layer3.  target variables set:
     ;;   trL3w = the total width of the third layer3 guard ring
     ;;   trL3l = the total length of the third layer3 guard ring
     ;;   trL3xDelta = the x origin of the third layer3 guard ring
     ;;   trL3yDelta = the y origin of the third layer3 guard ring
     ;;
     (setq trL3w (plus trL2w (times -2.0 tv2rEnc) (times 2.0 trLayer3EncVia2)))
     (setq trL3l (plus trL2l (times -2.0 tv2rEnc) (times 2.0 trLayer3EncVia2)))
     (setq trL3xDelta (plus trL2xDelta tv2rEnc -trLayer3EncVia2))
     (setq trL3yDelta (plus trL2yDelta tv2rEnc -trLayer3EncVia2))

     (if layer3EdgesAt45 then
         (setq lowerLeftBL  trLayer3Width)
         (setq upperLeftBL  trLayer3Width)
         (setq lowerRightBL trLayer3Width)
         (setq upperRightBL trLayer3Width)
      else
         (setq lowerLeftBL  0.0)
         (setq upperLeftBL  0.0)
         (setq lowerRightBL 0.0)
         (setq upperRightBL 0.0)
     )

     (setq dbid (dbCreateParamInst tcCellView ringId "ol3r_third" 0.0:0.0 "R0" 1
                                   (list (list "w" "float" trL3w)
                                         (list "l" "float" trL3l)
                                         (list "xOffset" "float" trL3xDelta)
                                         (list "yOffset" "float" trL3yDelta)
                                         (list "ringLayer" "list" nil)
                                         (list "ringWidth" "float" trLayer3Width)
                                         (list "additionalWidthInBevel" "float" 0.0)
                                         (list "llBevelLength" "float" lowerLeftBL)
                                         (list "ulBevelLength" "float" upperLeftBL)
                                         (list "lrBevelLength" "float" lowerRightBL)
                                         (list "urBevelLength" "float" upperRightBL)
                                         (list "bevelTheOutside" "boolean" t)
                                         (list "grid" "float" layer3grid)
                                         (list "breakupPolygons" "boolean" t)
                                   )))

     (setq theMaster dbid~>master)
     (setq dbid1 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints1))
     (setq dbid2 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints2))
     (setq dbid3 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints3))
     (setq dbid4 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints4))
     (dbAddFigToNet dbid1 trNet)
     (dbAddFigToNet dbid2 trNet)
     (dbAddFigToNet dbid3 trNet)
     (dbAddFigToNet dbid4 trNet)

 )

 ;; 7.  create a terminal out of the topmost layer.  This could be layer2 or 3
 (setq pin (dbCreatePin trNet dbid1))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pin (dbCreatePin trNet dbid2))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pin (dbCreatePin trNet dbid3))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pin (dbCreatePin trNet dbid4))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 ;;end of third ring
)

)
;;; 
;;; $Id: pluggedPadClass.il,v 1.19 2008/02/29 21:18:00 cva Exp $ %T%
;;; 
;;; pluggedPadClass.il
;;; 
;;; Copyright (c) 1997 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Mar 07, 1997
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This is the code for the pluged pad element in the device library.
;;; 
;;; Revision History:
;;;   gtc 04/22/97  Adding support for subLayer and subViaLayer
;;;   gtc 07/07/97  Fixing the length
;;;   gtc 07/18/97  Adding the maxBevelCutLength
;;;   gtc 09/11/97  Breaking up rings into 4 geometries
;;;   xgs 07/08/99  Changed botLayerGrid to subLayerGrid in the section
;;;                 for drawing subLayer ring 
;;;   xgs 04/18/00  Added subViaWidth and subViaSpace parameters
;;;   kgr 08/29/01  Added subVia enclosure to for different met/via enclosures
;;;   lpn 04/12/02  Added pluggedPadMultLayClass to handle multiple layers in the form of lists 
;;;                 and pluggedPadClassT013 for T013 flow. 
;;;   lpn 04/16/02  Enhanced pluggedPadClass to handle multiple layers in the form of lists 
;;;                 and renamed pluggedPadClassT013 to pluggedPadClassSlot. 
;;;   lpn 05/27/02  Enhanced the pluggedPadClass to draw the octagonal top Via layer
;;;                 and two topLayers for Mram flow(*Z of 01-70001 spec).
;;;   lpn 06/25/02  Enhanced  pluggedPadClassSlot to draw minimum length of pad metal corner.
;;;   lpn 06/01/04  Enhanced class to draw text to identify package 
;;;   kmi 02/03/05  Adding signalLayer
;;;   kmi 02/08/05  Adding signalViaLayer
;;;   cva 03/28/05  padType added for labels
;;;   cva 04/01/05  adding pad target (center)
;;;   kuc 10/26/05  added offsets to change pad w and l
;;;   osd 11/13/06  updated labellayer location
;;;   kuc 08/01/07  added ability to fill pad with vias
;;;   cva 02/21/08  added shield layer
;;;


(putpropqq pluggedPadClass "$Id: pluggedPadClass.il,v 1.19 2008/02/29 21:18:00 cva Exp $ %T%" SCCS)


(tcCreateDeviceClass
  "symbolic" "pluggedPadClass"
  ;; Class parameters
  (
   (padLayer              "y0")
   (topLayer              '()) ;; Can be list of lpp's/ lpp like  (topLayer  '('("met2" "drawing")
			       ;;                                              '("met3" "drawing")))

   (botLayer              '()) ;; Should be list of lists '('()'())for the newer flows and for older flows it is a list 
   (subLayer              nil);; additional bottomLayer   
   (shieldLayer           nil);; unconnected pad shield 
 
   (viaLayer              nil) ;; Should be list of lists '('() '()) for the newer flows and for older flows it is a list
   (viaSpace              0.0) 
   (viaWidth              0.0)

   (subViaLayer           nil) ;; additional viaLayer
   (subViaWidth           0.0) 
   (subViaSpace           0.0)
   
   (bevelCutLength        0.0)
   (maxBevelCutLength     0.0)
   (topLayerEncPad        0.0)
   (botLayerSpacePad      0.0)
   (subLayerSpacePad      0.0)
   (genericRingName       "ringer")
   (rivetedRingName       "riveter")
   (bevelViaName          "bevelvia")
   
   (botLayerInsideEncVia     0.0)
   (botLayerOutsideEncVia    0.0)  
   (botLayerInsideEncSubVia  0.0) 
   (botLayerOutsideEncSubVia 0.0)
   
   (minWidth              0.0)
   (minLength             0.0)
   
   (padGrid               0.0)
   (topLayerGrid          0.0)   
   (botLayerGrid          0.0)
   (subLayerGrid          0.0)
   (viaGrid               0.0)
   (solidTopVia           "FALSE") 
   (filledVias            "FALSE")
   (topViaLayer           nil)
   (topLayerEncTopVia     0.0)
   (labelLayer (list "text" "drawing")) ;;; layer on which labels should be drawn, if nil labels are not drawn
   (labelWidth      1.0)   ;;; width of the label
   (signalLayer     nil)
   (signalViaLayer  nil)
   (padType         nil)
   (padCenter       nil)   ;;; center of pad layer
   (padCenterWidth  0.0)   ;;; dimension of the laser target 
   (wOffset         0.0)
   (lOffset         0.0)
  )
  ;; Formal parameters
  (
   (signalUnderPad  "FALSE")
   (shieldedPad     "FALSE")
   (shieldEnclosure 0.0)
   (plasticPackage  "FALSE")
   (hermeticPackage "FALSE")
   (w             0.0)
   (l             0.0)
   (shrinkPercent 0.0)
   (centerPad       "FALSE")
  )
  
  (setq w (difference w wOffset))
  (setq l (difference l lOffset))
  
  (if (or (equal filledVias t) (equal filledVias "TRUE")) then
   (setq filledVias t)
   else
   (setq filledVias nil)
  ) 

  (if (or (equal signalUnderPad t) (equal signalUnderPad "TRUE")) then
   (setq signalUnderPad t)
   else
   (setq signalUnderPad nil)
  ) 

  (if (or (equal shieldedPad t) (equal shieldedPad "TRUE")) then
    (setq shieldedPad t)
    else
    (setq shieldedPad nil)
   );cond 

  (setq net (dbCreateNet tcCellView "ppd"))
  (dbCreateTerm net "n" "inputOutput")
  
  ;; open the generic ring and do sanity checks on it
  (setq ringId (dbOpenCellView tcCellView~>lib genericRingName "symbolic" nil "rn"))
  (unless ringId
      (error "pluggedPadClass:  Cannot find/open generic ring %s\n" genericRingName)
  )
  (unless ringId~>isParamCell
      (error "pluggedPadClass:  Ring %s is not a pcell\n" genericRingName)
  )
  
  ;; open the riveted ring and do sanity checks on it
  (setq rivetId (dbOpenCellView tcCellView~>lib rivetedRingName "symbolic" nil "rn"))
  (unless rivetId
      (error "pluggedPadClass:  Cannot find/open riveted ring %s\n" rivetedRingName)
  )
  (unless rivetId~>isParamCell
      (error "pluggedPadClass:  Rivet ring %s is not a pcell\n" rivetedRingName)
  )
  ;; open the beveled via fill class and do sanity checks
  (when filledVias
    (setq fillId (dbOpenCellView tcCellView~>lib bevelViaName "symbolic" nil "rn"))
    (unless fillId~>isParamCell
      (error "pluggedPadClass:  Beveled via fill %s is not a pcell\n" bevelViaName)
      )
    )
  
  (setq s2 (sqrt 2.0))
  
  ;; get the X (or Y) cut length of the bevel and max
  (setq bevelCutLength (quotient bevelCutLength s2))
  (setq maxBevelCutLength (quotient maxBevelCutLength s2))
  
  ;; massage all of the parameters to account for the technology shrink
  
  (cond ((equal shrinkPercent 0.0)
	 (setq scaleMult 1.0)
	)         
      (t
       (setq scaleMult (quotient 100.0 (difference 100.0 shrinkPercent)))
       
       ;;
       ;; foreach doesn't work as it ought to here.  Another Cadence feature
       ;;
       (foreach sizeAndGrid (list (list 'w padGrid)
				  (list 'l padGrid)
				  (list 'topLayerEncPad topLayerGrid)
				  (list 'minWidth padGrid)
				  (list 'minLength padGrid)
				  (list 'botLayerSpacePad botLayerGrid)
				  (list 'subLayerSpacePad subLayerGrid)
				  
			    )
	   
	   (setq theSize (car sizeAndGrid))
	   (setq theGrid (cadr sizeAndGrid))
	   
	   (setq tempSize (quotient (times (eval theSize) scaleMult) theGrid))
	   (set theSize (times (fix (plus tempSize 0.999)) theGrid))
       )
      )
  )
  
 
  ;; calculate the correct bevel cut length
  (setq bevelCutLength (times padGrid (fix (plus 0.999 (quotient (times bevelCutLength scaleMult) padGrid)))))
  (when (greaterp bevelCutLength maxBevelCutLength)
      (setq bevelCutLength (times padGrid (fix (plus 1e-5 (quotient maxBevelCutLength padGrid)))))
  )
  
  ;; draw the pad opening
  (setq padXside (difference l (times 2.0 bevelCutLength)))
  (setq padYside (difference w (times 2.0 bevelCutLength)))
  
  (setq padPoints (list bevelCutLength:0.0
			(plus padXside bevelCutLength):0.0
			l:bevelCutLength
			l:(plus bevelCutLength padYside)
			(plus padXside bevelCutLength):w
			bevelCutLength:w
			0.0:(plus bevelCutLength padYside)
			0.0:bevelCutLength))
  
  (dbCreatePolygon tcCellView padLayer padPoints)
  
  ;; draw the top level
  ;; (setq thisLayer topLayer)
  (cond
      
      ((listp (car topLayer))
       topLayers = topLayer
      ) 
      
      ((car topLayer)
	topLayers =  (list topLayer)
      )
      
      (t 
       printf( "topLayer should be lpp or List(lpp1,lpp2...) only")
      )
      
  )    
  (setq encPad topLayerEncPad)
  
  ;; there is a fair amount of geometry/trig behind this equation.
  ;; See the design document for the details
  (setq extraOffset (quotient (times encPad (difference 2.0 s2)) topLayerGrid))
  
  ;; snap the extra offset to grid
  (setq extraOffset (times topLayerGrid (fix (plus 0.999 extraOffset))))
  
  ;; satisfy the enclosures better by removing one grid unit from the offset
  (setq extraOffset (difference extraOffset topLayerGrid))
  
  (setq theLength (plus l (times 2.0 encPad)))
  (setq lengthSide (difference theLength (times 2.0 (plus bevelCutLength extraOffset))))
  (setq theWidth (plus w (times 2.0 encPad)))
  (setq widthSide (difference theWidth (times 2.0 (plus bevelCutLength extraOffset))))
  (setq theBevel (plus bevelCutLength extraOffset))
  
  (setq thePoints (list (plus -encPad theBevel):-encPad
			(plus -encPad theBevel lengthSide):-encPad
			(plus -encPad theLength):(plus -encPad theBevel)
			(plus -encPad theLength):(plus -encPad theBevel widthSide)
			(plus -encPad theBevel lengthSide):(plus -encPad theWidth)
			(plus -encPad theBevel):(plus -encPad theWidth)
			-encPad:(plus -encPad theBevel widthSide)
			-encPad:(plus -encPad theBevel)))
  
  (foreach topLay topLayers  
      (setq dbid (dbCreatePolygon tcCellView topLay thePoints))
      (dbAddFigToNet dbid net)
  )

  (setq pinid (dbCreatePin net dbid))
  pinid~>accessDir = (list "top" "bottom" "left" "right")


 ;;; Shielded pads should be identical to topLayer, except may have a different enclosure
  (when shieldedPad
    (setq shieldEncPad shieldEnclosure)
    
    ;; there is a fair amount of geometry/trig behind this equation.
    ;; See the design document for the details
    (setq shieldExtraOffset (quotient (times shieldEncPad (difference 2.0 s2)) topLayerGrid))
    
    ;; snap the extra offset to grid
    (setq shieldExtraOffset (times topLayerGrid (fix (plus 0.999 shieldExtraOffset))))
    
    ;; satisfy the enclosures better by removing one grid unit from the offset
    (setq shieldExtraOffset (difference shieldExtraOffset topLayerGrid))
    
    (setq shieldLength     (plus l (times 2.0 shieldEncPad)))
    (setq shieldLengthSide (difference shieldLength (times 2.0 (plus bevelCutLength shieldExtraOffset))))
    (setq shieldWidth      (plus w (times 2.0 shieldEncPad)))
    (setq shieldWidthSide  (difference shieldWidth  (times 2.0 (plus bevelCutLength shieldExtraOffset))))
    (setq shieldBevel      (plus bevelCutLength shieldExtraOffset))
    
    (setq shieldPoints (list (plus -shieldEncPad shieldBevel):-shieldEncPad
			  (plus -shieldEncPad shieldBevel shieldLengthSide):-shieldEncPad
			  (plus -shieldEncPad shieldLength):(plus -shieldEncPad shieldBevel)
			  (plus -shieldEncPad shieldLength):(plus -shieldEncPad shieldBevel shieldWidthSide)
			  (plus -shieldEncPad shieldBevel shieldLengthSide):(plus -shieldEncPad shieldWidth)
			  (plus -shieldEncPad shieldBevel):(plus -shieldEncPad shieldWidth)
			  -shieldEncPad:(plus -shieldEncPad shieldBevel shieldWidthSide)
			  -shieldEncPad:(plus -shieldEncPad shieldBevel)))
    
    (setq dbid (dbCreatePolygon tcCellView shieldLayer shieldPoints))
    )

  (when ((plasticPackage == "TRUE") && (hermeticPackage == "TRUE"))
      (error "pluggedPadClass:  Cannot select plasticPackage and hermeticPackage")
  )
  
  (when  (plasticPackage == "TRUE")
      (setq netL "plastic")	
  ) 
  (when  (hermeticPackage == "TRUE")
      (setq netL "hermetic")		
  )
  
  (when (labelLayer && netL)
      (dbCreateLabel tcCellView labelLayer
		     (list  (quotient l 2.0) 
			    (quotient w 2.0))
		     netL "centerCenter" "R0" "roman" labelWidth)
  )

  (when  (padType == "highParallel")
      (setq typeL "HP")
  )
  (when  (padType == "finePitch")
      (setq typeL "FP")
  )
   (when  (padType == "staggered")
      (setq typeL "STG")
  )
  (when  (padType == "waferLevelBurnIn")
      (setq typeL "WLBI")
  )
  (when  (padType == "waferScale")
      (setq typeL "WSP")
  )
  (when (labelLayer && netL)
      (dbCreateLabel tcCellView labelLayer
                   (list  (quotient l 2.0)
                          (quotient w 2.0))
                   netL "centerCenter" "R0" "roman" labelWidth)
  )
  (when (labelLayer && typeL)
      (dbCreateLabel tcCellView labelLayer
                   (list  (quotient l 2.0)
                          (quotient w 2.1))
                   typeL "centerCenter" "R0" "roman" labelWidth)
  )
  (when (labelLayer && shieldedPad)
    (dbCreateLabel tcCellView labelLayer
                   (list  (quotient l 2.0)
                          (quotient w 2.2))
                   "shielded" "centerCenter" "R0" "roman" labelWidth)
    ) 

;; draw the laser target
(when (equal  centerPad "TRUE")
 (setq x1Coord (quotient (difference l padCenterWidth) 2.0))
 (setq y1Coord (quotient (difference w padCenterWidth) 2.0))
 (setq dbId    (dbCreateRect tcCellView padCenter
                         (list x1Coord:y1Coord 
                              (x1Coord+padCenterWidth):(y1Coord+padCenterWidth))))
)


 
  
  ;; To draw Single solid octagonal shaped Via layer enclosing "pad" Layer 

  (when solidTopVia
	
	(setq topViaencPad (plus topLayerEncPad -topLayerEncTopVia))
	
	;; there is a fair amount of geometry/trig behind this equation.
	;; See the design document for the details
	(setq extraOffsetVia (quotient (times topViaencPad (difference 2.0 s2)) topLayerGrid))
	
	;; snap the extra offset to grid
	(setq extraOffsetVia (times topLayerGrid (fix (plus 0.999 extraOffsetVia))))
	
	;; satisfy the enclosures better by removing one grid unit from the offset
	(setq extraOffsetVia (difference extraOffsetVia topLayerGrid))
	
	(setq theLengthVia (plus l (times 2.0 topViaencPad)))
	(setq lengthSide (difference theLengthVia (times 2.0 (plus bevelCutLength extraOffsetVia))))
	(setq theWidthVia (plus w (times 2.0 topViaencPad)))
	(setq widthSide (difference theWidthVia (times 2.0 (plus bevelCutLength extraOffsetVia))))
	(setq theBevelVia (plus bevelCutLength extraOffsetVia))
	
	(setq thePoints (list (plus -topViaencPad theBevelVia):-topViaencPad
			      (plus -topViaencPad theBevelVia lengthSide):-topViaencPad
			      (plus -topViaencPad theLengthVia):(plus -topViaencPad theBevelVia)
			      (plus -topViaencPad theLengthVia):(plus -topViaencPad theBevelVia widthSide)
			      (plus -topViaencPad theBevelVia lengthSide):(plus -topViaencPad theWidthVia)
			      (plus -topViaencPad theBevelVia):(plus -topViaencPad theWidthVia)
			      -topViaencPad:(plus -topViaencPad theBevelVia widthSide)
			      -topViaencPad:(plus -topViaencPad theBevelVia)))
	
	(setq dbid (dbCreatePolygon tcCellView topViaLayer thePoints))  
	(dbAddFigToNet dbid net)
	
	)
   
  (cond 
   
   ((listp (car botLayer)) && (listp (car viaLayer))
    botLayers = botLayer
    viaLayers = viaLayer
    )
      
      (!(listp (car botLayer)) && !(listp (car viaLayer))
	botLayers = (list botLayer)
	viaLayers = (list (list (car viaLayer) viaSpace viaWidth padGrid))
	
	(when subLayer
	    botLayers = (cons subLayer  botLayers)
	) 
	
	(when subViaLayer
	    viaLayers1 = (list  (list  (car subViaLayer) subViaSpace subViaWidth padGrid))
	    viaLayers  = (append viaLayers1 viaLayers)
	) 
	
      )
      
      (t
       printf( "BOTH  botLayer and viaLayer should be list(lists) or just lists \n")
      )
  )
  
    
  (setq dbid
	(dbCreateParamInst tcCellView ringId "botRing" 0.0:0.0 "R0" 1
			   (list (list "w"  "float" theWidth)
				 (list "l" "float" theLength)
				 (list "xOffset" "float" -topLayerEncPad)
				 (list "yOffset" "float" -topLayerEncPad)
				 (list "ringLayer" "list" nil)
				(list "ringWidth" "float" (difference topLayerEncPad botLayerSpacePad))
				(list "additionalWidthInBevel" "float" 0.0)
				(list "llBevelLength" "float" theBevel)
				(list "ulBevelLength" "float" theBevel)
				(list "lrBevelLength" "float" theBevel)
				(list "urBevelLength" "float" theBevel)
				(list "bevelTheOutside" "boolean" t)
				 (list "grid" "float" topLayerGrid)
				 (list "breakupPolygons" "boolean" "TRUE")
			   )
	) 
  ) 
  
  (setq theMaster dbid~>master)
  (foreach botLay   botLayers
    (when (or (nequal botLay signalLayer) !signalUnderPad)
      (setq dbid (dbCreatePolygon tcCellView   botLay  theMaster~>ringPoints1))
      (dbAddFigToNet dbid net)
      (setq dbid (dbCreatePolygon tcCellView   botLay  theMaster~>ringPoints2))
      (dbAddFigToNet dbid net)
      (setq dbid (dbCreatePolygon tcCellView   botLay   theMaster~>ringPoints3))
      (dbAddFigToNet dbid net)
      (setq dbid (dbCreatePolygon tcCellView   botLay   theMaster~>ringPoints4))
      (dbAddFigToNet dbid net)
    )
  )
  
  (setq viaCount 0)
  
 
  (foreach viaLayer viaLayers
      (setq viaOffset (difference topLayerEncPad botLayerOutsideEncVia))
      (setq extraOffset (quotient (times viaOffset (difference 2.0 s2)) padGrid))
      (setq extraOffset (times padGrid (fix (plus 0.999 extraOffset))))
      (setq extraOffset (difference extraOffset padGrid))
      (setq theBevel (plus bevelCutLength extraOffset padGrid))
      (setq viaLayerName     (list (car viaLayer) "drawing"))
      (setq viaWidth1        (caddr viaLayer)) 
      (setq viaSpace1        (cadr viaLayer))
      (setq layGrid          (nth 3 viaLayer))

      (unless filledVias
	(when (or (nequal viaLayerName signalViaLayer) !signalUnderPad)
	  (dbCreateParamInst tcCellView rivetId (sprintf nil "rivetVia%d" viaCount) -viaOffset:-viaOffset "R0" 1
			     (list (list "w" "float" (difference theWidth (times 2.0 (difference topLayerEncPad viaOffset))))
				   (list "l" "float" (difference theLength (times 2.0 (difference topLayerEncPad viaOffset))))
				   (list "xOffset" "float" 0.0)
				   (list "yOffset" "float" 0.0)
				   (list "rivetLayer" "list"  viaLayerName)
				   (list "ringWidth" "float" (difference viaOffset botLayerInsideEncVia botLayerSpacePad))
				   (list "rivetWidth" "float" viaWidth1)
				   (list "rivetSpace" "float" viaSpace1)
				   (list "llBevelLength" "float" theBevel)
				   (list "ulBevelLength" "float" theBevel)
				   (list "lrBevelLength" "float" theBevel)
				   (list "urBevelLength" "float" theBevel)
				   (list "autoIncreaseBevelWidth" "boolean" "FALSE")
				   (list "grid" "float" layGrid)
				   )
			     )
	  (setq viaCount (plus viaCount 1))
	  ))
      
      (when filledVias
	(setq layMetEnc          (nth 4 viaLayer))
	(setq theViaBevel        (times s2 (plus (quotient theBevel s2) (difference topLayerEncPad layMetEnc))))
	(setq viaShift (quotient (difference (times 2 topLayerEncPad) (times layMetEnc 2)) 2))
	(dbCreateParamInst tcCellView fillId (sprintf nil "fillVia%d" viaCount) -viaShift:-viaShift "R0" 1
			   (list (list "viaLayer" "list"  viaLayerName)
				 (list "l" "float" (difference (plus (times 2 topLayerEncPad) w) (times layMetEnc 2)))
				 (list "w" "float" (difference (plus (times 2 topLayerEncPad) l) (times layMetEnc 2)))
				 (list "viaWidth" "float" viaWidth1)
				 (list "viaSpace" "float" viaSpace1)
				 (list "bevelLength" "float" theViaBevel)
				 )
			   )
	(setq viaCount (plus viaCount 1))
	)

  ) ;; end foreach
  
  (dbClose ringId)
  (dbClose rivetId)
  (when filledVias
    (dbClose fillId)
    )
 
 ) ;; end of class definition











;;; 
;;; 
;;; 
;;; pluggedPadClassSlot
;;; 
;;; Description:
;;;   This is the code for the plugged pad element for T013 flow in the device library.
;;; 
;;; Revision History:
;;;  
;;;  lpn 04/04/2002 Production Release
;;;  lpn 05/05/2002 Enhanced the class to handle vialayers in form of lists.
;;;

(tcCreateDeviceClass
 "symbolic" "pluggedPadClassSlot"
 ;; Class parameters
 ((padLayer              (list "y0" "drawing"))
  (topViaLayer           '( "y1" 0.0 0.0 0.0 )) ;;'("layerName" spacing width grid)
  (topLayer              (list "y2" "drawing"))
  (oddMetLayers          (list nil nil nil nil))
  (evenMetLayers         (list nil nil nil))
  (viaLayers             `( '("y3"   0.1 0.1)  ;;'("layerN" spacing width)	
			    '("y4"  0.1 0.1)			
			    '("y5"  0.1 0.1)			
			  )	
  )		
  (viaArraySize          (list (list 3 3) (list 2 2)))  
  (bevelCutLength        0.0)
  (maxBevelCutLength     0.0)
  (topLayerEncPad        0.0)
  (metRingWidth          0.0)       
  (metLineWidth          0.0)
  (metLineSpace          0.0)  
  (endMetLineSpace       0.0)
  (padGrid               0.0)
  (genericRingName       "genDLring")
  (topLayerGrid          0.0) 
 )
 
 ;; Formal parameters
 (
  (w             0.0)
  (l             0.0)
  (shrinkPercent 0.0)
 )
 
 (setq net (dbCreateNet tcCellView "ppd"))
 (dbCreateTerm net "n" "inputOutput")
 
 ;; open the generic ring and do sanity checks on it
 (setq ringId (dbOpenCellView tcCellView~>lib genericRingName "symbolic" nil "rn"))
 (unless ringId
     (error "pluggedPadClassSlot:  Cannot find/open generic ring %s\n" genericRingName)
 )
 (unless ringId~>isParamCell
     (error "pluggedPadClassSlot:  Ring %s is not a pcell\n" genericRingName)
 )
  
 (setq s2 (sqrt 2.0))
 (setq via1_6Rows (caar viaArraySize))
 (setq via1_6Cols (cadar viaArraySize))
 (setq via7Rows   (caadr viaArraySize))
 (setq via7Cols   (cadadr viaArraySize))
 
 topViaLayerName = car( topViaLayer) 
 topViaWidth     = nth( 2   topViaLayer)
 topViaSpace     = nth( 1   topViaLayer)

 
 ;; get the X (or Y) cut length of the bevel and max
 (setq bevelCutLength    (quotient bevelCutLength s2))
 (setq maxBevelCutLength (quotient maxBevelCutLength s2))
 (setq encPad topLayerEncPad)
 Array_length = l - (2 * (metRingWidth - encPad))
 Array_width  = w - (2 * (metRingWidth - encPad))
 
 metLinePitch = metLineWidth + metLineSpace
 numVerLines  = floor( (Array_length - endMetLineSpace) / metLinePitch )
 numHorLines  = floor( (Array_width - endMetLineSpace)  / metLinePitch )
 addSpaceVer  = (Array_length - (numVerLines * metLinePitch) + metLineSpace) / 2  
 addSpaceHor  = (Array_width  - (numHorLines * metLinePitch) + metLineSpace) / 2  
 
 
 
 ;; massage all of the parameters to account for the technology shrink
 (cond ((equal shrinkPercent 0.0)
	(setq scaleMult 1.0)
       ) 
     (t
      (setq scaleMult (quotient 100.0 (difference 100.0 shrinkPercent)))
      
      ;;
      ;; foreach doesn't work as it ought to here.  Another Cadence feature
      ;;
      (foreach sizeAndGrid (list (list 'w               padGrid)
				 (list 'l               padGrid)
				 (list 'topLayerEncPad  topLayerGrid)
				 (list 'metRingWidth    padGrid)                   
				 (list 'metLineWidth    padGrid)    
				 (list 'metLineSpace    padGrid)     
				 (list 'endMetLineSpace padGrid)    
				 (list 'topViaWidth     padGrid)   
				 (list 'topViaSpace     padGrid)  
			   )
	  
	  (setq theSize (car sizeAndGrid))
	  (setq theGrid (cadr sizeAndGrid))
	  
	  (setq tempSize (quotient (times (eval theSize) scaleMult) theGrid))
	  (set theSize (times (fix (plus tempSize 0.999)) theGrid))
      )
     )
 )
 

 ;; calculate the correct bevel cut length
 (setq bevelCutLength (times padGrid (fix (plus 0.999 (quotient (times bevelCutLength scaleMult) padGrid)))))
 (when (greaterp bevelCutLength maxBevelCutLength)
     (setq bevelCutLength (times padGrid (fix (plus 1e-5 (quotient maxBevelCutLength padGrid)))))
 )
 
 ;; draw the pad opening
 (setq padXside (difference l (times 2.0 bevelCutLength)))
 (setq padYside (difference w (times 2.0 bevelCutLength)))
 
 (setq padPoints (list bevelCutLength:0.0
		       (plus padXside bevelCutLength):0.0
		       l:bevelCutLength
		       l:(plus bevelCutLength padYside)
		       (plus padXside bevelCutLength):w
		       bevelCutLength:w
		       0.0:(plus bevelCutLength padYside)
		       0.0:bevelCutLength))
 
 (dbCreatePolygon tcCellView padLayer padPoints)
 
 ;; draw the top level
 (setq thisLayer topLayer)
 
 
 ;; there is a fair amount of geometry/trig behind this equation.
 ;; See the design document for the details
 (setq extraOffset (quotient (times encPad (difference 2.0 s2)) topLayerGrid))
 
 ;; snap the extra offset to grid
 (setq extraOffset (times topLayerGrid (fix (plus 0.999 extraOffset))))
 
 ;; satisfy the enclosures better by removing one grid unit from the offset
 (setq extraOffset (difference extraOffset topLayerGrid))
 
 (setq theLength (plus l (times 2.0 encPad)))
 (setq lengthSide (difference theLength (times 2.0  bevelCutLength )))
 (setq theWidth (plus w (times 2.0 encPad)))
 (setq widthSide (difference theWidth (times 2.0  bevelCutLength )))
 (setq theBevel (plus bevelCutLength extraOffset))
 
 (setq thePoints (list (plus -encPad  bevelCutLength):-encPad
		       (plus -encPad  bevelCutLength lengthSide):-encPad
		       (plus -encPad theLength):(plus -encPad bevelCutLength)
		       (plus -encPad theLength):(plus -encPad bevelCutLength widthSide)
		       (plus -encPad bevelCutLength lengthSide):(plus -encPad theWidth)
		       (plus -encPad bevelCutLength):(plus -encPad theWidth)
		       -encPad:(plus -encPad bevelCutLength widthSide)
		       -encPad:(plus -encPad bevelCutLength)))

 (setq dbid (dbCreatePolygon tcCellView thisLayer thePoints))
 (dbAddFigToNet dbid net)
 (setq pinid (dbCreatePin net dbid))
 pinid~>accessDir = (list "top" "bottom" "left" "right")
 

 ;; draw all the other Metal rings
 
 (setq dbid
       (dbCreateParamInst tcCellView ringId "botRing" 0.0:0.0 "R0" 1
			  (list (list "w"  "float" theWidth)
				(list "l" "float" theLength)
				(list "xOffset" "float" -topLayerEncPad)
				(list "yOffset" "float" -topLayerEncPad)
				(list "ringLayer" "list" nil)
				(list "ringWidth" "float" topLayerEncPad)
				(list "additionalWidthInBevel" "float" 0.0)
				(list "llBevelLength" "float" bevelCutLength)
				(list "ulBevelLength" "float" bevelCutLength)
				(list "lrBevelLength" "float" bevelCutLength)
				(list "urBevelLength" "float" bevelCutLength)
				(list "bevelTheOutside" "boolean" "TRUE")
			;;	(list "bevelTheOutsideNoInside" "boolean" "TRUE")
				(list "grid" "float" topLayerGrid)
				(list "breakupPolygons" "boolean" "TRUE")
			  )
       )
 )
 
 
 (setq theMaster dbid~>master)
 
 MetLayers = append( oddMetLayers evenMetLayers) 
 
 (foreach layer MetLayers
     (setq dbid (dbCreatePolygon tcCellView (list layer "drawing") theMaster~>ringPoints1))
     (dbAddFigToNet dbid net)
     (setq dbid (dbCreatePolygon tcCellView (list layer "drawing") theMaster~>ringPoints2))
     (dbAddFigToNet dbid net)
     (setq dbid (dbCreatePolygon tcCellView (list layer "drawing") theMaster~>ringPoints3))
     (dbAddFigToNet dbid net)
     (setq dbid (dbCreatePolygon tcCellView (list layer "drawing") theMaster~>ringPoints4))
     (dbAddFigToNet dbid net)
 )
  (setq dbid
       (dbCreateParamInst tcCellView ringId "botRing1" 0.0:0.0 "R0" 1
			  (list (list "w"  "float" w)
				(list "l" "float" l)
				(list "xOffset" "float" 0.0)
				(list "yOffset" "float" 0.0)
				(list "ringLayer" "list" nil)
				(list "ringWidth" "float" (plus metRingWidth -topLayerEncPad))
				(list "additionalWidthInBevel" "float" 0.0)
				(list "grid" "float" topLayerGrid)
				(list "breakupPolygons" "boolean" "TRUE")
			  )
       )
  )
  
  
  (setq theMaster dbid~>master)
 
 (foreach layer MetLayers
     (setq dbid (dbCreatePolygon tcCellView (list layer "drawing") theMaster~>ringPoints1))
     (dbAddFigToNet dbid net)
     (setq dbid (dbCreatePolygon tcCellView (list layer "drawing") theMaster~>ringPoints2))
     (dbAddFigToNet dbid net)
     (setq dbid (dbCreatePolygon tcCellView (list layer "drawing") theMaster~>ringPoints3))
    (dbAddFigToNet dbid net)
     (setq dbid (dbCreatePolygon tcCellView (list layer "drawing") theMaster~>ringPoints4))
     (dbAddFigToNet dbid net)
 )

 (dbClose ringId)
 
 
 
 ;; Draw the Metal Array 
 
 Array_length = l - (2 * (metRingWidth - encPad))
 Array_width  = w - (2 * (metRingWidth - encPad))
 
 metLinePitch = metLineWidth + metLineSpace
 numVerLines  = floor( (Array_length - endMetLineSpace) / metLinePitch )
 numHorLines  = floor( (Array_width - endMetLineSpace)  / metLinePitch )
 addSpaceVer  = (Array_length - (numVerLines * metLinePitch) + metLineSpace) / 2  
 addSpaceHor  = (Array_width  - (numHorLines * metLinePitch) + metLineSpace) / 2  
 
 (setq addSpaceHor_tmp    (quotient (times addSpaceHor scaleMult) padGrid))
 (setq addSpaceHor        (times (fix (plus addSpaceHor_tmp 0.999)) padGrid))
 (setq addSpaceVer_tmp    (quotient (times addSpaceVer scaleMult) padGrid))
 (setq addSpaceVer        (times (fix (plus addSpaceVer_tmp 0.999)) padGrid))
 
 theX = metRingWidth - encPad + addSpaceVer
 theY = metRingWidth - encPad 
 
 (for number 1 numVerLines
      (foreach layer oddMetLayers
	  (dbCreateRect tcCellView (list layer "drawing")
			(list theX : theY
			      theX + metLineWidth : theY + Array_width))   
      )
      theX = theX + metLinePitch 
      
 ) ;; end for    
 
 theY = metRingWidth - encPad + addSpaceHor 
 theX = metRingWidth - encPad 
 
 (for number 1 numHorLines      
      (foreach layer evenMetLayers
	  (dbCreateRect tcCellView (list layer "drawing")
			(list theX : theY
			      theX + Array_length : theY + metLineWidth))   
      )
      
      theY = theY + metLinePitch
 ) ;; end for  
 
 
 ;;Draw the Via Arrays
 ;;via1 to via6 is assumed as an nxn array 
 ;;via7 is assumed as an mxm array   
 ;; This Class can be further enhanced to handle different arrays(n1xn1 ,n2xn2 .....) for different vias(via1 to via6) 
 
 
 (foreach viaLayer viaLayers  
  
     viaLayerName = car( viaLayer)
     viaSpace     = nth(1 viaLayer) 
     viaWidth     = nth( 2 viaLayer)
     enclViasMet     = ((metLineWidth - ((via1_6Rows - 1) * viaSpace) - (via1_6Rows * viaWidth)) / 2)     
     theX = metRingWidth - encPad + addSpaceVer + enclViasMet
     theY = metRingWidth - encPad + addSpaceHor + enclViasMet
     
     (for m 1 numHorLines
	  (for k 1 numVerLines     
	       theY1 = theY
	       (for i 1 via1_6Rows
		    theX1 = theX
		    (for j 1 via1_6Cols	
			 
			 (dbCreateRect tcCellView  (list viaLayerName "drawing") 
				       (list theX1 : theY1
					     theX1 + viaWidth : theY1 + viaWidth))  
		     	
			 theX1 = theX1 + viaWidth + viaSpace 
		    )
		    theY1 = theY1 + viaWidth + viaSpace 
	       )
	       theX  = theX +  metLinePitch
	       
	  ) 
	  
	  theY = theY + metLinePitch
	  theX = metRingWidth - encPad + addSpaceVer + enclViasMet     
     )
 )    
 
 enclTopViaMet   = ((metLineWidth - ((via7Rows - 1)   * topViaSpace) - ( via7Rows* topViaWidth)) / 2)
 theXtopVia = metRingWidth - encPad + addSpaceVer + enclTopViaMet
 theYtopVia = metRingWidth - encPad + addSpaceHor + enclTopViaMet
 
 (for m 1 numHorLines
      (for k 1 numVerLines     
	   theYtopVia1 = theYtopVia
	   (for i 1 via7Rows
		theXtopVia1 = theXtopVia
		(for j 1 via7Cols
		     
		     (dbCreateRect tcCellView  (list topViaLayerName "drawing")
				   (list theXtopVia1 : theYtopVia1
					 theXtopVia1 + topViaWidth : theYtopVia1 + topViaWidth))  
		     theXtopVia1 = theXtopVia1 + topViaWidth + topViaSpace 
		)
		theYtopVia1 = theYtopVia1 + topViaWidth + topViaSpace 
	   )
	   theXtopVia  = theXtopVia +  metLinePitch
	   
      ) 
      
      theYtopVia = theYtopVia + metLinePitch
      theXtopVia = metRingWidth - encPad + addSpaceVer + enclTopViaMet     
 )
 
) ;; End pluggedPadClassSlot class defn
;;; 
;;; $Id: nEsdTranImpCascodeClass.il,v 1.4 2008/04/01 20:51:16 kuc Exp $
;;; 
;;; nEsdTranImpCascodeClass.il
;;; 
;;; Copyright (c) 2002 by Cypress Semiconductor
;;; Cypress India Design Center (CIDC)
;;; 
;;; Date  : Feb 7, 2002
;;; Author: LakshmiNarayanan/CAD @INDC
;;; 
;;; Description:
;;;   This is an variant on the transistor for the device library.  It will
;;; provide ESD protection.  This should be used as the N ESD transistor for
;;; nwell technologies, and as the P ESD transistor for pwell technologies.
;;; 
;;; Revision History:
;;;
;;;   lpn 02/07/02  Intial Release 
;;;   cva 02/12/03  updates for HV
;;;   kuc 02/07/06  updates for semi-scalable models
;;;   kuc 03/26/08  guard ring updates
;;;

(tcCreateDeviceClass
 "symbolic" "nEsdTranImpCascodeClass"
 ;; Class parameters
 (
  (diffLayer            "y0")
  (gateLayer            "y1")
  (rgateLayer           "y2")
  (wellLayer            "y3")
  (tapLayer             "y4")
  (via1Layer            "y5")
  (layer2               "y6")
  (via2Layer            "y7")
  (layer3               "y8")
  (idLayer              "y9")
  (diffImplant          nil)
  (diffImpEnc           0.0)
  (diffCoreImplant      nil)
  (diffCoreImpEnc       0.0)
  (tapWellImplant       nil)
  (tapWellImpEnc        0.0)
  (tapSubImplant        nil)
  (tapSubImpEnc         0.0)
  (srcViaGateSpace      0.0)
  (drnViaGateSpace      0.0)
  (viaExtDiffY          0.0)
  (minDiffTapRingSpace  0.0)
  (GateToGateSpace      0.0)
  (flareYamount_out     0.0)
  (flareYamount_in      0.0)
  (flareYextension      0.0)
  (via1Width            0.0)
  (via1Space            0.0)
  (tapEncVia1           0.0)
  (innerRingTapEncVia1  0.0)
  (outerRingTapEncVia1  0.0)
  (wellEncTap           0.0)
  (ESDnwEncVia1         0.0)
  (ESDnwGateSp          0.0)
  (innerRingTapWidth    0.0)
  (outerRingTapWidth    0.0)
  (wellTapSpace         0.0)
  (layer2EncVia1        0.0)
  (via2Width            0.0)
  (via2Space            0.0)
  (via1Via2Space        0.0)
  (layer2EncVia2        0.0)
  (layer2Width          0.0)
  (layer3EncVia2        0.0)
  (layer3Width          0.0)
  (innerRingMetalWidth  0.0)
  (irLayer3EncVia2      0.0)
  (orLayer3Width        0.0)
  (minW                 0.0)
  (maxW                 0.0)
  (minTotalW            0.0)
  (genericRingName      "ring")
  (rivetedRingName      "rivetRing")
  (flaredGateName       "flaredGate")
  (diffGrid             0.00)
  (tapGrid              0.00)
  (wellGrid             0.00)
  (polyGrid             0.00)
  (via1grid             0.00)
  (layer2grid           0.00)
  (via2grid             0.00)
  (layer3grid           0.00)
  (tapEdgesAt45         nil)
  (layer2EdgesAt45      nil)
  (layer3EdgesAt45      nil)
  (noTapNwell           nil) 
  (hvLayer              nil)
  (hvDiffEnclosure      0.0) ;;;enclosure of diff by hv id layer.
  (modelTextLayer       (list "hilite" "drawing"))
  (modelTextLayerSize   0.2)
  (modelText            "")
  (modelWmax            0.0)
  (modelWmin            0.0)
  (modelLmax            0.0)
  (modelLmin            0.0)
  (filledRings          nil)
 )
 ;; Formal parameters
 (
  (w                0.0)
  (l                0.0)
  (m                0)
  (extraLeftSpace   0.0)
  (extraRightSpace  0.0)
  (shrinkPercent    0.0)
  (extraSrcSpace    0.0)
  (extraDrnSpace    0.0)
  (fullyStrap	    "FALSE")
  (drnViaYspaceRingViaTop  0.0)
  (drnViaYspaceRingViaBot  0.0)
  (viaExtDiffX          0.0)
  (orirLayer3Space      0.0)
 )

 (when (w > modelWmax)
   (error "%f is greater than allowable maximum width %f for model %L" w modelWmax modelText))
 (when (w < modelWmin)
   (error "%f is less than allowable minimum width %f for model %L" w modelWmin modelText))
 (when (l > modelLmax)
   (error "%f is greater than allowable length %f for model %L" l modelLmax modelText))
 (when (l < modelLmin)
   (error "%f is less than allowable minimum length %f for model %L" l modelLmin modelText))

 ;; make the nets and the terminals that will be used in the cell
 (setq gNet (dbCreateNet tcCellView "g"))
 (dbCreateTerm gNet "g" "input")
 (setq sNet (dbCreateNet tcCellView "s"))
 (dbCreateTerm sNet "s" "inputOutput")
 (setq dNet (dbCreateNet tcCellView "d"))
 (dbCreateTerm dNet "d" "inputOutput")
 (setq irNet (dbCreateNet tcCellView "ir"))
 (dbCreateTerm irNet "ir" "inputOutput")
 (setq orNet (dbCreateNet tcCellView "or"))
 (dbCreateTerm orNet "or" "inputOutput")


 ;; massage all parameters to their scaled counterparts
 (cond ((equal shrinkPercent 0.0)
	(setq scaleMult 1.0)
      ) 
     (t
      (setq scaleMult (quotient 100.0 (difference 100.0 shrinkPercent)))
      (setq via1PolyGrid (max via1grid polyGrid))

      ;;
      ;; foreach doesn't work as it ought to here.  Another Cadence feature
      ;;
      (foreach sizeAndGrid (list (list 'srcViaGateSpace via1PolyGrid)
				 (list 'drnViaGateSpace via1PolyGrid)
				 (list 'drnViaYspaceRingViaTop via1grid)
				 (list 'drnViaYspaceRingViaBot via1grid)
				 (list 'ESDnwEncVia1 tapGrid)
				 (list 'ESDnwGateSp tapGrid)
				 (list 'innerRingTapWidth tapGrid)
				 (list 'outerRingTapWidth tapGrid)
				 (list 'innerRingMetalWidth layer2grid)
				 (list 'via1Via2Space via1grid)
				 (list 'layer2Width layer2grid)
				 (list 'layer3Width layer3grid)
				 (list 'orLayer3Width layer3grid)
				 (list 'minW diffGrid)
				 (list 'maxW diffGrid)
				 (list 'minTotalW diffGrid)
				 (list 'viaExtDiffY diffGrid)
			   )

	  (setq theSize (car sizeAndGrid))
	  (setq theGrid (cadr sizeAndGrid))

	  (setq tempSize (quotient (times (eval theSize) scaleMult) theGrid))
	  (set theSize (times (fix (plus tempSize 0.999)) theGrid))
      )

     ) ;; end massaging the variables to account for the scale
 )

 ;; we want to be able to share the outer guard ring between to pcell
 ;; instances placed side by side.  In order to do this, we need to have
 ;; the contacts in the outer ring centered and on grid.  This might be a
 ;; bit confusing, but this means:
 ;;
 ;;   If the contact is an odd integer multiple of the snap grid, the width of
 ;;   the ring enclosing it must be an odd integer multiple of the snap grid.
 ;;   This will keep the enclosure the same to the inside and outside of the
 ;;   contact.
 ;;
 ;;   If the contact is an even integer multiple of the snap grid, the width
 ;;   of the ring enclosing it must be an even integer multiple of the snap
 ;;   grid.  This will keep the enclosure the same to the inside and outside
 ;;   of the contact.
 ;;
 (foreach kludge (list (list 'orLayer3Width layer3grid via2Width via2grid)
		       (list 'outerRingTapWidth tapGrid via1Width via1grid)
		 )
     (setq tmpOrLayerWidth (nth 0 kludge))
     (setq tmpOrLayerGrid (nth 1 kludge))
     (setq tmpViaWidth (nth 2 kludge))
     (setq tmpViaGrid (nth 3 kludge))

     (setq tempSize (quotient tmpViaWidth tmpViaGrid))
     (cond
	 ((oddp (fix (plus tempSize 0.999)))
	  ;; make sure that tmpOrLayerWidth is an odd multiple of the grid
	  (setq tempSize (quotient (eval tmpOrLayerWidth) tmpOrLayerGrid))
	  (when (evenp (fix (plus tempSize 0.999)))
	      (set tmpOrLayerWidth (plus (eval tmpOrLayerWidth) layer3grid))
	  )
	 )
	 (t
	  ;; make sure that tmpOrLayerWidth is an even multiple of the grid
	  (setq tempSize (quotient (eval tmpOrLayerWidth) tmpOrLayerGrid))
	  (when (oddp (fix (plus tempSize 0.999)))
	      (set tmpOrLayerWidth (plus (eval tmpOrLayerWidth) layer3grid))
	  )
	 )
     )
 )

 ;;
 ;; do sanity checks on the width
 ;; Sub sanity check on width:  It is an integral multiple of the via pitch
 ;;
 (setq via1Pitch (plus via1Width via1Space))

 ;; targetRows is a floating point number that represents the number of rows
 ;; of via1's that can fit within the width
 (setq targetRows (quotient (plus w (times -2.0 viaExtDiffY) via1Space) via1Pitch))

 ;; rowsOfContacts is an integer version of targetRows
 (setq rowsOfContacts (fix (plus 0.999 targetRows)))

 ;; targetRows and rowsOfContacts must be the same to satisfy the via pitch
 ;; requirement of the ESD transistor
 (when (greaterp (abs (difference rowsOfContacts targetRows)) 1e-4)
     (error "nEsdTranImpCascodeClass: w (%f) does not satisfy via pitch requirements.  Try either %f or %f\n" w
	    (plus (times rowsOfContacts via1Pitch) -via1Space (times 2.0 viaExtDiffY ))
	    (plus (times (difference rowsOfContacts 1) via1Pitch) -via1Space (times 2.0 viaExtDiffY ))
     )
 )

 ;;
 ;; Sub sanity check on width:  It is between the minimum and maximum width
 ;;
 (when (lessp (difference w 1e-6) minW)
     (error "nEsdTranImpCascodeClass:  w (%f) is less than minimum allowable width per leg (%f)\n" w minW)
 )

 (when (greaterp (difference w 1e-6) maxW )
     (error "nEsdTranImpCascodeClass:  w (%f) is greater than maximum allowable width per leg (%f)\n" w maxW)
 )

 (when (lessp (times w  m) minTotalW)
     (error "nEsdTranImpCascodeClass:  total w (%f) is less than the minimum total width (%f)\n"
	    (times w m) minTotalW)
 )

 ;; 
 ;; Sanity check on drnViaYspaceRingViaTop
 (when (lessp drnViaYspaceRingViaTop (plus srcViaGateSpace drnViaGateSpace l extraDrnSpace extraSrcSpace))
     (error "nEsdTranImpCascodeClass:  drnViaYspaceRingViaTop (%f) is less than minimum allowable (%f)\n"
	    drnViaYspaceRingViaTop (plus srcViaGateSpace drnViaGateSpace l extraDrnSpace extraSrcSpace))
 )

 ;; Sanity check on drnViaYspaceRingViaBot
 (when (lessp drnViaYspaceRingViaBot (plus srcViaGateSpace drnViaGateSpace l extraDrnSpace extraSrcSpace))
     (error "nEsdTranImpCascodeClass:  drnViaYspaceRingViaBot (%f) is less than minimum allowable (%f)\n"
	    drnViaYspaceRingViaBot (plus srcViaGateSpace drnViaGateSpace l extraDrnSpace extraSrcSpace))
 )

 ;;
 ;; do a sanity check on the number of legs
 ;;
 (unless (and (null (floatp m)) (numberp m))
     (error "nEsdTranImpCascodeClass:  m must be an even integer, not a float\n")
 )

 (when (oddp m)
     (error "nEsdTranImpCascodeClass:  m (number of legs) must be an even integer\n")
 )

 ;;
 ;; do a sanity check that the sub-pcells exist
 ;; 1.  verify that the flared gate pcell exists & is a pcell
 ;;
 (setq flaredGateId (dbOpenCellView tcCellView~>lib flaredGateName "symbolic" nil "rn"))
 (unless flaredGateId
     (error "nEsdTranImpCascodeClass:  Cannot find/open flared gate %s\n" flaredGateName)
 )
 (unless flaredGateId~>isParamCell
     (error "nEsdTranImpCascodeClass:  Flared gate %s is not a pcell\n" flaredGateName)
 )

 ;;
 ;; 2.  verify that the generic ring exists & is a pcell
 ;;
 (setq ringId (dbOpenCellView tcCellView~>lib genericRingName "symbolic" nil "rn"))
 (unless ringId
     (error "nEsdTranImpCascodeClass:  Cannot find/open ring %s\n" genericRingName)
 )
 (unless ringId~>isParamCell
     (error "nEsdTranImpCascodeClass:  Ring %s is not a pcell\n" genericRingName)
 )

 ;;
 ;; 3.  verify that the riveted ring exists & is a pcell
 ;;
 (setq rivetedRingId (dbOpenCellView tcCellView~>lib rivetedRingName "symbolic" nil "rn"))
 (unless rivetedRingId
     (error "nEsdTranImpCascodeClass:  Cannot find/open riveted ring %s\n" rivetedRingName)
 )
 (unless rivetedRingId~>isParamCell
     (error "nEsdTranImpCascodeClass:  Riveted ring %s is not a pcell\n" rivetedRingName)
 )

 ;;
 ;; create the diffusion.
 ;;
(if noTapNwell 
 (setq diffXorigin (plus -viaExtDiffX -via1Width -via1Width -via1Space -srcViaGateSpace -extraSrcSpace))
 (setq diffXorigin (plus -viaExtDiffX -via1Width -srcViaGateSpace -extraSrcSpace))
) 
 (setq diffYorigin 0.0)

 ;; totalDrnLength is the gate to gate length of a drain region
 ;; totalSrcLength is the gate to gate length of a source region
(if noTapNwell then
 (setq totalDrnLength (plus (times 2.0 (plus drnViaGateSpace extraDrnSpace))
			    (times 2.0 via1Width) via1Space))
 (setq totalSrcLength (plus (times 2.0 (plus srcViaGateSpace extraSrcSpace))
			    (times 2.0 via1Width) via1Space))
else
 (setq totalDrnLength (plus (times 2.0 (plus drnViaGateSpace extraDrnSpace))
			    via1Width))
 (setq totalSrcLength (plus (times 2.0 (plus srcViaGateSpace extraSrcSpace))
			    via1Width))
)

 (setq diffXend (plus diffXorigin
		      (times -2.0 diffXorigin)
		      (times l m)
		      (times (plus GateToGateSpace l) m)
		      (times (xquotient m 2) totalDrnLength)
		      (times (difference (xquotient m 2) 1) totalSrcLength)
		)
 )
 ;;(setq diffYend (plus w (times 2 flareYamount)))
 (setq diffYend w)

 ;; define parameters for ESD nwell tap
 (when (and (greaterp ESDnwEncVia1 0.0) (greaterp ESDnwGateSp 0.0))
					;  (setq ESDnwTWidth   (difference totalDrnLength (times 2.0 ESDnwGateSp)))
    (if noTapNwell then
     (setq ESDnwTWidthDrn   (difference (plus (times 2.0 drnViaGateSpace) (times 2.0 via1Width) via1Space) 
                            (times 2.0 ESDnwGateSp)))
     (setq ESDnwTWidthSrc   (difference (plus (times 2.0 srcViaGateSpace) (times 2.0 via1Width) via1Space) 
                            (times 2.0 ESDnwGateSp)))
     else
      (setq ESDnwTWidthDrn  (difference (plus (times 2.0 drnViaGateSpace) via1Width) (times 2.0 ESDnwGateSp)))
      (setq ESDnwTWidthSrc  (difference (plus (times 2.0 srcViaGateSpace) via1Width) (times 2.0 ESDnwGateSp)))
    )

     (setq ESDnwTXorigin (plus -ESDnwGateSp -ESDnwTWidthSrc))
     (setq ESDnwTYorigin (difference viaExtDiffY ESDnwEncVia1))
     (setq ESDnwTYend    (plus viaExtDiffY (times rowsOfContacts via1Width) (times (difference rowsOfContacts 1) via1Space) ESDnwEncVia1))
 )

 ;; if ESDnwEncVia1 and ESDnwGateSp parameters are defined then source/drain diffusion has to be drawn with a hole and
 ;; also need to draw  ESD nwell tap in this hole region

 (if (and (greaterp ESDnwEncVia1 0.0) (greaterp ESDnwGateSp 0.0)) then 

     ;; draw the diffusion for the first source region & attach to source net
     ;;  (setq diffXloop (quotient l 2.0))
     (setq diffXloop (plus l (quotient GateToGateSpace 2.0)))
     (setq dbid (dbCreatePolygon tcCellView diffLayer
				 (list diffXorigin:diffYorigin
				       diffXorigin:diffYend
				       diffXloop:diffYend
				       diffXloop:ESDnwTYend
				       (plus ESDnwTXorigin -extraSrcSpace):ESDnwTYend
				       (plus ESDnwTXorigin -extraSrcSpace):diffYorigin)))
				   
     (dbAddFigToNet dbid sNet)  
     (setq dbid (dbCreatePolygon tcCellView diffLayer
				 (list (plus ESDnwTXorigin -extraSrcSpace):diffYorigin
				       diffXloop:diffYorigin
				       diffXloop:ESDnwTYend
				       (plus ESDnwTXorigin -extraSrcSpace ESDnwTWidthSrc):ESDnwTYend
				       (plus ESDnwTXorigin -extraSrcSpace ESDnwTWidthSrc):ESDnwTYorigin
				       (plus ESDnwTXorigin -extraSrcSpace):ESDnwTYorigin)))
     (dbAddFigToNet dbid sNet)  

      ;; draw ESD nwell tap region
 (if noTapNwell then
     (setq dbid (dbCreateRect tcCellView diffLayer
			      (list (plus ESDnwTXorigin -extraSrcSpace):ESDnwTYorigin
				    (plus ESDnwTXorigin -extraSrcSpace ESDnwTWidthSrc):ESDnwTYend)))
     (dbAddFigToNet dbid sNet)
     
     (setq dbid (dbCreateRect tcCellView diffLayer
			      (list (plus ESDnwTXorigin -extraSrcSpace):ESDnwTYorigin
				    (plus ESDnwTXorigin -extraSrcSpace ESDnwTWidthSrc):ESDnwTYend)))
  else
     (setq dbid (dbCreateRect tcCellView tapLayer
			      (list (plus ESDnwTXorigin -extraSrcSpace):ESDnwTYorigin
				    (plus ESDnwTXorigin -extraSrcSpace ESDnwTWidthSrc):ESDnwTYend)))
     (dbAddFigToNet dbid sNet)
     
     (setq dbid (dbCreateRect tcCellView wellLayer
			      (list (plus ESDnwTXorigin -extraSrcSpace):ESDnwTYorigin
				    (plus ESDnwTXorigin -extraSrcSpace ESDnwTWidthSrc):ESDnwTYend)))
  )   

     ;;(setq ESDnwTXorigin (plus ESDnwTXorigin ESDnwTWidth (times 2.0 ESDnwGateSp) l))
     (setq ESDnwTXorigin (plus ESDnwTXorigin ESDnwTWidthSrc (times 2.0 ESDnwGateSp) l l GateToGateSpace extraDrnSpace))
    
     ;; loop through all the inside source/drain regions, draw the diffusion
     ;; and attach to correct net
     (for section 1 (xquotient m 2)
	  ;; draw the drain region
	  ;; (setq drnDiffXend (plus diffXloop totalDrnLength l))
	  (setq drnDiffXend (plus diffXloop totalDrnLength l l GateToGateSpace))
	 
	  (setq dbid (dbCreatePolygon tcCellView diffLayer
				      (list diffXloop:diffYorigin
					    diffXloop:diffYend
					    drnDiffXend:diffYend
					    drnDiffXend:ESDnwTYend
					    ESDnwTXorigin:ESDnwTYend
					    ESDnwTXorigin:diffYorigin)))
	  
	  (dbAddFigToNet dbid dNet)  
	  (setq dbid (dbCreatePolygon tcCellView diffLayer
				      (list ESDnwTXorigin:diffYorigin
					    drnDiffXend:diffYorigin
					    drnDiffXend:ESDnwTYend
					    (plus ESDnwTXorigin ESDnwTWidthDrn):ESDnwTYend
					    (plus ESDnwTXorigin ESDnwTWidthDrn):ESDnwTYorigin
					    ESDnwTXorigin:ESDnwTYorigin)))
	  (dbAddFigToNet dbid dNet)    
      
	  ;; draw ESD nwell tap regions

	  (setq dbid (dbCreateRect tcCellView tapLayer
				   (list ESDnwTXorigin:ESDnwTYorigin
					 (plus ESDnwTXorigin ESDnwTWidthDrn):ESDnwTYend)))
	  (dbAddFigToNet dbid dNet)
	  
	  (setq dbid (dbCreateRect tcCellView wellLayer
				   (list ESDnwTXorigin:ESDnwTYorigin
					 (plus ESDnwTXorigin ESDnwTWidthDrn):ESDnwTYend)))
	  
	  ;;(setq ESDnwTXorigin (plus ESDnwTXorigin ESDnwTWidth (times 2.0 ESDnwGateSp) l))
	  (setq ESDnwTXorigin (plus ESDnwTXorigin ESDnwTWidthDrn (times 2.0 ESDnwGateSp) l l GateToGateSpace
                                                                                          extraSrcSpace extraDrnSpace ))

	  (setq diffXloop drnDiffXend)

	  (unless (equal section (xquotient m 2))
	      (setq srcDiffXend (plus diffXloop totalSrcLength l l GateToGateSpace))
	      
	      (setq dbid (dbCreatePolygon tcCellView diffLayer
					  (list diffXloop:diffYorigin
						diffXloop:diffYend
						srcDiffXend:diffYend
						srcDiffXend:ESDnwTYend
						ESDnwTXorigin:ESDnwTYend
						ESDnwTXorigin:diffYorigin)))
	      
	      (dbAddFigToNet dbid sNet)  
	      (setq dbid (dbCreatePolygon tcCellView diffLayer
					  (list ESDnwTXorigin:diffYorigin
						srcDiffXend:diffYorigin
						srcDiffXend:ESDnwTYend
						(plus ESDnwTXorigin ESDnwTWidthSrc):ESDnwTYend
						(plus ESDnwTXorigin ESDnwTWidthSrc):ESDnwTYorigin
						ESDnwTXorigin:ESDnwTYorigin)))
	      (dbAddFigToNet dbid sNet)  
	  
	  ;; draw ESD nwell tap regions
             (if noTapNwell then	      
	      (setq dbid (dbCreateRect tcCellView diffLayer
				       (list ESDnwTXorigin:ESDnwTYorigin
					     (plus ESDnwTXorigin ESDnwTWidthSrc):ESDnwTYend)))
	      (dbAddFigToNet dbid sNet)
	      
	      (setq dbid (dbCreateRect tcCellView diffLayer
				       (list ESDnwTXorigin:ESDnwTYorigin
					     (plus ESDnwTXorigin ESDnwTWidthSrc):ESDnwTYend)))
	     else
	      	      (setq dbid (dbCreateRect tcCellView tapLayer
				       (list ESDnwTXorigin:ESDnwTYorigin
					     (plus ESDnwTXorigin ESDnwTWidthSrc):ESDnwTYend)))
	      (dbAddFigToNet dbid sNet)
	      
	      (setq dbid (dbCreateRect tcCellView wellLayer
				       (list ESDnwTXorigin:ESDnwTYorigin
					     (plus ESDnwTXorigin ESDnwTWidthSrc):ESDnwTYend)))
             )
	      
	      ;;(setq ESDnwTXorigin (plus ESDnwTXorigin ESDnwTWidth (times 2.0 ESDnwGateSp) l))
	      (setq ESDnwTXorigin (plus ESDnwTXorigin ESDnwTWidthSrc extraSrcSpace (times 2.0 ESDnwGateSp) l l GateToGateSpace extraDrnSpace ))
	      (setq diffXloop srcDiffXend)
	  )
     )

 ;; draw the diffusion for the last source region & attach to source net

     (setq dbid (dbCreatePolygon tcCellView diffLayer
				 (list diffXloop:diffYorigin
				       diffXloop:diffYend
				       diffXend:diffYend
				       diffXend:ESDnwTYend
				       ESDnwTXorigin:ESDnwTYend
				       ESDnwTXorigin:diffYorigin)))
				   
     (dbAddFigToNet dbid sNet)  
     (setq dbid (dbCreatePolygon tcCellView diffLayer
				 (list ESDnwTXorigin:diffYorigin
				       diffXend:diffYorigin
				       diffXend:ESDnwTYend
				       (plus ESDnwTXorigin ESDnwTWidthSrc):ESDnwTYend
				       (plus ESDnwTXorigin ESDnwTWidthSrc):ESDnwTYorigin
				       ESDnwTXorigin:ESDnwTYorigin)))
     (dbAddFigToNet dbid sNet)  

      ;; draw ESD nwell tap regions

    (if noTapNwell then	
     (setq dbid (dbCreateRect tcCellView diffLayer
			      (list ESDnwTXorigin:ESDnwTYorigin
				    (plus ESDnwTXorigin ESDnwTWidthSrc):ESDnwTYend)))
     (dbAddFigToNet dbid sNet)

     (setq dbid (dbCreateRect tcCellView diffLayer
			      (list ESDnwTXorigin:ESDnwTYorigin
				    (plus ESDnwTXorigin ESDnwTWidthSrc):ESDnwTYend)))

     (setq ESDnwTXorigin (plus ESDnwTXorigin ESDnwTWidthSrc (times 2.0 ESDnwGateSp) l))
   else
     (setq dbid (dbCreateRect tcCellView tapLayer
			      (list ESDnwTXorigin:ESDnwTYorigin
				    (plus ESDnwTXorigin ESDnwTWidthSrc):ESDnwTYend)))
     (dbAddFigToNet dbid sNet)

     (setq dbid (dbCreateRect tcCellView wellLayer
			      (list ESDnwTXorigin:ESDnwTYorigin
				    (plus ESDnwTXorigin ESDnwTWidthSrc):ESDnwTYend)))

     (setq ESDnwTXorigin (plus ESDnwTXorigin ESDnwTWidthSrc (times 2.0 ESDnwGateSp) l))
    )

;; blew this section away as it was drawing unecessary diff on the esdnwelltap areas
;;
;;     ;; draw the diffusion for the first source region & attach to source net
;;     (setq diffXloop (quotient l 2.0))
;;     (setq dbid (dbCreateRect tcCellView diffLayer (list diffXorigin:diffYorigin
;;							 diffXloop:diffYend)))
;;     (dbAddFigToNet dbid sNet)
;;
;;     ;; loop through all the inside source/drain regions, draw the diffusion
;;     ;; and attach to correct net
;;     (for section 1 (xquotient m 2)
;;	  ;; draw the drain region
;;	  (setq drnDiffXend (plus diffXloop totalDrnLength l l GateToGateSpace))
;;     (if ! noTapNwell then
;;	  (setq dbid (dbCreateRect tcCellView diffLayer (list diffXloop:diffYorigin
;;							      drnDiffXend:diffYend)))
;;	  (dbAddFigToNet dbid dNet)
;;     )
;;	  (setq diffXloop drnDiffXend)
;;
;;	  (unless (equal section (xquotient m 2))
;;	      (setq srcDiffXend (plus diffXloop totalSrcLength l l GateToGateSpace))
;;	      (setq dbid (dbCreateRect tcCellView diffLayer (list diffXloop:diffYorigin
;;								  srcDiffXend:diffYend)))
;;	      (dbAddFigToNet dbid sNet)
;;	      (setq diffXloop srcDiffXend)
;;	  )
;;     )
;;
;;     ;; draw the diffusion for the last source region & attach to source net
;;     (setq dbid (dbCreateRect tcCellView diffLayer (list diffXloop:diffYorigin
;;							 diffXend:diffYend)))
;;     (dbAddFigToNet dbid sNet)
;;     
 )

 ;; draw the id layer (esd) around the diffusion
 (dbCreateRect tcCellView idLayer (list diffXorigin:diffYorigin diffXend:diffYend))
 
 ;; draw the diff implant
 (when diffImplant
     (dbCreateRect tcCellView diffImplant (list (list (difference diffXorigin diffImpEnc)
						      (difference diffYorigin diffImpEnc)
						)
						(list (plus       diffXend    diffImpEnc)
						      (plus       diffYend    diffImpEnc)
						  )
					  )
     )
 )
 
 ;; draw the diff Core implant
 (when diffCoreImplant
     (dbCreateRect tcCellView diffCoreImplant (list (list (difference diffXorigin diffCoreImpEnc)
						      (difference diffYorigin diffCoreImpEnc)
						)
						(list (plus       diffXend    diffCoreImpEnc)
						      (plus       diffYend    diffCoreImpEnc)
						  )
					  )
     )
 )
 
 (when hvLayer
     ;;;The hvi layer must enclose the diff layer ,so we can draw the hvi layer here
     ;;;Create the lowerLeft and upperRight corners of the hvi rectangle.
     ;;;The ll corner is x:(diffXorigin - hvDiffEnclosure), y:(diffYorigin - hvDiffEnclosure)
     (setq hvllx (difference diffXorigin hvDiffEnclosure))
     (setq hvlly (difference diffYorigin hvDiffEnclosure))
     ;;;The ur corner is x:(diffXend + hvDiffEnclosure), y:(diffYend + hvDiffEnclosure)
     (setq hvurx (plus diffXend hvDiffEnclosure))
     (setq hvury (plus diffYend hvDiffEnclosure))
     (dbCreateRect tcCellView hvLayer list(hvllx:hvlly hvurx:hvury))
 )

 ;;
 ;; create the flared gates
 ;;
 (setq gateXoffset 0.0)
 (for gateNum 1 m

      ;; instantiate the flared gate
      (setq inst (dbCreateParamInst tcCellView flaredGateId (sprintf nil "g%d" gateNum)
				    0.0:0.0 "R0" 1
				    (list (list "gateLayer" "list" nil)
					  (list "gateRecognitionLayer" "list" rgateLayer)
					  (list "w" "float" w)
					  (list "l" "float" l)
					  (list "flareAmount_out" "float" flareYamount_out)
					  (list "flareAmount_in" "float" flareYamount_in)
					  (list "flareExtension" "float" flareYextension)
					  (list "xOffset" "float" gateXoffset)
					  (list  "gateToGateSpace" "float" GateToGateSpace)
				    )
		 ))
      (unless inst
	  (error "nEsdTranImpCascodeClass:  Failed to create instance of flared gate %s" flaredGateName)
      )

      ;; add the gate to net, and create pins out of the flared regions
      (setq master inst~>master)
      (setq dbid (dbCreateRect tcCellView gateLayer master~>noflarePoints))
      (dbAddFigToNet dbid gNet)

      (setq modelTextX (plus gateXoffset (quotient (difference (caadr master~>noflarePoints) (caar master~>noflarePoints)) 2)))
      (setq modelTextY (quotient (difference (cadar master~>noflarePoints) (cadadr master~>noflarePoints)) 2))
      (dbCreateLabel tcCellView modelTextLayer (list modelTextX modelTextY) modelText "centerCenter" "R0" "stick" modelTextLayerSize)
      (setq modelTextX (plus (plus GateToGateSpace l) (plus gateXoffset (quotient (difference (caadr master~>noflarePoints) (caar master~>noflarePoints)) 2))))
      (dbCreateLabel tcCellView modelTextLayer (list modelTextX modelTextY) modelText "centerCenter" "R0" "stick" modelTextLayerSize)

      (setq dbid (dbCreateRect tcCellView gateLayer master~>noflarePoints1))
      (dbAddFigToNet dbid gNet)
      
      (setq dbid (dbCreatePolygon tcCellView gateLayer master~>topFlarePoints))
      (setq pinid (dbCreatePin gNet dbid))
      (pinid~>accessDir = (list "top"))

      (setq dbid (dbCreatePolygon tcCellView gateLayer master~>topFlarePoints1))
      (setq pinid (dbCreatePin gNet dbid))
      (pinid~>accessDir = (list "top"))

      (setq dbid (dbCreatePolygon tcCellView gateLayer master~>bottomFlarePoints))
      (setq pinid (dbCreatePin gNet dbid))
      (pinid~>accessDir = (list "bottom"))
 
      (setq dbid (dbCreatePolygon tcCellView gateLayer master~>bottomFlarePoints1))
      (setq pinid (dbCreatePin gNet dbid))
      (pinid~>accessDir = (list "bottom"))
    
      ;; add the correct x offset whether the next region is a source or drain
      (cond ((oddp gateNum)
	     (setq gateXoffset (plus gateXoffset l l GateToGateSpace totalDrnLength))
	    )
	  (t
	   (setq gateXoffset (plus gateXoffset l l GateToGateSpace totalSrcLength))
	  )
      )
 )

 ;;
 ;; create the contacts
 ;;
(if noTapNwell
 (setq via1Xorigin (plus -srcViaGateSpace -extraSrcSpace -via1Width -via1Width -via1Space))
 (setq via1Xorigin (plus -srcViaGateSpace -extraSrcSpace -via1Width))
)
 (setq via1Yorigin viaExtDiffY)
;; (setq via1Xdelta (plus via1Width extraSrcSpace srcViaGateSpace l drnViaGateSpace extraDrnSpace))
(if noTapNwell
 (setq via1Xdelta (plus via1Width via1Width via1Space extraSrcSpace srcViaGateSpace l GateToGateSpace l  drnViaGateSpace extraDrnSpace))
 (setq via1Xdelta (plus via1Width extraSrcSpace srcViaGateSpace l GateToGateSpace l  drnViaGateSpace extraDrnSpace))
)
(setq theNet sNet)

 ;; make sure that the L of layer2 can handle both a via1 and a via2
 ;; target variables set are:
 ;;   layer2DeltaVia1 = how far offset layer2 is from via1 in the X
 ;;   layer2L = the length of layer2 to enclose the vias
 ;; auxillary variables used are:
 ;;   layer2L = layer2 length enclosing via1
 ;;   layer2La = layer2 length enclosing via2
 ;;   delta, when layer2La > layer2L, is layer2La - layer2L
 ;;
 (cond ((greaterp (setq layer2L (plus layer2EncVia1 via1Width layer2EncVia1))
		  (setq layer2La (plus layer2EncVia2 via2Width layer2EncVia2)))
	(setq layer2DeltaVia1 layer2EncVia1)
       )
     (t
      (setq delta (quotient (difference layer2La layer2L) 2.0))
      (setq layer2DeltaVia1 (plus layer2EncVia1 (times (fix (plus 0.999 (quotient delta layer2grid))) layer2grid)))
      (setq layer2L layer2La)
     )
 )

 (setq via2Pitch (plus via2Width via2Space))

 ;; calculate how many via2 contacts we can fit
 ;; target variables set:
 ;;   layer2YDeltaVia1 = how far offset layer2 is from via1 in the Y
 ;;   layer2W - the width of layer2 to enclose the vias
 ;;   rowsOfContacts2 - the number of rows of via2 contacts
 ;; auxillary variables used are:
 ;;   layer2W = the width of layer2 to encloseing via1
 ;;   layer2Wa = the width of layer2 to enclosing via2
 ;;   delta, when layer2Wa > layer2W, is layer2Wa - layer2W
 ;;
 (setq layer2W (plus (times 2.0 layer2EncVia1) (times rowsOfContacts via1Pitch) -via1Space))
 (setq layer2Wa (difference (times 2.0 layer2EncVia2) via2Space))
 (setq rowsOfContacts2 0)
 (while (lessp (difference layer2Wa 1e-5) layer2W)
     (setq layer2Wa (plus layer2Wa via2Pitch))
     (setq rowsOfContacts2 (plus rowsOfContacts2 1))
 )
 (setq layer2Wa (difference layer2Wa via2Pitch))
 (setq rowsOfContacts2 (difference rowsOfContacts2 1))
 (setq layer2YDeltaVia1 layer2EncVia1)

 ;; loop through all of the source and drain regions while drawing
 ;; 1.  via1s
 ;; 2.  layer2
 ;; 3.  via2s
 ;; 4.  layer3
 ;;
 (for column 0 m

      ;; set "theNet" to the proper source or drain net for this region
      (cond ((evenp column)
	     (setq theNet sNet)
	    )
	  (t
	   (setq theNet dNet)
	  )
      )

      ;;
      ;; 1.  Draw the via1s
      ;;
      (setq via1Xend (plus via1Xorigin via1Width))
      (setq via1Yloop via1Yorigin)
      (for row 1 rowsOfContacts
	  (if noTapNwell then
	   (setq dbid (dbCreateRect tcCellView via1Layer
				    (list via1Xorigin:via1Yloop
					  via1Xend:(plus via1Yloop via1Width))))
           ;;;Draw the second row of via1Layer
          
 	   (setq dbid (dbCreateRect tcCellView via1Layer
				    (list (plus via1Xend via1Space):via1Yloop
					  (plus via1Xend via1Space via1Width):(plus via1Yloop via1Width))))          
	   (dbAddFigToNet dbid theNet)
	   (setq via1Yloop (plus via1Yloop via1Pitch))
          else
	   (setq dbid (dbCreateRect tcCellView via1Layer
				    (list via1Xorigin:via1Yloop
					  via1Xend:(plus via1Yloop via1Width))))
	   (dbAddFigToNet dbid theNet)
	   (setq via1Yloop (plus via1Yloop via1Pitch))
	  )
      )

      ;;
      ;; 2.  Draw layer2
      ;;

      ;; draw layer2 with a width of layer2Width if this parameter is > 0.0
      (if (greaterp layer2Width 0.0) then
	(if noTapNwell
          (setq layer2Xorigin (min (difference (plus via1Xorigin (times 0.5 via1Space) via1Width)
                              (times 0.5 layer2Width)) (plus via1Xorigin  -layer2EncVia2)))
          (setq layer2Xorigin (min (plus (difference via1Xorigin (times 0.5 layer2Width))
                              (times 0.5 via1Width))(plus via1Xorigin -via1Via2Space -via2Width -layer2EncVia2)))
        )
	  ;; make sure layer2Xorigin is on grid
	  (setq layer2Xorigin (times (round (plus (quotient layer2Xorigin layer2grid) 0.001)) layer2grid))
       else
	  (setq layer2Xorigin (difference via1Xorigin layer2DeltaVia1))
      )
      (setq layer2Yorigin (difference via1Yorigin layer2YDeltaVia1))
      (setq layer2Yend (plus layer2Yorigin layer2W))

      (if (greaterp layer2Width 0.0) then
	(if layer2EdgesAt45 then
	  ;; set parameter to control the length of bevel at 45 degrees 
	  (setq l2bvlCntrl (quotient layer2Width 3.0))
	  ;; snap l2bvlCntrl to grid
	  (setq l2bvlCntrl (times (round (plus (quotient l2bvlCntrl layer2grid) 0.001)) layer2grid))
	  
	  (setq dbid (dbCreatePolygon tcCellView layer2
				      (list (list (plus layer2Xorigin l2bvlCntrl)
						  (plus layer2Yorigin -l2bvlCntrl)
						  )
					    (list layer2Xorigin layer2Yorigin)
					    (list layer2Xorigin layer2Yend)
					    (list (plus layer2Xorigin l2bvlCntrl) (plus layer2Yend l2bvlCntrl))
					    (list (plus layer2Xorigin 
							(max layer2Width 
							     (plus (times 2.0 via2Width) 
								   (times 2.0 via1Via2Space)
								   via1Width 
								   (times 2.0 layer2EncVia2)
								   )
							     )
							-l2bvlCntrl
							)
						  (plus layer2Yend l2bvlCntrl)
						  )
					    (list (plus layer2Xorigin 
							(max layer2Width 
							     (plus (times 2.0 via2Width)
								   (times 2.0 via1Via2Space)
								   via1Width
								   (times 2.0 layer2EncVia2)
								   )
							     )
							)
						  layer2Yend
						  )
					    (list (plus layer2Xorigin 
							(max layer2Width 
							     (plus (times 2.0 via2Width)
								   (times 2.0 via1Via2Space)
								   via1Width
								   (times 2.0 layer2EncVia2)
								   )
							     )
							)
						  layer2Yorigin
						  )
					    (list (plus layer2Xorigin 
							(max layer2Width
							     (plus (times 2.0 via2Width)
								   (times 2.0 via1Via2Space)
								   via1Width
								   (times 2.0 layer2EncVia2)
								   )
							     )
							-l2bvlCntrl)
						  (plus layer2Yorigin -l2bvlCntrl)
						  )
					    )
				      )
		)
	  (dbAddFigToNet dbid theNet)
	 else
	  ;; don't bevel layer2 edges
	  (setq dbid (dbCreateRect tcCellView layer2
				  (list (list layer2Xorigin
					      layer2Yorigin
					      )
					(list (plus layer2Xorigin 
						    (max layer2Width 
							 (plus (times 2.0 via2Width)
							       (times 2.0 via1Via2Space)
							       via1Width
							       (times 2.0 layer2EncVia2)
							       )
							 )
						    )
					      layer2Yend
					      )
					)
				  ))
	  (dbAddFigToNet dbid theNet)
	  ) ;; end if layer2EdgesAt45
       else
	  (setq dbid (dbCreateRect tcCellView layer2
				   (list layer2Xorigin:layer2Yorigin
					 (plus layer2Xorigin layer2L):layer2Yend)))
	  (dbAddFigToNet dbid theNet)
      ) ;; end if layer2Width > 0

      ;;
      ;; 3.  Draw the via2s
      ;;
      
      ;; draw 2 columns of via2s on either side of via1s if parameter via1Via2Space > 0.0
       (if noTapNwell then
	 (setq via2Xorigin (difference (plus via1Xorigin (times 0.5 via1Space) via1Width) 
                                       (plus (times 0.5 via2Space) via2Width)))
       else   
         (if (greaterp via1Via2Space 0.0) then
           (setq via2Xorigin (plus via1Xorigin via1Width via1Via2Space))
         else
           (setq via2Xorigin (plus layer2Xorigin layer2EncVia2))
         )
        )

      (setq via2Xend (plus via2Xorigin via2Width))
      (setq via2Yorigin (plus layer2Yorigin layer2EncVia2))
      (setq via2Yloop via2Yorigin)
      
      (for row 1 rowsOfContacts2
	   (setq dbid (dbCreateRect tcCellView via2Layer
				    (list via2Xorigin:via2Yloop
					  via2Xend:(plus via2Yloop via2Width))))
	   (dbAddFigToNet dbid theNet)
	   
	   ;; draw additional column only when via1Via2Space > 0.0
	 (if noTapNwell then
             (setq dbid (dbCreateRect tcCellView via2Layer
			(list (plus via2Xorigin via2Space via2Width):via2Yloop
		              (plus via2Xorigin via2Space via2Width via2Width):(plus via2Yloop via2Width))))
         else   
            (when (greaterp via1Via2Space 0.0) 
	     (setq dbid (dbCreateRect tcCellView via2Layer
                        (list (plus via1Xorigin -via1Via2Space -via2Width):via2Yloop
                              (plus via1Xorigin -via1Via2Space):(plus via2Yloop via2Width))))
            )
         ) 
	 (dbAddFigToNet dbid theNet)
	 (setq via2Yloop (plus via2Yloop via2Pitch))
       )
      
      ;;
      ;; 4.  Draw layer3
      ;;
      
      ;; draw layer3 with a width of layer3Width if this parameter is > 0.0
      (if (greaterp layer3Width 0.0) then
       (if noTapNwell
	(setq layer3Xorigin (plus (difference via1Xorigin (times 0.5 layer3Width)) (times 0.5 via1Space) via1Width))
        (setq layer3Xorigin (plus (difference via1Xorigin (times 0.5 layer3Width)) (times 0.5 via1Width)))
       )
	;; make sure layer3Xorigin is on grid
	(setq layer3Xorigin (times (round (plus (quotient layer3Xorigin layer3grid) 0.001)) layer3grid))
	
	(if layer3EdgesAt45 then
	  ;; set parameter to control the length of bevel at 45 degrees 
	  (setq l3bvlCntrl (quotient layer3Width 3.0))
	  ;; snap l3bvlCntrl to grid
	  (setq l3bvlCntrl (times (round (plus (quotient l3bvlCntrl layer2grid) 0.001)) layer2grid))
	  
	  (setq dbid (dbCreatePolygon tcCellView layer3
				      (list (list (plus layer3Xorigin l3bvlCntrl)
						  (plus via2Yorigin -layer3EncVia2 -l3bvlCntrl)
						  )
					    (list layer3Xorigin (plus via2Yorigin -layer3EncVia2))
					    (list layer3Xorigin (plus via2Yloop -via2Space layer3EncVia2))
					    (list (plus layer3Xorigin l3bvlCntrl)
						  (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrl)
						  )
					    (list (plus layer3Xorigin layer3Width -l3bvlCntrl)
						  (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrl)
						  )
					    (list (plus layer3Xorigin layer3Width)
						  (plus via2Yloop -via2Space layer3EncVia2)
						  )
					    (list (plus layer3Xorigin layer3Width)
						  (plus via2Yorigin -layer3EncVia2)
						  )
					    (list (plus layer3Xorigin layer3Width -l3bvlCntrl)
						  (plus via2Yorigin -layer3EncVia2 -l3bvlCntrl)
						  )
					    )
				      )
		)
	  else
	  ;; don't bevel layer3 edges
	  (setq dbid (dbCreateRect tcCellView layer3
				  (list (list layer3Xorigin
					      (plus via2Yorigin -layer3EncVia2)
					      )
					(list (plus layer3Xorigin layer3Width)
					      (plus via2Yloop -via2Space layer3EncVia2)
					      )
					)
				  )
		)
	  (dbAddFigToNet dbid theNet)
	  );; end if layer3EdgesAt45
	else
	(setq dbid (dbCreateRect tcCellView layer3
				 (list (difference via2Xorigin layer3EncVia2):(difference via2Yorigin layer3EncVia2)
				       (plus via2Xend layer3EncVia2):(plus via2Yloop -via2Space layer3EncVia2))))
	)
      
      
      (setq pinid (dbCreatePin theNet dbid))

      ;; set pin access dir depending on if this is the first, last
      ;; or middle source/drain area
      (cond ((equal column 0)
	     pinid~>accessDir = (list "top" "bottom" "left")
	    )
	  ((equal column m)
	   pinid~>accessDir = (list "top" "bottom" "right")
	  )
	  (t
	   pinid~>accessDir = (list "top" "bottom")
	  )
      )

      (setq via1Xorigin (plus via1Xorigin via1Xdelta))
 ) ; end drawing the source/drain contacts

 ;;
 ;; create the inner guard ring in 6 steps:
 ;; 1.  create the inner ring of tap
 ;;   1a. create the inner ring tap implant if required
 ;; 2.  create the inner riveted ring of via1's
 ;; 3.  create the inner ring of layer2
 ;; *4.  create the inner riveted ring of via2's
 ;; *5.  create the inner ring of layer3
 ;; 6.  create a terminal out of the topmost layer
 ;; (* = if necessary)
 ;;

 ;;
 ;; 1.  create the tap in the inner guard ring
 ;; target variables set:
 ;;   tapWidthInIR = the ring width of tap in the inner guard ring
 ;;   irViaOffset = offset needed to center contacts in tap
 ;;   irTapXorigin = the X origin (LL corner) of the inner tap guard ring
 ;;   irTapYorigin = the Y origin (LL corner) of the inner tap guard ring
 ;;   irTapL = the total length of the inner tap guard ring
 ;;   irTapW = the total width of the inner tap guard ring
 (setq tapWidthInIR (max innerRingTapWidth (plus via1Width (times 2.0 innerRingTapEncVia1))))
 (setq irViaOffset (times (fix (plus (quotient (difference (quotient tapWidthInIR 2.0) (quotient via1Width 2.0)) via1grid) 0.999)) via1grid))
 (setq irTapXorigin (difference diffXorigin minDiffTapRingSpace extraLeftSpace tapWidthInIR))
 (setq irTapYorigin (difference via1Yorigin drnViaYspaceRingViaBot via1Width (max irViaOffset innerRingTapEncVia1)))

 (setq irTapL (difference (plus diffXend minDiffTapRingSpace extraRightSpace tapWidthInIR) irTapXorigin))
 (setq irTapW  (difference (plus via1Yloop -via1Space drnViaYspaceRingViaTop via1Width (max irViaOffset innerRingTapEncVia1)) irTapYorigin))

 ;; draw tap corners at 45 degrees if tapEdgesAt45 is set
 (if tapEdgesAt45 then
     (setq bevelLength (times 0.6 tapWidthInIR))
     ;; snap this to grid
     (setq bevelLength (times (round (plus (quotient bevelLength tapGrid) 0.001)) tapGrid))

     (setq lowerLeftBL  bevelLength)
     (setq upperLeftBL  bevelLength)
     (setq lowerRightBL bevelLength)
     (setq upperRightBL bevelLength)
  else
     (setq lowerLeftBL  0.0)
     (setq upperLeftBL  0.0)
     (setq lowerRightBL 0.0)
     (setq upperRightBL 0.0)
 )
     
 (setq dbid (dbCreateParamInst tcCellView ringId "itr" 0.0:0.0 "R0" 1
			       (list (list "w" "float" irTapW)
				     (list "l" "float" irTapL)
				     (list "xOffset" "float" irTapXorigin)
				     (list "yOffset" "float" irTapYorigin)
				     (list "ringLayer" "list" tapLayer)
				     (list "ringWidth" "float" tapWidthInIR)
				     (list "additionalWidthInBevel" "float" 0.0)
				     (list "llBevelLength" "float" lowerLeftBL)
				     (list "ulBevelLength" "float" upperLeftBL)
				     (list "lrBevelLength" "float" lowerRightBL)
				     (list "urBevelLength" "float" upperRightBL)
				     (list "bevelTheOutside" "boolean" t)
				     (list "grid" "float" tapGrid)
				     (list "breakupPolygons" "boolean" "TRUE")
			       )))
 (setq theMaster dbid~>master)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints1))
 (dbAddFigToNet dbid irNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints2))
 (dbAddFigToNet dbid irNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints3))
 (dbAddFigToNet dbid irNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints4))
 (dbAddFigToNet dbid irNet)
 (when tapSubImplant
   (setq itriXorigin   (difference irTapXorigin tapSubImpEnc))
   (setq itriYorigin   (difference irTapYorigin tapSubImpEnc))
   (setq itriRingWidth (plus tapWidthInIR tapSubImpEnc tapSubImpEnc))
   (setq itriW         (plus irTapW tapSubImpEnc tapSubImpEnc))
   (setq itriL         (plus irTapL tapSubImpEnc tapSubImpEnc))
   (dbCreateParamInst tcCellView ringId "itri" 0.0:0.0 "R0" 1
		      (list (list "w" "float" itriW)
			    (list "l" "float" itriL)
			    (list "xOffset"   "float"     itriXorigin)
			    (list "yOffset"   "float"     itriYorigin)
			    (list "ringLayer" "list"      tapSubImplant)
			    (list "ringWidth" "float"     itriRingWidth)
			    (list "additionalWidthInBevel" "float" 0.0)
			    (list "llBevelLength" "float" 0.0)
			    (list "ulBevelLength" "float" 0.0)
			    (list "lrBevelLength" "float" 0.0)
			    (list "urBevelLength" "float" 0.0)
			    (list "bevelTheOutside" "boolean" nil)
			    (list "grid" "float" tapGrid)
			    (list "breakupPolygons" "boolean" "TRUE")
			    ))
 )
 ;;
 ;; 2.  create the inner riveted ring of via1's
 ;;
 (setq xCoord   (plus irTapXorigin (max irViaOffset innerRingTapEncVia1)))
 (setq yCoord   (plus irTapYorigin (max irViaOffset innerRingTapEncVia1)))

 (if layer2EdgesAt45 then
     (setq lowerLeftBL  (times 3.0 via1Space))
     (setq upperLeftBL  (times 3.0 via1Space))
     (setq lowerRightBL (times 3.0 via1Space))
     (setq upperRightBL (times 3.0 via1Space))
  else
     (setq lowerLeftBL  0.0)
     (setq upperLeftBL  0.0)
     (setq lowerRightBL 0.0)
     (setq upperRightBL 0.0)
 )     

(when filledRings
  (setq via1WidthInIR (difference tapWidthInIR innerRingTapEncVia1))
  (setq via1Xorigin (plus irTapXorigin innerRingTapEncVia1))
  (setq via1Yorigin (plus irTapYorigin innerRingTapEncVia1))
  )

 (dbCreateParamInst tcCellView rivetedRingId "iv1r" 0.0:0.0 "R0" 1
		    (list (list "w" "float" ,(if filledRings
						 (difference irTapW (times 2.0 innerRingTapEncVia1))
					       (difference irTapW (times 2.0 (max irViaOffset innerRingTapEncVia1)))))
			  (list "l" "float" ,(if filledRings
						 (difference irTapL (times 2.0 innerRingTapEncVia1))
					       (difference irTapL (times 2.0 (max irViaOffset innerRingTapEncVia1)))))
			  (list "xOffset" "float" ,(if filledRings via1Xorigin xCoord))
			  (list "yOffset" "float" ,(if filledRings via1Yorigin yCoord))
			  (list "rivetLayer" "list" via1Layer)
			  (list "ringWidth" "float" ,(if filledRings via1WidthInIR via1Width))
			  (list "rivetWidth" "float" via1Width)
			  (list "rivetSpace" "float" via1Space)
			  (list "llBevelLength" "float" lowerLeftBL)
			  (list "ulBevelLength" "float" upperLeftBL)
			  (list "lrBevelLength" "float" lowerRightBL)
			  (list "urBevelLength" "float" upperRightBL)
			  (list "autoIncreaseBevelWidth" "boolean" "FALSE")
			  (list "grid" "float" via1grid)))


 ;;
 ;; 3.  create the inner ring of layer2
 ;; target variables set:
 ;;   irL2w = the total width of the inner layer2 guard ring
 ;;   irL2l = the total length of the inner layer2 guard ring
 ;;   irL2xDelta = the x offset of the inner guard ring's layer2 x origin
 ;;   irL2yDelta = the y offset of the inner guard ring's layer2 y origin
 ;;   irL2ringW = the width of the layer2 in the inner guard ring
 ;;

 (if (greaterp innerRingMetalWidth 0.0) then
     (setq irL2w irTapW)
     (setq irL2l irTapL)
     (setq irL2xDelta irTapXorigin)
     (setq irL2yDelta irTapYorigin)
     (setq irL2ringW (max (plus (times 2.0 layer2EncVia1) via1Width)
			  (plus (times 2.0 layer2EncVia2) via2Width)
			  innerRingMetalWidth))
  else
     (setq irL2w (plus irTapW (times -2.0 (max irViaOffset innerRingTapEncVia1)) (times 2.0 layer2EncVia1)))
     (setq irL2l (plus irTapL (times -2.0 (max irViaOffset innerRingTapEncVia1)) (times 2.0 layer2EncVia1)))
     (setq irL2xDelta (plus xCoord -layer2EncVia1))
     (setq irL2yDelta (plus yCoord -layer2EncVia1))
     (setq irL2ringW (max (plus (times 2.0 layer2EncVia1) via1Width)
			  (plus (times 2.0 layer2EncVia2) via2Width)))
 )
 (if layer2EdgesAt45 then
     (setq lowerLeftBL  irL2ringW)
     (setq upperLeftBL  irL2ringW)
     (setq lowerRightBL irL2ringW)
     (setq upperRightBL irL2ringW)
  else
     (setq lowerLeftBL  0.0)
     (setq upperLeftBL  0.0)
     (setq lowerRightBL 0.0)
     (setq upperRightBL 0.0)
 ) 
 (setq dbid (dbCreateParamInst tcCellView ringId "il2r" 0.0:0.0 "R0" 1
			       (list (list "w" "float" ,(if filledRings irTapW irL2w))
				     (list "l" "float" ,(if filledRings irTapL irL2l))
				     (list "xOffset" "float" ,(if filledRings irTapXorigin irL2xDelta))
				     (list "yOffset" "float" ,(if filledRings irTapYorigin irL2yDelta))
				     (list "ringLayer" "list" nil)
				     (list "ringWidth" "float" ,(if filledRings tapWidthInIR irL2ringW))
				     (list "additionalWidthInBevel" "float" 0.0)
				     (list "llBevelLength" "float" lowerLeftBL)
				     (list "ulBevelLength" "float" upperLeftBL)
				     (list "lrBevelLength" "float" lowerRightBL)
				     (list "urBevelLength" "float" upperRightBL)
				     (list "bevelTheOutside" "boolean" t)
				     (list "grid" "float" layer2grid)
				     (list "breakupPolygons" "boolean" "TRUE")
			       )))


 (setq theMaster dbid~>master)
 (setq dbid1 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints1))
 (setq dbid2 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints2))
 (setq dbid3 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints3))
 (setq dbid4 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints4))
 (dbAddFigToNet dbid1 irNet)
 (dbAddFigToNet dbid2 irNet)
 (dbAddFigToNet dbid3 irNet)
 (dbAddFigToNet dbid4 irNet)

 ;; if we must go to layer3, create the via2's and then create layer3
 (when  (and layer3 fullyStrap (nequal fullyStrap "FALSE"))  

     ;;
     ;; 4.  create the inner riveted ring of via2's
     ;;

     (when filledRings
       (setq via2Enc (max layer2EncVia2 layer3EncVia2))
       (setq via2WidthIR (difference innerRingMetalWidth (times 2.0 via2Enc)))
       (setq via2BL (plus via2WidthIR via2Space))
       )

     ;; center the via2's in the middle of layer2
     (setq iv2rEnc (quotient (difference irL2ringW ,(if filledRings via2WidthIR via2Width)) 2.0))
     ;; snap iv2rEnc to grid
     (setq tempSize (quotient iv2rEnc via2grid))
     (setq iv2rEnc (times (fix (plus tempSize 0.999)) via2grid))

     (if layer3EdgesAt45 then
	 (setq lowerLeftBL  (times 2.0 via2Space))
	 (setq upperLeftBL  (times 2.0 via2Space))
	 (setq lowerRightBL (times 2.0 via2Space))
	 (setq upperRightBL (times 2.0 via2Space))
      else
	 (setq lowerLeftBL  0.0)
	 (setq upperLeftBL  0.0)
	 (setq lowerRightBL 0.0)
	 (setq upperRightBL 0.0)
     )     

     (dbCreateParamInst tcCellView rivetedRingId "iv2r" (plus irL2xDelta iv2rEnc):(plus irL2yDelta iv2rEnc) "R0" 1
			(list (list "w" "float" (difference irL2w (times 2.0 iv2rEnc)))
			      (list "l" "float" (difference irL2l (times 2.0 iv2rEnc)))
			      (list "xOffset" "float" 0.0)
			      (list "yOffset" "float" 0.0)
			      (list "rivetLayer" "list" via2Layer)
			      (list "ringWidth" "float" ,(if filledRings via2WidthIR via2Width))
			      (list "rivetWidth" "float" via2Width)
			      (list "rivetSpace" "float" via2Space)
			      (list "llBevelLength" "float" ,(if filledRings via2BL lowerLeftBL))
			      (list "ulBevelLength" "float" ,(if filledRings via2BL upperLeftBL))
			      (list "lrBevelLength" "float" ,(if filledRings via2BL lowerRightBL))
			      (list "urBevelLength" "float" ,(if filledRings via2BL upperRightBL))
			      (list "autoIncreaseBevelWidth" "boolean" "FALSE")
			      (list "grid" "float" via2grid)))
     

     ;;
     ;; 5.  create the inner ring of layer3
     ;; target variables set:
     ;;   irL3w = the total width of the inner guard ring of layer3
     ;;   irL3l = the total length of the inner guard ring of layer3
     ;;   irL3xDelta = the x offset of the inner guard ring's layer3 x origin
     ;;   irL3yDelta = the y offset of the inner guard ring's layer3 y origin
     ;;

     (if (greaterp innerRingMetalWidth 0.0) then
	 (setq irL3w irL2w)
	 (setq irL3l irL2l)
	 (setq irL3xDelta irL2xDelta)
	 (setq irL3yDelta irL2yDelta)
	 (setq irL3ringW (max (plus (times 2.0 irLayer3EncVia2) via2Width)
			      innerRingMetalWidth))
      else
	 (setq irL3w (plus irL2w (times -2.0 iv2rEnc) (times 2.0 irLayer3EncVia2)))
	 (setq irL3l (plus irL2l (times -2.0 iv2rEnc) (times 2.0 irLayer3EncVia2)))
	 (setq irL3xDelta (plus irL2xDelta iv2rEnc -irLayer3EncVia2))
	 (setq irL3yDelta (plus irL2yDelta iv2rEnc -irLayer3EncVia2))
	 (setq irL3ringW  (plus (times 2.0 irLayer3EncVia2) via2Width))
     )
	 
     (if layer3EdgesAt45 then
	 (setq lowerLeftBL  irL3ringW)
	 (setq upperLeftBL  irL3ringW)
	 (setq lowerRightBL irL3ringW)
	 (setq upperRightBL irL3ringW)
      else
	 (setq lowerLeftBL  0.0)
	 (setq upperLeftBL  0.0)
	 (setq lowerRightBL 0.0)
	 (setq upperRightBL 0.0)
     )

     (setq dbid (dbCreateParamInst tcCellView ringId "il3r" 0.0:0.0 "R0" 1
				   (list (list "w" "float" irL3w)
					 (list "l" "float" irL3l)
					 (list "xOffset" "float" irL3xDelta)
					 (list "yOffset" "float" irL3yDelta)
					 (list "ringLayer" "list" nil)
					 (list "ringWidth" "float" irL3ringW)
					 (list "additionalWidthInBevel" "float" 0.0)
					 (list "llBevelLength" "float" lowerLeftBL)
					 (list "ulBevelLength" "float" upperLeftBL)
					 (list "lrBevelLength" "float" lowerRightBL)
					 (list "urBevelLength" "float" upperRightBL)
					 (list "bevelTheOutside" "boolean" t)
					 (list "grid" "float" layer3grid)
					 (list "breakupPolygons" "boolean" t)
				   )))

     (setq theMaster dbid~>master)
     (setq dbid1 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints1))
     (setq dbid2 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints2))
     (setq dbid3 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints3))
     (setq dbid4 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints4))
     (dbAddFigToNet dbid1 irNet)
     (dbAddFigToNet dbid2 irNet)
     (dbAddFigToNet dbid3 irNet)
     (dbAddFigToNet dbid4 irNet)
 )

 ;; 6.  create a terminal out of the topmost layer.  This could be layer2 or 3
 (setq pin (dbCreatePin irNet dbid1))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pin (dbCreatePin irNet dbid2))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pin (dbCreatePin irNet dbid3))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pin (dbCreatePin irNet dbid4))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))

 ;;
 ;; create the outer guard ring in 7 steps:
 ;; 1.  create the outer ring of well
 ;; 2.  create the outer ring of tap
 ;;  2a. create the outer ring tap implant if required
 ;; 3.  create the outer riveted ring of via1's
 ;; 4.  create the outer ring of layer2
 ;; *5.  create the outer riveted ring of via2's
 ;; *6.  create the outer ring of layer3
 ;; 7.  create a terminal out of the topmost layer
 ;; (* = if necessary)
 ;;

 ;; set up the tap variables in the outer guard ring:
 ;;  tapWidthInOR = the width of the tap in the outer guard ring
 ;;  outerTapDelta = the offset between the inner and outer tap guard rings
 ;;  orTapXorigin = the x origin for the outer tap guard ring
 ;;  orTapYorigin = the y origin for the outer tap guard ring
 ;;  orTapW = the total width for the outer tap guard ring
 ;;  orTapL = the total length for the outer tap guard ring
 (setq tapWidthInOR (max outerRingTapWidth (plus (times 2.0 outerRingTapEncVia1) via1Width)))
 (setq outerTapDelta (plus wellTapSpace wellEncTap tapWidthInOR))
 (setq orTapXorigin (difference irTapXorigin outerTapDelta))
 (setq orTapYorigin (difference irTapYorigin outerTapDelta))
 (setq orTapW (plus irTapW (times 2.0 outerTapDelta)))
 (setq orTapL (plus irTapL (times 2.0 outerTapDelta)))

 ;;
 ;; first, make sure that we will not create a spacing error for layer3
 ;;
 (when  (and layer3 fullyStrap (nequal fullyStrap "FALSE")) 
     ;; this just satisfies the min spacing of layer3 from inner ring to outer
     (setq orLayer3XoriginA (difference irL3xDelta orirLayer3Space orLayer3Width))

     ;; this will be where layer3 has its origin when it just satisfies the
     ;; spacing of tap in the inner ring to the well in the outer ring
     (setq orLayer3XoriginB (plus orTapXorigin (quotient tapWidthInOR 2.0) (quotient orLayer3Width -2.0)))

     ;; when the layer3 spacing is not going to be satisfied when the at the
     ;; specified spacing of tap in the inner ring to well in outer ring,
     ;; we need to push out the outer guard ring
     (when (lessp orLayer3XoriginA orLayer3XoriginB)
	 (setq extraSpace (difference orLayer3XoriginB orLayer3XoriginA))
	 (setq tempSize (quotient extraSpace tapGrid))
	 (setq extraSpace (times (fix (plus tempSize 0.999)) tapGrid))

	 (setq orTapXorigin (difference orTapXorigin extraSpace))
	 (setq orTapYorigin (difference orTapYorigin extraSpace))
	 (setq orTapW (plus orTapW (times 2.0 extraSpace)))
	 (setq orTapL (plus orTapL (times 2.0 extraSpace)))
     )
 )

 ;;
 ;; 1.  create the well in the outer guard ring
 ;;
 (setq dbid (dbCreateParamInst tcCellView ringId "owr" 0.0:0.0 "R0" 1
			       (list (list "w" "float" (plus orTapW (times 2.0 wellEncTap)))
				     (list "l" "float" (plus orTapL (times 2.0 wellEncTap)))
				     (list "xOffset" "float" (difference orTapXorigin wellEncTap))
				     (list "yOffset" "float" (difference orTapYorigin wellEncTap))
				     (list "ringLayer" "list" nil)
				     (list "ringWidth" "float" (plus tapWidthInOR (times 2.0 wellEncTap)))
				     (list "additionalWidthInBevel" "float" 0.0)
				     (list "llBevelLength" "float" 0.0)
				     (list "ulBevelLength" "float" 0.0)
				     (list "lrBevelLength" "float" 0.0)
				     (list "urBevelLength" "float" 0.0)
				     (list "bevelTheOutside" "boolean" t)
				     (list "grid" "float" wellGrid)
				     (list "breakupPolygons" "boolean" "TRUE"))))
 (setq theMaster dbid~>master)
 (setq dbid1 (dbCreatePolygon tcCellView wellLayer theMaster~>ringPoints1))
 (setq dbid2 (dbCreatePolygon tcCellView wellLayer theMaster~>ringPoints2))
 (setq dbid3 (dbCreatePolygon tcCellView wellLayer theMaster~>ringPoints3))
 (setq dbid4 (dbCreatePolygon tcCellView wellLayer theMaster~>ringPoints4))


 ;;
 ;; 2.  create the outer ring of tap
 ;;

 ;; draw tap corners at 45 degrees if tapEedgesAt45 is set
 (if tapEdgesAt45 then
     (setq bevelLength (times 0.6 tapWidthInOR))
     ;; snap this to grid
     (setq bevelLength (times (round (plus (quotient bevelLength tapGrid) 0.001)) tapGrid))
     
     (setq lowerLeftBL  bevelLength)
     (setq upperLeftBL  bevelLength)
     (setq lowerRightBL bevelLength)
     (setq upperRightBL bevelLength)
  else
     (setq lowerLeftBL  0.0)
     (setq upperLeftBL  0.0)
     (setq lowerRightBL 0.0)
     (setq upperRightBL 0.0)
 )  
     
 (setq dbid (dbCreateParamInst tcCellView ringId "otr" 0.0:0.0 "R0" 1
			       (list (list "w" "float" orTapW)
				     (list "l" "float" orTapL)
				     (list "xOffset" "float" orTapXorigin)
				     (list "yOffset" "float" orTapYorigin)
				     (list "ringLayer" "list" nil)
				     (list "ringWidth" "float" tapWidthInOR)
				     (list "additionalWidthInBevel" "float" 0.0)
				     (list "llBevelLength" "float" lowerLeftBL)
				     (list "ulBevelLength" "float" upperLeftBL)
				     (list "lrBevelLength" "float" lowerRightBL)
				     (list "urBevelLength" "float" upperRightBL)
				     (list "bevelTheOutside" "boolean" t)
				     (list "grid" "float" tapGrid)
				     (list "breakupPolygons" "boolean" "TRUE")
			       )))
 (setq theMaster dbid~>master)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints1))
 (dbAddFigToNet dbid orNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints2))
 (dbAddFigToNet dbid orNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints3))
 (dbAddFigToNet dbid orNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints4))
 (dbAddFigToNet dbid orNet)
 (when tapWellImplant
   (setq otriXorigin   (difference orTapXorigin tapWellImpEnc))
   (setq otriYorigin   (difference orTapYorigin tapWellImpEnc))
   (setq otriRingWidth (plus tapWidthInOR tapWellImpEnc tapWellImpEnc))
   (setq otriW         (plus orTapW tapWellImpEnc tapWellImpEnc))
   (setq otriL         (plus orTapL tapWellImpEnc tapWellImpEnc))
   (setq dbid (dbCreateParamInst tcCellView ringId "otri" 0.0:0.0 "R0" 1
				 (list (list "w" "float" otriW)
				       (list "l" "float" otriL)
				       (list "xOffset" "float" otriXorigin)
				       (list "yOffset" "float" otriYorigin)
				       (list "ringLayer" "list" tapWellImplant)
				       (list "ringWidth" "float" otriRingWidth)
				       (list "additionalWidthInBevel" "float" 0.0)
				       (list "llBevelLength" "float" 0.0)
				       (list "ulBevelLength" "float" 0.0)
				       (list "lrBevelLength" "float" 0.0)
				       (list "urBevelLength" "float" 0.0)
				       (list "bevelTheOutside" "boolean" nil)
				       (list "grid" "float" tapGrid)
				       (list "breakupPolygons" "boolean" "TRUE")
				       )))
 )

 ;;
 ;; 3.  create the outer riveted ring of via1's
 ;;
 (setq orViaOffset (times (fix (plus (quotient (difference (quotient tapWidthInOR 2.0) (quotient via1Width 2.0)) via1grid) 0.999)) via1grid))
 (setq xCoord   (plus orTapXorigin (max orViaOffset outerRingTapEncVia1)))
 (setq yCoord   (plus orTapYorigin (max orViaOffset outerRingTapEncVia1)))

 (setq lowerLeftBL  (times 3.0 via1Space))
 (setq upperLeftBL  (times 3.0 via1Space))
 (setq lowerRightBL (times 3.0 via1Space))
 (setq upperRightBL (times 3.0 via1Space))

 (unless (or filledRings layer2EdgesAt45 tapEdgesAt45)
   ;; draw an extra via1 in each corner
   (setq extraVia1RightOrigin (plus xCoord
				    (difference orTapL (times 2.0 (max orViaOffset outerRingTapEncVia1)))
				    (minus via1Width)))
   (setq extraVia1TopOrigin   (plus yCoord
				    (difference orTapW (times 2.0 (max orViaOffset outerRingTapEncVia1)))
				    (minus via1Width)))
   
   (dbCreateRect tcCellView via1Layer
		 (list (list xCoord yCoord )
		       (list (plus  xCoord via1Width)
			     (plus  yCoord via1Width)
			     )))
   (dbCreateRect tcCellView via1Layer
		 (list (list extraVia1RightOrigin yCoord )
		       (list (plus  extraVia1RightOrigin via1Width )
			     (plus  yCoord via1Width)
			     )))
   (dbCreateRect tcCellView via1Layer
		 (list (list xCoord extraVia1TopOrigin)
		       (list (plus xCoord via1Width)
			     (plus extraVia1TopOrigin via1Width)
			     )))
   (dbCreateRect tcCellView via1Layer
		 (list (list extraVia1RightOrigin extraVia1TopOrigin)
		       (list (plus extraVia1RightOrigin via1Width)
			     (plus extraVia1TopOrigin via1Width)
			     )))
   )

 ;; actual ring is created in 4.
 
 ;;
 ;; 4.  create the outer ring of layer2.  target variables set:
 ;;   orL2w = the total width of the outer layer2 guard ring
 ;;   orL2l = the total length of the outer layer2 guard ring
 ;;   orL2xDelta = the x origin of the outer layer2 guard ring
 ;;   orL2yDelta = the y origin of the outer layer2 guard ring
 ;;   orL2ringW = the ring width of layer2 in the outer guard ring
 ;;

 (if layer3 then
     ;; draw layer2 with the same width as of layer3
     (setq orLayer3EncVia2 (quotient (difference orLayer3Width via2Width) 2.0))
     ;; snap orLayer3EncVia2 to grid
     (setq tempSize (quotient orLayer3EncVia2 layer3grid))
     (setq orLayer3EncVia2 (times (fix (plus tempSize 0.999)) layer3grid))
     (setq outerRingMetalWidth (plus (times 2.0 orLayer3EncVia2) via2Width))
     
     (setq orL2w (plus orTapW -tapWidthInOR outerRingMetalWidth))
     (setq orL2l (plus orTapL -tapWidthInOR outerRingMetalWidth))

     (setq orL2xDelta (plus orTapXorigin (quotient (plus tapWidthInOR -outerRingMetalWidth) 2.0)))
     ;; snap orL2xDelta to grid
     (setq orL2xDelta (times (fix (plus (quotient orL2xDelta layer2grid) 0.999)) layer2grid))

     (setq orL2yDelta (plus orTapYorigin (quotient (plus tapWidthInOR -outerRingMetalWidth) 2.0)))
     ;; snap orL2yDelta to grid
     (setq orL2yDelta (times (fix (plus (quotient orL2yDelta layer2grid) 0.999)) layer2grid))

     (setq orL2ringW (max (plus (times 2.0 layer2EncVia1) via1Width)
			  (plus (times 2.0 layer2EncVia2) via2Width)
			  orLayer3Width))
    else
     (setq orL2w (plus orTapW (times -2.0 (max orViaOffset outerRingTapEncVia1)) (times 2.0 layer2EncVia1)))
     (setq orL2l (plus orTapL (times -2.0 (max orViaOffset outerRingTapEncVia1)) (times 2.0 layer2EncVia1)))
     (setq orL2xDelta (plus xCoord -layer2EncVia1))
     (setq orL2yDelta (plus yCoord -layer2EncVia1))
     (setq orL2ringW (max (plus (times 2.0 layer2EncVia1) via1Width)
			  (plus (times 2.0 layer2EncVia2) via2Width)))
 )
     
;; create the ring of via1's here, since we need orL2ringW defined before creation
;; create riveted ring if no filledRings, otherwise create generic ring
(unless filledRings
  (dbCreateParamInst tcCellView rivetedRingId "ov1r" xCoord:yCoord "R0" 1
                     (list (list "w" "float" (difference orTapW (times 2.0 (max orViaOffset outerRingTapEncVia1))))
                           (list "l" "float" (difference orTapL (times 2.0 (max orViaOffset outerRingTapEncVia1))))
                           (list "xOffset" "float" 0.0)
                           (list "yOffset" "float" 0.0)
                           (list "rivetLayer" "list" via1Layer)
                           (list "ringWidth" "float" via1Width)
                           (list "rivetWidth" "float" via1Width)
			   (list "rivetSpace" "float" via1Space)
                           (list "llBevelLength" "float" lowerLeftBL)
                           (list "ulBevelLength" "float" upperLeftBL)
                           (list "lrBevelLength" "float" lowerRightBL)
                           (list "urBevelLength" "float" upperRightBL)
                           (list "autoIncreaseBevelWidth" "boolean" "FALSE")
                           (list "grid" "float" via1grid)))
  )
(when filledRings
  (dbCreateParamInst tcCellView rivetedRingId "ov1r" 0:0 "R0" 1
                     (list (list "w" "float" (difference orTapW (times 2.0 outerRingTapEncVia1) (times 2.0 innerRingTapEncVia1)))
                           (list "l" "float" (difference orTapL (times 2.0 outerRingTapEncVia1) (times 2.0 innerRingTapEncVia1)))
                           (list "xOffset" "float" (plus orTapXorigin outerRingTapEncVia1 innerRingTapEncVia1))
                           (list "yOffset" "float" (plus orTapYorigin outerRingTapEncVia1 innerRingTapEncVia1))
                           (list "rivetLayer" "list" via1Layer)
                           (list "ringWidth" "float" (difference tapWidthInOR outerRingTapEncVia1 (times 2.0 innerRingTapEncVia1)))
                           (list "rivetWidth" "float" via1Width)
                           (list "rivetSpace" "float" via1Space)
			   (list "llBevelLength" "float" 0.0)
			   (list "ulBevelLength" "float" 0.0)
			   (list "lrBevelLength" "float" 0.0)
                           (list "urBevelLength" "float" 0.0)
			   (list "autoIncreaseBevelWidth" "boolean" "FALSE")
                           (list "grid" "float" via1grid)))
  )

 (if layer2EdgesAt45 then
   
     (setq lowerLeftBL  orL2ringW)
     (setq upperLeftBL  orL2ringW)
     (setq lowerRightBL orL2ringW)
     (setq upperRightBL orL2ringW)
  else
   
     (setq lowerLeftBL  0.0)
     (setq upperLeftBL  0.0)
     (setq lowerRightBL 0.0)
     (setq upperRightBL 0.0)
 )

     (setq dbid (dbCreateParamInst tcCellView ringId "ol2r" 0.0:0.0 "R0" 1
				   (list (list "w" "float" ,(if filledRings
								(difference orTapW (times 2.0 outerRingTapEncVia1))
							      orL2w))
					 (list "l" "float" ,(if filledRings
								(difference orTapL (times 2.0 outerRingTapEncVia1))
							      orL2l))
					 (list "xOffset" "float" ,(if filledRings (plus orTapXorigin outerRingTapEncVia1) orL2xDelta))
					 (list "yOffset" "float" ,(if filledRings (plus orTapYorigin outerRingTapEncVia1) orL2yDelta))
					 (list "ringLayer" "list" layer2)
					 (list "ringWidth" "float" ,(if filledRings (difference tapWidthInOR outerRingTapEncVia1) orL2ringW))
					 (list "additionalWidthInBevel" "float" 0.0)
					 (list "llBevelLength" "float" lowerLeftBL)
					 (list "ulBevelLength" "float" upperLeftBL)
					 (list "lrBevelLength" "float" lowerRightBL)
					 (list "urBevelLength" "float" upperRightBL)
					 (list "bevelTheOutside" "boolean" t)
					 (list "grid" "float" layer2grid)
					 (list "breakupPolygons" "boolean" "TRUE")
				   )))

 (setq theMaster dbid~>master)
 (setq dbid1 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints1))
 (setq dbid2 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints2))
 (setq dbid3 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints3))
 (setq dbid4 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints4))
 (dbAddFigToNet dbid1 orNet)
 (dbAddFigToNet dbid2 orNet)
 (dbAddFigToNet dbid3 orNet)
 (dbAddFigToNet dbid4 orNet)

 ;; when layer2 is the topmost layer, create a terminal out of it
 (when  (and layer3 fullyStrap (nequal fullyStrap "FALSE")) 

     ;;
     ;; 5.  if we must go to layer3, create the via2's and then create layer3
     ;;
     ;; center the via2's in the middle of layer2
     (setq ov2rEnc (quotient (difference orL2ringW via2Width) 2.0))
     ;; snap ov2rEnc to grid
     (setq tempSize (quotient ov2rEnc via2grid))
     (setq ov2rEnc (times (fix (plus tempSize 0.999)) via2grid))

     (if layer3EdgesAt45 then
	 (setq lowerLeftBL  (times 2.0 via2Space))
	 (setq upperLeftBL  (times 2.0 via2Space))
	 (setq lowerRightBL (times 2.0 via2Space))
	 (setq upperRightBL (times 2.0 via2Space))
      else
	 (setq lowerLeftBL  via2Space)
	 (setq upperLeftBL  via2Space)
	 (setq lowerRightBL via2Space)
	 (setq upperRightBL via2Space)
     )    

     (when filledRings
       (setq via2WidthOR (difference orLayer3Width (times 2.0 via2Enc)))
       (setq via2BL (plus via2WidthOR via2Space))

       (dbCreateParamInst tcCellView rivetedRingId "ov2r" 0:0 "R0" 1
                         (list (list "w" "float" (difference orTapW (times 2.0 (plus via2Enc outerRingTapEncVia1))))
                               (list "l" "float" (difference orTapL (times 2.0 (plus via2Enc outerRingTapEncVia1))))
                               (list "xOffset" "float" (plus orTapXorigin outerRingTapEncVia1 via2Enc))
                               (list "yOffset" "float" (plus orTapYorigin outerRingTapEncVia1 via2Enc))
                               (list "rivetLayer" "list" via2Layer)
                               (list "ringWidth" "float" via2WidthOR)
                               (list "rivetWidth" "float" via2Width)
                               (list "rivetSpace" "float" via2Space)
                               (list "llBevelLength" "float" via2BL)
                               (list "ulBevelLength" "float" via2BL)
                               (list "lrBevelLength" "float" via2BL)
                               (list "urBevelLength" "float" via2BL)
                               (list "autoIncreaseBevelWidth" "boolean" "FALSE")
                               (list "grid" "float" via2grid)))
       )
(unless filledRings
     (dbCreateParamInst tcCellView rivetedRingId "ov2r" (plus orL2xDelta ov2rEnc):(plus orL2yDelta ov2rEnc) "R0" 1
			(list (list "w" "float" (difference orL2w (times 2.0 ov2rEnc)))
			      (list "l" "float" (difference orL2l (times 2.0 ov2rEnc)))
			      (list "xOffset" "float" 0.0)
			      (list "yOffset" "float" 0.0)
			      (list "rivetLayer" "list" via2Layer)
			      (list "ringWidth" "float" via2Width)
			      (list "rivetWidth" "float" via2Width)
			      (list "rivetSpace" "float" via2Space)
			      (list "llBevelLength" "float" lowerLeftBL)
			      (list "ulBevelLength" "float" upperLeftBL)
			      (list "lrBevelLength" "float" lowerRightBL)
			      (list "urBevelLength" "float" upperRightBL)
			      (list "autoIncreaseBevelWidth" "boolean" "FALSE")
			      (list "grid" "float" via2grid)))
     )
     
     
     ;; 6.  create the outer ring of layer3.  target variables set:
     ;;   orL3w = the total width of the outer layer3 guard ring
     ;;   orL3l = the total length of the outer layer3 guard ring
     ;;   orL3xDelta = the x origin of the outer layer3 guard ring
     ;;   orL3yDelta = the y origin of the outer layer3 guard ring
     ;;
     (setq orL3w (plus orL2w (times -2.0 ov2rEnc) (times 2.0 orLayer3EncVia2)))
     (setq orL3l (plus orL2l (times -2.0 ov2rEnc) (times 2.0 orLayer3EncVia2)))
     (setq orL3xDelta (plus orL2xDelta ov2rEnc -orLayer3EncVia2))
     (setq orL3yDelta (plus orL2yDelta ov2rEnc -orLayer3EncVia2))

     (if layer3EdgesAt45 then
	 (setq lowerLeftBL  orLayer3Width)
	 (setq upperLeftBL  orLayer3Width)
	 (setq lowerRightBL orLayer3Width)
	 (setq upperRightBL orLayer3Width)
      else
	 (setq lowerLeftBL  0.0)
	 (setq upperLeftBL  0.0)
	 (setq lowerRightBL 0.0)
	 (setq upperRightBL 0.0)
     )
     
     (setq dbid (dbCreateParamInst tcCellView ringId "ol3r" 0.0:0.0 "R0" 1
				   (list (list "w" "float" ,(if filledRings
								(difference orTapW (times 2.0 outerRingTapEncVia1))
							      orL3w))
					 (list "l" "float" ,(if filledRings
								(difference orTapL (times 2.0 outerRingTapEncVia1))
							      orL3l))
					 (list "xOffset" "float" ,(if filledRings (plus orTapXorigin outerRingTapEncVia1) orL3xDelta))
					 (list "yOffset" "float" ,(if filledRings (plus orTapYorigin outerRingTapEncVia1) orL3yDelta))
					 (list "ringLayer" "list" nil)
					 (list "ringWidth" "float" orLayer3Width) ;;;(plus (times 2.0 orLayer3EncVia2) via2Width)
					 (list "additionalWidthInBevel" "float" 0.0)
					 (list "llBevelLength" "float" lowerLeftBL)
					 (list "ulBevelLength" "float" upperLeftBL)
					 (list "lrBevelLength" "float" lowerRightBL)
					 (list "urBevelLength" "float" upperRightBL)
					 (list "bevelTheOutside" "boolean" t)
					 (list "grid" "float" layer3grid)
					 (list "breakupPolygons" "boolean" t)
				   )))

     (setq theMaster dbid~>master)
     (setq dbid1 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints1))
     (setq dbid2 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints2))
     (setq dbid3 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints3))
     (setq dbid4 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints4))
     (dbAddFigToNet dbid1 orNet)
     (dbAddFigToNet dbid2 orNet)
     (dbAddFigToNet dbid3 orNet)
     (dbAddFigToNet dbid4 orNet)

 )

 ;; 7.  create a terminal out of the topmost layer.  This could be layer2 or 3
 (setq pin (dbCreatePin orNet dbid1))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pin (dbCreatePin orNet dbid2))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pin (dbCreatePin orNet dbid3))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pin (dbCreatePin orNet dbid4))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))

)
;;; 
;;; 
;;; 
;;; pEsdTranImpCascodeClass.il
;;; 
;;; Copyright (c) 2002 by Cypress Semiconductor
;;; Cypress India Design Center (CIDC)
;;; 
;;; Date  : Feb 7, 2002
;;; Author: LakshmiNarayanan/CAD (lpn) @ INDC
;;; 
;;; Description:
;;;   This is an variant on the transistor for the device library.  It will
;;; provide ESD protection.  This should be used as the P ESD transistor for
;;; nwell technologies, and as the N ESD transistor for pwell technologies.
;;; 
;;; Revision History:
;;;
;;;   lpn 02/07/02  Production Release 
;;;   lpn 02/08/02  Added an option to draw diffCoreImplant layer enclosing Diff layer 
;;;   kuc 02/07/06  updates for semi-scalable models
;;;   kuc 03/26/08  guard ring updates
;;;
;;;

(tcCreateDeviceClass
 "symbolic" "pEsdTranImpCascodeClass"
 ;; Class parameters
 (
  (diffLayer            "y0")
  (gateLayer            "y1")
  (rgateLayer           "y2")
  (wellLayer            "y3")
  (tapLayer             "y4")
  (via1Layer            "y5")
  (layer2               "y6")
  (via2Layer            "y7")
  (layer3               "y8")
  (idLayer              "y9")
  (diffImplant          nil)
  (diffImpEnc           0.0)
  (diffCoreImplant      nil)
  (diffCoreImpEnc       0.0)
  (tapWellImplant       nil)
  (tapWellImpEnc        0.0)
  (tapSubImplant        nil)
  (tapSubImpEnc         0.0)
  (tapWidth             0.0)
  (srcViaGateSpace      0.0)
  (srcViaTapSpace       0.0)
  (drnViaGateSpace      0.0)
  (viaExtDiff           0.0)
  (minDiffTapRingSpace  0.0)
  (GateToGateSpace      0.0)
  (flareYamount_out     0.0)
  (flareYamount_in      0.0)
  (flareYextension      0.0)
  (via1Width            0.0)
  (via1Space            0.0)
  (tapEncVia1           0.0)
  (wellEncTap           0.0)
  (innerRingTapWidth    0.0)
  (outerRingTapWidth    0.0)
  (wellTapSpace         0.0)
  (layer2EncVia1        0.0)
  (via2Width            0.0)
  (via2Space            0.0)
  (via1Via2Space        0.0)
  (layer2EncVia2        0.0)
  (layer2Width          0.0)
  (layer3EncVia2        0.0)
  (layer3Width          0.0)
  (layer3Width_outside  0.0)
  (innerRingMetalWidth  0.0)
  (irLayer3EncVia2      0.0)
  (orLayer3Width        0.0)
  (minW                 0.0)
  (maxW                 0.0)
  (minTotalW            0.0)
  (genericRingName      "ring")
  (rivetedRingName      "rivetRing")
  (flaredGateName       "flaredGate")
  (diffGrid             0.00)
  (tapGrid              0.00)
  (wellGrid             0.00)
  (polyGrid             0.00)
  (via1grid             0.00)
  (layer2grid           0.00)
  (via2grid             0.00)
  (layer3grid           0.00)
  (tapEdgesAt45         nil)
  (layer2EdgesAt45      nil)
  (layer3EdgesAt45      nil)
  (endTapMetInsideOut   nil)
  (modelTextLayer       (list "hilite" "drawing"))
  (modelTextLayerSize   0.2)
  (modelText            "")
  (modelWmax            0.0)
  (modelWmin            0.0)
  (modelLmax            0.0)
  (modelLmin            0.0)
  (filledRings          t)
 )
 ;; Formal parameters
 (
  (w                0.0)
  (l                0.0)
  (m                0)
  (extraLeftSpace   0.0)
  (extraRightSpace  0.0)
  (shrinkPercent    0.0)
  (extraSrcSpace    0.0)
  (extraDrnSpace    0.0)
  (fullyStrap	    "FALSE")
  (drnViaYspaceRingViaTop  0.0)
  (drnViaYspaceRingViaBot  0.0)
  (orirLayer3Space      0.0)
 )

 (when (w > modelWmax)
   (error "%f is greater than allowable maximum width %f for model %L" w modelWmax modelText))
 (when (w < modelWmin)
   (error "%f is less than allowable minimum width %f for model %L" w modelWmin modelText))
 (when (l > modelLmax)
   (error "%f is greater than allowable length %f for model %L" l modelLmax modelText))
 (when (l < modelLmin)
   (error "%f is less than allowable minimum length %f for model %L" l modelLmin modelText))

 ;; make the nets and the terminals that will be used in the cell
 (setq gNet (dbCreateNet tcCellView "g"))
 (dbCreateTerm gNet "g" "input")
 (setq sNet (dbCreateNet tcCellView "s"))
 (dbCreateTerm sNet "s" "inputOutput")
 (setq dNet (dbCreateNet tcCellView "d"))
 (dbCreateTerm dNet "d" "inputOutput")
 (setq irNet (dbCreateNet tcCellView "ir"))
 (dbCreateTerm irNet "ir" "inputOutput")
 (setq orNet (dbCreateNet tcCellView "or"))
 (dbCreateTerm orNet "or" "inputOutput")
 
 ;; massage all parameters to their scaled counterparts
 (cond ((equal shrinkPercent 0.0)
	(setq scaleMult 1.0)
      ) 
     (t
      (setq scaleMult (quotient 100.0 (difference 100.0 shrinkPercent)))
      (setq via1PolyGrid (max via1grid polyGrid))

      ;;
      ;; foreach doesn't work as it ought to here.  Another Cadence feature
      ;;
      (foreach sizeAndGrid (list (list 'srcViaGateSpace via1PolyGrid)
				 (list 'drnViaGateSpace via1PolyGrid)
				 (list 'drnViaYspaceRingViaTop via1grid)
				 (list 'drnViaYspaceRingViaBot via1grid)
				 (list 'innerRingTapWidth tapGrid)
				 (list 'outerRingTapWidth tapGrid)
				 (list 'innerRingMetalWidth layer2grid)
				 (list 'via1Via2Space via1grid)
				 (list 'layer2Width layer2grid)
				 (list 'layer3Width layer3grid)
				 (list 'orLayer3Width layer3grid)
				 (list 'minW diffGrid)
				 (list 'maxW diffGrid)
				 (list 'minTotalW diffGrid)
			   )

	  (setq theSize (car sizeAndGrid))
	  (setq theGrid (cadr sizeAndGrid))

	  (setq tempSize (quotient (times (eval theSize) scaleMult) theGrid))
	  (set theSize (times (fix (plus tempSize 0.999)) theGrid))
      )

     ) ;; end massaging the variables to account for the scale
 )

 ;; we want to be able to share the outer guard ring between to pcell
 ;; instances placed side by side.  In order to do this, we need to have
 ;; the contacts in the outer ring centered and on grid.  This might be a
 ;; bit confusing, but this means:
 ;;
 ;;   If the contact is an odd integer multiple of the snap grid, the width of
 ;;   the ring enclosing it must be an odd integer multiple of the snap grid.
 ;;   This will keep the enclosure the same to the inside and outside of the
 ;;   contact.
 ;;
 ;;   If the contact is an even integer multiple of the snap grid, the width
 ;;   of the ring enclosing it must be an even integer multiple of the snap
 ;;   grid.  This will keep the enclosure the same to the inside and outside
 ;;   of the contact.
 ;;
 (foreach kludge (list (list 'orLayer3Width layer3grid via2Width via2grid)
		       (list 'outerRingTapWidth tapGrid via1Width via1grid)
		 )
     (setq tmpOrLayerWidth (nth 0 kludge))
     (setq tmpOrLayerGrid (nth 1 kludge))
     (setq tmpViaWidth (nth 2 kludge))
     (setq tmpViaGrid (nth 3 kludge))

     (setq tempSize (quotient tmpViaWidth tmpViaGrid))
     (cond
	 ((oddp (fix (plus tempSize 0.999)))
	  ;; make sure that tmpOrLayerWidth is an odd multiple of the grid
	  (setq tempSize (quotient (eval tmpOrLayerWidth) tmpOrLayerGrid))
	  (when (evenp (fix (plus tempSize 0.999)))
	      (set tmpOrLayerWidth (plus (eval tmpOrLayerWidth) layer3grid))
	  )
	 )
	 (t
	  ;; make sure that tmpOrLayerWidth is an even multiple of the grid
	  (setq tempSize (quotient (eval tmpOrLayerWidth) tmpOrLayerGrid))
	  (when (oddp (fix (plus tempSize 0.999)))
	      (set tmpOrLayerWidth (plus (eval tmpOrLayerWidth) layer3grid))
	  )
	 )
     )
 )

 ;;
 ;; do sanity checks on the width
 ;; Sub sanity check on width:  It is an integral multiple of the via pitch
 ;;
 (setq via1Pitch (plus via1Width via1Space))
 (setq via2Pitch (plus via2Width via2Space))

 ;; targetRows is a floating point number that represents the number of rows
 ;; of via1's that can fit within the width
 ;;(setq targetRows (quotient (plus w (times -2.0 viaExtDiff) (times 2.0 flareYamount) via1Space) via1Pitch))
 (setq targetRows (quotient (plus w (times -2.0 viaExtDiff) via1Space) via1Pitch))

 ;; rowsOfContacts is an integer version of targetRows
 (setq rowsOfContacts (fix (plus 0.999 targetRows)))

 ;; targetRows and rowsOfContacts must be the same to satisfy the via pitch
 ;; requirement of the ESD transistor
 (when (greaterp (abs (difference rowsOfContacts targetRows)) 1e-4)
     (error "pEsdTranImpCascodeClass: w (%f) does not satisfy via pitch requirements.  Try either %f or %f\n" w
;;(plus (times rowsOfContacts via1Pitch) -via1Space (times 2.0  (difference viaExtDiff flareYamount)))
;;(plus (times (difference rowsOfContacts 1) via1Pitch) -via1Space (times 2.0  (difference viaExtDiff flareYamount))))
	    (plus (times rowsOfContacts via1Pitch) -via1Space (times 2.0 viaExtDiff ))
	    (plus (times (difference rowsOfContacts 1) via1Pitch) -via1Space (times 2.0 viaExtDiff )))
 )

;; (setq rowsOfContacts (difference rowsOfContacts 1))
 
 ;;
 ;; Sub sanity check on width:  It is between the minimum and maximum width
 ;;
 ;;(when (lessp (difference w 1e-6) (plus minW flareYamount flareYamount))
 (when (lessp (difference w 1e-6) minW )
     (error "pEsdTranImpCascodeClass:  w (%f) is less than minimum allowable width per leg (%f)\n" w minW)
 )

 (when (greaterp (difference w 1e-6) maxW )
     (error "pEsdTranImpCascodeClass:  w (%f) is greater than maximum allowable width per leg (%f)\n" w maxW)
 )

 (when (lessp (times w m) minTotalW)
     (error "pEsdTranImpCascodeClass:  total w (%f) is less than the minimum total width (%f)\n"
	    (times w m) minTotalW)
 )

 ;;
 ;; do a sanity check on the number of legs
 ;;
 (unless (and (null (floatp m)) (numberp m))
     (error "pEsdTranImpCascodeClass:  m must be an even integer, not a float\n")
 )

 (when (oddp m)
     (error "pEsdTranImpCascodeClass:  m (number of legs) must be an even integer\n")
 )

 ;;
 ;; do a sanity check that the sub-pcells exist
 ;; 1.  verify that the flared gate pcell exists & is a pcell
 ;;
 (setq flaredGateId (dbOpenCellView tcCellView~>lib flaredGateName "symbolic" nil "rn"))
 (unless flaredGateId
     (error "pEsdTranImpCascodeClass:  Cannot find/open flared gate %s\n" flaredGateName)
 )
 (unless flaredGateId~>isParamCell
     (error "pEsdTranImpCascodeClass:  Flared gate %s is not a pcell\n" flaredGateName)
 )

 ;;
 ;; 2.  verify that the generic ring exists & is a pcell
 ;;
 (setq ringId (dbOpenCellView tcCellView~>lib genericRingName "symbolic" nil "rn"))
 (unless ringId
     (error "pEsdTranImpCascodeClass:  Cannot find/open ring %s\n" genericRingName)
 )
 (unless ringId~>isParamCell
     (error "pEsdTranImpCascodeClass:  Ring %s is not a pcell\n" genericRingName)
 )

 ;;
 ;; 3.  verify that the riveted ring exists & is a pcell
 ;;
 (setq rivetedRingId (dbOpenCellView tcCellView~>lib rivetedRingName "symbolic" nil "rn"))
 (unless rivetedRingId
     (error "pEsdTranImpCascodeClass:  Cannot find/open riveted ring %s\n" rivetedRingName)
 )
 (unless rivetedRingId~>isParamCell
     (error "pEsdTranImpCascodeClass:  Riveted ring %s is not a pcell\n" rivetedRingName)
 )

 ;;
 ;; create the diffusion and tap.  Target variables set are:
 ;;   srcViaToSrcTapSpace = the space between a source diffusion via to the
 ;;                         tap in the same source region
 ;;   diffXorigin = the X origin of the diff/tap regions
 ;;   diffYorigin = the Y origin of the diff/tap regions
 ;;   totalDrnLength = the gate to gate length of a drain region
 ;;   totalSrcDiffLength = the gate to gate length of a source region minus
 ;;                        the length of the tap in the source region
 ;;   diffYend = the Y end of the diff/tap regions
 ;;   diffXloop = the X origin of the next diffusion region to draw
 ;;
 (setq srcViaToSrcTapSpace (max 0.0
				(difference via1Space
					    (quotient (difference tapWidth via1Width) 2.0))
				srcViaTapSpace
				))

 (setq diffXorigin (plus -tapWidth -srcViaToSrcTapSpace -via1Width -srcViaGateSpace -extraSrcSpace))
 (setq diffYorigin 0.0)

 (setq totalDrnLength (plus (times 2.0 (plus drnViaGateSpace extraDrnSpace))
			    via1Width))

 (setq halfSrcDiffLength (plus srcViaGateSpace extraSrcSpace via1Width srcViaToSrcTapSpace))
 (setq totalSrcDiffLength (times 2.0 halfSrcDiffLength))
 ;;(setq halfL (quotient l 2.0))
 (setq halfL (plus l (quotient GateToGateSpace 2.0)))
 (setq diffYend w)
 
 (setq diffImpYend    (plus       diffYend    diffImpEnc))
 (setq diffImpYorigin (difference diffYorigin diffImpEnc))
 


 ;; draw the first source
 (setq dbid (dbCreateRect tcCellView tapLayer (list diffXorigin:diffYorigin
						    (plus diffXorigin tapWidth):diffYend)))
 (dbAddFigToNet dbid sNet)
 (setq dbid (dbCreateRect tcCellView tapWellImplant
			  (list (list (difference diffXorigin tapWellImpEnc)
				      (difference diffYorigin tapWellImpEnc)
				      )
				(list (plus diffXorigin tapWidth)
				      (plus diffYend tapWellImpEnc)
				      )
				)
			  )
       )
 (dbAddFigToNet dbid sNet)
 (setq diffXloop (plus diffXorigin tapWidth))

 ;; draw the middle drains/sources and the last source
 (for section 1 (xquotient m 2)
      (setq srcDiffXend (plus diffXloop halfSrcDiffLength halfL))
      (setq dbid (dbCreateRect tcCellView diffLayer (list diffXloop:diffYorigin
							  srcDiffXend:diffYend)))
      (dbAddFigToNet dbid sNet)
      (setq dbid (dbCreateRect tcCellView diffImplant 
			       (list (list diffXloop diffImpYorigin)
				     (list srcDiffXend diffImpYend))))
      (dbAddFigToNet dbid sNet)
      
      (setq diffXloop srcDiffXend)

      (setq drnDiffXend (plus diffXloop totalDrnLength l l GateToGateSpace))
      (setq dbid (dbCreateRect tcCellView diffLayer (list diffXloop:diffYorigin
							  drnDiffXend:diffYend)))
      (dbAddFigToNet dbid dNet)
      (setq dbid (dbCreateRect tcCellView diffImplant
			       (list (list diffXloop diffImpYorigin)
				     (list drnDiffXend diffImpYend))))
      (dbAddFigToNet dbid dNet)

      (setq diffXloop drnDiffXend)

      (setq srcDiffXend (plus diffXloop halfSrcDiffLength halfL))
      (setq dbid (dbCreateRect tcCellView diffLayer (list diffXloop:diffYorigin
							  srcDiffXend:diffYend)))
      (dbAddFigToNet dbid sNet)
      (setq dbid (dbCreateRect tcCellView diffImplant 
			       (list (list diffXloop diffImpYorigin)
				     (list srcDiffXend diffImpYend))))
      (dbAddFigToNet dbid sNet)
      	  
      (setq diffXloop (plus srcDiffXend tapWidth))

      (setq dbid (dbCreateRect tcCellView tapLayer (list srcDiffXend:diffYorigin
							 diffXloop:diffYend)))
      (dbAddFigToNet dbid sNet)
      (if (equal section (xquotient m 2)) then
	;; implant for last piece meets enclosure
	(setq dbid (dbCreateRect tcCellView tapWellImplant
				 (list (list srcDiffXend
					     (difference diffYorigin tapWellImpEnc))
				       (list (plus diffXloop tapWellImpEnc)
					     (plus diffYend tapWellImpEnc)))))
	else
	;; this is drawn the rest of the time
	(setq dbid (dbCreateRect tcCellView tapWellImplant
				 (list (list srcDiffXend 
					     (difference diffYorigin tapWellImpEnc))
				       (list diffXloop
					     (plus diffYend tapWellImpEnc)))))
	)
      (dbAddFigToNet dbid sNet)
 )

 ;; draw the id layer (esd) around the diffusion
 (dbCreateRect tcCellView idLayer (list diffXorigin:diffYorigin diffXloop:diffYend))

 ;; draw the core Implant  around the diffusion

 (when diffCoreImplant
     (dbCreateRect tcCellView diffCoreImplant (list (plus diffXorigin tapWidth -diffCoreImpEnc) 
						    : (plus diffYorigin -diffCoreImpEnc)
						    
						    (plus diffXloop -tapWidth diffCoreImpEnc)
						    : (plus diffYend diffCoreImpEnc)
					      )
     )
 )
 (setq diffXend diffXloop)

 ;;
 ;; create the flared gates
 ;;
 (setq gateXoffset 0.0)
 (for gateNum 1 m

      ;; instantiate the flared gate
      (setq inst (dbCreateParamInst tcCellView flaredGateId (sprintf nil "g%d" gateNum)
				    0.0:0.0 "R0" 1
				    (list (list "gateLayer" "list" nil)
					  (list "gateRecognitionLayer" "list" rgateLayer)
					  (list "w" "float" w)
					  (list "l" "float" l) 
					  (list "flareAmount_out" "float" flareYamount_out)
					  (list "flareAmount_in" "float" flareYamount_in)
					  (list "flareExtension" "float" flareYextension)
					  (list "xOffset" "float" gateXoffset)
					  (list  "gateToGateSpace" "float" GateToGateSpace)
				    )
		 ))
      (unless inst
	  (error "pEsdTranImpCascodeClass:  Failed to create instance of flared gate %s" flaredGateName)
      )

      ;; add the gate to net, and create pins out of the flared regions
      (setq master inst~>master)
      (setq dbid (dbCreateRect tcCellView gateLayer master~>noflarePoints))
      (dbAddFigToNet dbid gNet)

      (setq modelTextX (plus gateXoffset (quotient (difference (caadr master~>noflarePoints) (caar master~>noflarePoints)) 2)))
      (setq modelTextY (quotient (difference (cadar master~>noflarePoints) (cadadr master~>noflarePoints)) 2))
      (dbCreateLabel tcCellView modelTextLayer (list modelTextX modelTextY) modelText "centerCenter" "R0" "stick" modelTextLayerSize)
      (setq modelTextX (plus (plus GateToGateSpace l) (plus gateXoffset (quotient (difference (caadr master~>noflarePoints) (caar master~>noflarePoints)) 2))))
      (dbCreateLabel tcCellView modelTextLayer (list modelTextX modelTextY) modelText "centerCenter" "R0" "stick" modelTextLayerSize)

      (setq dbid (dbCreateRect tcCellView gateLayer master~>noflarePoints1))
      (dbAddFigToNet dbid gNet)
      
      (setq dbid (dbCreatePolygon tcCellView gateLayer master~>topFlarePoints))
      (dbAddFigToNet dbid gNet)
      (setq pinid (dbCreatePin gNet dbid))
      (pinid~>accessDir = (list "top"))

      (setq dbid (dbCreatePolygon tcCellView gateLayer master~>topFlarePoints1))
      (setq pinid (dbCreatePin gNet dbid))
      (pinid~>accessDir = (list "top"))

      (setq dbid (dbCreatePolygon tcCellView gateLayer master~>bottomFlarePoints))
      (dbAddFigToNet dbid gNet)
      (setq pinid (dbCreatePin gNet dbid))
      (pinid~>accessDir = (list "bottom"))


      (setq dbid (dbCreatePolygon tcCellView gateLayer master~>bottomFlarePoints1))
      (setq pinid (dbCreatePin gNet dbid))
      (pinid~>accessDir = (list "bottom"))


      ;; add the correct x offset whether the next region is a source or drain
      (cond ((equal (mod gateNum 2) 1)
	     (setq gateXoffset (plus gateXoffset l l GateToGateSpace totalDrnLength))
	    )
	  (t
	   (setq gateXoffset (plus gateXoffset l l GateToGateSpace totalSrcDiffLength tapWidth))
	  )
      )
 )

 ;;
 ;; create the contacts
 ;; 1.  calculate the coordinates for the drain contacts
 ;;       these variables will have a "drn_" prefix
 ;;
 ;; 2.  calculate the coordinates for the end source contacts
 ;;       these variables will have a "es_" prefix
 ;;
 ;; 3.  (if needed) calculate the coordinates for the shared source contacts
 ;;       these variables will have a "ss_" prefix
 ;;

 ;; target variables set:  drn_via1Xorigin, drain via1 X origin
 ;;                        drn_via1Xend,    drain via1 X end
 (setq drn_via1Xorigin 0.0)
 (setq drn_via1Xend via1Width)

 ;; calculate the correct L of layer2 for the drain contacts
 ;; target variables set:  drn_layer2L,         length of layer2
 ;;                        drn_layer2DeltaVia1, offset of layer2 from via1
 ;;
 (cond ((greaterp (setq drn_layer2L (plus layer2EncVia1 via1Width layer2EncVia1))
		      (setq drn_layer2La (plus layer2EncVia2 via2Width layer2EncVia2)))
	(setq drn_layer2DeltaVia1 layer2EncVia1)
       )
     (t
      (setq delta (quotient (difference drn_layer2La drn_layer2L) 2.0))
      (setq drn_layer2DeltaVia1 (plus layer2EncVia1 (times (fix (plus 1e-6 (quotient delta layer2grid))) layer2grid)))
      (setq drn_layer2L drn_layer2La)
     )
 )

 ;; calculate the correct W of layer2 (Y values are the same for all contacts)
 ;; target variables set:  layer2W and layer2YDeltaVia1
 ;;
 (setq layer2W (plus (times 2.0 layer2EncVia1) (times rowsOfContacts via1Pitch) -via1Space))
 (setq layer2Wa (difference (times 2.0 layer2EncVia2) via2Space))
 (setq rowsOfContacts2 0)
 (while (lessp (difference layer2Wa 1e-5) layer2W)
     (setq layer2Wa (plus layer2Wa via2Pitch))
     (setq rowsOfContacts2 (plus rowsOfContacts2 1))
 )
 (setq layer2Wa (difference layer2Wa via2Pitch))
 (setq rowsOfContacts2 (difference rowsOfContacts2 1))
 (setq layer2YDeltaVia1 layer2EncVia1)

 ;; calculate the via origins for the left end source  (mirror for the right)
 ;; target variables set:  es_tvia1Xorigin, tap via1 X origin
 ;;                        es_tvia1Xend,    tap via1 X end
 ;;                        es_dvia1Xorigin, diffusion via1 X origin
 ;;                        es_dvia1Xorigin, diffusion via1 X end
 ;;
 (setq es_dvia1Xorigin srcViaToSrcTapSpace)
 (setq es_dvia1Xend (plus es_dvia1Xorigin via1Width))
 (setq es_tvia1Xorigin (difference es_dvia1Xorigin via1Pitch))
 (setq es_tvia1Xend (plus es_tvia1Xorigin via1Width))

 ;; calculate the correct L of layer2 for the end source contacts
 ;; target variables set:  es_layer2L,         length of layer2
 ;;                        es_layer2DeltaVia1, offset of layer2 from via1
 ;;
 (cond ((greaterp (setq es_layer2L (plus (times 2.0 (plus layer2EncVia1 via1Width)) via1Space))
		      (setq es_layer2La (plus (times 2.0 (plus layer2EncVia2 via2Width)) via2Space)))
	(setq es_layer2DeltaVia1 layer2EncVia1)
       )
     (t
      (setq delta (quotient (difference es_layer2La es_layer2L) 2.0))
      (setq es_layer2DeltaVia1 (plus layer2EncVia1 (times (fix (plus 1e-6 (quotient delta layer2grid))) layer2grid)))
      (setq es_layer2L es_layer2La)
     )
 )

 ;; calculate the via2 origins for the left end source
 ;; Target variables set:  es_tvia2Xorigin, tap via2 X origin
 ;;                        es_tvia2Xend,    tap via2 X end
 ;;                        es_dvia2Xorigin, diffusion via2 X origin
 ;;                        es_dvia2Xend,    diffusion via2 X end
 ;;
 (setq es_tvia2Xorigin (difference es_tvia1Xorigin es_layer2DeltaVia1))
 (setq es_tvia2Xend (plus es_tvia2Xorigin via2Width))
 (setq es_dvia2Xorigin (plus es_tvia2Xend via2Space))
 (setq es_dvia2Xend (plus es_dvia2Xorigin via2Width))

 ;; calculate the correct L of layer2 for the shared source contacts
 ;; target variables set:  ss_layer2L,         length of layer2
 ;;                        ss_layer2DeltaVia1, offset of layer2 from via1
 ;;
 (cond ((greaterp (setq ss_layer2L (plus (times 2.0 (plus layer2EncVia1 via1Space)) (times 3.0 via1Width)))
		  (setq ss_layer2La (plus (times 2.0 (plus layer2EncVia2 via2Space)) (times 3.0 via2Width))))
	(setq ss_layer2DeltaVia1 layer2EncVia1)
       )
     (t
      (setq delta (quotient (difference ss_layer2La ss_layer2L) 2.0))
      (setq ss_layer2DeltaVia1 (plus layer2EncVia1 (times (round (plus 1e-6 (quotient delta layer2grid))) layer2grid)))
      (setq ss_layer2L ss_layer2La)
     )
 )

 (setq contactXloop (plus diffXorigin tapWidth))
 (setq via1Yorigin viaExtDiff)
 (setq layer2Yorigin (difference via1Yorigin layer2YDeltaVia1))
 (setq via2Yorigin (plus layer2Yorigin layer2EncVia2))
 (setq layer2Yend (plus layer2Yorigin (times rowsOfContacts via1Pitch) -via1Space (times 2.0 layer2EncVia1)))

 ;; loop through each source/drain region and draw the appropriate contacts
 ;; Determine if this source/drain region is:
 ;;   1.  the left end source region
 ;;   2.  the right end source region
 ;;   3.  the drain regions
 ;;   4.  the shared source regions
 ;;   In all of the 4 cases, it will 
 ;;       1.  draw the via1s
 ;;       2.  draw layer2
 ;;       3.  draw the via2s
 ;;       4.  draw layer3
 ;;
 (for region 0 m

      (setq via1Yloop via1Yorigin)

      ;;
      ;; case 1:  this is the left end source region
      ;;
      (cond ((equal region 0)

	     ;; target variables set:  dvxo, drain via1 X origin
	     ;;                        dvxe, drain via1 X end
	     ;;                        tvxo, tap via1 X origin
	     ;;                        tvxe, tap via1 X end
	     ;;
	     (setq dvxo (plus contactXloop srcViaToSrcTapSpace))
	     (setq dvxe (plus dvxo via1Width))
	     (setq tvxo (plus dvxo -via1Pitch))
	     (setq tvxe (plus tvxo via1Width))

	     ;;
	     ;; 1.  Draw the via1s
	     ;;
	     (for row 1 rowsOfContacts
		  (setq dbid (dbCreateRect tcCellView via1Layer
					   (list dvxo:via1Yloop
						 dvxe:(plus via1Yloop via1Width))))
		  (dbAddFigToNet dbid sNet)
		  (setq dbid (dbCreateRect tcCellView via1Layer
					   (list tvxo:via1Yloop
						 tvxe:(plus via1Yloop via1Width))))
		  (dbAddFigToNet dbid sNet)

		  (setq via1Yloop (plus via1Yloop via1Pitch))
	     )

	     ;;
	     ;; 2.  Draw layer2
	     ;;
	     (if endTapMetInsideOut then
	       ;; if layer 2 will overlap the gate, pull it back to the edge
	       (setq endTapLayer2XOffset (minus (max (plus tvxo -layer2EncVia1 layer2Width) 0.0)))
	       else
	       (setq endTapLayer2XOffset 0.0)
	       )
	     ;; draw layer2 with width = layer2Width if this parameter is > 0.0

	     (if (greaterp layer2Width 0.0) then
	       (if layer2EdgesAt45 then
		 ;; set parameter to control the length of bevel at 45 degrees 
		 (setq l2bvlCntrl (quotient layer2Width 3.0))
		 ;; snap l2bvlCntrl to grid
		 (setq l2bvlCntrl (times (round (plus (quotient l2bvlCntrl layer2grid) 0.001)) layer2grid))	
		 
		 (setq dbid (dbCreatePolygon tcCellView layer2
					     (list (list (plus tvxo -layer2EncVia1 l2bvlCntrl endTapLayer2XOffset)
							 (plus layer2Yorigin -l2bvlCntrl)
							 )
						   (list (plus tvxo -layer2EncVia1 endTapLayer2XOffset) layer2Yorigin)
						   (list (plus tvxo -layer2EncVia1 endTapLayer2XOffset) layer2Yend)
						   (list (plus tvxo -layer2EncVia1 l2bvlCntrl endTapLayer2XOffset)
							 (plus layer2Yend l2bvlCntrl)
							 )
						   (list (plus tvxo 
							       endTapLayer2XOffset
							       -layer2EncVia1
							       (max layer2Width  
								    (plus (times 2.0 via1Width)
									  via2Width
									  via1Via2Space
									  via1Space
									  layer2EncVia1
									  layer2EncVia2)
								    )
							       -l2bvlCntrl
							       )
							 (plus layer2Yend l2bvlCntrl)
							 )
						   (list (plus tvxo
							       endTapLayer2XOffset
							       -layer2EncVia1
							       (max layer2Width
								    (plus (times 2.0 via1Width)
									  via2Width
									  via1Via2Space
									  via1Space
									  layer2EncVia1
									  layer2EncVia2
									  )
								    )
							       )
							 layer2Yend
							 )
						   (list (plus tvxo 
							       endTapLayer2XOffset
							       -layer2EncVia1
							       (max layer2Width
								    (plus (times 2.0 via1Width)
									  via2Width
									  via1Via2Space
									  via1Space
									  layer2EncVia1
									  layer2EncVia2
									  )
								    )
							       )
							 layer2Yorigin
							 )
						   (list (plus tvxo 
							       endTapLayer2XOffset
							       -layer2EncVia1
							       (max layer2Width
								    (plus (times 2.0 via1Width)
									  via2Width
									  via1Via2Space
									  via1Space
									  layer2EncVia1
									  layer2EncVia2
									  )
								    )
							       -l2bvlCntrl
							       )
							 (plus layer2Yorigin -l2bvlCntrl)
							 )
						   )
					     )
		       )
		 else
		 (setq dbid (dbCreateRect tcCellView layer2
					  (list (list (plus tvxo -layer2EncVia1 endTapLayer2XOffset) layer2Yorigin)
						(list (plus tvxo
							    endTapLayer2XOffset
							    -layer2EncVia1
							    (max layer2Width
								 (plus (times 2.0 via1Width)
								       via2Width
								       via1Via2Space
								       via1Space
								       layer2EncVia1
								       layer2EncVia2
								       )
								 )
							    )
						      layer2Yend
						      )
						)
					  )
		       )
		 )
	      else
		 (setq dbid (dbCreateRect tcCellView layer2
					  (list (plus tvxo -es_layer2DeltaVia1):layer2Yorigin
						(plus tvxo -es_layer2DeltaVia1 es_layer2L):layer2Yend)))
	     )

	     (dbAddFigToNet dbid sNet)
		 
	     ;; target variables set:  tvxo, tap via2 X origin
	     ;;                        tvxe, tap via2 X end
	     ;;                        dvxo, diffusion via2 X origin
	     ;;                        dvxe, diffusion via2 X end
	     ;;
	     (unless (greaterp via1Via2Space 0.0)
	       (setq tvxo (plus tvxo -es_layer2DeltaVia1 layer2EncVia2))
	       (setq tvxe (plus tvxo via2Width))
	       )
	     (if (greaterp via1Via2Space 0.0) then
	       (setq dvxo (plus dvxe via1Via2Space))
	       else
	       (setq dvxo (plus tvxe via2Space))
	       )
	     (setq dvxe (plus dvxo via2Width))
	     (setq via2Yloop (plus layer2Yorigin layer2EncVia2))
	     
	     ;;
	     ;; 3.  Draw the via2s
	     ;;
	     (for row 1 rowsOfContacts2
		  (setq dbid (dbCreateRect tcCellView via2Layer
					   (list dvxo:via2Yloop
						 dvxe:(plus via2Yloop via2Width))))
		  (dbAddFigToNet dbid sNet)
		  (unless (greaterp via1Via2Space 0.0) 
		    (setq dbid (dbCreateRect tcCellView via2Layer
					     (list tvxo:via2Yloop
						   tvxe:(plus via2Yloop via2Width))))
		    (dbAddFigToNet dbid sNet)
		    )
		  (setq via2Yloop (plus via2Yloop via2Pitch))
		  )
	     
	     ;;
	     ;; 4.  Draw layer3
	     ;;
	     
	     ;; draw layer3 with width = layer3Width_outside if layer3Width_outside > 0 
	     ;;                        = layer3Width if layer3Width > 0
	     
	     (if (greaterp layer3Width 0.0) then
	       (if (greaterp layer3Width_outside 0.0) then
		 (setq widthTobeDrawn (max layer3Width_outside 
					   (plus (times 2.0 via1Width)
						 via2Width
						 via1Space
						 via1Via2Space
						 layer2EncVia1
						 layer3EncVia2
						 )
					   )
		       )
		 else
		 (setq widthTobeDrawn (max layer3Width
					   (plus (times 2.0 via1Width)
						 via2Width
						 via1Space
						 via1Via2Space
						 layer2EncVia1
						 layer3EncVia2
						 )
					   )
		       )
		 )
	       (if endTapMetInsideOut then
		 (setq endTapLayer3XOffset (plus layer2Width -widthTobeDrawn endTapLayer2XOffset))
		 else
		 (setq endTapLayer3XOffset 0.0)
		 )
	       
	       (if layer3EdgesAt45 then
		 ;; set parameter to control the length of bevel at 45 degrees 
		 (setq l3bvlCntrl (quotient widthTobeDrawn 3.0))
		 ;; snap l3bvlCntrl to grid
		 (setq l3bvlCntrl (times (round (plus (quotient l3bvlCntrl layer3grid) 0.001)) layer3grid))
		 
		 (setq dbid 
		       (dbCreatePolygon tcCellView layer3
					  (list (list (plus tvxo -layer2EncVia1 l3bvlCntrl endTapLayer3XOffset)
						      (plus layer2Yorigin layer2EncVia2 -layer3EncVia2 -l3bvlCntrl)
						      )
						(list (plus tvxo -layer2EncVia1 endTapLayer3XOffset)
						      (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
						      )
						(list (plus tvxo -layer2EncVia1 endTapLayer3XOffset)
						      (plus via2Yloop -via2Space layer3EncVia2)
						      )
						(list (plus tvxo -layer2EncVia1 l3bvlCntrl endTapLayer3XOffset)
						      (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrl))
						(list (plus tvxo -layer2EncVia1 widthTobeDrawn 
							    -l3bvlCntrl endTapLayer3XOffset)
						      (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrl))
						(list (plus tvxo -layer2EncVia1 widthTobeDrawn endTapLayer3XOffset)
						      (plus via2Yloop -via2Space layer3EncVia2))
						(list (plus tvxo -layer2EncVia1 widthTobeDrawn endTapLayer3XOffset)
						      (plus layer2Yorigin layer2EncVia2 -layer3EncVia2))
						(list (plus tvxo -layer2EncVia1 widthTobeDrawn 
							    -l3bvlCntrl endTapLayer3XOffset)
						      (plus layer2Yorigin layer2EncVia2 -layer3EncVia2 -l3bvlCntrl)))
					  ))
		 else
		 (setq dbid (dbCreateRect tcCellView layer3
					    (list (list (plus tvxo -layer2EncVia1 endTapLayer3XOffset)
							(plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
							)
						  (list (plus tvxo -layer2EncVia1 widthTobeDrawn endTapLayer3XOffset)
							(plus via2Yloop -via2Space layer3EncVia2)
							)
						  )
					  )
		       )
		 )
	       else
	       (setq dbid 
		     (dbCreateRect tcCellView layer3
				   (list (list (difference tvxo layer3EncVia2)
					       (plus layer2Yorigin layer2EncVia2 -layer3EncVia2))
					 (list (plus dvxe layer3EncVia2)
					       (plus via2Yloop -via2Space layer3EncVia2)))))
	       )
	     (dbAddFigToNet dbid sNet)
	     
	     (setq pinid (dbCreatePin sNet dbid))
	     pinid~>accessDir = (list "top" "bottom" "left")
	    )

	  ;;
	  ;; case 2:  this is the right end source region
	  ;;
	  ((equal region m)

	   (setq contactXloop (plus contactXloop via1Width drnViaGateSpace extraDrnSpace l l GateToGateSpace extraSrcSpace srcViaGateSpace via1Width srcViaToSrcTapSpace))

	   ;; target variables set:  dvxo, drain via1 X origin
	   ;;                        dvxe, drain via1 X end
	   ;;                        tvxo, tap via1 X origin
	   ;;                        tvxe, tap via1 X end
	   ;;
	   (setq dvxo (plus contactXloop -srcViaToSrcTapSpace -via1Width))
	   (setq dvxe (plus dvxo via1Width))
	   (setq tvxo (plus dvxo via1Pitch))
	   (setq tvxe (plus tvxo via1Width))

	   ;;
	   ;; 1.  draw the via1s
	   ;;
	   (for row 1 rowsOfContacts
		(setq dbid (dbCreateRect tcCellView via1Layer
					 (list dvxo:via1Yloop
					       dvxe:(plus via1Yloop via1Width))))
		(dbAddFigToNet dbid sNet)
		(setq dbid (dbCreateRect tcCellView via1Layer
					 (list tvxo:via1Yloop
					       tvxe:(plus via1Yloop via1Width))))
		(dbAddFigToNet dbid sNet)

		(setq via1Yloop (plus via1Yloop via1Pitch))
	   )

	   ;;
	   ;; 2.  draw layer2
	   ;;
	   (if endTapMetInsideOut then
	     ;; if layer 2 will overlap the gate, pull it back to the edge
	     (setq endTapLayer2XOffset (max (difference  
					     (plus (times m l)
						   (times (quotient m 2) totalDrnLength)
						   (times (difference (quotient m 2) 1)
							  (plus tapWidth totalSrcDiffLength)
							  )
						   )
					     ;; normal layer2 right edge
					     (plus tvxe layer2EncVia1 -layer2Width)
					     )
					    0.0)
		   )
	     else
	     (setq endTapLayer2XOffset 0.0)
	     )

	   ;; draw layer2 with width = layer2Width if this parameter > 0.0
	   (if (greaterp layer2Width 0.0) then
	     (if layer2EdgesAt45 then
	       (setq dbid (dbCreatePolygon tcCellView layer2
					   (list (list (plus tvxe layer2EncVia1 -l2bvlCntrl endTapLayer2XOffset)
						       (plus layer2Yorigin -l2bvlCntrl)
						       )
						 (list (plus tvxe layer2EncVia1 endTapLayer2XOffset) layer2Yorigin)
						 (list (plus tvxe layer2EncVia1 endTapLayer2XOffset) layer2Yend)
						 (list (plus tvxe layer2EncVia1 -l2bvlCntrl endTapLayer2XOffset) 
						       (plus layer2Yend l2bvlCntrl)
						       )
						 (list (plus tvxe 
							     endTapLayer2XOffset
							     layer2EncVia1
							     -(max layer2Width 
								   (plus (times 2.0 via1Width)
									 via2Width
									 via1Via2Space
									 via1Space
									 layer2EncVia1
									 layer2EncVia2
									 )
								   )
							     l2bvlCntrl
							     )
						       (plus layer2Yend l2bvlCntrl)
						       )
						 (list (plus tvxe 
							     endTapLayer2XOffset
							     layer2EncVia1
							     -(max layer2Width 
								   (plus (times 2.0 via1Width)
									 via2Width
									 via1Via2Space
									 via1Space
									 layer2EncVia1
									 layer2EncVia2
									 )
								   )
							     )
						       layer2Yend
						       )
						 (list (plus tvxe 
							     endTapLayer2XOffset
							     layer2EncVia1
							     -(max layer2Width 
								   (plus (times 2.0 via1Width)
									 via2Width
									 via1Via2Space
									 via1Space
									 layer2EncVia1
									 layer2EncVia2
									 )
								   )
							     )
						       layer2Yorigin
						       )
						 (list (plus tvxe 
							     endTapLayer2XOffset
							     layer2EncVia1
							     -(max layer2Width
								   (plus (times 2.0 via1Width)
									 via2Width
									 via1Via2Space
									 via1Space
									 layer2EncVia1
									 layer2EncVia2
									 )
								   )
							     l2bvlCntrl
							     )
						       (plus layer2Yorigin -l2bvlCntrl))))
		     )
	       else
	       (setq dbid (dbCreateRect tcCellView layer2
					(list (list (plus tvxe layer2EncVia1 endTapLayer2XOffset) layer2Yorigin)
					      (list (plus tvxe 
							  endTapLayer2XOffset
							  layer2EncVia1
							  -(max layer2Width 
								(plus (times 2.0 via1Width)
								      via2Width
								      via1Via2Space
								      via1Space
								      layer2EncVia1
								      layer2EncVia2
								      )
								)
							  )
						    layer2Yend
						    )
					      )
					)
		     )
	       )
	    else
	       (setq dbid (dbCreateRect tcCellView layer2
					(list (plus dvxo -es_layer2DeltaVia1):layer2Yorigin
					      (plus dvxo -es_layer2DeltaVia1 es_layer2L):layer2Yend)))
	   )

	   ;; target variables set:  tvxo, tap via2 X origin
	   ;;                        tvxe, tap via2 X end
	   ;;                        dvxo, diffusion via2 X origin
	   ;;                        dvxe, diffusion via2 X end
	   ;;
	   (if (greaterp via1Via2Space 0.0) then
	     (setq dvxo (difference dvxo (plus via2Width via1Via2Space)))
	     else
	     (setq dvxo (plus dvxo -es_layer2DeltaVia1 layer2EncVia2))
	     )
	   (setq dvxe (plus dvxo via2Width))
	   
	   (unless (greaterp via1Via2Space 0.0)
	     (setq tvxo (plus dvxe via2Space))
	     (setq tvxe (plus tvxo via2Width))
	     )
	   
	   (setq via2Yloop (plus layer2Yorigin layer2EncVia2))
	   
	   ;;
	   ;; 3.  draw the via2s
	   ;;
	   (for row 1 rowsOfContacts2
		(setq dbid (dbCreateRect tcCellView via2Layer
					 (list dvxo:via2Yloop
					       dvxe:(plus via2Yloop via2Width))))
		(dbAddFigToNet dbid sNet)
		(unless (greaterp via1Via2Space 0.0) 
		  (setq dbid (dbCreateRect tcCellView via2Layer
					   (list tvxo:via2Yloop
						 tvxe:(plus via2Yloop via2Width))))
		  (dbAddFigToNet dbid sNet)
		  )
		(setq via2Yloop (plus via2Yloop via2Pitch))
		)
	   
	   ;;
	   ;; 4.  draw layer3
	   ;;
	   
	   ;; draw layer3 with width = layer3Width_outside if this parameter > 0.0
	   ;;                        = layer3Width if this parameter > 0.0 
	   
	   (if (greaterp layer3Width 0.0) then
	     (if (greaterp layer3Width_outside 0.0) then 
	       (setq widthTobeDrawn (max layer3Width_outside 
					 (plus (times 2.0 via1Width)
					       via2Width
					       via1Space
					       via1Via2Space
					       layer2EncVia1
					       layer3EncVia2)))
	       else
	       (setq widthTobeDrawn (max layer3Width 
					 (plus (times 2.0 via1Width)
					       via2Width
					       via1Space
					       via1Via2Space
					       layer2EncVia1
					       layer3EncVia2)))
	       )
	     
	     (if endTapMetInsideOut then
	       (setq endTapLayer3XOffset (plus -layer2Width widthTobeDrawn endTapLayer2XOffset))
	       else
	       (setq endTapLayer3XOffset 0.0)
	       )
	     
	     (if layer3EdgesAt45 then
	       ;; set parameter to control the length of bevel at 45 degrees 
	       (setq l3bvlCntrl (quotient widthTobeDrawn 3.0))
	       ;; snap l3bvlCntrl to grid
	       (setq l3bvlCntrl (times (round (plus (quotient l3bvlCntrl layer3grid) 0.001)) layer3grid))
	       
	       (setq dbid (dbCreatePolygon tcCellView layer3
					   (list (list (plus tvxe 
							     layer2EncVia1
							     -widthTobeDrawn
							     l3bvlCntrl
							     endTapLayer3XOffset
							     )
						       (plus layer2Yorigin
							     layer2EncVia2
							     -layer3EncVia2
							     -l3bvlCntrl
							     )
						       )
						 (list (plus tvxe layer2EncVia1 -widthTobeDrawn endTapLayer3XOffset)
						       (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
						       )
						 (list (plus tvxe layer2EncVia1 -widthTobeDrawn endTapLayer3XOffset)
						       (plus via2Yloop -via2Space layer3EncVia2)
						       )
						 (list (plus tvxe layer2EncVia1 -widthTobeDrawn 
							     l3bvlCntrl endTapLayer3XOffset)
						       (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrl)
						       )
						 (list (plus tvxe layer2EncVia1 -l3bvlCntrl endTapLayer3XOffset)
						       (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrl)
						       )
						 (list (plus tvxe layer2EncVia1 endTapLayer3XOffset)
						       (plus via2Yloop -via2Space layer3EncVia2)
						       )
						 (list (plus tvxe layer2EncVia1 endTapLayer3XOffset)
						       (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
						       )
						 (list (plus tvxe layer2EncVia1 -l3bvlCntrl endTapLayer3XOffset)
						       (plus layer2Yorigin layer2EncVia2 -layer3EncVia2 -l3bvlCntrl)
						       )
						 )
					   )
		     )
	       else
	       (setq dbid (dbCreateRect tcCellView layer3
					(list (list (plus tvxe layer2EncVia1 -widthTobeDrawn endTapLayer3XOffset)
						    (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
						    )
					      (list (plus tvxe layer2EncVia1 endTapLayer3XOffset)
						    (plus via2Yloop -via2Space layer3EncVia2)
						    )
					      )
					)
		     )
	       )
	     else
	     (setq dbid (dbCreateRect tcCellView layer3
				      (list (difference dvxo layer3EncVia2):(plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
					    (plus tvxe layer3EncVia2):(plus via2Yloop -via2Space layer3EncVia2))))
	     )
	   (dbAddFigToNet dbid sNet)
	   
	   (setq pinid (dbCreatePin sNet dbid))
	   pinid~>accessDir = (list "top" "bottom" "right")
	   
	  )

	  ;;
	  ;; case 3:  this is a drain region
	  ;;
	  ((equal 1 (mod region 2))

	   (setq contactXloop (plus contactXloop srcViaToSrcTapSpace via1Width srcViaGateSpace extraSrcSpace l l GateToGateSpace extraDrnSpace drnViaGateSpace))

	   ;; target variables set:  dvxo, diffusion via2 X origin
	   ;;                        dvxe, diffusion via2 X end
	   ;;
	   (setq dvxo contactXloop)
	   (setq dvxe (plus dvxo via1Width))

	   ;;
	   ;; 1.  draw the via1s
	   ;;
	   (for row 1 rowsOfContacts
		(setq dbid (dbCreateRect tcCellView via1Layer
					 (list dvxo:via1Yloop
					       dvxe:(plus via1Yloop via1Width))))
		(dbAddFigToNet dbid dNet)
		(setq via1Yloop (plus via1Yloop via1Pitch))
	   )

	   ;;
	   ;; 2.  draw layer2
	   ;;
	   (if (greaterp layer2Width 0.0) then
	       (if (greaterp layer2Width (plus (times 2.0 via1Via2Space) 
					       (times 2.0 via2Width)
					       via1Width
					       (times 2.0 layer2EncVia2))) then
		 (setq layer2Xorigin_dr (difference dvxo (times (difference layer2Width via1Width) 0.5)))
		 ;; make sure layer2Xorigin_dr is on grid
		 (setq layer2Xorigin_dr (times (round (plus (quotient layer2Xorigin_dr layer2grid) 0.001)) layer2grid))
		 (if layer2EdgesAt45 then
		   (setq dbid (dbCreatePolygon tcCellView layer2
					       (list (list (plus layer2Xorigin_dr l2bvlCntrl)
							   (plus layer2Yorigin -l2bvlCntrl)
							   )
						     (list layer2Xorigin_dr layer2Yorigin)
						     (list layer2Xorigin_dr layer2Yend)
						     (list (plus layer2Xorigin_dr l2bvlCntrl)
							   (plus layer2Yend l2bvlCntrl)
							   )
						     (list (plus layer2Xorigin_dr layer2Width -l2bvlCntrl)
							   (plus layer2Yend l2bvlCntrl)
							   )
						     (list (plus layer2Xorigin_dr layer2Width) layer2Yend)
						     (list (plus layer2Xorigin_dr layer2Width) layer2Yorigin)
						     (list (plus layer2Xorigin_dr layer2Width -l2bvlCntrl)
							   (plus layer2Yorigin -l2bvlCntrl)
							   )
						     )
					       )
			 )
		   else
		   (setq dbid (dbCreateRect tcCellView layer2
					    (list (list layer2Xorigin_dr layer2Yorigin)
						  (list (plus layer2Xorigin_dr layer2Width) layer2Yend)
						  )
					    )
			 )
		   )
		 else
		 (if layer2EdgesAt45 then
		   (setq dbid (dbCreatePolygon tcCellView layer2
					       (list (list (plus (difference dvxo 
									     (plus via1Via2Space
										   via2Width
										   layer2EncVia2
										   )
									     )
								 l2bvlCntrl)
							   (plus layer2Yorigin -l2bvlCntrl)
							   )
						     (list (difference dvxo 
								       (plus via1Via2Space
									     via2Width
									     layer2EncVia2
									     )
								       )
							   layer2Yorigin
							   )
						     (list (difference dvxo 
								       (plus via1Via2Space
									     via2Width
									     layer2EncVia2
									     )
								       )
							   layer2Yend
							   )
						     (list (plus (difference dvxo
									     (plus via1Via2Space
										   via2Width
										   layer2EncVia2
										   )
									     )
								 l2bvlCntrl)
							   (plus layer2Yend l2bvlCntrl)
							   )
						     (list (plus dvxe 
								 via1Via2Space
								 via2Width
								 layer2EncVia2
								 -l2bvlCntrl
								 )
							   (plus layer2Yend l2bvlCntrl)
							   )
						     (list (plus dvxe 
								 via1Via2Space
								 via2Width
								 layer2EncVia2
								 )
							   layer2Yend
							   )
						     (list (plus dvxe via1Via2Space via2Width layer2EncVia2)
							   layer2Yorigin
							   )
						     (list (plus dvxe via1Via2Space via2Width layer2EncVia2 -l2bvlCntrl)
							   (plus layer2Yorigin -l2bvlCntrl)
							   )
						     )
					       )
			 )
		   else
		   (setq dbid (dbCreateRect tcCellView layer2
					    (list (list (difference dvxo 
								    (plus via1Via2Space
									  via2Width
									  layer2EncVia2
									  )
								    )
							layer2Yorigin
							)
						  (list (plus dvxe 
							      via1Via2Space
							      via2Width
							      layer2EncVia2
							      )
							layer2Yend
							)						  )
					    )
			 )
		   )
		 )
	    else
	       (setq dbid (dbCreateRect tcCellView layer2
					(list (difference dvxo drn_layer2DeltaVia1):layer2Yorigin
					      (plus dvxe drn_layer2DeltaVia1):layer2Yend)))
	   )
	   (dbAddFigToNet dbid dNet)
	   
	   ;; target variables set:  dvxo, diffusion via2 X origin
	   ;;                        dvxe, diffusion via2 X end
	   ;;
	   (if (greaterp via1Via2Space 0.0) then
	     (setq dvxo (plus dvxo -via1Via2Space -via2Width))
	     else
	     (setq dvxo (plus dvxo -drn_layer2DeltaVia1 layer2EncVia2))
	     )
	   (setq dvxe (plus dvxo via2Width))
	   (setq via2Yloop (plus layer2Yorigin layer2EncVia2))
	   
	   ;;
	   ;; 3.  draw the via2s
	   ;;
	   (for row 1 rowsOfContacts2
		(setq dbid (dbCreateRect tcCellView via2Layer
					 (list dvxo:via2Yloop
					       dvxe:(plus via2Yloop via2Width))))
		(dbAddFigToNet dbid dNet)
		
		(when (greaterp via1Via2Space 0.0) 
		  (setq dbid (dbCreateRect tcCellView via2Layer
					   (list (plus dvxo (times 2.0 via1Via2Space) via1Width via2Width):via2Yloop
						 (plus dvxo (times 2.0 via1Via2Space) via1Width (times 2.0 via2Width)):(plus via2Yloop via2Width))))
		  (dbAddFigToNet dbid dNet)
		  )
		
		(setq via2Yloop (plus via2Yloop via2Pitch))
		)
	   
	   ;;
	   ;; 4.  draw layer3
	   ;;
	   
	   ;; draw layer3 with width = layer3Width if this parameter > 0.0
	   (if (greaterp layer3Width 0.0) then
	     ;; set parameter to control the length of bevel at 45 degrees 
	     (setq l3bvlCntrl (quotient layer3Width 3.0))
	     ;; snap l3bvlCntrl to grid
	     (setq l3bvlCntrl (times (round (plus (quotient l3bvlCntrl layer2grid) 0.001)) layer2grid))
	     
	     (if (greaterp layer3Width (plus (times 2.0 via2Width) via1Width (times 2.0 via1Via2Space) (times 2.0 layer3EncVia2))) then
	       (setq layer3Xorigin_dr (difference contactXloop (times (difference layer3Width via2Width) 0.5)))
	       ;; make sure layer3Xorigin_dr is on grid
	       (setq layer3Xorigin_dr (times (round (plus (quotient layer3Xorigin_dr layer3grid) 0.001)) layer3grid)) 
	       (if layer3EdgesAt45 then
		 (setq dbid (dbCreatePolygon tcCellView layer3
					     (list (list (plus layer3Xorigin_dr l3bvlCntrl)
							 (plus layer2Yorigin layer2EncVia2 -layer3EncVia2 -l3bvlCntrl)
							 )
						   (list layer3Xorigin_dr
							 (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
							 )
						   (list layer3Xorigin_dr
							 (plus via2Yloop -via2Space layer3EncVia2)
							 )
						   (list (plus layer3Xorigin_dr l3bvlCntrl)
							 (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrl)
							 )
						   (list (plus layer3Xorigin_dr layer3Width -l3bvlCntrl)
							 (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrl)
							 )
						   (list (plus layer3Xorigin_dr layer3Width)
							 (plus via2Yloop -via2Space layer3EncVia2)
							 )
						   (list (plus layer3Xorigin_dr layer3Width)
							 (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
							 )
						   (list (plus layer3Xorigin_dr layer3Width -l3bvlCntrl)
							 (plus layer2Yorigin layer2EncVia2 -layer3EncVia2 -l3bvlCntrl)
							 )
						   )
					     )
		       )
		 else
		 (setq dbid (dbCreateRect tcCellView layer3
					  (list (list layer3Xorigin_dr
						      (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
						      )
						(list (plus layer3Xorigin_dr layer3Width)
						      (plus via2Yloop -via2Space layer3EncVia2)
						      )
						)
					  )
		       )
		 )
	       else
	       (if layer3EdgesAt45 then
		 (setq dbid (dbCreatePolygon tcCellView layer3
					     (list (list (plus dvxo -layer3EncVia2 l3bvlCntrl)
							 (plus layer2Yorigin layer2EncVia2 -layer3EncVia2 -l3bvlCntrl)
							 )
						   (list (plus dvxo -layer3EncVia2)
							 (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
							 )
						   (list (plus dvxo -layer3EncVia2)
							 (plus via2Yloop -via2Space layer3EncVia2)
							 )
						   (list (plus dvxo -layer3EncVia2 l3bvlCntrl)
							 (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrl)
							 )
						   (list (plus dvxo 
							       (times 2.0 via2Width)
							       via1Width
							       (times 2.0 via1Via2Space)
							       layer3EncVia2
							       -l3bvlCntrl
							       )
							 (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrl)
							 )
						   (list (plus dvxo 
							       (times 2.0 via2Width)
							       via1Width
							       (times 2.0 via1Via2Space)
							       layer3EncVia2
							       )
							 (plus via2Yloop -via2Space layer3EncVia2)
							 )
						   (list (plus dvxo
							       (times 2.0 via2Width)
							       via1Width
							       (times 2.0 via1Via2Space)
							       layer3EncVia2
							       )
							 (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
							 )
						   (list (plus dvxo 
							       (times 2.0 via2Width)
							       via1Width
							       (times 2.0 via1Via2Space)
							       layer3EncVia2
							       -l3bvlCntrl
							       )
							 (plus layer2Yorigin layer2EncVia2 -layer3EncVia2 -l3bvlCntrl)
							 )
						   )
					     )
		       )
		 else
		 (setq dbid (dbCreateRect tcCellView layer3
					  (list (list (plus dvxo -layer3EncVia2)
							 (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
							 )
						(list (plus dvxo 
							    (times 2.0 via2Width)
							    via1Width
							    (times 2.0 via1Via2Space)
							    layer3EncVia2
							    )
						      (plus via2Yloop -via2Space layer3EncVia2)
						      )
						)
					  )
		       )
		 )
	       )
	     else
	     (setq dbid (dbCreateRect tcCellView layer3
				      (list (difference dvxo layer3EncVia2):(plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
					    (plus dvxe layer3EncVia2):(plus via2Yloop -via2Space layer3EncVia2))))
	     )
	   (dbAddFigToNet dbid dNet)
	   
	   (setq pinid (dbCreatePin dNet dbid))
	   pinid~>accessDir = (list "top" "bottom")
	  )

	  ;;
	  ;; case 4:  this is a shared source region
	  ;;
	  (t

	   (setq contactXloop (plus contactXloop via1Width drnViaGateSpace extraDrnSpace l l GateToGateSpace extraSrcSpace srcViaGateSpace via1Width srcViaToSrcTapSpace tapWidth))

	   ;; target variables set:  rdvxo, right diffusion x origin
	   ;;                        rdvxe, right diffusion x end
	   ;;                        tvxo,  center tap via2 X origin
	   ;;                        tvxe,  center tap via2 X end
	   ;;                        ldvxo, left diffusion via2 X origin
	   ;;                        ldvxe, left diffusion via2 X end
	   ;;
	   (setq rdvxo (plus contactXloop srcViaToSrcTapSpace))
	   (setq rdvxe (plus rdvxo via1Width))
	   (if (greaterp tapWidth (plus via1Width (times 2.0 tapEncVia1))) then
	       (setq tvxo (difference (difference (difference rdvxo 
							      (times 0.5 (difference tapWidth via1Width))
							      ) via1Width) srcViaTapSpace))
	       ;; snap this to grid
	       (setq tvxo (times (round (plus (quotient tvxo via1grid) 0.001)) via1grid))
	    else
	       (setq tvxo (plus rdvxo -via1Pitch))
	   )
	   (setq tvxe (plus tvxo via1Width))
	   (setq ldvxo (min (plus tvxo -via1Pitch) (plus contactXloop -tapWidth -via1Width -srcViaTapSpace)))
	   (setq ldvxe (plus ldvxo via1Width))

	   ;;
	   ;; 1.  Draw the via1s
	   ;;
	   (for row 1 rowsOfContacts
		(setq dbid (dbCreateRect tcCellView via1Layer
					 (list rdvxo:via1Yloop
					       rdvxe:(plus via1Yloop via1Width))))
		(dbAddFigToNet dbid sNet)
		(setq dbid (dbCreateRect tcCellView via1Layer
					 (list tvxo:via1Yloop
					       tvxe:(plus via1Yloop via1Width))))
		(dbAddFigToNet dbid sNet)
		(setq dbid (dbCreateRect tcCellView via1Layer
					 (list ldvxo:via1Yloop
					       ldvxe:(plus via1Yloop via1Width))))
		(dbAddFigToNet dbid sNet)

		(setq via1Yloop (plus via1Yloop via1Pitch))
	   )

	   ;;
	   ;; 2.  Draw layer2
	   ;;

	   (if (greaterp layer2Width 0.0) then
	     (if layer2EdgesAt45 then
	       (setq dbid (dbCreatePolygon tcCellView layer2
					   (list (list (plus (difference ldvxo 
									 (plus via1Via2Space
									       via2Width
									       layer2EncVia2
									       )
									 )
							     l2bvlCntrl
							     )
						       (plus layer2Yorigin -l2bvlCntrl)
						       )
						 (list (difference ldvxo 
								   (plus via1Via2Space via2Width layer2EncVia2)
								   )
						       layer2Yorigin
						       )
						 (list (difference ldvxo 
								   (plus via1Via2Space via2Width layer2EncVia2)
								   )
						       layer2Yend
						       )
						 (list (plus (difference ldvxo 
									 (plus via1Via2Space via2Width layer2EncVia2)
									 )
							     l2bvlCntrl
							     )
						       (plus layer2Yend l2bvlCntrl)
						       )
						 (list (plus rdvxe via1Via2Space via2Width layer2EncVia2 -l2bvlCntrl)
						       (plus layer2Yend l2bvlCntrl)
						       )
						 (list (plus rdvxe via1Via2Space via2Width layer2EncVia2)
						       layer2Yend
						       )
						 (list (plus rdvxe via1Via2Space via2Width layer2EncVia2)
						       layer2Yorigin
						       )
						 (list (plus rdvxe via1Via2Space via2Width layer2EncVia2 -l2bvlCntrl)
						       (plus layer2Yorigin -l2bvlCntrl)))))
	       else
	       (setq dbid (dbCreateRect tcCellView layer2
					(list (list (difference ldvxo 
								(plus via1Via2Space via2Width layer2EncVia2)
								)
						    layer2Yorigin
						    )
					      (list (plus rdvxe via1Via2Space via2Width layer2EncVia2)
						    layer2Yend
						    )
					      )
					)
		     )
	       )
	    else
	       (setq dbid (dbCreateRect tcCellView layer2
					(list (difference ldvxo ss_layer2DeltaVia1):layer2Yorigin
					      (plus ldvxo -ss_layer2DeltaVia1 ss_layer2L):layer2Yend)))
	   )
	   (dbAddFigToNet dbid sNet)

	   ;; target variables set:  rdvxo, right diffusion x origin
	   ;;                        rdvxe, right diffusion x end
	   ;;                        tvxo,  center tap via2 X origin
	   ;;                        tvxe,  center tap via2 X end
	   ;;                        ldvxo, left diffusion via2 X origin
	   ;;                        ldvxe, left diffusion via2 X end
	   ;;
	   (if (greaterp via1Via2Space 0.0) then
	     (setq ldvxo (plus ldvxo -via1Via2Space -via2Width))
	     else
	     (setq ldvxo (plus ldvxo -ss_layer2DeltaVia1 layer2EncVia2))
	     )
	   (setq ldvxe (plus ldvxo via2Width))
	   (setq tvxo (plus ldvxe via2Space))
	   (setq tvxe (plus tvxo via2Width))
	   (if (greaterp via1Via2Space 0.0) then
	     (setq rdvxo (plus rdvxe via1Via2Space))
	     else
	     (setq rdvxo (plus tvxe via2Space))
	     )
	   (setq rdvxe (plus rdvxo via2Width))
	   (setq via2Yloop (plus layer2Yorigin layer2EncVia2))
	   
	   ;;
	   ;; 3.  Draw the via2s
	   ;;
	   (for row 1 rowsOfContacts2
		(setq dbid (dbCreateRect tcCellView via2Layer
					 (list ldvxo:via2Yloop
					       ldvxe:(plus via2Yloop via2Width))))
		(dbAddFigToNet dbid sNet)
		
		(unless (greaterp via1Via2Space 0.0)
		  (setq dbid (dbCreateRect tcCellView via2Layer
					   (list tvxo:via2Yloop
						 tvxe:(plus via2Yloop via2Width))))
		  (dbAddFigToNet dbid sNet)
		  )
		
		(setq dbid (dbCreateRect tcCellView via2Layer
					 (list rdvxo:via2Yloop
					       rdvxe:(plus via2Yloop via2Width))))
		(dbAddFigToNet dbid sNet)
		(setq via2Yloop (plus via2Yloop via2Pitch))
		)
	   
	   ;;
	   ;; 4.  Draw layer3
	   ;;
	   (if (greaterp layer3Width 0.0) then
	     (if layer3EdgesAt45 then
	       (setq dbid (dbCreatePolygon tcCellView layer3
					   (list (list (plus (difference ldvxo layer3EncVia2) l3bvlCntrl)
						       (plus layer2Yorigin layer2EncVia2 -layer3EncVia2 -l3bvlCntrl)
						       )
						 (list (difference ldvxo layer3EncVia2)
						       (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
						       )
						 (list (difference ldvxo layer3EncVia2)
						       (plus via2Yloop -via2Space layer3EncVia2)
						       )
						 (list (plus (difference ldvxo layer3EncVia2) l3bvlCntrl)
						       (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrl)
						       )
						 (list (plus rdvxe layer3EncVia2 -l3bvlCntrl)
						       (plus via2Yloop -via2Space layer3EncVia2 l3bvlCntrl)
						       )
						 (list (plus rdvxe layer3EncVia2)
						       (plus via2Yloop -via2Space layer3EncVia2)
						       )
						 (list (plus rdvxe layer3EncVia2)
						       (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
						       )
						 (list (plus rdvxe layer3EncVia2 -l3bvlCntrl)
						       (plus layer2Yorigin layer2EncVia2 -layer3EncVia2 -l3bvlCntrl)
						       )
						 )
					   )
		     )
	       else
	       (setq dbid (dbCreateRect tcCellView layer3
					(list (list (difference ldvxo layer3EncVia2)
						    (plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
						    )
					      (list (plus rdvxe layer3EncVia2)
						    (plus via2Yloop -via2Space layer3EncVia2)
						    )
					      )
					)
		     )
	       )
	     else
	     (setq dbid (dbCreateRect tcCellView layer3
				      (list (difference ldvxo layer3EncVia2):(plus layer2Yorigin layer2EncVia2 -layer3EncVia2)
					    (plus rdvxe layer3EncVia2):(plus via2Yloop -via2Space layer3EncVia2))))
	     )
	   (dbAddFigToNet dbid sNet)
	   
	   (setq pinid (dbCreatePin sNet dbid))
	   pinid~>accessDir = (list "top" "bottom")
	   )
	  )
      )
 
 ;;
 ;; create the inner guard ring in 7 steps:
 ;; 1.  create the inner ring of tap
 ;; 2.  create the well enclosing the tap and transistor
 ;; 3.  create the inner riveted ring of via1's
 ;; 4.  create the inner ring of layer2
 ;; *5.  create the inner riveted ring of via2's
 ;; *6.  create the inner ring of layer3
 ;; 7.  create a terminal out of the topmost layer
 ;; (* = if necessary)
 ;;
 ;; All of the variables that start with "ir" deal with the inner guard ring

 ;; 1.  create the tap in the inner guard ring
 ;; target variables set:
 ;;   tapWidthInIR = the ring width of tap in the inner guard ring
 ;;   irTapXorigin = the X origin (LL corner) of the inner tap guard ring
 ;;   irTapYorigin = the Y origin (LL corner) of the inner tap guard ring
 ;;   irTapL = the total length of the inner tap guard ring
 ;;   irTapW = the total width of the inner tap guard ring
 (setq tapWidthInIR (max innerRingTapWidth (plus via1Width (times 2.0 tapEncVia1))))
 (setq irTapXorigin (difference diffXorigin minDiffTapRingSpace extraLeftSpace tapWidthInIR))

 (if (greaterp innerRingMetalWidth 0.0) then
     (setq irViaOffset (times (fix (plus (quotient (difference (quotient innerRingMetalWidth 2.0) (quotient via1Width 2.0)) via1grid) 0.999)) via1grid))
     (setq irTapYorigin (difference via1Yorigin drnViaYspaceRingViaBot via1Width irViaOffset))
  else
     (setq irTapYorigin (difference via1Yorigin drnViaYspaceRingViaBot via1Width tapEncVia1))
 )

 (setq irTapL (difference (plus diffXend minDiffTapRingSpace extraRightSpace tapWidthInIR) irTapXorigin))

 (if (greaterp innerRingMetalWidth 0.0) then 
     (setq irTapW (difference (plus via1Yloop -via1Space drnViaYspaceRingViaTop via1Width irViaOffset) irTapYorigin))
  else
     (setq irTapW  (difference (plus via1Yloop -via1Space drnViaYspaceRingViaTop via1Width tapEncVia1) irTapYorigin))
 )

 ;; draw tap corners at 45 degrees if tapEdgesAt45 is set
 (if tapEdgesAt45 then
     (setq bevelLength (times 0.6 tapWidthInIR))
     ;; snap this to grid
     (setq bevelLength (times (round (plus (quotient bevelLength tapGrid) 0.001)) tapGrid))

     (setq lowerLeftBL  bevelLength)
     (setq upperLeftBL  bevelLength)
     (setq lowerRightBL bevelLength)
     (setq upperRightBL bevelLength)
  else
     (setq lowerLeftBL  0.0)
     (setq upperLeftBL  0.0)
     (setq lowerRightBL 0.0)
     (setq upperRightBL 0.0)
 )
     
 (setq dbid (dbCreateParamInst tcCellView ringId "itr" 0.0:0.0 "R0" 1
			       (list (list "w" "float" irTapW)
				     (list "l" "float" irTapL)
				     (list "xOffset" "float" irTapXorigin)
				     (list "yOffset" "float" irTapYorigin)
				     (list "ringLayer" "list" nil)
				     (list "ringWidth" "float" tapWidthInIR)
				     (list "additionalWidthInBevel" "float" 0.0)
				     (list "llBevelLength" "float" lowerLeftBL)
				     (list "ulBevelLength" "float" upperLeftBL)
				     (list "lrBevelLength" "float" lowerRightBL)
				     (list "urBevelLength" "float" upperRightBL)
				     (list "bevelTheOutside" "boolean" t)
				     (list "grid" "float" tapGrid)
				     (list "breakupPolygons" "boolean" "TRUE")
			       )))
 (setq theMaster dbid~>master)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints1))
 (dbAddFigToNet dbid irNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints2))
 (dbAddFigToNet dbid irNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints3))
 (dbAddFigToNet dbid irNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints4))
 (dbAddFigToNet dbid irNet)
 
 (when tapWellImplant
   (setq itriXorigin   (difference irTapXorigin tapWellImpEnc))
   (setq itriYorigin   (difference irTapYorigin tapWellImpEnc))
   (setq itriRingWidth (plus tapWidthInIR tapWellImpEnc tapWellImpEnc))
   (setq itriW         (plus irTapW tapWellImpEnc tapWellImpEnc))
   (setq itriL         (plus irTapL tapWellImpEnc tapWellImpEnc))
   (setq dbid (dbCreateParamInst tcCellView ringId "itri" 0.0:0.0 "R0" 1
				 (list (list "w" "float" itriW)
				       (list "l" "float" itriL)
				       (list "xOffset" "float" itriXorigin)
				       (list "yOffset" "float" itriYorigin)
				       (list "ringLayer" "list" tapWellImplant)
				       (list "ringWidth" "float" itriRingWidth)
				       (list "additionalWidthInBevel" "float" 0.0)
				       (list "llBevelLength" "float" 0.0)
				       (list "ulBevelLength" "float" 0.0)
				       (list "lrBevelLength" "float" 0.0)
				       (list "urBevelLength" "float" 0.0)
				       (list "bevelTheOutside" "boolean" nil)
				       (list "grid" "float" tapGrid)
				       (list "breakupPolygons" "boolean" "TRUE")
				       )))
 )

 ;; 2.  create the well enclosing the tap and transistor
 (setq wellXorigin (difference irTapXorigin wellEncTap))
 (setq wellYorigin (difference irTapYorigin wellEncTap))

 (dbCreateRect tcCellView wellLayer (list wellXorigin:wellYorigin
					  (plus wellXorigin irTapL (times 2.0 wellEncTap)):(plus wellYorigin irTapW (times 2.0 wellEncTap))))

 ;; 3.  create the inner riveted ring of via1's
 (if (greaterp innerRingMetalWidth 0.0) then
     (setq xCoord   (plus irTapXorigin (max irViaOffset tapEncVia1)))
     (setq yCoord   (plus irTapYorigin (max irViaOffset tapEncVia1)))
     (setq modW     (difference irTapW (times 2.0 (max irViaOffset tapEncVia1))))
     (setq modL     (difference irTapL (times 2.0 (max irViaOffset tapEncVia1))))
  else
     (setq xCoord   (plus irTapXorigin tapEncVia1))
     (setq yCoord   (plus irTapYorigin tapEncVia1))
     (setq modW     (difference irTapW (times 2.0 tapEncVia1)))
     (setq modL     (difference irTapL (times 2.0 tapEncVia1)))
 )
 (if layer2EdgesAt45 then
     (setq lowerLeftBL  (times 2.0 via1Space))
     (setq upperLeftBL  (times 2.0 via1Space))
     (setq lowerRightBL (times 2.0 via1Space))
     (setq upperRightBL (times 2.0 via1Space))
  else
     (setq lowerLeftBL  0.0)
     (setq upperLeftBL  0.0)
     (setq lowerRightBL 0.0)
     (setq upperRightBL 0.0)
 )     

 (when filledRings
   (setq via1Enc (max layer2EncVia1 tapEncVia1))
   (setq via1WidthInIR (difference tapWidthInIR (times 2.0 via1Enc)))
   (setq via1Xorigin (plus irTapXorigin via1Enc))
   (setq via1Yorigin (plus irTapYorigin via1Enc))
   )

 (dbCreateParamInst tcCellView rivetedRingId "iv1r" ,(if filledRings 0:0 xCoord:yCoord) "R0" 1
		    (list (list "w" "float" ,(if filledRings
						 (difference irTapW (times 2.0 via1Enc))
					       modW))
			  (list "l" "float" ,(if filledRings
						 (difference irTapL (times 2.0 via1Enc))
					       modL))
			  (list "xOffset" "float" ,(if filledRings via1Xorigin 0.0))
			  (list "yOffset" "float" ,(if filledRings via1Yorigin 0.0))
			  (list "rivetLayer" "list" via1Layer)
			  (list "ringWidth" "float" ,(if filledRings via1WidthInIR via1Width))
			  (list "rivetWidth" "float" via1Width)
			  (list "rivetSpace" "float" via1Space)
			  (list "llBevelLength" "float" lowerLeftBL)
			  (list "ulBevelLength" "float" upperLeftBL)
			  (list "lrBevelLength" "float" lowerRightBL)
			  (list "urBevelLength" "float" upperRightBL)
			  (list "autoIncreaseBevelWidth" "boolean" "FALSE")
			  (list "grid" "float" via1grid)))

 ;; 4.  create the inner ring of layer2
 ;; target variables set:
 ;;   irL2w = the total width of the inner layer2 guard ring
 ;;   irL2l = the total length of the inner layer2 guard ring
 ;;   irL2xDelta = the x offset of the inner guard ring's layer2 x origin
 ;;   irL2yDelta = the y offset of the inner guard ring's layer2 y origin
 ;;   irL2ringW = the width of the layer2 in the inner guard ring
 ;;

 (setq irL2w (plus irTapW (times -2.0 tapEncVia1) (times 2.0 layer2EncVia1)))
 (setq irL2l (plus irTapL (times -2.0 tapEncVia1) (times 2.0 layer2EncVia1)))
 (setq irL2xDelta (plus irTapXorigin tapEncVia1 -layer2EncVia1))
 (setq irL2yDelta (plus irTapYorigin tapEncVia1 -layer2EncVia1))

 (if (greaterp innerRingMetalWidth 0.0) then
     (setq irL2ringW (max (plus (times 2.0 layer2EncVia1) via1Width)
			  (plus (times 2.0 layer2EncVia2) via2Width)
			  innerRingMetalWidth))
     else
     (setq irL2ringW (max (plus (times 2.0 layer2EncVia1) via1Width)
			  (plus (times 2.0 layer2EncVia2) via2Width)))
 )     

 (if layer2EdgesAt45 then
     (setq lowerLeftBL  irL2ringW)
     (setq upperLeftBL  irL2ringW)
     (setq lowerRightBL irL2ringW)
     (setq upperRightBL irL2ringW)
  else
     (setq lowerLeftBL  0.0)
     (setq upperLeftBL  0.0)
     (setq lowerRightBL 0.0)
     (setq upperRightBL 0.0)
 )

 (setq dbid (dbCreateParamInst tcCellView ringId "il2r" 0.0:0.0 "R0" 1
			       (list (list "w" "float" ,(if filledRings irTapW irL2w))
				     (list "l" "float" ,(if filledRings irTapL irL2l))
				     (list "xOffset" "float" ,(if filledRings irTapXorigin irL2xDelta))
				     (list "yOffset" "float" ,(if filledRings irTapYorigin irL2yDelta))
				     (list "ringLayer" "list" nil)
				     (list "ringWidth" "float" ,(if filledRings tapWidthInIR irL2ringW))
				     (list "additionalWidthInBevel" "float" 0.0)
				     (list "llBevelLength" "float" lowerLeftBL)
				     (list "ulBevelLength" "float" upperLeftBL)
				     (list "lrBevelLength" "float" lowerRightBL)
				     (list "urBevelLength" "float" upperRightBL)
				     (list "bevelTheOutside" "boolean" t)
				     (list "grid" "float" layer2grid)
				     (list "breakupPolygons" "boolean" "TRUE")
			       )))
 
 (setq theMaster dbid~>master)
 (setq dbid1 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints1))
 (setq dbid2 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints2))
 (setq dbid3 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints3))
 (setq dbid4 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints4))
 (dbAddFigToNet dbid1 irNet)
 (dbAddFigToNet dbid2 irNet)
 (dbAddFigToNet dbid3 irNet)
 (dbAddFigToNet dbid4 irNet)

 (when (and layer3 fullyStrap (nequal fullyStrap "FALSE"))

     ;; if we must go to layer3, create the via2's and then create layer3

     ;;
     ;; 5.  create the inner riveted ring of via2's
     ;;
     ;; center the via2's in the middle of layer2
     (setq iv2rEnc (quotient (difference irL2ringW via2Width) 2.0))
     ;; snap iv2rEnc to grid
     (setq tempSize (quotient iv2rEnc via2grid))
     (setq iv2rEnc (times (fix (plus tempSize 0.999)) via2grid))

     (if layer3EdgesAt45 then
	 (setq lowerLeftBL   (times 2.0 via2Space))
	 (setq upperLeftBL   (times 2.0 via2Space))
	 (setq lowerRightBL  (times 2.0 via2Space))
	 (setq upperRightBL  (times 2.0 via2Space))
      else
	 (setq lowerLeftBL  0.0)
	 (setq upperLeftBL  0.0)
	 (setq lowerRightBL 0.0)
	 (setq upperRightBL 0.0)
     )    

     (unless filledRings
     (dbCreateParamInst tcCellView rivetedRingId "iv2r" (plus irL2xDelta iv2rEnc):(plus irL2yDelta iv2rEnc) "R0" 1
			(list (list "w" "float" (difference irL2w (times 2.0 iv2rEnc)))
			      (list "l" "float" (difference irL2l (times 2.0 iv2rEnc)))
			      (list "xOffset" "float" 0.0)
			      (list "yOffset" "float" 0.0)
			      (list "rivetLayer" "list" via2Layer)
			      (list "ringWidth" "float" via2Width)
			      (list "rivetWidth" "float" via2Width)
			      (list "rivetSpace" "float" via2Space)
			      (list "llBevelLength" "float" lowerLeftBL)
			      (list "ulBevelLength" "float" upperLeftBL)
			      (list "lrBevelLength" "float" lowerRightBL)
			      (list "urBevelLength" "float" upperRightBL)
			      (list "autoIncreaseBevelWidth" "boolean" "FALSE")
			      (list "grid" "float" via2grid)))
     )
     (when filledRings
     (setq via2Enc (max layer2EncVia2 layer3EncVia2))
     (setq via2WidthInIR (difference tapWidthInIR (times 2.0 via2Enc)))
     (setq via2Xorigin (plus irTapXorigin via2Enc))
     (setq via2Yorigin (plus irTapYorigin via2Enc))
     (setq via2Bevel (plus via2WidthInIR (times 2.0 via2Enc)))
     (dbCreateParamInst tcCellView rivetedRingId "iv2r" 0:0 "R0" 1
			(list (list "w" "float" (difference irTapW (times 2.0 via2Enc)))
			      (list "l" "float" (difference irTapL (times 2.0 via2Enc)))
			      (list "xOffset" "float" via2Xorigin)
			      (list "yOffset" "float" via2Yorigin)
			      (list "rivetLayer" "list" via2Layer)
			      (list "ringWidth" "float" via2WidthInIR)
			      (list "rivetWidth" "float" via2Width)
			      (list "rivetSpace" "float" via2Space)
			      (list "llBevelLength" "float" via2Bevel)
			      (list "ulBevelLength" "float" via2Bevel)
			      (list "lrBevelLength" "float" via2Bevel)
			      (list "urBevelLength" "float" via2Bevel)
			      (list "autoIncreaseBevelWidth" "boolean" "FALSE")
			      (list "grid" "float" via2grid)))
     )
     
     ;; 6.  create the inner ring of layer3
     ;; target variables set:
     ;;   irL3w = the total width of the inner guard ring of layer3
     ;;   irL3l = the total length of the inner guard ring of layer3
     ;;   irL3xDelta = the x offset of the inner guard ring's layer3 x origin
     ;;   irL3yDelta = the y offset of the inner guard ring's layer3 y origin
     ;;

     (if (greaterp innerRingMetalWidth 0.0) then
	 (setq irL3w irL2w)
	 (setq irL3l irL2l)
	 (setq irL3xDelta irL2xDelta)
	 (setq irL3yDelta irL2yDelta)
	 (setq irL3ringW (max (plus (times 2.0 irLayer3EncVia2) via2Width)
			      innerRingMetalWidth))
      else
	 (setq irL3w (plus irL2w (times -2.0 iv2rEnc) (times 2.0 irLayer3EncVia2)))
	 (setq irL3l (plus irL2l (times -2.0 iv2rEnc) (times 2.0 irLayer3EncVia2)))
	 (setq irL3xDelta (plus irL2xDelta iv2rEnc -irLayer3EncVia2))
	 (setq irL3yDelta (plus irL2yDelta iv2rEnc -irLayer3EncVia2))
	 (setq irL3ringW (plus (times 2.0 irLayer3EncVia2) via2Width))
     )

     (setq topLayer layer3)
     (if layer3EdgesAt45 then
	 (setq lowerLeftBL  irL3ringW)
	 (setq upperLeftBL  irL3ringW)
	 (setq lowerRightBL irL3ringW)
	 (setq upperRightBL irL3ringW)
      else
	 (setq lowerLeftBL  0.0)
	 (setq upperLeftBL  0.0)
	 (setq lowerRightBL 0.0)
	 (setq upperRightBL 0.0)
     )

     (setq dbid (dbCreateParamInst tcCellView ringId "il3r" 0.0:0.0 "R0" 1
				   (list (list "w" "float" ,(if filledRings irTapW irL3w))
					 (list "l" "float" ,(if filledRings irTapL irL3l))
					 (list "xOffset" "float" ,(if filledRings irTapXorigin irL3xDelta))
					 (list "yOffset" "float" ,(if filledRings irTapYorigin irL3yDelta))
					 (list "ringLayer" "list" nil)
					 (list "ringWidth" "float" ,(if filledRings tapWidthInIR irL3ringW))
					 (list "additionalWidthInBevel" "float" 0.0)
					 (list "llBevelLength" "float" ,(if filledRings tapWidthInIR lowerLeftBL))
					 (list "ulBevelLength" "float" ,(if filledRings tapWidthInIR upperLeftBL))
					 (list "lrBevelLength" "float" ,(if filledRings tapWidthInIR lowerRightBL))
					 (list "urBevelLength" "float" ,(if filledRings tapWidthInIR upperRightBL))
					 (list "bevelTheOutside" "boolean" t)
					 (list "grid" "float" layer3grid)
					 (list "breakupPolygons" "boolean" t)
				   )))
     (setq theMaster dbid~>master)
     (setq dbid1 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints1))
     (setq dbid2 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints2))
     (setq dbid3 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints3))
     (setq dbid4 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints4))
     (dbAddFigToNet dbid1 irNet)
     (dbAddFigToNet dbid2 irNet)
     (dbAddFigToNet dbid3 irNet)
     (dbAddFigToNet dbid4 irNet)
 )

 ;; 7.  create a terminal out of the topmost layer
 (setq pinid (dbCreatePin irNet dbid1))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pinid (dbCreatePin irNet dbid2))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pinid (dbCreatePin irNet dbid3))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pinid (dbCreatePin irNet dbid4))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))

 ;;
 ;; create the outer guard ring in 7 steps:
 ;; 1.  create the outer ring of tap
 ;; 2.  create the outer riveted ring of via1's
 ;; 3.  create the outer ring of layer2
 ;; *4.  create the outer riveted ring of via2's
 ;; *5.  create the outer ring of layer3
 ;; 6.  create a terminal out of the topmost layer
 ;; (* = if necessary)
 ;;
 ;; All of the variables that start with "or" deal with the outer guard ring

 ;; set up the tap variables in the outer guard ring:
 ;;  tapWidthInOR = the width of the tap in the outer guard ring
 ;;  outerTapDelta = the offset between the inner and outer tap guard rings
 ;;  orTapXorigin = the x origin for the outer tap guard ring
 ;;  orTapYorigin = the y origin for the outer tap guard ring
 ;;  orTapW = the total width for the outer tap guard ring
 ;;  orTapL = the total length for the outer tap guard ring
 (setq tapWidthInOR (max outerRingTapWidth (plus (times 2.0 tapEncVia1) via1Width)))
 (setq outerTapDelta (plus wellTapSpace tapWidthInOR))
 (setq orTapXorigin (difference wellXorigin outerTapDelta))
 (setq orTapYorigin (difference wellYorigin outerTapDelta))
 (setq orTapW (plus irTapW (times 2.0 (plus outerTapDelta wellEncTap))))
 (setq orTapL (plus irTapL (times 2.0 (plus outerTapDelta wellEncTap))))

 ;;
 ;; first, make sure that we will not create a spacing error for layer3
 ;;
 (when (and layer3 fullyStrap (nequal fullyStrap "FALSE")) 
     ;; this just satisfies the min spacing of layer3 from inner ring to outer
     (setq orLayer3XoriginA (difference irL3xDelta orirLayer3Space orLayer3Width))

     ;; this will be where layer3 has its origin when it just satisfies the
     ;; spacing of tap in the inner ring to the well in the outer ring
     (setq orLayer3XoriginB (plus orTapXorigin (quotient tapWidthInOR 2.0) (quotient orLayer3Width -2.0)))

     ;; when the layer3 spacing is not going to be satisfied when the at the
     ;; specified spacing of tap in the inner ring to well in outer ring,
     ;; we need to push out the outer guard ring
     (when (lessp orLayer3XoriginA orLayer3XoriginB)
	 (setq extraSpace (difference orLayer3XoriginB orLayer3XoriginA))
	 (setq tempSize (quotient extraSpace tapGrid))
	 (setq extraSpace (times (fix (plus tempSize 0.999)) tapGrid))

	 (setq orTapXorigin (difference orTapXorigin extraSpace))
	 (setq orTapYorigin (difference orTapYorigin extraSpace))
	 (setq orTapW (plus orTapW (times 2.0 extraSpace)))
	 (setq orTapL (plus orTapL (times 2.0 extraSpace)))
     )
 )

 ;; 1.  create the outer ring of tap

 ;; draw tap corners at 45 degrees if tapEdgesAt45 is set
 (if tapEdgesAt45 then
     (setq bevelLength (times 0.6 tapWidthInOR))
     ;; snap this to grid
     (setq bevelLength (times (round (plus (quotient bevelLength tapGrid) 0.001)) tapGrid))
     
     (setq lowerLeftBL  bevelLength)
     (setq upperLeftBL  bevelLength)
     (setq lowerRightBL bevelLength)
     (setq upperRightBL bevelLength)
  else
     (setq lowerLeftBL  0.0)
     (setq upperLeftBL  0.0)
     (setq lowerRightBL 0.0)
     (setq upperRightBL 0.0)
 )  

 (setq dbid (dbCreateParamInst tcCellView ringId "otr" 0.0:0.0 "R0" 1
			       (list (list "w" "float" orTapW)
				     (list "l" "float" orTapL)
				     (list "xOffset" "float" orTapXorigin)
				     (list "yOffset" "float" orTapYorigin)
				     (list "ringLayer" "list" nil)
				     (list "ringWidth" "float" tapWidthInOR)
				     (list "additionalWidthInBevel" "float" 0.0)
				     (list "llBevelLength" "float" lowerLeftBL)
				     (list "ulBevelLength" "float" upperLeftBL)
				     (list "lrBevelLength" "float" lowerRightBL)
				     (list "urBevelLength" "float" upperRightBL)
				     (list "bevelTheOutside" "boolean" t)
				     (list "grid" "float" tapGrid)
				     (list "breakupPolygons" "boolean" "TRUE")
			       )))
 (setq theMaster dbid~>master)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints1))
 (dbAddFigToNet dbid orNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints2))
 (dbAddFigToNet dbid orNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints3))
 (dbAddFigToNet dbid orNet)
 (setq dbid (dbCreatePolygon tcCellView tapLayer theMaster~>ringPoints4))
 (dbAddFigToNet dbid orNet)
 (when tapSubImplant
   (setq otriXorigin   (difference orTapXorigin tapSubImpEnc))
   (setq otriYorigin   (difference orTapYorigin tapSubImpEnc))
   (setq otriRingWidth (plus tapWidthInOR tapSubImpEnc tapSubImpEnc))
   (setq otriW         (plus orTapW tapSubImpEnc tapSubImpEnc))
   (setq otriL         (plus orTapL tapSubImpEnc tapSubImpEnc))
   (setq dbid (dbCreateParamInst tcCellView ringId "otri" 0.0:0.0 "R0" 1
				 (list (list "w" "float" otriW)
				       (list "l" "float" otriL)
				       (list "xOffset" "float" otriXorigin)
				       (list "yOffset" "float" otriYorigin)
				       (list "ringLayer" "list" tapSubImplant)
				       (list "ringWidth" "float" otriRingWidth)
				       (list "additionalWidthInBevel" "float" 0.0)
				       (list "llBevelLength" "float" 0.0)
				       (list "ulBevelLength" "float" 0.0)
				       (list "lrBevelLength" "float" 0.0)
				       (list "urBevelLength" "float" 0.0)
				       (list "bevelTheOutside" "boolean" nil)
				       (list "grid" "float" tapGrid)
				       (list "breakupPolygons" "boolean" "TRUE")
				       )))
 )
 ;; 2.  create the outer riveted ring of via1's
 (setq orViaOffset (times (fix (plus (quotient (difference (quotient tapWidthInOR 2.0) (quotient via1Width 2.0)) via1grid) 0.999)) via1grid))
 (setq xCoord   (plus orTapXorigin (max orViaOffset tapEncVia1)))
 (setq yCoord   (plus orTapYorigin (max orViaOffset tapEncVia1)))

 (setq lowerLeftBL  (times 3.0 via1Space))
 (setq upperLeftBL  (times 3.0 via1Space))
 (setq lowerRightBL (times 3.0 via1Space))
 (setq upperRightBL (times 3.0 via1Space))

 (when filledRings
    (setq orTapEncVia1 (difference tapWidthInOR orLayer3Width))
    (setq via1WidthInOR (difference orLayer3Width (times 2.0 via1Enc)))
    )
 (dbCreateParamInst tcCellView rivetedRingId "ov1r" ,(if filledRings orTapXorigin:orTapYorigin xCoord:yCoord) "R0" 1
		    (list (list "w" "float" ,(if filledRings
						 (difference orTapW (times 2.0 (plus orTapEncVia1 via1Enc)))
					       (difference orTapW (times 2.0 (max orViaOffset tapEncVia1)))))
			  (list "l" "float" ,(if filledRings
						 (difference orTapL (times 2.0 (plus orTapEncVia1 via1Enc)))
					       (difference orTapL (times 2.0 (max orViaOffset tapEncVia1)))))
			  (list "xOffset" "float" ,(if filledRings (plus orTapEncVia1 via1Enc) 0.0))
			  (list "yOffset" "float" ,(if filledRings (plus orTapEncVia1 via1Enc) 0.0))
			  (list "rivetLayer" "list" via1Layer)
			  (list "ringWidth" "float" ,(if filledRings via1WidthInOR via1Width))
			  (list "rivetWidth" "float" via1Width)
			  (list "rivetSpace" "float" via1Space)
			  (list "llBevelLength" "float" ,(if filledRings 0.0 lowerLeftBL))
			  (list "ulBevelLength" "float" ,(if filledRings 0.0 upperLeftBL))
			  (list "lrBevelLength" "float" ,(if filledRings 0.0 lowerRightBL))
			  (list "urBevelLength" "float" ,(if filledRings 0.0 upperRightBL))
			  (list "autoIncreaseBevelWidth" "boolean" "FALSE")
			  (list "grid" "float" via1grid)))

 (unless (or filledRings layer2EdgesAt45 tapEdgesAt45)
   ;; draw an extra via1 in each corner
   (setq extraVia1RightOrigin (plus xCoord
				    (difference orTapL (times 2.0 (max orViaOffset tapEncVia1)))
				    (minus via1Width)))
   (setq extraVia1TopOrigin   (plus yCoord
				    (difference orTapW (times 2.0 (max orViaOffset tapEncVia1)))
				    (minus via1Width)))
   
   (dbCreateRect tcCellView via1Layer
		 (list (list xCoord yCoord )
		       (list (plus  xCoord via1Width)
			     (plus  yCoord via1Width)
			     )))
   (dbCreateRect tcCellView via1Layer
		 (list (list extraVia1RightOrigin yCoord )
		       (list (plus  extraVia1RightOrigin via1Width )
			     (plus  yCoord via1Width)
			     )))
   (dbCreateRect tcCellView via1Layer
		 (list (list xCoord extraVia1TopOrigin)
		       (list (plus xCoord via1Width)
			     (plus extraVia1TopOrigin via1Width)
			     )))
   (dbCreateRect tcCellView via1Layer
		 (list (list extraVia1RightOrigin extraVia1TopOrigin)
		       (list (plus extraVia1RightOrigin via1Width)
			     (plus extraVia1TopOrigin via1Width)
			     )))
   )

 ;; 3.  create the outer ring of layer2.  target variables set:
 ;;   orL2w = the total width of the outer layer2 guard ring
 ;;   orL2l = the total length of the outer layer2 guard ring
 ;;   orL2xDelta = the x origin of the outer layer2 guard ring
 ;;   orL2yDelta = the y origin of the outer layer2 guard ring
 ;;   orL2ringW = the ring width of layer2 in the outer guard ring
 ;;
 (if layer3 then
   ;; draw layer2 with the same width as of layer3
   (setq orLayer3EncVia2 (quotient (difference orLayer3Width via2Width) 2.0))
   ;; snap orLayer3EncVia2 to grid
   (setq tempSize (quotient orLayer3EncVia2 layer3grid))
   (setq orLayer3EncVia2 (times (fix (plus tempSize 0.999)) layer3grid))
   (setq outerRingMetalWidth (plus (times 2.0 orLayer3EncVia2) via2Width))
   
   (setq orL2w (plus orTapW -tapWidthInOR outerRingMetalWidth))
   (setq orL2l (plus orTapL -tapWidthInOR outerRingMetalWidth))
   (setq orL2xDelta (plus orTapXorigin (quotient (plus tapWidthInOR -outerRingMetalWidth) 2.0)))
   ;; snap orL2xDelta to grid
   (setq orL2xDelta (times (fix (plus (quotient orL2xDelta layer2grid) 0.999)) layer2grid))
   (setq orL2yDelta (plus orTapYorigin (quotient (plus tapWidthInOR -outerRingMetalWidth) 2.0)))
   ;; snap orL2yDelta to grid
   (setq orL2yDelta (times (fix (plus (quotient orL2yDelta layer2grid) 0.999)) layer2grid))
   (setq orL2ringW (max (plus (times 2.0 layer2EncVia1) via1Width)
			(plus (times 2.0 layer2EncVia2) via2Width)
			outerRingMetalWidth))
  else
   (setq orL2w (plus orTapW (times -2.0 (max orViaOffset tapEncVia1)) (times 2.0 layer2EncVia1)))
   (setq orL2l (plus orTapL (times -2.0 (max orViaOffset tapEncVia1)) (times 2.0 layer2EncVia1)))
   (setq orL2xDelta (plus xCoord -layer2EncVia1))
   (setq orL2yDelta (plus yCoord -layer2EncVia1))
   (setq orL2ringW (max (plus (times 2.0 layer2EncVia1) via1Width)
			(plus (times 2.0 layer2EncVia2) via2Width)))
 )

 (if layer2EdgesAt45 then
   (setq lowerLeftBL  orL2ringW)
   (setq upperLeftBL  orL2ringW)
   (setq lowerRightBL orL2ringW)
   (setq upperRightBL orL2ringW)
  else
   (setq lowerLeftBL  0.0)
   (setq upperLeftBL  0.0)
   (setq lowerRightBL 0.0)
   (setq upperRightBL 0.0)
 )     

 (setq dbid (dbCreateParamInst tcCellView ringId "ol2r" 0.0:0.0 "R0" 1
			       (list (list "w" "float" ,(if filledRings
							    (difference orTapW (times 2.0 orTapEncVia1))
							  orL2w))
				     (list "l" "float" ,(if filledRings
							    (difference orTapL (times 2.0 orTapEncVia1))
							  orL2l))
				     (list "xOffset" "float" ,(if filledRings (plus orTapXorigin orTapEncVia1) orL2xDelta))
				     (list "yOffset" "float" ,(if filledRings (plus orTapYorigin orTapEncVia1) orL2yDelta))
				     (list "ringLayer" "list" nil)
				     (list "ringWidth" "float" ,(if filledRings orLayer3Width orL2ringW))
				     (list "additionalWidthInBevel" "float" 0.0)
				     (list "llBevelLength" "float" ,(if filledRings 0.0 lowerLeftBL))
				     (list "ulBevelLength" "float" ,(if filledRings 0.0 upperLeftBL))
				     (list "lrBevelLength" "float" ,(if filledRings 0.0 lowerRightBL))
				     (list "urBevelLength" "float" ,(if filledRings 0.0 upperRightBL))
				     (list "bevelTheOutside" "boolean" t)
				     (list "grid" "float" layer2grid)
				     (list "breakupPolygons" "boolean" "TRUE")
			       )))

 (setq theMaster dbid~>master)
 (setq dbid1 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints1))
 (setq dbid2 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints2))
 (setq dbid3 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints3))
 (setq dbid4 (dbCreatePolygon tcCellView layer2 theMaster~>ringPoints4))
 (dbAddFigToNet dbid1 orNet)
 (dbAddFigToNet dbid2 orNet)
 (dbAddFigToNet dbid3 orNet)
 (dbAddFigToNet dbid4 orNet)

 (when (and layer3 fullyStrap (nequal fullyStrap "FALSE"))

     ;;
     ;; 4.  if we must go to layer3, create the via2's and then create layer3
     ;;
     ;; center the via2's in the middle of layer2
     (setq ov2rEnc (quotient (difference orL2ringW via2Width) 2.0))
     ;; snap ov2rEnc to grid
     (setq tempSize (quotient ov2rEnc via2grid))
     (setq ov2rEnc (times (fix (plus tempSize 0.999)) via2grid))

     (if layer3EdgesAt45 then
	 (setq lowerLeftBL   (times 2.0 via2Space))
	 (setq upperLeftBL   (times 2.0 via2Space))
	 (setq lowerRightBL  (times 2.0 via2Space))
	 (setq upperRightBL  (times 2.0 via2Space))
      else
	 (setq lowerLeftBL   via2Space)
	 (setq upperLeftBL   via2Space)
	 (setq lowerRightBL  via2Space)
	 (setq upperRightBL  via2Space)
     )

     (when filledRings
       (setq via2WidthInOR (difference orLayer3Width (times 2.0 via2Enc)))
       )
     (when filledRings
     (dbCreateParamInst tcCellView rivetedRingId "ov2r" orTapXorigin:orTapYorigin "R0" 1
			(list (list "w" "float" (difference orTapW (times 2.0 (plus via2Enc orTapEncVia1))))
			      (list "l" "float" (difference orTapL (times 2.0 (plus via2Enc orTapEncVia1))))
			      (list "xOffset" "float" (plus orTapEncVia1 via2Enc))
			      (list "yOffset" "float" (plus orTapEncVia1 via2Enc))
			      (list "rivetLayer" "list" via2Layer)
			      (list "ringWidth" "float" via2WidthInOR)
			      (list "rivetWidth" "float" via2Width)
			      (list "rivetSpace" "float" via2Space)
			      (list "llBevelLength" "float" (plus via2Enc (plus -0.50 orLayer3Width)))
			      (list "ulBevelLength" "float" (plus via2Enc (plus -0.50 orLayer3Width)))
			      (list "lrBevelLength" "float" (plus via2Enc (plus -0.50 orLayer3Width)))
			      (list "urBevelLength" "float" (plus via2Enc (plus -0.50 orLayer3Width)))
			      (list "autoIncreaseBevelWidth" "boolean" "FALSE")
			      (list "grid" "float" via2grid)))
     )
     (unless filledRings
     (dbCreateParamInst tcCellView rivetedRingId "ov2r" (plus orL2xDelta ov2rEnc):(plus orL2yDelta ov2rEnc) "R0" 1
			(list (list "w" "float" (difference orL2w (times 2.0 ov2rEnc)))
			      (list "l" "float" (difference orL2l (times 2.0 ov2rEnc)))
			      (list "xOffset" "float" 0.0)
			      (list "yOffset" "float" 0.0)
			      (list "rivetLayer" "list" via2Layer)
			      (list "ringWidth" "float" via2Width)
			      (list "rivetWidth" "float" via2Width)
			      (list "rivetSpace" "float" via2Space)
			      (list "llBevelLength" "float" lowerLeftBL)
			      (list "ulBevelLength" "float" upperLeftBL)
			      (list "lrBevelLength" "float" lowerRightBL)
			      (list "urBevelLength" "float" upperRightBL)
			      (list "autoIncreaseBevelWidth" "boolean" "FALSE")
			      (list "grid" "float" via2grid)))
     )

     ;; 5.  create the outer ring of layer3.  target variables set:
     ;;   orL3w = the total width of the outer layer3 guard ring
     ;;   orL3l = the total length of the outer layer3 guard ring
     ;;   orL3xDelta = the x origin of the outer layer3 guard ring
     ;;   orL3yDelta = the y origin of the outer layer3 guard ring
     ;;

     (setq orL3w (plus orL2w (times -2.0 ov2rEnc) (times 2.0 orLayer3EncVia2)))
     (setq orL3l (plus orL2l (times -2.0 ov2rEnc) (times 2.0 orLayer3EncVia2)))
     (setq orL3xDelta (plus orL2xDelta ov2rEnc -orLayer3EncVia2))
     (setq orL3yDelta (plus orL2yDelta ov2rEnc -orLayer3EncVia2))

     (if layer3EdgesAt45 then
	 (setq lowerLeftBL  (plus (times 2.0 orLayer3EncVia2) via2Width))
	 (setq upperLeftBL  (plus (times 2.0 orLayer3EncVia2) via2Width))
	 (setq lowerRightBL (plus (times 2.0 orLayer3EncVia2) via2Width))
	 (setq upperRightBL (plus (times 2.0 orLayer3EncVia2) via2Width))
      else
	 (setq lowerLeftBL  0.0)
	 (setq upperLeftBL  0.0)
	 (setq lowerRightBL 0.0)
	 (setq upperRightBL 0.0)
     )

     (setq dbid (dbCreateParamInst tcCellView ringId "ol3r" 0.0:0.0 "R0" 1
				   (list (list "w" "float" ,(if filledRings
								(difference orTapW (times 2.0 orTapEncVia1))
							      orL3w))
					 (list "l" "float" ,(if filledRings
								(difference orTapL (times 2.0 orTapEncVia1))
							      orL3l))
					 (list "xOffset" "float" ,(if filledRings (plus orTapXorigin orTapEncVia1) orL3xDelta))
					 (list "yOffset" "float" ,(if filledRings (plus orTapYorigin orTapEncVia1) orL3yDelta))
					 (list "ringLayer" "list" nil)
					 (list "ringWidth" "float" ,(if filledRings
									orLayer3Width
								      (plus (times 2.0 orLayer3EncVia2) via2Width)))
					 (list "additionalWidthInBevel" "float" 0.0)
					 (list "llBevelLength" "float" ,(if filledRings (plus -0.50 orLayer3Width) lowerLeftBL))
					 (list "ulBevelLength" "float" ,(if filledRings (plus -0.50 orLayer3Width) upperLeftBL))
					 (list "lrBevelLength" "float" ,(if filledRings (plus -0.50 orLayer3Width) lowerRightBL))
					 (list "urBevelLength" "float" ,(if filledRings (plus -0.50 orLayer3Width) upperRightBL))
					 (list "bevelTheOutside" "boolean" t)
					 (list "grid" "float" layer3grid)
					 (list "breakupPolygons" "boolean" t)
				   )))
	 
     (setq theMaster dbid~>master)
     (setq dbid1 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints1))
     (setq dbid2 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints2))
     (setq dbid3 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints3))
     (setq dbid4 (dbCreatePolygon tcCellView layer3 theMaster~>ringPoints4))
     (dbAddFigToNet dbid1 orNet)
     (dbAddFigToNet dbid2 orNet)
     (dbAddFigToNet dbid3 orNet)
     (dbAddFigToNet dbid4 orNet)
 )

 ;; 6.  create a terminal out of the topmost layer
 (setq pin (dbCreatePin orNet dbid1))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pin (dbCreatePin orNet dbid2))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pin (dbCreatePin orNet dbid3))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))
 (setq pin (dbCreatePin orNet dbid4))
 (pinid~>accessDir = (list "top" "bottom" "left" "right"))

)
;;; 
;;; $Id: wlResImpClass.il,v 1.5 2003/06/05 11:18:43 lpn Exp $ %T%
;;; 
;;; wlResImpClass.il
;;; 
;;; Copyright (c) 1996 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Oct 29, 1996
;;; Author: Sanjay Rekhi/Senior CAD (syr) @ CSDC
;;; 
;;; Description:
;;;  Geometry parameters based resistor device class.
;;;  This device class will be used to declare poly resistors
;;;  (silicided, and unsilicided), diffusion, and well resistors.
;;;  The devices operate the same way as the current subres resistor.
;;;  This class allows implants to be toggled.
;;;
;;; Note:
;;;  The support for contacts is hierarchical, the contactPitch, 
;;;  contactSpace and enclosure of contact by bottom layer are
;;;  used to calculate the how many contacts can be fitted in the
;;;  user specified rw parameter.
;;;
;;; Revision History:
;;;   syr 11/21/96  Added a class parameter to offset the implant
;;;                 layer when rw is less than width of the botLayer in contact
;;;   syr 12/05/96  Edited to change printf to error, the grid parameter,
;;;                 edited the description, and added a note.
;;;   syr 02/28/97  Edited floating point number comparison.
;;;   gtc 04/02/97  Removing "contactPitch" as a parameter getting the info
;;;                 from the contact pcell.
;;;   jim 09/11/98  Updated to use new rcInterConClass parameters
;;;   xgs 11/06/00  Added isEsdRes to formal params
;;;   cry 08/20/01  copied from wlResClass to allow toggled implants
;;;                 removed isEsdRes since already existing parameters
;;;                 can do this, and toggling is unnecessary.
;;;   dxj 05/24/02  Add class parameter for maximising the no of contacts
;;;                 copying the code from wlBentResClass
;;;   kmi 04/08/03  Updating the class to support rc3InterConImpClass and
;;;                 rc3InterConImpEnhClass (SPR 15627)
;;;   lpn 06/05/03   Added areaIdLayer areaIdEncRes rpoMaxLength rpoMinLength numCols class parameters 
;;;

 (putpropqq wlResImpClass "$Id: wlResImpClass.il,v 1.5 2003/06/05 11:18:43 lpn Exp $ %T%" SCCS)
 
 (tcCreateDeviceClass
  "symbolic" "wlResImpClass"
 ;;; Class parameters
  (
   (resistorLayer "tap")                ;;; layer which forms the resistor body.
   (resIdLayer  (list "res" "drawing")) ;;; layer to identify resistor
   (resCutLayer (list "res" "cut"))     ;;; layer to cut resisor into halves
   (resCutWidth           0.0) ;;; Width of the resCut layer (should be very small)
   (areaIdLayer           nil) 
   (fullImplantLayer      nil) ;;; layer to implant into entire resistorLayer
   (fullImpEnc            0.0) ;;; enclosure of resistorLayer by fullImplantLayer
   (wellLayer             nil) ;;; well layer which may need to be drawn 
   (wellEnc               0.0) ;;; enclosure of resistor layer by well.
   (wellWidth             0.0) ;;; minimum width of the well layer
   (implantLayer          nil) ;;; any implant layer for resistor (e.g., silblk)
                              ;;; drawn only on resistor area (not contact)
   (impEnc                0.0) ;;; enclosure of resistor layer by implant layer.
   (impWidth              0.0) ;;; minimum width of the implant layer
   (impSpaceContact       0.0) ;;; minimum spacing of implant layer to contact to resistorLayer
   (impSpaceResistorLayer 0.0) ;;; minimum spacing of implant layer to resistor layer
           ;;; This spacing should be preserved if the width of the resistor is less
           ;;; than the width of the botLayer in the contact
   
  ;;; The following parameter provides the grid of the drawn layer.
  ;;; This will be used to draw the pins if contact is not specified, and will also
  ;;; be used to offset the last contact based on perCentVariability and deltaLength
  (resistorLayerGrid 0.0) 
  (maximiseContacts "FALSE")  ;;; Draws the maximum no of contacts
  (numCols                1) ;; Setting default to 1 column of contacts
  (areaIdEncRes         0.0)
  (rpoMaxLength         0.0) 
  (rpoMinLength         0.0)
  ) 
  
 ;;; Formal parameters
  (
   (rw 0.0)                 ;;; Width of the resistor layer
   (rl 0.0)                 ;;; length of the resistor layer
   (percentVariability 0)   ;;; how much should the length extend beyond contact
   (deltaLength 0.0)        ;;; how much should the contact be offset to
   (contactName "")         ;;; name of the contact that should be used
   (implant  t)             ;;; controls whether fullImplantLayer is drawn or not
  )
  ;; convert all boolean parameters to either t or nil
  ;; this way we can use the simple (when parameter) syntax
  ;; and speed up pcell evaluation and make code simpler
  (if (or (equal implant t) (equal implant "TRUE")) then
   (setq implant t)
   else
   (setq implant nil)
   )

 (if (or (equal maximiseContacts t) (equal maximiseContacts "TRUE")) then
   (setq maximiseContacts t)
   else
   (setq maximiseContacts nil)
   )

 ;;; Make the nets and the corresponding terminals.
 (setq fNet (dbCreateNet tcCellView "r0"))
 (dbCreateTerm fNet "r0" "inputOutput")
 (setq lNet (dbCreateNet tcCellView "r1"))
 (dbCreateTerm lNet "r1" "inputOutput")

 ;;; Initialize the x1Coord, where things will start getting placed
 (setq x1Coord 0.0)   ;;; The initial X coordinate
 (setq xOffset 0.0)   ;;; The amount resistorLayer may have to be offset.
 (setq x1Coord2 0.0)  ;;; The initial x coordinate if resistorLayer has to be offset
 (setq y1Coord 0.0)   ;;; The initial y coordinate

 (when rpoMaxLength > 0.0 && rpoMinLength > 0.0	
     (when rl > rpoMaxLength ||  rl < rpoMinLength
	 (error (sprintf nil "Min rpo Length = %f and Max rpo Length = %f \n"  rpoMinLength rpoMaxLength ))
     )
 )
 ;;; Find and place the contact for the first terminal "r0"
 (when (nequal contactName "")
     (setq contactId (dbOpenCellView tcCellView~>lib contactName "symbolic" nil "rn"))
     (unless contactId
	 (error (sprintf nil "Cannot find/open `%s'\n" contactName))
     )
     (unless contactId~>isParamCell
	 (error (sprintf nil "`%s' is not a pcell\n" contactName))
     )

     (setq params contactId~>parameters)
     (if params~>yPitch then
         (setq contactPitch params~>yPitch)
      else
         (setq contactPitch (plus contactId~>contactWidth contactId~>contactSpace))
     )
     (if params~>l then
         (setq contactSpace (difference contactPitch params~>l))
      else
         (setq contactSpace contactId~>contactSpace)
     )
     
     (when  maximiseContacts
	 (setq viaBbox contactId~>contactLayerBbox)
	 (setq effectiveRw (plus rw (times -2.0 (cadar viaBbox)) contactSpace))
	 (setq numRowsContacts (max 1 (fix (plus 1e-6 (quotient effectiveRw contactPitch)))))
	 (setq instParams (list (list "row" "int" numRowsContacts)))
     )

     (unless maximiseContacts
	 (setq numRows (max (fix (plus (quotient rw contactPitch) 1e-6)) 1))
	 (setq instParams (list (list "row" "int" numRows)))
     )
     
     (setq instParams (xcons instParams (list "column" "int" numCols)))

     
     (when params~>implant
       (if implant then
	 (setq instParams (xcons instParams
				 (list "implant" "boolean" t)
				 ))
	 else
	 (setq instParams (xcons instParams
				 (list "implant" "boolean" "FALSE")
				 ))
	 )
       )
     
     (when params~>inWell
       (if wellLayer then
	 (setq instParams (xcons instParams
				 (list "inWell" "boolean" t)
				 ))
	 else
	 (setq instParams (xcons instParams
				 (list "inWell" "boolean" "FALSE")
				 ))
	 )
       )
     
     (setq inst (dbCreateParamInst tcCellView contactId "c0"
				   x1Coord:y1Coord "MY" 1
				   instParams
				   )
     )

     (unless inst
	 (error (sprintf nil "Failed to create an instance of `%s'\n" contactName))
     )

     ;;; Create a rectangle from the topLayer of the specified contact

     (setq master inst~>master)
     ;;; make sure the contact pcell has the neccessary properties.
     ;;; first the botLayerBbox
     (unless master~>botLayerBbox
	 (error (sprintf nil "Cannot find botLayerBbox property for `%s'\n" contactName))
     )
     ;;; then check for the contactLayerBbox
     (unless master~>contactLayerBbox
	 (error (sprintf nil "Cannot find contactLayerBbox property for `%s'\n" contactName))
     )
     ;;; then for the topLayerBbox
     (unless (and master~>topLayer master~>topLayerPinBbox)
	 (error (sprintf nil "Missing topLayer and/or topLayerPinBbox in `%s'\n" contactName))
     )

     ;;; To enable correct extraction of resistance, the resistorIdLayer should be drawn
     ;;; from one contact to another, unless the width of the contact is greater than the
     ;;; specified resistor width.
     (setq contactXOffset 0.0)
     (if (greaterp (difference rw (difference (cadadr master~>botLayerBbox) 
					      (cadar master~>botLayerBbox)))
		-1e-6) then
	 (setq contactXOffset (caar master~>contactLayerBbox))
      else
	 (when (greaterp percentVariability 1e-6)
	     (error (sprintf nil "percentVariability must be 0 when rw is less than %L\n"
			     (difference (cadadr master~>botLayerBbox) 
					 (cadar master~>botLayerBbox)))
	     )
	     (setq percentVariability 0)
	 )
     )

     ;;; The resistorLayer should be drawn from the origin of the cell, the contact
     ;;; should be offset so that it is center justified w.r.t resistorLayer
     ;;; Calculate this yOffset now:
     (setq contactYOffset (difference (quotient rw 2.0)
			       (plus 
				(quotient (difference (cadadr master~>contactLayerBbox)
						      (cadar master~>contactLayerBbox))
					  2.0)
				(difference (cadar master~>contactLayerBbox)
					    (cadar master~>botLayerBbox))))
     )
     ;;; make sure the result is on grid
     (setq contactYOffset (times (round (quotient contactYOffset resistorLayerGrid)) resistorLayerGrid))
     (dbMoveFig inst tcCellView (list contactXOffset:contactYOffset "R0"))

     ;;; Calculate the bounding box of the pin to be drawn
     (setq bBox (list 
		 (list (difference contactXOffset (caar master~>topLayerPinBbox))
		       (plus contactYOffset (cadar master~>topLayerPinBbox)))
		 (list (difference contactXOffset (caadr master~>topLayerPinBbox))
		       (plus contactYOffset (cadadr master~>topLayerPinBbox))))
     )

     (setq dbid (dbCreateRect tcCellView master~>topLayer bBox))
     (dbCreatePin fNet dbid)

     ;;; set the x1coord from where the resistanceLayer will have to be drawn.
     (setq xOffset (difference (caadr master~>botLayerBbox) contactXOffset))
     (setq x1Coord2 (difference x1Coord xOffset))

     ;;; Initialize the lower coordinates of the well
     (when wellLayer
	 (setq x1WellCoord (difference x1Coord2 wellEnc))
	 (setq y1WellCoord (minus wellEnc))
	 (when (lessp contactYOffset 1e-6)
	     (setq y1WellCoord (difference contactYOffset wellEnc))
	 )
     )

     ;;; Calculate the offset of the implant layer
     (when implantLayer
	 ;;; The implant layer has to be offset from the contact
	 (setq impOffset (difference impSpaceContact 
				     (difference (caar master~>contactLayerBbox) contactXOffset)))
	 ;;; The contact should also be offset from the implantLayer to satisfy the
	 ;;; spacing of implant layer to botLayer of the contact.
	 (when (lessp rw (difference (cadadr master~>botLayerBbox) 
				     (cadar master~>botLayerBbox)))
	     (setq impOffset (plus impSpaceResistorLayer (caar master~>botLayerBbox)))
	 )
	 ;;; initialize the lower coordinates of the implant layer rectangle.
	 (setq x1ImpCoord (plus x1Coord impOffset))
	 (setq y1ImpCoord (difference y1Coord impEnc))
	 (setq x1Coord (plus x1Coord impOffset))
	 (setq xOffset (plus xOffset impOffset))
     )
 )

 ;;; The length of the resistorLayer is given by the rl parameter.
 (setq x2Coord (plus x1Coord rl xOffset))
 ;;; So is the length of the resIdLayer and where to draw the contacts
 (setq x2Coord2 (plus x1Coord rl))
 ;;; However, the above two parameters are offset by the existence of the
 ;;; percentVariability and deltaLength parameters.
 ;;; The resistor layer is drawn to x2Coord = rl + percentVariability * rl / 100.0
 ;;; The resistance will be to x2Coord2 = x2Coord - deltaLength
 (when (greaterp percentVariability 1e-6)
     (setq IncLength (quotient (times rl percentVariability) 100.0))
     (setq IncLength (times (round (quotient IncLength resistorLayerGrid)) resistorLayerGrid))
     ;;; The following point gives the total length of the resistor body layer.
     (setq x2Coord (plus xOffset x1Coord rl IncLength))
     ;;; The following point gives the actual resistor length. As per the 
     ;;; the current resistor pcell, the deltaLength can only
     ;;; change the resistor length between rl and rl+IncLength
     (setq x2Coord2 (plus x1Coord rl (min deltaLength IncLength)))
 )

 ;;; draw the cut layer
 (setq centerX (plus x1Coord (quotient (difference x2Coord2 x1Coord) 2.0)))
 (setq bBox (list (list (difference centerX (quotient resCutWidth 2.0)) y1Coord)
		  (list (plus centerX (quotient resCutWidth 2.0)) (plus y1Coord rw))))
 (dbCreateRect tcCellView resCutLayer bBox)
 
 ;;; Create the resistorLayer rectangle
 (dbCreateRect tcCellView resistorLayer
	       (list x1Coord2:y1Coord x2Coord:(plus y1Coord rw))
 )
 
 (when (and fullImplantLayer implant)
   ;;; define the bounding box for the fullImplantLayer (so far)
   (setq fullImpBbox (list (list (difference x1Coord2 fullImpEnc)
				 (difference y1Coord  fullImpEnc)
				 )
			   (list (plus       x2Coord  fullImpEnc)
				 (plus       y1Coord  fullImpEnc rw)
				 )
			   )
	 )
   )
 
 ;;; Create the resIdLayer to aid extraction, based on if 
 ;;; percentVariability has been defined
 (dbCreateRect tcCellView resIdLayer
	       (list x1Coord:y1Coord x2Coord2:(plus y1Coord rw))
 )

 (when areaIdLayer
     (dbCreateRect tcCellView areaIdLayer
		   (list (plus x1Coord -areaIdEncRes) : (plus y1Coord -areaIdEncRes) 
			 (plus x2Coord2 areaIdEncRes) : (plus y1Coord rw areaIdEncRes))
     )
 )

 ;;; if the contact is not specified, then the pin should be created on the
 ;;; resistorLayer.
 (when (equal contactName "")
     (setq dbid (dbCreateRect tcCellView resistorLayer
			      (list x1Coord:y1Coord 
				    (plus x1Coord resistorLayerGrid):(plus y1Coord rw)))
     )
     (dbCreatePin fNet dbid)
     (setq dbid (dbCreateRect tcCellView resistorLayer
			      (list (difference x2Coord2 resistorLayerGrid):y1Coord
				    x2Coord2:(plus y1Coord rw)))
     )
     (dbCreatePin lNet dbid)
     ;;; draw the well to completely enclose the drawn resistorLayer
     (when wellLayer
	 (setq x1WellCoord (difference x1Coord wellEnc))
	 (setq y1WellCoord (difference y1Coord wellEnc))
	 (setq x2WellCoord (max (plus x1WellCoord wellWidth)
				(plus x2Coord wellEnc))
	 )
	 (setq y2WellCoord (max (plus y1WellCoord wellWidth)
				(plus y1Coord rw wellEnc)))
	 (dbCreateRect tcCellView wellLayer
		       (list x1WellCoord:y1WellCoord x2WellCoord:y2WellCoord))
     )

     ;;; draw the implant layer to overlap the region forming the resistance
     (when implantLayer
	 (setq x1ImpCoord (difference x1Coord impEnc))
	 (setq y1ImpCoord (difference y1Coord impEnc))
	 (setq x2ImpCoord (max (plus x2Coord2 impEnc)
			       (plus x1ImpCoord impWidth)))
	 (setq y2ImpCoord (max (plus y1Coord rw impEnc)
			       (plus y1ImpCoord impWidth)))
	 (dbCreateRect tcCellView implantLayer
		       (list x1ImpCoord:y1ImpCoord x2ImpCoord:y2ImpCoord))
     )
 )

 ;;; However if the contactName is defined a contact has to be placed
 ;;; for the last terminal "r1" also
 (when (nequal contactName "")
     ;;; The x1Coord is where the contact instance will be placed.
     ;;; This point is where resistance finishes, taking into account
     ;;; percentVariability and deltaLength. The instance should be
     ;;; placed such that the first point of the contact touches the
     ;;; end point of the resistor layer (x2Coord2).
     ;;; But that will require changes in the diva-extraction code.
     ;;; So we will use the following, as is being with current subres.
     (setq x1Coord (plus x2Coord2 (caar master~>botLayerBbox)))

     ;;; Draw the implant layer and calculate where the contact will be placed.
     (when implantLayer
	 ;;; Draw the implant layer. We have all the coordinate now.
	 (setq x2ImpCoord (max x2Coord2
			       (plus x1ImpCoord impWidth)))
	 (setq y2ImpCoord (max (plus y1Coord rw impEnc)
			       (plus y1ImpCoord impWidth)))
	 (dbCreateRect tcCellView implantLayer
		       (list x1ImpCoord:y1ImpCoord x2ImpCoord:y2ImpCoord)
	 )
	 (setq x1Coord (plus x1Coord impOffset))
     )

     (setq contactXOffset (minus contactXOffset))
     ;;; Create the contact for the last terminal.
     (setq inst (dbCreateParamInst tcCellView contactId "c1"
				   (plus x1Coord contactXOffset):contactYOffset "R0" 1
				   instParams
				   )
     )

     (unless inst
	 (error (sprintf nil "Failed to create an instance of `%s'\n" contactName))
     )

     ;;; Create a rectangle from the topLayer of the specified contact
     (setq master inst~>master)
     (setq bBox (list (list (plus x1Coord (caar master~>topLayerPinBbox) contactXOffset)
			    (plus contactYOffset (cadar master~>topLayerPinBbox)))
		      (list (plus x1Coord (caadr master~>topLayerPinBbox) contactXOffset)
			    (plus contactYOffset (cadadr master~>topLayerPinBbox))))
     )

     (when (and (greaterp percentVariability 1e-6)
		(greaterp (difference IncLength deltaLength) 1e-6))
	 (setq bBox (list (list (plus x1Coord (caar master~>topLayerPinBbox) contactXOffset)
				(plus contactYOffset (cadar master~>topLayerPinBbox)))
			  (list (plus x1Coord (caadr master~>topLayerPinBbox) contactXOffset
				      (difference IncLength deltaLength))
				(plus contactYOffset (cadadr master~>topLayerPinBbox))))
	 )
     )

     (setq dbid (dbCreateRect tcCellView master~>topLayer bBox))
     (dbCreatePin lNet dbid)
     
     ;;; calculate the top right coordinates of the well and draw it
     (when wellLayer
	 (setq x2WellCoord (max (plus x1WellCoord wellWidth)
				(plus x2Coord wellEnc))
	 )
	 (setq y2WellCoord (max (plus y1Coord rw wellEnc)
				(plus contactYOffset (cadadr master~>botLayerBbox) wellEnc)
				(plus y1WellCoord wellWidth))
	 )
	 (dbCreateRect tcCellView wellLayer
		       (list x1WellCoord:y1WellCoord x2WellCoord:y2WellCoord)
	 )
     )
     
     (when (and fullImplantLayer implant)
       ;; calculate the bounding box for fullImplantLayer.
       ;; this takes the larger of what was previously calculated for
       ;; the resistor itself and what is required to enclose the
       ;; contacts
       (setq fullImpBbox (list (list (min (caar fullImpBbox)
					  (difference (caar master~>botLayerBbox) fullImpEnc)
					  )
				     (min (cadar fullImpBbox)
					  (plus contactYOffset (cadar master~>botLayerBbox) -fullImpEnc)
					  )
				     )
			       (list (max (caadr fullImpBbox)
					  (plus x2Coord fullImpEnc)
					  )
				     (max (cadadr fullImpBbox)
					  (plus contactYOffset (cadadr master~>botLayerBbox) fullImpEnc)
					  )
				     )
			       )
	     )
       )
     ;;; done with everything close the opened cell views
     (dbClose contactId)
 )
 
 ;; draw the fullImplantLayer with the calculated bBox
 (when (and fullImplantLayer implant)
   (dbCreateRect tcCellView fullImplantLayer fullImpBbox)
   )
) ;; End of Class Definition


;;; Define the function of the class.

(tfcDefineDeviceClassProp
;;(viewName       devClassName  propName          propValue)
 (symbolic        wlResImpClass    function          "transistor")
)



;;; 
;;; $Id: rcInterConClass.il,v 1.9 2006/02/01 14:37:18 osd Exp $
;;; 
;;; rcInterConClass.il
;;; 
;;; Copyright (c) 1998 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Jan 26, 1998
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This file defines the class for the row and column based
;;; 2 layer interconnect contact.
;;; 
;;; Revision History:
;;;   jim 08/14/98  Removed bevels since CCT doesn't support
;;;   jim 09/09/98  Renamed parameters to be "more" consistent with Cadence's 
;;;                 syEnhContact.
;;;   akr 12/07/98  Added X and Y enc of layer1
;;;   akr 01/05/99  Backed out X and Y enc changes
;;;   akr 01/06/99  Added X and Y enc of layer1 again
;;;   akg 02/22/99  Added maxvLayer as optional class parameter (similar to 2.0 flow)
;;;   cry 07/24/01  Fixed layer2ImpEnc to be used if given 
;;;                 (layer2Implant is currently unused in all flows)
;;;                 Added viaLayerImplant, viaLayerImplantEnc to allow specification
;;;                 of an implants enclosure of the contact
;;;                 added option to rotate top layer (swaps enclosure values)
;;;   osd 01/31/06  added option to center the contacts
;;; 

(putpropqq rcInterConClass "$Id: rcInterConClass.il,v 1.9 2006/02/01 14:37:18 osd Exp $" SCCS)

(tcCreateDeviceClass
 "symbolic" "rcInterConClass"
 ;; class parameters
 (
  (layer1         "hilite")    ; the layer (& purpose) of layer1
  (layer2     "prBoundary")    ; the layer (& purpose) of layer2
  (viaLayer           "y4")    ; the layer (& purpose) of layer1-2 contacts
  (maxvLayer           nil)    ; the (optional) recognition layer to be drawn identical to layer1

  (encByLayer1         0.0)    ; layer 1 enclosure of contact
  (layer1XEnc          0.0)    ; layer 1 X enclosure of contact
  (layer1YEnc          0.0)    ; layer 1 Y enclosure of contact
  (layer2XEnc          0.0)    ; layer 2 X enclosure of contact
  (layer2YEnc          0.0)    ; layer 2 Y enclosure of contact
  (layer1Implant       nil)    ; implant layer to draw around layer 1
  (layer1ImpEnc        0.0)    ; enclosure of layer 1 by implant layer
  (layer2Implant       nil)    ; implant layer to draw around layer 2
  (layer2ImpEnc        0.0)    ; enclosure of layer 2 by implant layer
  (viaLayerImplant     nil)    ; implant layer to draw around viaLayer
  (viaLayerImpEnc      0.0)    ; enclosure of viaLayer by implant layer
  (CenterAtOrigin  "FALSE")    ;center at (0,0) for the via
 )

 ;; formal parameters
 (
  (row    		 1)    ; the number of rows
  (column 		 1)    ; the number of columns
  (xPitch 	       0.0)    ; contact pitch in x direction
  (yPitch 	       0.0)    ; contact pitch in y direction
  (w      	       0.0)    ; width of the contact  (x direction)
  (l      	       0.0)    ; length of the contact (y direction)
  (rotateTop       "FALSE")    ; reverse the layer2 X and Y enclosures
  )
 
 ;; swap top layer enclosures for a "rotate" effect
 (when (or (equal rotateTop t) (equal rotateTop "TRUE"))
   (setq swapTemp   layer2XEnc)
   (setq layer2XEnc layer2YEnc)
   (setq layer2YEnc swapTemp)
   )
 
 ; variables used in this pcell
 ; allDir       - list of right, left, top, bottom for pin access direction
 ; col          - loop control variable, looping through all the columns
 ; dbId         - temporary database id of the most recently created object
 ; layer1length - the length of layer1
 ; layer1width  - the width of layer1
 ; layer2length - the length of layer2
 ; layer2width  - the width of layer2
 ; net          - the net all of the shapes will be attached to
 ; pinId        - temporary pin id of the most recently created pin
 ; r            - loop control variable, looping through all the rows
 ; theX         - loop variable; the X origin of the next via to create
 ; theY         - loop variable; the Y origin of the next via to create

 (setq allDir (list "right" "left" "top" "bottom"))
 (setq net (dbMakeNet tcCellView "ppd"))
 (when (stringp layer1)
     (setq layer1 (list layer1 "drawing"))
 )
 (when (stringp layer2)
     (setq layer2 (list layer2 "drawing"))
 )
 
 ;; draw layer1
 (cond ((equal encByLayer1 0.0)
	(setq layer1X layer1XEnc)
	(setq layer1Y layer1YEnc))
       (t 
	(setq layer1X encByLayer1)
	(setq layer1Y encByLayer1))
       )
 (setq layer1length (plus (times 2 layer1X) w
			  (times (difference column 1) xPitch)))
 (setq layer1width  (plus (times 2 layer1Y) l
			  (times (difference row 1) yPitch)))
 (setq layer1XLL (minus (quotient layer1length 2.0))) 
 (setq layer1YLL (minus (quotient layer1width  2.0))) 
 (setq layer1XUR (quotient layer1length 2.0)) 
 (setq layer1YUR (quotient layer1width  2.0))
 
 (if  CenterAtOrigin then
   (setq dbId (dbCreateRect tcCellView layer1
			  (list (list layer1XLL layer1YLL )
				(list layer1XUR layer1YUR))))
   else
   (setq dbId (dbCreateRect tcCellView layer1
			  (list (list 0.0 0.0)
				(list layer1length layer1width))))
   )
 (dbAddFigToNet dbId net)
 (setq pinId (dbCreatePin net dbId))
 pinId~>accessDir = allDir
 (dbCreateProp tcCellView "botLayer" "list" layer1)
 (dbCreateProp tcCellView "botLayerBbox" "list" dbId~>bBox)

 ;; draw maxv layer if specified
 (when maxvLayer
   (if  CenterAtOrigin then
     (setq dbId (dbCreateRect tcCellView maxvLayer
			  (list (list layer1XLL layer1YLL )
				(list layer1XUR layer1YUR))))
     else
     (setq dbId (dbCreateRect tcCellView maxvLayer
                              (list (list 0.0 0.0)
                                    (list layer1length layer1width))))
     )
     (dbAddFigToNet dbId net)
     (setq pinId (dbCreatePin net dbId))
     pinId~>accessDir = allDir
 )

 ;; draw layer1 implant
 (when layer1Implant
   (if  CenterAtOrigin then
     (setq dbId (dbCreateRect tcCellView layer1Implant
			    (list (list (difference layer1XLL layer1ImpEnc)
					(difference layer1YLL layer1ImpEnc))
				  (list (plus layer1XUR     layer1ImpEnc)
					(plus layer1YUR     layer1ImpEnc)))))
     else
     (setq dbId (dbCreateRect tcCellView layer1Implant
			    (list (list (minus layer1ImpEnc)
					(minus layer1ImpEnc))
				  (list (plus layer1length layer1ImpEnc)
					(plus layer1width layer1ImpEnc)))))
     )
   (dbAddFigToNet dbId net)
   (setq pinId (dbCreatePin net dbId))
   pinId~>accessDir = allDir
 )

 (if  CenterAtOrigin then
   (setq theY  (plus layer1YLL layer1Y))
   else
   (setq theY layer1Y)
   )
 (for r 1 row
      ;; initailize the x coordinate as the layer1 enclosure of via1.
      (if  CenterAtOrigin then
	 (setq theX (plus layer1XLL layer1X))
	 else
	 (setq theX layer1X)
	 )
      (for col 1 column
	   (setq dbId (dbCreateRect tcCellView viaLayer
				    (list (list theX theY)
					  (list (plus theX w)
						(plus theY l)))))
	   (dbAddFigToNet dbId net)
	   (setq theX (plus theX xPitch))
      )
     (setq theY (plus theY yPitch))
 )

 (dbCreateProp tcCellView "contactLayer" "list" viaLayer)

 (if  CenterAtOrigin then 
   (dbCreateProp tcCellView "contactLayerBbox" "list" 
		 (list (plus layer1XLL layer1X):(plus layer1YLL layer1Y)
		       (caadr dbId~>bBox):(cadadr dbId~>bBox)))
   else
   (dbCreateProp tcCellView "contactLayerBbox" "list" 
		 (list layer1X:layer1Y
		       (caadr dbId~>bBox):(cadadr dbId~>bBox)))
   )

 ;; based on the contacts, calculate layer2's width & length
 (setq layer2length (plus (times 2 layer2XEnc) w
			  (times (difference column 1) xPitch)))

 (setq layer2width  (plus (times 2 layer2YEnc) l
			  (times (difference row 1) yPitch)))

 (if  CenterAtOrigin then 
   (setq layer2X1Coord (plus layer1XLL (difference layer1X layer2XEnc)))
   (setq layer2Y1Coord (plus layer1YLL (difference layer1Y layer2YEnc)))
   else
   (setq layer2X1Coord (difference layer1X layer2XEnc))
   (setq layer2Y1Coord (difference layer1Y layer2YEnc))
   )
 (setq layer2X2Coord (plus layer2X1Coord layer2length))
 (setq layer2Y2Coord (plus layer2Y1Coord layer2width))

 ;; draw layer2
 (setq dbId (dbCreateRect tcCellView layer2
			  (list layer2X1Coord:layer2Y1Coord
				layer2X2Coord:layer2Y2Coord)))
 (setq pinId (dbCreatePin net dbId))
 pinId~>accessDir = allDir
 (dbCreateProp tcCellView "topLayer" "list" layer2)
 (dbCreateProp tcCellView "topLayerPinBbox" "list" dbId~>bBox)

 ;; draw layer2 implant
 (when layer2Implant
   (setq dbId (dbCreateRect tcCellView layer2Implant
			    (list (list (difference layer2X1Coord layer2ImpEnc)
					(difference layer2Y1Coord layer2ImpEnc))
				  (list (plus layer2X2Coord layer2ImpEnc)
					(plus layer2Y2Coord layer2ImpEnc)))))
   (dbAddFigToNet dbId net)
   (setq pinId (dbCreatePin net dbId))
   pinId~>accessDir = allDir
 )
 
 ;; draw viaLayer implant
 (when viaLayerImplant
   (setq dbId (dbCreateRect tcCellView viaLayerImplant
			    (list (list (difference (caar tcCellView~>contactLayerBbox)
						    viaLayerImpEnc)
					(difference (cadar tcCellView~>contactLayerBbox) 
						    viaLayerImpEnc))
				  (list (plus (caadr tcCellView~>contactLayerBbox)
					      viaLayerImpEnc)
					(plus (cadadr tcCellView~>contactLayerBbox)
					      viaLayerImpEnc)))))
   (dbAddFigToNet dbId net)
   (setq pinId (dbCreatePin net dbId))
   pinId~>accessDir = allDir
 )
 (dbCreateProp tcCellView "bBoxEff" "list"
	       (list (list (min (caar tcCellView~>topLayerPinBbox)
				(caar tcCellView~>botLayerBbox))
			   (min (cadar tcCellView~>topLayerPinBbox)
				(cadar tcCellView~>botLayerBbox))
			   )
		     (list (max (caadr tcCellView~>topLayerPinBbox)
				(caadr tcCellView~>botLayerBbox))
			   (max (cadadr tcCellView~>topLayerPinBbox)
				(cadadr tcCellView~>botLayerBbox))
			   )))
)


(tfcDefineDeviceClassProp
;;(viewName       devClassName           propName          propValue)
;;;-------------------------------------------------------------------
 (symbolic        rcInterConClass        function          "contact")
)
;;; 
;;; $Id: rcInterConImpClass.il,v 1.2 2006/02/01 14:37:18 osd Exp $
;;; 
;;; rcInterConImpClass.il
;;; 
;;; Copyright (c) 1998 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Jan 26, 1998
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This file defines the class for the row and column based
;;;   2 layer interconnect contact. It allows implant layers to be
;;;   turned on and off
;;; 
;;; Revision History:
;;;   jim 08/14/98  Removed bevels since CCT doesn't support
;;;   jim 09/09/98  Renamed parameters to be "more" consistent with Cadence's 
;;;                 syEnhContact.
;;;   akr 12/07/98  Added X and Y enc of layer1
;;;   akr 01/05/99  Backed out X and Y enc changes
;;;   akr 01/06/99  Added X and Y enc of layer1 again
;;;   akg 02/22/99  Added maxvLayer as optional class parameter (similar to 2.0 flow)
;;;   cry 07/24/01  Fixed layer2ImpEnc to be used if given 
;;;                  (layer2Implant is unused in all flows)
;;;                 Added viaLayerImplant, viaLayerImplantEnc to allow specification
;;;                  of an implants enclosure of the contact
;;;   cry 07/25/01  Copied from rcInterConClass to create a contact with implants
;;;                  that can be turned on and off
;;;   osd 01/31/06  added option to center the contacts
;;; 

(putpropqq rcInterConImpClass "$Id: rcInterConImpClass.il,v 1.2 2006/02/01 14:37:18 osd Exp $" SCCS)

(tcCreateDeviceClass
 "symbolic" "rcInterConImpClass"
 ;; class parameters
 (
  (layer1         "hilite")    ; the layer (& purpose) of layer1
  (layer2     "prBoundary")    ; the layer (& purpose) of layer2
  (viaLayer           "y4")    ; the layer (& purpose) of layer1-2 contacts
  (maxvLayer           nil)    ; the (optional) recognition layer to be drawn identical to layer1

  (encByLayer1         0.0)    ; layer 1 enclosure of contact
  (layer1XEnc          0.0)    ; layer 1 X enclosure of contact
  (layer1YEnc          0.0)    ; layer 1 Y enclosure of contact
  (layer2XEnc          0.0)    ; layer 2 X enclosure of contact
  (layer2YEnc          0.0)    ; layer 2 Y enclosure of contact
  (layer1Implant       nil)    ; implant layer to draw around layer 1
  (layer1ImpEnc        0.0)    ; enclosure of layer 1 by implant layer
  (layer2Implant       nil)    ; implant layer to draw around layer 2
  (layer2ImpEnc        0.0)    ; enclosure of layer 2 by implant layer
  (viaLayerImplant     nil)    ; implant layer to draw around viaLayer
  (viaLayerImpEnc      0.0)    ; enclosure of viaLayer by implant layer
  (CenterAtOrigin  "FALSE")    ;center at (0,0) for the via
 )

 ;; formal parameters
 (
  (row    		 1)    ; the number of rows
  (column 		 1)    ; the number of columns
  (xPitch 	       0.0)    ; contact pitch in x direction
  (yPitch 	       0.0)    ; contact pitch in y direction
  (w      	       0.0)    ; width of the contact  (x direction)
  (l      	       0.0)    ; length of the contact (y direction)
  (implant               t)    ; toggles implants on/off.
  (rotateTop       "FALSE")    ; reverse the layer2 X and Y enclosures
 )

 ; variables used in this pcell
 ; allDir       - list of right, left, top, bottom for pin access direction
 ; col          - loop control variable, looping through all the columns
 ; dbId         - temporary database id of the most recently created object
 ; layer1length - the length of layer1
 ; layer1width  - the width of layer1
 ; layer2length - the length of layer2
 ; layer2width  - the width of layer2
 ; net          - the net all of the shapes will be attached to
 ; pinId        - temporary pin id of the most recently created pin
 ; r            - loop control variable, looping through all the rows
 ; theX         - loop variable; the X origin of the next via to create
 ; theY         - loop variable; the Y origin of the next via to create

 ;; convert all boolean parameters to either t or nil
 ;; this way we can use the simple (when parameter) syntax
 ;; and speed up pcell evaluation and make code simpler
 (if (or (equal implant t) (equal implant "TRUE")) then
   (setq implant t)
   else
   (setq implant nil)
   )
 ;; swap top layer enclosures for a "rotate" effect
 (when (or (equal rotateTop t) (equal rotateTop "TRUE"))
   (setq swapTemp   layer2XEnc)
   (setq layer2XEnc layer2YEnc)
   (setq layer2YEnc swapTemp)
   )
 
 (setq allDir (list "right" "left" "top" "bottom"))
 (setq net (dbMakeNet tcCellView "ppd"))
 (when (stringp layer1)
     (setq layer1 (list layer1 "drawing"))
 )
 (when (stringp layer2)
     (setq layer2 (list layer2 "drawing"))
 )
 
 ;; draw layer1
 (cond ((equal encByLayer1 0.0)
	(setq layer1X layer1XEnc)
	(setq layer1Y layer1YEnc))
       (t 
	(setq layer1X encByLayer1)
	(setq layer1Y encByLayer1))
       )
 (setq layer1length (plus (times 2 layer1X) w
			  (times (difference column 1) xPitch)))
 (setq layer1width  (plus (times 2 layer1Y) l
			  (times (difference row 1) yPitch)))
 (setq layer1XLL (minus (quotient layer1length 2.0)))
 (setq layer1YLL (minus (quotient layer1width  2.0)))
 (setq layer1XUR (quotient layer1length 2.0))
 (setq layer1YUR (quotient layer1width  2.0))
 (if  CenterAtOrigin then
   (setq dbId (dbCreateRect tcCellView layer1
			    (list (list layer1XLL layer1YLL )
				  (list layer1XUR layer1YUR))))
   else
   (setq dbId (dbCreateRect tcCellView layer1
			  (list (list 0.0 0.0)
				(list layer1length layer1width))))
   )
 (dbAddFigToNet dbId net)
 (setq pinId (dbCreatePin net dbId))
 pinId~>accessDir = allDir
 (dbCreateProp tcCellView "botLayer" "list" layer1)
 (dbCreateProp tcCellView "botLayerBbox" "list" dbId~>bBox)

 ;; draw maxv layer if specified
 (when maxvLayer
   (if  CenterAtOrigin then
     (setq dbId (dbCreateRect tcCellView maxvLayer
			      (list (list layer1XLL layer1YLL )
				    (list layer1XUR layer1YUR))))
     else
     (setq dbId (dbCreateRect tcCellView maxvLayer
                              (list (list 0.0 0.0)
                                    (list layer1length layer1width))))
     )
     (dbAddFigToNet dbId net)
     (setq pinId (dbCreatePin net dbId))
     pinId~>accessDir = allDir
 )

 ;; draw layer1 implant
 (when (and layer1Implant implant)
   (if  CenterAtOrigin then
     (setq dbId (dbCreateRect tcCellView layer1Implant
			      (list (list (difference layer1XLL layer1ImpEnc)
					  (difference layer1YLL layer1ImpEnc))
				    (list (plus layer1XUR     layer1ImpEnc)
					  (plus layer1YUR     layer1ImpEnc)))))
     else
     (setq dbId (dbCreateRect tcCellView layer1Implant
			      (list (list (minus layer1ImpEnc)
					  (minus layer1ImpEnc))
				    (list (plus layer1length layer1ImpEnc)
					  (plus layer1width layer1ImpEnc)))))
     )
     (dbAddFigToNet dbId net)
 )

 (if  CenterAtOrigin then
   (setq theY  (plus layer1YLL layer1Y))
   else
   (setq theY layer1Y)
   )
 (for r 1 row
      ;; initailize the x coordinate as the layer1 enclosure of via1.
      (if  CenterAtOrigin then
        (setq theX (plus layer1XLL layer1X))
        else
	(setq theX layer1X)
	)
      (for col 1 column
	   (setq dbId (dbCreateRect tcCellView viaLayer
				    (list (list theX theY)
					  (list (plus theX w)
						(plus theY l)))))
	   (dbAddFigToNet dbId net)
	   (setq theX (plus theX xPitch))
      )
     (setq theY (plus theY yPitch))
 )

 (dbCreateProp tcCellView "contactLayer" "list" viaLayer)
 (if  CenterAtOrigin then 
   (dbCreateProp tcCellView "contactLayerBbox" "list" 
		 (list (plus layer1XLL layer1X):(plus layer1YLL layer1Y)
		       (caadr dbId~>bBox):(cadadr dbId~>bBox)))
   else
   (dbCreateProp tcCellView "contactLayerBbox" "list" 
		 (list layer1X:layer1Y
		       (caadr dbId~>bBox):(cadadr dbId~>bBox)))
   )

 ;; based on the contacts, calculate layer2's width & length
 (setq layer2length (plus (times 2 layer2XEnc) w
			  (times (difference column 1) xPitch)))

 (setq layer2width  (plus (times 2 layer2YEnc) l
			  (times (difference row 1) yPitch)))
 (if  CenterAtOrigin then
   (setq layer2X1Coord (plus layer1XLL (difference layer1X layer2XEnc)))
   (setq layer2Y1Coord (plus layer1YLL (difference layer1Y layer2YEnc)))
   else
   (setq layer2X1Coord (difference layer1X layer2XEnc))
   (setq layer2Y1Coord (difference layer1Y layer2YEnc))
   )
 (setq layer2X2Coord (plus layer2X1Coord layer2length))
 (setq layer2Y2Coord (plus layer2Y1Coord layer2width))

 ;; draw layer2
 (setq dbId (dbCreateRect tcCellView layer2
			  (list layer2X1Coord:layer2Y1Coord
				layer2X2Coord:layer2Y2Coord)))
 (setq pinId (dbCreatePin net dbId))
 pinId~>accessDir = allDir
 (dbCreateProp tcCellView "topLayer" "list" layer2)
 (dbCreateProp tcCellView "topLayerPinBbox" "list" dbId~>bBox)

 ;; draw layer2 implant
 (when (and layer2Implant implant)
     (setq dbId (dbCreateRect tcCellView layer2Implant
			 (list (list (difference layer2X1Coord layer2ImpEnc)
				     (difference layer2Y1Coord layer2ImpEnc))
			       (list (plus layer2X2Coord layer2ImpEnc)
				     (plus layer2Y2Coord layer2ImpEnc)))))
     (dbAddFigToNet dbId net)
 )
 
 (when (and viaLayerImplant implant)
   (setq dbId (dbCreateRect tcCellView viaLayerImplant
			    (list (list (difference (caar tcCellView~>contactLayerBbox)
						    viaLayerImpEnc)
					(difference (cadar tcCellView~>contactLayerBbox) 
						    viaLayerImpEnc))
				  (list (plus (caadr tcCellView~>contactLayerBbox)
					      viaLayerImpEnc)
					(plus (cadadr tcCellView~>contactLayerBbox)
					      viaLayerImpEnc)))))
   (dbAddFigToNet dbId net)
 )
 (dbCreateProp tcCellView "bBoxEff" "list"
	       (list (list (min (caar tcCellView~>topLayerPinBbox)
				(caar tcCellView~>botLayerBbox))
			   (min (cadar tcCellView~>topLayerPinBbox)
				(cadar tcCellView~>botLayerBbox))
			   )
		     (list (max (caadr tcCellView~>topLayerPinBbox)
				(caadr tcCellView~>botLayerBbox))
			   (max (cadadr tcCellView~>topLayerPinBbox)
				(cadadr tcCellView~>botLayerBbox))
			   )))
)


(tfcDefineDeviceClassProp
;;(viewName       devClassName           propName          propValue)
;;;-------------------------------------------------------------------
 (symbolic        rcInterConImpClass     function          "contact")
)
;;; 
;;; $Id: rcInterConPolImpClass.il,v 1.3 2006/08/03 19:11:24 kuc Exp $
;;; 
;;; rcInterConPolImpClass.il
;;; 
;;; Copyright (c) 1998 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Jan 26, 1998
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This file defines the class for the row and column based
;;;   2 layer interconnect contact. It allows implant layers to be
;;;   turned on and off. It also allows the polarity (n/p) to be toggled.
;;; 
;;; Revision History:
;;;   jim 08/14/98  Removed bevels since CCT doesn't support
;;;   jim 09/09/98  Renamed parameters to be "more" consistent with Cadence's 
;;;                 syEnhContact.
;;;   akr 12/07/98  Added X and Y enc of layer1
;;;   akr 01/05/99  Backed out X and Y enc changes
;;;   akr 01/06/99  Added X and Y enc of layer1 again
;;;   akg 02/22/99  Added maxvLayer as optional class parameter (similar to 2.0 flow)
;;;   cry 07/24/01  Fixed layer2ImpEnc to be used if given 
;;;                  (layer2Implant is unused in all flows)
;;;                 Added viaLayerImplant, viaLayerImplantEnc to allow specification
;;;                  of an implants enclosure of the contact
;;;   cry 07/25/01  Copied from rcInterConClass to create a contact with implants
;;;                  that can be turned on and off
;;;   cry 07/25/01  Copied from rcInterConImpClass to create a contact with implants
;;;                  that can have polarity toggled.
;;;   lpn 02/08/02  Added an option to draw diffCoreImplant layer enclosing Diff layer 
;;;   kuc 08/03/06  added option to center the contacts
;;; 

(putpropqq rcInterConPolImpClass "$Id: rcInterConPolImpClass.il,v 1.3 2006/08/03 19:11:24 kuc Exp $" SCCS)

(tcCreateDeviceClass
 "symbolic" "rcInterConPolImpClass"
 ;; class parameters
 (
  (layer1         "hilite")    ; the layer (& purpose) of layer1
  (layer2     "prBoundary")    ; the layer (& purpose) of layer2
  (viaLayer           "y4")    ; the layer (& purpose) of layer1-2 contacts
  (maxvLayer           nil)    ; the (optional) recognition layer to be drawn identical to layer1

  (encByLayer1         0.0)    ; layer 1 enclosure of contact
  (layer1XEnc          0.0)    ; layer 1 X enclosure of contact
  (layer1YEnc          0.0)    ; layer 1 Y enclosure of contact
  (layer2XEnc          0.0)    ; layer 2 X enclosure of contact
  (layer2YEnc          0.0)    ; layer 2 Y enclosure of contact
  (layer1Implant       nil)         ; layer 1 implant layer list (inWell=nil:inWell=t)
  (layer1ImpEnc     (list 0.0 0.0)) ; layer 1 implant enclosure list (inWell=nil:inWell=t)
  (layer1CoreImplant       nil)         ; layer 1 Core implant layer list (inWell=nil:inWell=t)
  (layer1CoreImpEnc     (list 0.0 0.0)) ; layer 1 Core implant enclosure list (inWell=nil:inWell=t)
  (layer2Implant       nil)         ; layer 2 implant layer list (inWell=nil:inWell=t)
  (layer2ImpEnc     (list 0.0 0.0)) ; layer 2 implant enclosure list (inWell=nil:inWell=t)
  (viaLayerImplant     nil)         ; viaLayer implant layer list (inWell=nil:inWell=t)
  (viaLayerImpEnc   (list 0.0 0.0)) ; viaLayer implant enclosure list (inWell=nil:inWell=t)
  (wellLayer           nil)         ; the layer to be drawn for the well when inWell and implants are on
  (wellLayerEnc        0.0)         ; the amount by which the wellLayer must enclose layer1
  (CenterAtOrigin  "FALSE")         ; center at (0,0) for the via
 )

 ;; formal parameters
 (
  (row    		 1)    ; the number of rows
  (column 		 1)    ; the number of columns
  (xPitch 	       0.0)    ; contact pitch in x direction
  (yPitch 	       0.0)    ; contact pitch in y direction
  (w      	       0.0)    ; width of the contact  (x direction)
  (l      	       0.0)    ; length of the contact (y direction)
  (implant               t)    ; toggles implants on/off.
  (inWell                t)    ; toggles polarity of implant. disregarded when
			       ;  implant is FALSE
  (rotateTop       "FALSE")    ; reverse the layer2 X and Y enclosures
 )
 ;; convert all boolean parameters to either t or nil
 ;; this way we can use the simple (when parameter) syntax
 ;; and speed up pcell evaluation and make code simpler
 (if (or (equal implant t) (equal implant "TRUE")) then
   (setq implant t)
   else
   (setq implant nil)
   )
 (if (or (equal inWell t) (equal inWell "TRUE")) then
   (setq inWell t)
   else
   (setq inWell nil)
   )
 (if (or (equal CenterAtOrigin t) (equal CenterAtOrigin "TRUE")) then
   (setq center t)
   else
   (setq center nil)
   )
 ;; swap top layer enclosures for a "rotate" effect
 (when (or (equal rotateTop t) (equal rotateTop "TRUE"))
   (setq swapTemp   layer2XEnc)
   (setq layer2XEnc layer2YEnc)
   (setq layer2YEnc swapTemp)
   )
 
 ; variables used in this pcell
 ; allDir       - list of right, left, top, bottom for pin access direction
 ; col          - loop control variable, looping through all the columns
 ; dbId         - temporary database id of the most recently created object
 ; layer1length - the length of layer1
 ; layer1width  - the width of layer1
 ; layer2length - the length of layer2
 ; layer2width  - the width of layer2
 ; net          - the net all of the shapes will be attached to
 ; pinId        - temporary pin id of the most recently created pin
 ; r            - loop control variable, looping through all the rows
 ; theX         - loop variable; the X origin of the next via to create
 ; theY         - loop variable; the Y origin of the next via to create

 (setq allDir (list "right" "left" "top" "bottom"))
 (setq net (dbMakeNet tcCellView "ppd"))
 (when (stringp layer1)
     (setq layer1 (list layer1 "drawing"))
 )
 (when (stringp layer2)
     (setq layer2 (list layer2 "drawing"))
 )
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;; DERIVE EFFECTIVE IMPLANT LAYERS AND INCLOSURES
 ;;; BASED ON POLARITY
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 (when implant
     (when layer1Implant
	 (if inWell then
	     (setq layer1Implant (cadr layer1Implant))
	     (setq layer1ImpEnc  (cadr layer1ImpEnc))
	  else
	     (setq layer1Implant (car layer1Implant))
	     (setq layer1ImpEnc  (car layer1ImpEnc))
	 )
     )

     (when layer1CoreImplant
	 (if inWell then
	     (setq layer1CoreImplant (cadr layer1CoreImplant))
	     (setq layer1CoreImpEnc  (cadr layer1CoreImpEnc))
	  else
	     (setq layer1CoreImplant (car layer1CoreImplant))
	     (setq layer1CoreImpEnc  (car layer1CoreImpEnc))
	 )
     )


     (when layer2Implant
	 (if inWell then
	     (setq layer2Implant (cadr layer2Implant))
	     (setq layer2ImpEnc  (cadr layer2ImpEnc))
	  else
	     (setq layer2Implant (car layer2Implant))
	     (setq layer2ImpEnc  (car layer2ImpEnc))
	 )
     )
   (when viaLayerImplant
       (if inWell then
	   (setq viaLayerImplant (cadr viaLayerImplant))
	   (setq viaLayerImpEnc  (cadr viaLayerImpEnc))
	else
	   (setq viaLayerImplant (car viaLayerImplant))
	   (setq viaLayerImpEnc  (car viaLayerImpEnc))
       )
   )
 )
 
 
 ;; draw layer1
 (cond ((equal encByLayer1 0.0)
	(setq layer1X layer1XEnc)
	(setq layer1Y layer1YEnc))
       (t 
	(setq layer1X encByLayer1)
	(setq layer1Y encByLayer1))
 )
 (setq layer1length (plus (times 2 layer1X) w
			  (times (difference column 1) xPitch)))
 (setq layer1width  (plus (times 2 layer1Y) l
			  (times (difference row 1) yPitch)))
 (setq dbId (dbCreateRect tcCellView layer1
			  (list (list 0.0 0.0)
				(list layer1length layer1width))))
 (if CenterAtOrigin then
   (setq xShift (quotient layer1length 2))
   (setq yShift (quotient layer1width 2))
   else
   (setq xShift 0)
   (setq yShift 0)
   )
 (setq dbId (dbMoveFig dbId nil (list -xShift:-yShift "R0")))

 (dbAddFigToNet dbId net)
 (setq pinId (dbCreatePin net dbId))
 pinId~>accessDir = allDir
 (dbCreateProp tcCellView "botLayer" "list" layer1)
 (dbCreateProp tcCellView "botLayerBbox" "list" dbId~>bBox)

 ;; draw maxv layer if specified
 (when maxvLayer
     (setq dbId (dbCreateRect tcCellView maxvLayer
                              (list (list 0.0 0.0)
                                    (list layer1length layer1width))))
     (setq dbId (dbMoveFig dbId nil (list -xShift:-yShift "R0")))
     (dbAddFigToNet dbId net)
     (setq pinId (dbCreatePin net dbId))
     pinId~>accessDir = allDir
 )

 ;; draw layer1 implant
 (when (and layer1Implant implant)
     (setq dbId (dbCreateRect tcCellView layer1Implant
			      (list (list (minus layer1ImpEnc)
					  (minus layer1ImpEnc))
				    (list (plus layer1length layer1ImpEnc)
					  (plus layer1width layer1ImpEnc)))))
     (setq dbId (dbMoveFig dbId nil (list -xShift:-yShift "R0")))
     (dbAddFigToNet dbId net)
 )
 

 ;; draw layer1 Core implant
 (when (and layer1CoreImplant implant)
     (setq dbId (dbCreateRect tcCellView layer1CoreImplant
			      (list (list (minus layer1CoreImpEnc)
					  (minus layer1CoreImpEnc))
				    (list (plus layer1length layer1CoreImpEnc)
					  (plus layer1width layer1CoreImpEnc)))))
     (setq dbId (dbMoveFig dbId nil (list -xShift:-yShift "R0")))
     (dbAddFigToNet dbId net)
 )
 
 ;; draw well layer to enclosure of layer 1
 (when (and  wellLayer implant inWell)
     (setq dbId (dbCreateRect tcCellView wellLayer
			      (list (list (minus wellLayerEnc)
					  (minus wellLayerEnc))
				    (list (plus layer1length wellLayerEnc)
					  (plus layer1width wellLayerEnc)))))
     (setq dbId (dbMoveFig dbId nil (list -xShift:-yShift "R0")))
 )
 
 
 (setq theY layer1Y)
 (for r 1 row
      ;; initailize the x coordinate as the layer1 enclosure of via1.
      (setq theX layer1X)
      (for col 1 column
	   (setq dbId (dbCreateRect tcCellView viaLayer
				    (list (list theX theY)
					  (list (plus theX w)
						(plus theY l)))))
	   (setq dbId (dbMoveFig dbId nil (list -xShift:-yShift "R0")))
	   (dbAddFigToNet dbId net)
	   (setq theX (plus theX xPitch))
      )
      (setq theY (plus theY yPitch))
 )
 
 (dbCreateProp tcCellView "contactLayer" "list" viaLayer)
 (dbCreateProp tcCellView "contactLayerBbox" "list" 
	       (list layer1X:layer1Y
		     (caadr dbId~>bBox):(cadadr dbId~>bBox)))
 
 ;; based on the contacts, calculate layer2's width & length
 (setq layer2length (plus (times 2 layer2XEnc) w
			  (times (difference column 1) xPitch)))
 
 (setq layer2width  (plus (times 2 layer2YEnc) l
			  (times (difference row 1) yPitch)))
 
 (setq layer2X1Coord (difference layer1X layer2XEnc))
 (setq layer2Y1Coord (difference layer1Y layer2YEnc))
 (setq layer2X2Coord (plus layer2X1Coord layer2length))
 (setq layer2Y2Coord (plus layer2Y1Coord layer2width))
 
 ;; draw layer2
 (setq dbId (dbCreateRect tcCellView layer2
			  (list layer2X1Coord:layer2Y1Coord
				layer2X2Coord:layer2Y2Coord)))
 (setq dbId (dbMoveFig dbId nil (list -xShift:-yShift "R0")))
 (setq pinId (dbCreatePin net dbId))
 pinId~>accessDir = allDir
 (dbCreateProp tcCellView "topLayer" "list" layer2)
 (dbCreateProp tcCellView "topLayerPinBbox" "list" dbId~>bBox)
 
 ;; draw layer2 implant
 (when (and layer2Implant implant)
     (setq dbId (dbCreateRect tcCellView layer2Implant
			      (list (list (difference layer2X1Coord layer2ImpEnc)
					  (difference layer2Y1Coord layer2ImpEnc))
				    (list (plus layer2X2Coord layer2ImpEnc)
					  (plus layer2Y2Coord layer2ImpEnc)))))
     (setq dbId (dbMoveFig dbId nil (list -xShift:-yShift "R0")))
     (dbAddFigToNet dbId net)
 )
 
 (when (and viaLayerImplant implant)
     (setq dbId (dbCreateRect tcCellView viaLayerImplant
			      (list (list (difference (caar tcCellView~>contactLayerBbox)
						      viaLayerImpEnc)
					  (difference (cadar tcCellView~>contactLayerBbox) 
						      viaLayerImpEnc))
				    (list (plus (caadr tcCellView~>contactLayerBbox)
						viaLayerImpEnc)
					  (plus (cadadr tcCellView~>contactLayerBbox)
						viaLayerImpEnc)))))
     (setq dbId (dbMoveFig dbId nil (list -xShift:-yShift "R0")))
     (dbAddFigToNet dbId net)
 )
 
 (dbCreateProp tcCellView "bBoxEff" "list"
	       (list (list (min (caar tcCellView~>topLayerPinBbox)
				(caar tcCellView~>botLayerBbox))
			   (min (cadar tcCellView~>topLayerPinBbox)
				(cadar tcCellView~>botLayerBbox))
		     )
		     (list (max (caadr tcCellView~>topLayerPinBbox)
				(caadr tcCellView~>botLayerBbox))
			   (max (cadadr tcCellView~>topLayerPinBbox)
				(cadadr tcCellView~>botLayerBbox))
		     )))
 
)


(tfcDefineDeviceClassProp
 ;;(viewName       devClassName           propName          propValue)
;;;-------------------------------------------------------------------
 (symbolic        rcInterConPolImpClass  function          "contact")
)


;;; $Id: rcInterConSPolImpClass.il,v 1.3 2002/08/08 19:16:35 kmi Exp $
;;; 
;;; rcInterConSPolImpClass.il
;;; 
;;; Copyright (c) 1998 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Jan 26, 1998
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This file defines the class for a single contact
;;;   2 layer interconnect contact. It has enhancemnts
;;;   in control of layer2. It's primary usefulness is
;;;   for connected sources to well/substrate at a distance
;;;   from the transistor.  It allows implant layers to be
;;;   turned on and off. It also allows the polarity (n/p) to be toggled.
;;; 
;;; Revision History:
;;;   jim 08/14/98  Removed bevels since CCT doesn't support
;;;   jim 09/09/98  Renamed parameters to be "more" consistent with Cadence's 
;;;                 syEnhContact.
;;;   akr 12/07/98  Added X and Y enc of layer1
;;;   akr 01/05/99  Backed out X and Y enc changes
;;;   akr 01/06/99  Added X and Y enc of layer1 again
;;;   akg 02/22/99  Added maxvLayer as optional class parameter (similar to 2.0 flow)
;;;   cry 07/24/01  Fixed layer2ImpEnc to be used if given 
;;;                  (layer2Implant is unused in all flows)
;;;                 Added viaLayerImplant, viaLayerImplantEnc to allow specification
;;;                  of an implants enclosure of the contact
;;;   cry 07/25/01  Copied from rcInterConClass to create a contact with implants
;;;                 that can be turned on and off
;;;   cry 07/25/01  Copied from rcInterConImpClass to create a contact with implants
;;;                 that can have polarity toggled.
;;;   cry 08/07/01  Copied from rcInterConPolImpClass to add enhancements for
;;;                 layer2 control
;;;   kmi 06/14/02  Adding idLayer
;;;   kmi 08/08/02  changing the comment of deltaw&deltal: extra w&l for layer2 (not for layer1)
;;;                 adding inLayerWidth
;;; 

(putpropqq rcInterConSPolImpClass "$Id: rcInterConSPolImpClass.il,v 1.3 2002/08/08 19:16:35 kmi Exp $" SCCS)

(tcCreateDeviceClass
 "symbolic" "rcInterConSPolImpClass"
 ;; class parameters
 (
  (layer1         "hilite")    ; the layer (& purpose) of layer1
  (layer2     "prBoundary")    ; the layer (& purpose) of layer2
  (viaLayer           "y4")    ; the layer (& purpose) of layer1-2 contacts
  (maxvLayer           nil)    ; the (optional) recognition layer to be drawn identical to layer1
  (viaLayerX           0.0)    ; the size of viaLayer in the X direction
  (viaLayerY           0.0)    ; the size of viaLayer in the Y direction
  (encByLayer1         0.0)    ; layer 1 enclosure of contact
  (layer1XEnc          0.0)    ; layer 1 X enclosure of contact
  (layer1YEnc          0.0)    ; layer 1 Y enclosure of contact
  (layer2AdjEnc        0.0)    ; layer 2 adjacent edge enclosure of contact
  (layer2AnyEnc        0.0)    ; layer 2 any edge enclosure of contact
  (layer1Implant       nil)         ; layer 1 implant layer list (inWell=nil:inWell=t)
  (layer1ImpEnc     (list 0.0 0.0)) ; layer 1 implant enclosure list (inWell=nil:inWell=t)
  (layer2Implant       nil)         ; layer 2 implant layer list (inWell=nil:inWell=t)
  (layer2ImpEnc     (list 0.0 0.0)) ; layer 2 implant enclosure list (inWell=nil:inWell=t)
  (viaLayerImplant     nil)         ; viaLayer implant layer list (inWell=nil:inWell=t)
  (viaLayerImpEnc   (list 0.0 0.0)) ; viaLayer implant enclosure list (inWell=nil:inWell=t)
  (wellLayer           nil)    ; the layer to be drawn for the well when inWell and implants are on
  (wellLayerEnc        0.0)    ; the amount by which the wellLayer must enclose layer1
  (idLayer           nil)      ;;; the layer (& purpose) of idLayer
  (idLayerEnc        0.0)      ;;; enclosure of layer 1 by idLayer
  (idLayerEncWell    0.0)      ;;; enclosure of wellLayer by idLayer
  (idEncWell         nil)      ;;; true for idLayer enclosures wellLayer
  (idLayerWidth      0.0)      ;;; idLayer minWidth
  (snapGrid (TECHgetProp snapGrid)) ; grid size
 )

 ;; formal parameters
 (
  (deltaw              0.0)    ; extra width for layer2 (x direction)
  (deltal              0.0)    ; extra length for layer2 (y direction)
  (implant             t)      ; toggles implants on/off.
  (inWell              t)      ; toggles polarity of implant. disregarded when
			       ;  implant is FALSE
  (rotate             "FALSE") ; to rotate layer1
 )

 ;; sanity check deltaw and l
 (when ( deltaw < 0 ) 
   (error "deltaw (%g) must be greater than or equal to 0.0\n" deltaw )
   )
 (when ( deltal < 0 )
   (error "deltal (%g) must be greater than or equal to 0.0\n" deltal )
   )
 
 ;; enforce adjacent edge enclosure >= any edge enclosure
 (if ( layer2AdjEnc < layer2AnyEnc ) then
   (setq layer2AdjEnc layer2AnyEnc)
   )
 
 ;; convert all boolean parameters to either t or nil
 ;; this way we can use the simple (when parameter) syntax
 ;; and speed up pcell evaluation and make code simpler
 (if (or (equal inWell t) (equal inWell "TRUE")) then
   (setq inWell t)
   else
   (setq inWell nil)
   )
 (if (or (equal implant t) (equal implant "TRUE")) then
   (setq implant t)
   else
   (setq implant nil)
   )
 (if (or (equal rotate t) (equal rotate "TRUE")) then
   (setq rotate t)
   else
   (setq rotate nil)
   )

 ; variables used in this pcell
 ; allDir       - list of right, left, top, bottom for pin access direction
 ; dbId         - temporary database id of the most recently created object
 ; layer1length - the length of layer1
 ; layer1width  - the width of layer1
 ; layer2length - the length of layer2
 ; layer2width  - the width of layer2
 ; net          - the net all of the shapes will be attached to
 ; pinId        - temporary pin id of the most recently created pin

 (setq allDir (list "right" "left" "top" "bottom"))
 (setq net (dbMakeNet tcCellView "ppd"))
 (when (stringp layer1)
     (setq layer1 (list layer1 "drawing"))
 )
 (when (stringp layer2)
     (setq layer2 (list layer2 "drawing"))
 )
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;; DERIVE EFFECTIVE IMPLANT LAYERS AND ENCLOSURES
 ;;; BASED ON POLARITY
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 (when implant
   (when layer1Implant
     (if inWell then
       (setq layer1Implant (cadr layer1Implant))
       (setq layer1ImpEnc  (cadr layer1ImpEnc))
       else
       (setq layer1Implant (car layer1Implant))
       (setq layer1ImpEnc  (car layer1ImpEnc))
       )
     )
   (when layer2Implant
     (if inWell then
       (setq layer2Implant (cadr layer2Implant))
       (setq layer2ImpEnc  (cadr layer2ImpEnc))
       else
       (setq layer2Implant (car layer2Implant))
       (setq layer2ImpEnc  (car layer2ImpEnc))
       )
     )
   (when viaLayerImplant
     (if inWell then
       (setq viaLayerImplant (cadr viaLayerImplant))
       (setq viaLayerImpEnc  (cadr viaLayerImpEnc))
       else
       (setq viaLayerImplant (car viaLayerImplant))
       (setq viaLayerImpEnc  (car viaLayerImpEnc))
       )
     )
   )

 
 ;; draw contact first, base other layers on this
 (setq dbId (dbCreateRect tcCellView viaLayer
			  (list (list 0.0       0.0)
				(list viaLayerX viaLayerY)
				)
			  )
       )
 (dbAddFigToNet dbId net)
 
 (dbCreateProp tcCellView "contactLayer" "list" viaLayer)
 (dbCreateProp tcCellView "contactLayerBbox" "list" 
	       (list 0.0:0.0
		     viaLayerX:viaLayerY
		     )
	       )
 (when (and viaLayerImplant implant )
   (setq dbId (dbCreateRect tcCellView viaLayerImplant
			    (list (list (difference (caar tcCellView~>contactLayerBbox)
						    viaLayerImpEnc)
					(difference (cadar tcCellView~>contactLayerBbox) 
						    viaLayerImpEnc))
				  (list (plus (caadr tcCellView~>contactLayerBbox)
					      viaLayerImpEnc)
					(plus (cadadr tcCellView~>contactLayerBbox)
					      viaLayerImpEnc)))))
   (dbAddFigToNet dbId net)
 )
 
 ;; draw layer1
 (cond ((equal encByLayer1 0.0)
	(setq layer1X layer1XEnc)
	(setq layer1Y layer1YEnc))
       (t 
	(setq layer1X encByLayer1)
	(setq layer1Y encByLayer1))
       )
 ;; calculate layer1 bounding box
 (if rotate then
   (setq layer1Bbox (list (list (minus layer1Y)
				(minus layer1X)
				)
			  (list (plus viaLayerX layer1Y)
				(plus viaLayerY layer1X)
				)
			  )
	 )
   else
   (setq layer1Bbox (list (list (minus layer1X)
				(minus layer1Y)
				)
			  (list (plus viaLayerX layer1X)
				(plus viaLayerY layer1Y)
				)
			  )
	 )
   )
 (setq dbId (dbCreateRect tcCellView layer1 layer1Bbox))
 (dbAddFigToNet dbId net)
 (setq pinId (dbCreatePin net dbId))
 pinId~>accessDir = allDir
 (dbCreateProp tcCellView "botLayer" "list" layer1)
 (dbCreateProp tcCellView "botLayerBbox" "list" layer1Bbox)

 ;; draw maxv layer if specified
 (when maxvLayer
     (setq dbId (dbCreateRect tcCellView maxvLayer layer1Bbox))
     (dbAddFigToNet dbId net)
     (setq pinId (dbCreatePin net dbId))
     pinId~>accessDir = allDir
     )
 
 ;; draw layer1 implant
 (when (and layer1Implant implant )
     (setq dbId (dbCreateRect tcCellView layer1Implant
			      (list (list (difference (caar  layer1Bbox) layer1ImpEnc)
					  (difference (cadar layer1Bbox) layer1ImpEnc)
					  )
				    (list (plus (caadr  layer1Bbox) layer1ImpEnc)
					  (plus (cadadr layer1Bbox) layer1ImpEnc)
					  )
				    )
			      )
	   )
     (dbAddFigToNet dbId net)
 )
 
 ;; draw well layer to enclosure of layer 1
 (when (and  wellLayer implant inWell)
   (setq wellLayerX1 (difference (caar layer1Bbox) wellLayerEnc))
   (setq wellLayerY1 (difference (cadar layer1Bbox) wellLayerEnc))
   (setq wellLayerX2 (plus (caadr layer1Bbox) wellLayerEnc))
   (setq wellLayerY2 (plus (cadadr layer1Bbox) wellLayerEnc))
   (setq dbId (dbCreateRect tcCellView wellLayer
                            (list wellLayerX1:wellLayerY1 wellLayerX2:wellLayerY2)))
 )

 (when idLayer

   (if (and wellLayer inWell implant idEncWell) then
       (setq dbId (dbCreateRect tcCellView idLayer
                            (list (list (difference wellLayerX1 idLayerEncWell)
                                        (difference wellLayerY1 idLayerEncWell))
                                  (list (plus wellLayerX2 idLayerEncWell)
                                        (plus wellLayerY2 idLayerEncWell)))))

    else
     ;; idLayer minWidth check
     (setq layer1Xwidth (abs (difference (caadr layer1Bbox) (caar layer1Bbox))))
     (setq layer1Ywidth (abs (difference (cadadr layer1Bbox) (cadar layer1Bbox))))
     (setq idWidthX (plus (times 2 idLayerEnc) layer1Xwidth))
     (setq idWidthY (plus (times 2 idLayerEnc) layer1Ywidth))
     (if (lessp idWidthX idLayerWidth) then
       (setq idLayerEncX (quotient (difference idLayerWidth layer1Xwidth) 2))
       (setq idLayerEncX (times (ceiling (plus (quotient idLayerEncX snapGrid) -1e-6)) snapGrid))
      else 
       (setq idLayerEncX idLayerEnc)
     )
     (if (lessp idWidthY idLayerWidth) then
       (setq idLayerEncY (quotient (difference idLayerWidth layer1Ywidth) 2))
       (setq idLayerEncY (times (ceiling (plus (quotient idLayerEncY snapGrid) -1e-6)) snapGrid))
      else
       (setq idLayerEncY idLayerEnc)
     )
       (setq dbId (dbCreateRect tcCellView idLayer
                            (list (list (difference (caar layer1Bbox) idLayerEncX)
                                        (difference (cadar layer1Bbox) idLayerEncY))
                                  (list (plus (caadr layer1Bbox) idLayerEncX)
                                        (plus (cadadr layer1Bbox) idLayerEncY)))))
   )
   (dbAddFigToNet dbId net)
 ) ;; end when idLayer



 ;; calculate layer2's bounding box based on deltaw and deltal given
 ;; and centered around contact
 ;; layer2AdjEnc will always be >= layer2AnyEnc
 ;; note: encountered a bit of a round off issue when
 ;; deltaw == layer2AdjEnc, so we just make sure...
 (if (lessp deltaw (difference (difference layer2AdjEnc layer2AnyEnc) 0.000001) ) then
   (setq layer2DeltaY layer2AdjEnc)
   else
   (setq layer2DeltaY layer2AnyEnc)
   )
 (setq layer2Bbox (list (list (minus (plus layer2AnyEnc deltaw))
			      (minus layer2DeltaY)
			      )
			(list (plus viaLayerX 
				    layer2AnyEnc
				    deltaw)
			      (plus viaLayerY
				    deltal
				    layer2DeltaY)
			      )
			)
       )
 ;; draw layer2
 (setq dbId (dbCreateRect tcCellView layer2 layer2Bbox))
 (setq pinId (dbCreatePin net dbId))
 pinId~>accessDir = allDir
 (dbCreateProp tcCellView "topLayer" "list" layer2)
 (dbCreateProp tcCellView "topLayerPinBbox" "list" layer2Bbox)

 ;; draw layer2 implant
 (when (and layer2Implant implant )
     (setq dbId (dbCreateRect tcCellView layer2Implant
			 (list (list (difference (caar  layer2Bbox) layer2ImpEnc)
				     (difference (cadar layer2Bbox) layer2ImpEnc))
			       (list (plus (caadr  layer2Bbox) layer2ImpEnc)
				     (plus (cadadr layer2Bbox) layer2ImpEnc)))))
     (dbAddFigToNet dbId net)
 )
 
 
)


(tfcDefineDeviceClassProp
;;(viewName       devClassName           propName          propValue)
;;;-------------------------------------------------------------------
 (symbolic        rcInterConSPolImpClass  function          "contact")
)
;;; 
;;; $Id: rc3InterConCenPolImpClass.il,v 1.4 2002/08/08 19:16:08 kmi Exp $
;;; 
;;; rc3InterConCenPolImpClass.il
;;; 
;;; Copyright (c) 2001 by Cypress Semiconductor
;;; Cypress Kentucky CAD Center (KYCC)
;;; 
;;; Date  : Sept. 20, 2001
;;; Author: Cory Davis/CAD (cry) @ KYCC
;;; 
;;; Description:
;;;   This file defines the class for the centered three level 
;;;   (level 3 optional) contact with option for row/column based
;;;   control or layer1 size control. It allows implant layers to be
;;;   turned on and off. It also allows the polarity (n/p) to be toggled.
;;; 
;;; Revision History:
;;;   cry 09/25/01  initial version
;;;   cry 09/25/01  removed property that proved troublesome at the class level
;;;   kmi 06/13/02  adding idLayer
;;;   kmi 08/08/02  adding idLayerWidth
;;;

(putpropqq rcInterConPolImpClass "$Id: rc3InterConCenPolImpClass.il,v 1.4 2002/08/08 19:16:08 kmi Exp $" SCCS)

(tcCreateDeviceClass
 "symbolic" "rc3InterConCenPolImpClass"
 ;; class parameters
 (
  (layer1         "hilite")    ;;; the layer (& purpose) of layer1
  (layer2     "prBoundary")    ;;; the layer (& purpose) of layer2
  (layer3              nil)    ;;; Metal layer
  (via1Layer          "y4")    ;;; the layer (& purpose) of layer1-2 contacts
  (via2Layer           nil)    ;;; the layer (& purpose) of layer2-3 contacts
  (layer1Width         0.0)    ;;; Width of layer1
  (layer1XEncVia1      0.0)    ;;; layer 1 X enclosure of via1
  (layer1YEncVia1      0.0)    ;;; layer 1 Y enclosure of via1
  (layer2XEncVia1      0.0)    ;;; layer 2 X enclosure of via1
  (layer2YEncVia1      0.0)    ;;; layer 2 Y enclosure of via1
  (layer2XEncVia2      0.0)    ;;; layer 2 X enclosure of via2
  (layer2YEncVia2      0.0)    ;;; layer 2 Y enclosure of via2
  (layer3XEncVia2      0.0)    ;;; layer3 enclosure over via2
  (layer3YEncVia2      0.0)    ;;; layer3 enclosure over via2
  (wellLayer           nil)    ;;; the layer (& purpose) of well
  (wellLayerEnc        0.0)    ;;; enclosure of layer 1 by wellLayer
  (idLayer           nil)      ;;; the layer (& purpose) of idLayer
  (idLayerEnc        0.0)      ;;; enclosure of layer 1 by idLayer
  (idLayerEncWell    0.0)      ;;; enclosure of wellLayer by idLayer
  (idEncWell         nil)      ;;; true for idLayer enclosures wellLayer
  (idLayerWidth      0.0)      ;;; idLayer minWidth
  (layer1Implant       nil)      ;;; layer 1 implant layer list (inWell=nil:inWell=t)
  (layer1ImpEnc  (list 0.0 0.0)) ;;; layer 1 implant enclosure list (inWell=nil:inWell=t)
  (layer2Implant       nil)      ;;; layer 2 implant layer list (inWell=nil:inWell=t)
  (layer2ImpEnc  (list 0.0 0.0)) ;;; layer 2 implant enclosure list (inWell=nil:inWell=t)
  (layer3Implant       nil)      ;;; layer 3 implant layer list (inWell=nil:inWell=t)
  (layer3ImpEnc  (list 0.0 0.0)) ;;; layer 3 implant enclosure list (inWell=nil:inWell=t)
  (via1Implant         nil)      ;;; via1Layer implant layer list (inWell=nil:inWell=t)
  (via1ImpEnc    (list 0.0 0.0)) ;;; via1Layer implant enclosure list (inWell=nil:inWell=t)
  (via2Implant         nil)      ;;; via2Layer implant layer list (inWell=nil:inWell=t)
  (via2ImpEnc    (list 0.0 0.0)) ;;; via2Layer implant enclosure list (inWell=nil:inWell=t)
  (via1Width           0.0)    ;;; width of contact
  (via1Length          0.0)    ;;; length of contact
  (via1Spacing         0.0)    ;;; Min spacing between contacts
  (via2Width           0.0)    ;;; Width of second contact
  (via2Length          0.0)    ;;; Length of second contact 
  (via2Spacing         0.0)    ;;; Min spacing between second contacts 
  (snapGrid            (TECHgetProp snapGrid))
  )
 
 ;; formal parameters
 (  
  (rotL1EncV1      "FALSE")
  (rotL2EncV1      "FALSE")
  (rotL2EncV2      "FALSE")
  (rotL3EncV2      "FALSE")
  (noLayer3              t)
  (fullLayer2      "FALSE")
  (RowCol          "FALSE")
  (inWell          "FALSE")
  (implant               t)
  (row                   1)
  (column                1)
  (layer1W             0.0)
  (layer1L             0.0)
  )
 
 ;; convert all boolean parameters to either t or nil
 ;; this way we can use the simple (when parameter) syntax
 ;; and speed up pcell evaluation and make code simpler
 (if (or (equal inWell t) (equal inWell "TRUE")) then
   (setq inWell t)
   else
   (setq inWell nil)
   )
 (if (or (equal implant t) (equal implant "TRUE")) then
   (setq implant t)
   else
   (setq implant nil)
   )
 (if (or (equal rotL1EncV1 t) (equal rotL1EncV1 "TRUE")) then
   (setq rotL1EncV1 t)
   else
   (setq rotL1EncV1 nil)
   )
 (if (or (equal rotL2EncV1 t) (equal rotL2EncV1 "TRUE")) then
   (setq rotL2EncV1 t)
   else
   (setq rotL2EncV1 nil)
   )
 (if (or (equal rotL2EncV2 t) (equal rotL2EncV2 "TRUE")) then
   (setq rotL2EncV2 t)
   else
   (setq rotL2EncV2 nil)
   )
 (if (or (equal rotL3EncV2 t) (equal rotL3EncV2 "TRUE")) then
   (setq rotL3EncV2 t)
   else
   (setq rotL3EncV2 nil)
   )
 (if (or (equal noLayer3 t) (equal noLayer3 "TRUE")) then
   (setq noLayer3 t)
   else
   (setq noLayer3 nil)
   )
 (if (or (equal fullLayer2 t) (equal fullLayer2 "TRUE")) then
   (setq fullLayer2 t)
   else
   (setq fullLayer2 nil)
   )
 (if (or (equal RowCol t) (equal RowCol "TRUE")) then
   (setq RowCol t)
   else
   (setq RowCol nil)
   )
 
 (when rotL1EncV1
   (setq temp layer1XEncVia1)
   (setq layer1XEncVia1 layer1YEncVia1)
   (setq layer1YEncVia1 temp)
   )
 
 (when rotL2EncV1
   (setq temp layer2XEncVia1)
   (setq layer2XEncVia1 layer2YEncVia1)
   (setq layer2YEncVia1 temp)
   )
 
 (when rotL2EncV2
   (setq temp layer2XEncVia2)
   (setq layer2XEncVia2 layer2YEncVia2)
   (setq layer2YEncVia2 temp)
   )
 
 (when rotL3EncV2
   (setq temp layer3XEncVia2)
   (setq layer3XEncVia2 layer3YEncVia2)
   (setq layer3YEncVia2 temp)
   )

 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;; DERIVE EFFECTIVE IMPLANT LAYERS AND INCLOSURES
 ;;; BASED ON POLARITY
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 (when implant
   (when layer1Implant
     (if inWell then
       (setq layer1Implant (cadr layer1Implant))
       (setq layer1ImpEnc  (cadr layer1ImpEnc))
       else
       (setq layer1Implant (car layer1Implant))
       (setq layer1ImpEnc  (car layer1ImpEnc))
       )
     )
   (when layer2Implant
     (if inWell then
       (setq layer2Implant (cadr layer2Implant))
       (setq layer2ImpEnc  (cadr layer2ImpEnc))
       else
       (setq layer2Implant (car layer2Implant))
       (setq layer2ImpEnc  (car layer2ImpEnc))
       )
     )
   (when layer3Implant
     (if inWell then
       (setq layer3Implant (cadr layer3Implant))
       (setq layer3ImpEnc  (cadr layer3ImpEnc))
       else
       (setq layer3Implant (car layer3Implant))
       (setq layer3ImpEnc  (car layer3ImpEnc))
       )
     )
   (when via1Implant
     (if inWell then
       (setq via1Implant (cadr via1Implant))
       (setq via1ImpEnc  (cadr via1ImpEnc))
       else
       (setq via1Implant (car via1Implant))
       (setq via1ImpEnc  (car via1ImpEnc))
       )
     )
   (when via2Implant
     (if inWell then
       (setq via2Implant (cadr via2Implant))
       (setq via2ImpEnc  (cadr via2ImpEnc))
       else
       (setq via2Implant (car via2Implant))
       (setq via2ImpEnc  (car via2ImpEnc))
       )
     )
   )

 (setq allDir (list "right" "left" "top" "bottom"))
 (setq net (dbMakeNet tcCellView "ppd"))

 (setq via1XPitch (plus via1Spacing via1Width))
 (setq via1YPitch (plus via1Spacing via1Length))
 (setq via2XPitch (plus via2Spacing via2Width))
 (setq via2YPitch (plus via2Spacing via2Length))
 
 (if RowCol then
   (setq rowVia1 (max row 1))
   (setq colVia1 (max column 1))
   (setq layer1XSize (plus (times colVia1 via1XPitch)
			   -via1Spacing
			   layer1XEncVia1 layer1XEncVia1))
   (setq layer1YSize (plus (times rowVia1 via1YPitch)
			   -via1Spacing
			   layer1YEncVia1 layer1YEncVia1))
   
   else ;; controlled by layer1 size
   
   ;; enforce at least one row and column
   (if (lessp layer1W (max layer1Width (plus via1Width (times 2 layer1XEncVia1)))) then
     (error "rc3InterConCenPolImpClass: layer1W %g is too narrow (min %g)\n" 
	    layer1W (plus via1Width (times 2 layer1XEncVia1)))
     )
   (if (lessp layer1L (max layer1Width (plus via1Length (times 2 layer1YEncVia1)))) then
     (error "rc3InterConCenPolImpClass: layer1L %g is too narrow (min %g)\n" 
	    layer1L (plus via1Length (times 2 layer1YEncVia1)))
     )
   
   (setq layer1XSize layer1W)
   (setq layer1YSize layer1L)
   
   )
 
 (setq rowVia1 (max (fix (plus (quotient (plus layer1YSize
					       via1Spacing 
					       (minus (times 2 layer1YEncVia1))
					       )
					 via1YPitch)
			       1e-5)
			 )
		    1 ) ;; ensure at least 1
       )
 (setq colVia1 (max (fix (plus (quotient (plus layer1XSize
					       via1Spacing 
					       (minus (times 2 layer1XEncVia1))
					       )
					 via1XPitch)
			       1e-5)
			 )
		    1 ) ;; ensure at least 1
       )
 (setq layer1Bbox (list (list  0.0 0.0)
			(list layer1XSize layer1YSize)))
 
 
 (setq dbId (dbCreateRect tcCellView layer1 layer1Bbox))
 (dbAddFigToNet dbId net)
 (setq pinId (dbCreatePin net dbId))
 pinId~>accessDir = allDir
 (dbCreateProp tcCellView "botLayer" "list" layer1)
 (dbCreateProp tcCellView "botLayerBbox" "list" layer1Bbox)
  
 ;; draw layer1 implant
 (when (and implant layer1Implant)
   (setq dbId (dbCreateRect tcCellView layer1Implant 
			    (list (list -layer1ImpEnc -layer1ImpEnc)
				  (list (plus layer1XSize  layer1ImpEnc)
					(plus layer1YSize  layer1ImpEnc)))))
   (dbAddFigToNet dbId net)
   ) ;; end when layer1Implant
 
 ;; draw wellLayer
 (when (and wellLayer inWell implant)
   (setq wellLayerX1 (difference (caar layer1Bbox) wellLayerEnc))
   (setq wellLayerY1 (difference (cadar layer1Bbox) wellLayerEnc))
   (setq wellLayerX2 (plus (caadr layer1Bbox) wellLayerEnc))
   (setq wellLayerY2 (plus (cadadr layer1Bbox) wellLayerEnc)) 
   (setq dbId (dbCreateRect tcCellView wellLayer
			    (list wellLayerX1:wellLayerY1 wellLayerX2:wellLayerY2)))
   (dbAddFigToNet dbId net)
 ) ;; end when wellLayer and inWell

 ;; draw idLayer
 (when idLayer
   (if (and wellLayer inWell implant idEncWell) then
       (setq dbId (dbCreateRect tcCellView idLayer
                            (list (list (difference wellLayerX1 idLayerEncWell)
                                        (difference wellLayerY1 idLayerEncWell))
                                  (list (plus wellLayerX2 idLayerEncWell)
                                        (plus wellLayerY2 idLayerEncWell)))))

    else
       (setq layer1Xwidth (abs (difference (caar layer1Bbox) (caadr layer1Bbox))))
       (setq layer1Ywidth (abs (difference (cadar layer1Bbox) (cadadr layer1Bbox))))
       (setq idWidthX (plus (times 2 idLayerEnc) layer1Xwidth))
       (setq idWidthY (plus (times 2 idLayerEnc) layer1Ywidth))
       (if (lessp idWidthX idLayerWidth) then
         (setq idLayerEncX (quotient (difference idLayerWidth layer1Xwidth) 2))
         (setq idLayerEncX (times (ceiling (plus (quotient idLayerEncX snapGrid) -1e-6)) snapGrid))
        else
         (setq idLayerEncX idLayerEnc))
       (if (lessp idWidthY idLayerWidth) then
         (setq idLayerEncY (quotient (difference idLayerWidth layer1Ywidth) 2))
         (setq idLayerEncY (times (ceiling (plus (quotient idLayerEncY snapGrid) -1e-6)) snapGrid))
        else
         (setq idLayerEncY idLayerEnc))
       (setq dbId (dbCreateRect tcCellView idLayer
                            (list (list (difference (caar layer1Bbox) idLayerEncX)
                                        (difference (cadar layer1Bbox) idLayerEncY))
                                  (list (plus (caadr layer1Bbox) idLayerEncX)
                                        (plus (cadadr layer1Bbox) idLayerEncY)))))
   )
   (dbAddFigToNet dbId net)
 ) ;; end when idLayer

  (setq via1Yoffset (max 0.0 
			 (quotient (plus layer1YSize
					 (times -2 layer1YEncVia1)
					 via1Spacing
					 (times -rowVia1 via1YPitch)
					 )
				   2)))
  (setq via1Yoffset (times (fix (plus (quotient via1Yoffset snapGrid) 1e-5)) snapGrid))
  (setq via1Ystart (plus (cadar layer1Bbox) via1Yoffset layer1YEncVia1))
  (setq via1Xoffset (max 0.0
			 (quotient (plus layer1XSize
					 (times -2 layer1XEncVia1)
					 via1Spacing
					 (times -colVia1 via1XPitch)
					 )
				   2)))
  (setq via1Xoffset (times (fix (plus (quotient via1Xoffset snapGrid) 1e-5)) snapGrid))
  (setq via1Xstart (plus via1Xoffset (caar layer1Bbox) layer1XEncVia1))
  
  (setq theY via1Ystart)
  ;; draw via1
  (for r 1 rowVia1
       ;; initialize the x coordinate as the layer1 enclosure of via1.
       (setq theX via1Xstart)
       (for col 1 colVia1
	    (setq dbId (dbCreateRect tcCellView via1Layer
				     (list  theX:theY
					    (plus theX via1Width):(plus theY via1Length))))
	    (dbAddFigToNet dbId net)
	    (setq theX (plus theX via1XPitch))
	    )
       (setq theY (plus theY via1YPitch))
       )
  (setq via1Bbox (list (list via1Xstart via1Ystart)
		       (list (caadr dbId~>bBox) (cadadr dbId~>bBox))))
  
  (when (and implant via1Implant)
    (setq dbId (dbCreateRect tcCellView via1Implant
			     (list (list (difference (caar via1Bbox) via1ImpEnc)
					 (difference (cadar via1Bbox) via1ImpEnc))
				   (list (plus (caadr via1Bbox) via1ImpEnc)
					 (plus (cadadr via1Bbox) via1ImpEnc)
					 ))))
    (dbAddFigToNet dbId net)
    )


  ;; based on the contacts, calculate layer2's width & length
  (setq layer2Bbox (list (list (difference via1Xstart layer2XEncVia1)
			       (difference via1Ystart layer2YEncVia1)
			       )
			 (list (plus (caadr via1Bbox) layer2XEncVia1)
			       (plus (cadadr via1Bbox) layer2YEncVia1)
			       )))
  (when fullLayer2
    (setq layer2Bbox (list (list (min (caar layer2Bbox) (caar layer1Bbox))
				 (min (cadar layer2Bbox) (cadar layer1Bbox)))
			   (list (max (caadr layer2Bbox) (caadr layer1Bbox))
				 (max (cadadr layer2Bbox) (cadadr layer1Bbox)))
			   ))
    )
  
  (if (or (null layer3)  noLayer3) then
    ;; layer2 is the top layer, so we're done
    (setq dbId (dbCreateRect tcCellView layer2 layer2Bbox))
    (dbAddFigToNet dbId net)
    (setq pinId (dbCreatePin net dbId))
    pinId~>accessDir = allDir
    (dbCreateProp tcCellView "topLayer" "list" layer2)
    (dbCreateProp tcCellView "topLayerPinBbox" "list" layer2Bbox)
    (when (and implant layer2Implant)
      (setq dbId (dbCreateRect tcCellView layer2Implant
			       (list (list (difference (caar layer2Bbox) layer2ImpEnc)
					   (difference (cadar layer2Bbox) layer2ImpEnc))
				     (list (plus (caadr layer2Bbox) layer2ImpEnc)
					   (plus (cadadr layer2Bbox) layer2ImpEnc)
					   ))))
      (dbAddFigToNet dbId net)
      )
    
    else
    ;; layer3 is the top layer, so do all this and draw layer2
    (setq layer2XSize (difference (caadr layer2Bbox) (caar layer2Bbox)))
    (setq layer2YSize (difference (cadadr layer2Bbox) (cadar layer2Bbox)))

    (setq rowVia2 (max (fix (plus (quotient (plus layer2YSize
						  via2Spacing 
						  (minus (times 2 layer2YEncVia2))
						  )
					    via2YPitch)
				  1e-5)
			    )
		       1 ) ;; ensure at least 1
	  )
    (setq colVia2 (max (fix (plus (quotient (plus layer2XSize
						  via2Spacing 
						  (minus (times 2 layer2XEncVia2))
						  )
					    via2XPitch)
				  1e-5)
			    )
		       1 ) ;; ensure at least 1
	  )
    
    ;; calculate how much extra we have to add to each side of layer 2
    ;; to make it big enough to hold the via2's we are adding
    ;; (0.0 except when we have to force a min of 1 via2)
    (setq layer2YSizeV2 (plus (times via2YPitch rowVia2)
			      (times 2.0 layer2YEncVia2)
			      -via2Spacing))
    (setq layer2YExtra  (max 0.0
			     (difference layer2YSizeV2 layer2YSize)
			     ))
    (setq layer2YExtra  (times (ceiling (plus (quotient (quotient layer2YExtra 2.0)
							snapGrid) -1e-5)) snapGrid))

    (setq layer2XSizeV2 (plus (times via2XPitch colVia2)
			      (times 2.0 layer2XEncVia2)
			      -via2Spacing))
    (setq layer2XExtra  (max 0.0
			     (difference layer2XSizeV2 layer2XSize)
			     ))
    (setq layer2XExtra  (times (ceiling (plus (quotient (quotient layer2XExtra 2.0)
							snapGrid) -1e-5)) snapGrid))

    ;; calculate the new layer2Bbox based on the additional size
    (setq layer2Bbox    (list (list (difference (caar layer2Bbox) layer2XExtra)
				    (difference (cadar layer2Bbox) layer2YExtra)
				    )
			      (list (plus       (caadr layer2Bbox) layer2XExtra)
				    (plus       (cadadr layer2Bbox) layer2YExtra)
				    )
			      ))
    ;; recalculate the size of layer2
    (setq layer2XSize (difference (caadr layer2Bbox) (caar layer2Bbox)))
    (setq layer2YSize (difference (cadadr layer2Bbox) (cadar layer2Bbox)))
    
    ;; go ahead and draw layer2 now, since we have all the information
    (setq dbId (dbCreateRect tcCellView layer2 layer2Bbox))
    (dbAddFigToNet dbId net)
    (setq pinId (dbCreatePin net dbId))
    pinId~>accessDir = allDir
    
    (when (and implant layer2Implant)
      (setq dbId (dbCreateRect tcCellView layer2Implant
			       (list (list (difference (caar layer2Bbox) layer2ImpEnc)
					   (difference (cadar layer2Bbox) layer2ImpEnc))
				     (list (plus (caadr layer2Bbox) layer2ImpEnc)
					   (plus (cadadr layer2Bbox) layer2ImpEnc)
					   ))))
      (dbAddFigToNet dbId net)
      )

    (setq via2Yoffset (max 0.0
			   (quotient (plus layer2YSize
					   (times -2 layer2YEncVia2)
					   via2Spacing
					   (times -rowVia2 via2YPitch)
					   )
				     2)))
    (setq via2Yoffset (times (fix (plus (quotient via2Yoffset snapGrid) 1e-5)) snapGrid))
    (setq via2Ystart (plus (cadar layer2Bbox) via2Yoffset layer2YEncVia2))
    (setq via2Xoffset (max 0.0
			   (quotient (plus layer2XSize
					   (times -2 layer2XEncVia2)
					   via2Spacing
					   (times -colVia2 via2XPitch)
					   )
				     2)))
    (setq via2Xoffset (times (fix (plus (quotient via2Xoffset snapGrid) 1e-5)) snapGrid))
    (setq via2Xstart (plus via2Xoffset (caar layer2Bbox) layer2XEncVia2))
    
    (setq theY via2Ystart)
    ;; draw via2
    (for r 1 rowVia2
	 ;; initialize the x coordinate as the layer2 enclosure of via2.
	 (setq theX via2Xstart)
	 (for col 1 colVia2
	      (setq dbId (dbCreateRect tcCellView via2Layer
				       (list  theX:theY
					      (plus theX via2Width):(plus theY via2Length))))
	      (dbAddFigToNet dbId net)
	      (setq theX (plus theX via2XPitch))
	      )
	 (setq theY (plus theY via2YPitch))
	 )
    (setq via2Bbox (list (list via2Xstart via2Ystart)
			 (list (caadr dbId~>bBox) (cadadr dbId~>bBox))))

    (when (and implant via2Implant)
      (setq dbId (dbCreateRect tcCellView via2Implant
			       (list (list (difference (caar via2Bbox) via2ImpEnc)
					   (difference (cadar via2Bbox) via2ImpEnc))
				     (list (plus (caadr via2Bbox) via2ImpEnc)
					   (plus (cadadr via2Bbox) via2ImpEnc)
					   ))))
      (dbAddFigToNet dbId net)
      )

    ;; based on the contacts, calculate layer3's width & length
    (setq layer3Bbox (list (list (difference via2Xstart layer3XEncVia2)
				 (difference via2Ystart layer3YEncVia2)
				 )
			   (list (plus (caadr via2Bbox) layer3XEncVia2)
				 (plus (cadadr via2Bbox) layer3YEncVia2)
				 )))
    (setq dbId (dbCreateRect tcCellView layer3 layer3Bbox))
    (dbAddFigToNet dbId net)
    (setq pinId (dbCreatePin net dbId))
    pinId~>accessDir = allDir
    (dbCreateProp tcCellView "topLayer" "list" layer3)
    (dbCreateProp tcCellView "topLayerPinBbox" "list" layer3Bbox)

    (when (and implant layer3Implant)
      (setq dbId (dbCreateRect tcCellView layer3Implant
			       (list (list (difference (caar layer3Bbox) layer3ImpEnc)
					   (difference (cadar layer3Bbox) layer3ImpEnc))
				     (list (plus (caadr layer3Bbox) layer3ImpEnc)
					   (plus (cadadr layer3Bbox) layer3ImpEnc)
					   ))))
      (dbAddFigToNet dbId net)
      )

    )
  ) ;;tcCreateDevice

(tfcDefineDeviceClassProp
;;(viewName       devClassName           propName          propValue)
;;;-------------------------------------------------------------------
 (symbolic        rc3InterConCenPolImpClass        function          "contact")
)
 
;;; 
;;; $Id: rc3InterConClass.il,v 1.2 2001/09/07 14:00:12 cry Exp $
;;; 
;;; rc3InterConClass.il
;;; 
;;; Copyright (c) 1996 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Oct 17, 1996
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This file defines the class for the row and column based
;;; 2 and 3 layer interconnect contact.
;;; 
;;; Revision History:
;;;   syr 11/21/96  Changed the class property function
;;;   gtc 12/10/96  fixed bug with enclosures
;;;   syr 12/16/96  row and column should apply to both 
;;;                 via1 and via2 (designer review).
;;;   gtc 12/07/98  ported over and renamed in a hurry for v20 compatability
;;;                 with 3 layer contacts
;;;   cry 08/22/01  fixed enclosure bug where layer2 may not meet
;;;                 correct enclosure when layer2 enclosure of via2 and via1
;;;                 is different.
;;; 

(putpropqq rcInterConClass "$Id: rc3InterConClass.il,v 1.2 2001/09/07 14:00:12 cry Exp $" SCCS)

(tcCreateDeviceClass
 "symbolic" "rc3InterConClass"
 ;; class parameters
 (
  (layer1 "hilite")     ; the layer (& purpose) of layer1
  (layer2 "prBoundary") ; the layer (& purpose) of layer2
  (layer3 nil)          ; the layer (& purpose) of layer3
  (maxvLayer nil)       ; the (optional) recognition layer to be drawn
                        ; identical to layer1
  (via1Layer "y4")      ; the layer (& purpose) of layer1-2 contacts
  (via2Layer nil)       ; the layer (& purpose) of layer2-3 contacts
  (layer1Width 0.0)     ; the minimum width for layer1
  (layer2Width 0.0)     ; the minimum width for layer2
  (layer3Width 0.0)     ; the minimum width for layer3
  (via1Width 0.0)       ; the width of layer1-2 contacts
  (via1Space 0.0)       ; the spacing between layer1-2 contacts
  (via2Width 0.0)       ; the width of layer2-3 contacts
  (via2Space 0.0)       ; the spacing between layer2-3 contacts
  (layer1EncVia1 0.0)   ; layer 1 enclosure of layer1-2 contact
  (layer2XEncVia1 0.0)  ; layer 2 enclosure of layer1-2 contact
  (layer2YEncVia1 0.0)  ; layer 2 enclosure of layer1-2 contact
  (layer2EncVia2 0.0)   ; layer 2 enclosure of layer2-3 contact
  (layer3XEncVia2 0.0)  ; layer 3 enclosure of layer2-3 contact
  (layer3YEncVia2 0.0)  ; layer 3 enclosure of layer2-3 contact
 )

 ;; formal parameters
 (
  (row 1)             ; the number of rows of via1 and via2 contacts to place
  (column 1)          ; the number of columns of via1 and via2 contacts to place
 )

 ; variables used in this pcell
 ; allDir       - list of right, left, top, bottom for pin access direction
 ; c23column    - the number of columns of via2 contacts that can be placed
 ; c23row       - the number of rows of via2 contacts that can be placed
 ; col          - loop control variable, looping through all the columns
 ; contactPitch- the distance between the LL of two consecutive contacts
 ; dbId         - temporary database id of the most recently created object
 ; layer1length - the length of layer1
 ; layer1width  - the width of layer1
 ; layer2length - the length of layer2
 ; layer2width  - the width of layer2
 ; layer3length - the length of layer3
 ; layer3width  - the width of layer3
 ; minLayer2length- the minimum length of layer2 for a via2
 ; minLayer2width- the minimum width of layer2 for a via2
 ; net          - the net all of the shapes will be attached to
 ; pinId        - temporary pin id of the most recently created pin
 ; r            - loop control variable, looping through all the rows
 ; theX         - loop variable; the X origin of the next via to create
 ; theY         - loop variable; the Y origin of the next via to create
 ; via1XEncDifference- the difference in the X enclosures of via1 between layer1 and layer2
 ; via1YEncDifferenc- the difference in the Y enclosures of via1 between layer1 and layer2
 ; via2XEncDifference- the difference in the X enclosures of via2 between layer2 and layer3
 ; via2YEncDifference- the difference in the Y enclosures of via2 between layer2 and layer3

 (setq allDir (list "right" "left" "top" "bottom"))

 (setq net (dbMakeNet tcCellView "ppd"))

 (when (stringp layer1)
     (setq layer1 (list layer1 "drawing"))
 )
 (when (stringp layer2)
     (setq layer2 (list layer2 "drawing"))
 )
 
 (when (and layer3 (stringp layer3))
     (setq layer3 (list layer3 "drawing"))
 )

 ;; calculate the layer1 length
 (setq layer1length (max (plus (times 2 layer1EncVia1) (times column via1Width)
			       (times (difference column 1) via1Space))
			 layer1Width))

 ;; calculate the layer1 width
 (setq layer1width (max (plus (times 2 layer1EncVia1) (times row via1Width)
			      (times (difference row 1) via1Space))
			layer1Width))

 ;; draw layer1
 (setq dbId (dbCreateRect tcCellView layer1
			  (list (list 0.0 0.0)
				(list layer1length layer1width))))
 (dbAddFigToNet dbId net)
 (setq pinId (dbCreatePin net dbId))
 pinId~>accessDir = allDir

 (when maxvLayer
     (setq dbId (dbCreateRect tcCellView maxvLayer
			      (list (list 0.0 0.0)
				    (list layer1length layer1width))))
     (dbAddFigToNet dbId net)
     (setq pinId (dbCreatePin net dbId))
     pinId~>accessDir = allDir
 )

 (dbCreateProp tcCellView "botLayer" "list" layer1)
 (dbCreateProp tcCellView "botLayerBbox" "list" dbId~>bBox)

 ;; draw all of the via1 contacts
 (setq contactPitch (plus via1Space via1Width))
 ;; initialize the y coordinate of the via1 rectangle.
 (setq theY layer1EncVia1)
 (for r 1 row
      ;; initailize the x coordinate as the layer1 enclosure of via1.
      (setq theX layer1EncVia1)
      (for col 1 column
	 (dbId = (dbCreateRect tcCellView via1Layer
			       (list (list theX theY)
				     (list (plus theX via1Width)
					   (plus theY via1Width)))))
	 (dbAddFigToNet dbId net)
	 (setq theX (plus theX contactPitch))
     )
     (setq theY (plus theY contactPitch))
 )

 (dbCreateProp tcCellView "contactLayer" "list" via1Layer)
 (dbCreateProp tcCellView "contactLayerBbox" "list" 
	       (list layer1EncVia1:layer1EncVia1
		     (caadr dbId~>bBox):(cadadr dbId~>bBox)))

 ;; based on the layer1-2 contacts, calculate layer2's width & length
 (setq layer2length (max (plus (times 2 layer2XEncVia1) (times column via1Width)
			       (times (difference column 1) via1Space))
			 layer2Width))
 (setq layer2width (max (plus (times 2 layer2YEncVia1) (times row via1Width)
			      (times (difference row 1) via1Space))
			layer2Width))

 (setq layer2X1Coord (difference layer1EncVia1 layer2XEncVia1))
 (setq layer2Y1Coord (difference layer1EncVia1 layer2YEncVia1))

 (when layer3
     ;; we need to save these values before we overwrite
     ;; this is where these should be for enclosure of via1
     (setq layer2RightEdge (plus layer2X1Coord layer2length))
     (setq layer2TopEdge   (plus layer2Y1Coord layer2width))
     (setq layer2LeftEdge layer2X1Coord)
     (setq layer2BotEdge  layer2Y1Coord)
     
     ;; calculate the layer2 length required to cover via2
     (setq layer2length (plus (times 2 layer2EncVia2) (times column via2Width)
			      (times (difference column 1) via2Space))
     )
     
     ;; calculate the layer2 width required to cover via2
     ;; We will draw this layer later on.
     (setq layer2width (plus (times 2 layer2EncVia2) (times row via2Width)
			     (times (difference row 1) via2Space))
     )
     
     ;; this uses enclosure of via2 to ensure via2 starts at same
     ;; place as via1 when via2 enclosure is greater.
     (setq layer2X1Coord (difference layer1EncVia1 layer2EncVia2))
     (setq layer2Y1Coord (difference layer1EncVia1 layer2EncVia2))
     
     ;; we now calculate to ensure layer2 meets enclosures based
     ;; on requirements for via1 and via2.
     (setq layer2RightEdge (max layer2RightEdge (plus layer2X1Coord layer2length)))
     (setq layer2TopEdge   (max layer2TopEdge   (plus layer2Y1Coord layer2width)))
     (setq layer2X1Coord   (min layer2LeftEdge  layer2X1Coord))
     (setq layer2Y1Coord   (min layer2BotEdge   layer2Y1Coord))
     (setq layer2length    (difference layer2RightEdge layer2X1Coord))
     (setq layer2width     (difference layer2TopEdge layer2Y1Coord))


     ;; calculate the length of layer3 as well
     (setq layer3length (max (plus (times 2.0 layer3XEncVia2)
				   (times column via2Width)
				   (times (difference column 1) via2Space))
			     layer3Width))
     
     ;; calculate the width of layer3.
     (setq layer3width (max (plus (times 2.0 layer3YEncVia2)
				  (times row via2Width)
				  (times (difference row 1) via2Space))
			    layer3Width))

     ;; set the contact pitch for via2
     (setq contactPitch (plus via2Space via2Width))
     ;; initialize the X and Y coordinates for via2
     (setq theY (plus layer2Y1Coord layer2EncVia2))
     (setq theX (plus layer2X1Coord layer2EncVia2))
     ;; From the X coordinates calculate the layer3 coordinates
     (setq layer3X1Coord (difference theX layer3XEncVia2))
     (setq layer3Y1Coord (difference theY layer3YEncVia2))
     (for r 1 row
	  ;; Calculate the via2 X coordinate
	  (setq theX (plus layer2X1Coord layer2EncVia2))
	  (for col 1 column
	       (setq dbId (dbCreateRect tcCellView via2Layer
					(list (list theX theY)
					      (list (plus theX via2Width)
						    (plus theY via2Width)))))
	       (dbAddFigToNet dbId net)
	       (setq theX (plus theX contactPitch))
	  )
	  (setq theY (plus theY contactPitch))
     )
     
 )

 (setq layer2X2Coord (plus layer2X1Coord layer2length))
 (setq layer2Y2Coord (plus layer2Y1Coord layer2width))

 ;; draw layer2
 (setq dbId (dbCreateRect tcCellView layer2
			  (list layer2X1Coord:layer2Y1Coord
				layer2X2Coord:layer2Y2Coord))
 )

 ;; Create a pin for this rectangle. This will allow us to route in layer2
 (setq pinId (dbCreatePin net dbId))
 pinId~>accessDir = allDir

 ;; Check if layer3 has to be drawn.
 (cond ((null layer3)
	;; If layer3 does not need to be drawn, then we are done.
	(dbCreateProp tcCellView "topLayer" "list" layer2)
	(dbCreateProp tcCellView "topLayerPinBbox" "list" dbId~>bBox)
       )
     (t
      ;; draw the layer3 rectangle and put the topLayer pin property
      (setq dbId (dbCreateRect tcCellView layer3
			       (list layer3X1Coord:layer3Y1Coord
				     (plus layer3X1Coord layer3length):(plus layer3Y1Coord layer3width)))
      )
      ;; create a pin from the layer3 rectangle.
      (setq pinId (dbCreatePin net dbId))
      pinId~>accessDir = allDir
      
      (dbCreateProp tcCellView "topLayer" "list" layer3)
      (dbCreateProp tcCellView "topLayerPinBbox" "list" dbId~>bBox)
     )
 )
)

(tfcDefineDeviceClassProp
;;(viewName       devClassName           propName          propValue)
;;;-------------------------------------------------------------------
 (symbolic        rc3InterConClass        function          "contact")
)
;;; 
;;; $Id: rc3InterConImpClass.il,v 1.2 2003/04/08 15:48:15 kmi Exp $
;;; 
;;; rc3InterConImpClass.il
;;; 
;;; Copyright (c) 1996 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Oct 17, 1996
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This file defines the class for the row and column based
;;; 2 and 3 layer interconnect contact.
;;; 
;;; Revision History:
;;;   syr 11/21/96  Changed the class property function
;;;   gtc 12/10/96  fixed bug with enclosures
;;;   syr 12/16/96  row and column should apply to both 
;;;                 via1 and via2 (designer review).
;;;   gtc 12/07/98  ported over and renamed in a hurry for v20 compatability
;;;                 with 3 layer contacts
;;;   cry 08/21/01  Copied from rc3InterConClass.il and
;;;                 added toggleable implant capability.
;;;   kmi 04/08/03  Added contactWidth and contactSpace params (SPR 15627)
;;; 

(putpropqq rc3InterConClass "$Id: rc3InterConImpClass.il,v 1.2 2003/04/08 15:48:15 kmi Exp $" SCCS)

(tcCreateDeviceClass
 "symbolic" "rc3InterConImpClass"
 ;; class parameters
 (
  (layer1 "hilite")     ; the layer (& purpose) of layer1
  (layer2 "prBoundary") ; the layer (& purpose) of layer2
  (layer3         nil)  ; the layer (& purpose) of layer3
  (maxvLayer      nil)  ; the (optional) recognition layer to be drawn
                        ; identical to layer1
  (via1Layer     "y4")  ; the layer (& purpose) of layer1-2 contacts
  (via2Layer      nil)  ; the layer (& purpose) of layer2-3 contacts
  (layer1Implant  nil)  ; the layer (& purpose) of the layer1 implant
  (layer2Implant  nil)  ; the layer (& purpose) of the layer2 implant
  (layer3Implant  nil)  ; the layer (& purpose) of the layer3 implant
  (via1Implant    nil)  ; the layer (& purpose) of the via1 implant
  (via2Implant    nil)  ; the layer (& purpose) of the via2 implant
  (layer1Width    0.0)  ; the minimum width for layer1
  (layer2Width    0.0)  ; the minimum width for layer2
  (layer3Width    0.0)  ; the minimum width for layer3
  (via1Width      0.0)  ; the width of layer1-2 contacts
  (via1Space      0.0)  ; the spacing between layer1-2 contacts
  (via2Width      0.0)  ; the width of layer2-3 contacts
  (via2Space      0.0)  ; the spacing between layer2-3 contacts
  (layer1EncVia1  0.0)  ; layer 1 enclosure of layer1-2 contact
  (layer2XEncVia1 0.0)  ; layer 2 enclosure of layer1-2 contact
  (layer2YEncVia1 0.0)  ; layer 2 enclosure of layer1-2 contact
  (layer2EncVia2  0.0)  ; layer 2 enclosure of layer2-3 contact
  (layer3XEncVia2 0.0)  ; layer 3 enclosure of layer2-3 contact
  (layer3YEncVia2 0.0)  ; layer 3 enclosure of layer2-3 contact
  (layer1ImpEnc   0.0)  ; enclosure of layer1 by layer1Implant
  (layer2ImpEnc   0.0)  ; enclosure of layer2 by layer2Implant
  (layer3ImpEnc   0.0)  ; enclosure of layer3 by layer3Implant
  (via1ImpEnc     0.0)  ; enclosure of via1Layer by via1Implant
  (via2ImpEnc     0.0)  ; enclosure of via2Layer by via2Implant
 )

 ;; formal parameters
 (
  (row           1) ; the number of rows of via1 and via2 contacts to place
  (column        1) ; the number of columns of via1 and via2 contacts to place
  (implant "FALSE") ; determines whether or not to draw implants
 )
 
 ;; convert all boolean parameters to either t or nil
 ;; this way we can use the simple (when parameter) syntax
 ;; and speed up pcell evaluation and make code simpler
 (if (or (equal implant t) (equal implant "TRUE")) then
   (setq implant t)
   else
   (setq implant nil)
   )

 ; variables used in this pcell
 ; allDir       - list of right, left, top, bottom for pin access direction
 ; c23column    - the number of columns of via2 contacts that can be placed
 ; c23row       - the number of rows of via2 contacts that can be placed
 ; col          - loop control variable, looping through all the columns
 ; contactPitch- the distance between the LL of two consecutive contacts
 ; dbId         - temporary database id of the most recently created object
 ; layer1length - the length of layer1
 ; layer1width  - the width of layer1
 ; layer2Bbox   - the bounding box of layer2
 ; layer3length - the length of layer3
 ; layer3width  - the width of layer3
 ; net          - the net all of the shapes will be attached to
 ; pinId        - temporary pin id of the most recently created pin
 ; r            - loop control variable, looping through all the rows
 ; theX         - loop variable; the X origin of the next via to create
 ; theY         - loop variable; the Y origin of the next via to create
 ; via1XEncDifference- the difference in the X enclosures of via1 between layer1 and layer2
 ; via1YEncDifferenc- the difference in the Y enclosures of via1 between layer1 and layer2
 ; via2XEncDifference- the difference in the X enclosures of via2 between layer2 and layer3
 ; via2YEncDifference- the difference in the Y enclosures of via2 between layer2 and layer3

 (setq allDir (list "right" "left" "top" "bottom"))

 (setq net (dbMakeNet tcCellView "ppd"))

 (when (stringp layer1)
     (setq layer1 (list layer1 "drawing"))
 )
 (when (stringp layer2)
     (setq layer2 (list layer2 "drawing"))
 )
 
 (when (and layer3 (stringp layer3))
     (setq layer3 (list layer3 "drawing"))
 )

 ;; calculate the layer1 length
 (setq layer1length (max (plus (times 2 layer1EncVia1) (times column via1Width)
			       (times (difference column 1) via1Space))
			 layer1Width))

 ;; calculate the layer1 width
 (setq layer1width (max (plus (times 2 layer1EncVia1) (times row via1Width)
			      (times (difference row 1) via1Space))
			layer1Width))

 ;; draw layer1
 (setq dbId (dbCreateRect tcCellView layer1
			  (list (list 0.0 0.0)
				(list layer1length layer1width))))
 (dbAddFigToNet dbId net)
 (setq pinId (dbCreatePin net dbId))
 pinId~>accessDir = allDir
 (dbCreateProp tcCellView "botLayer" "list" layer1)
 (dbCreateProp tcCellView "botLayerBbox" "list" dbId~>bBox)

 (when maxvLayer
     (setq dbId (dbCreateRect tcCellView maxvLayer
			      (list (list 0.0 0.0)
				    (list layer1length layer1width))))
     (dbAddFigToNet dbId net)
     (setq pinId (dbCreatePin net dbId))
     pinId~>accessDir = allDir
 )
 
 (when (and implant layer1Implant)
   (setq dbId (dbCreateRect tcCellView layer1Implant
			    (list (list -layer1ImpEnc -layer1ImpEnc)
				  (list (plus layer1length layer1ImpEnc)
					(plus layer1length layer1ImpEnc)
					)
				  )
			    )
	 )
   (dbAddFigToNet dbId net)
   )
 
 ;; draw all of the via1 contacts
 (setq contactPitch (plus via1Space via1Width))
 ;; initialize the y coordinate of the via1 rectangle.
 (setq theY layer1EncVia1)
 (for r 1 row
      ;; initailize the x coordinate as the layer1 enclosure of via1.
      (setq theX layer1EncVia1)
      (for col 1 column
	 (dbId = (dbCreateRect tcCellView via1Layer
			       (list (list theX theY)
				     (list (plus theX via1Width)
					   (plus theY via1Width)))))
	 (dbAddFigToNet dbId net)
	 (setq theX (plus theX contactPitch))
     )
     (setq theY (plus theY contactPitch))
 )

 (dbCreateProp tcCellView "contactWidth" "list" via1Width)
 (dbCreateProp tcCellView "contactSpace" "list" via1Space)
 (dbCreateProp tcCellView "contactLayer" "list" via1Layer)
 (dbCreateProp tcCellView "contactLayerBbox" "list" 
	       (list layer1EncVia1:layer1EncVia1
		     (caadr dbId~>bBox):(cadadr dbId~>bBox)))
 
 (when (and implant via1Implant)
   (setq dbId (dbCreateRect tcCellView via1Implant
			    (list (list (difference layer1EncVia1 via1ImpEnc)
					(difference layer1EncVia1 via1ImpEnc)
					)
				  (list (plus (caadr  dbId~>bBox) via1ImpEnc)
					(plus (cadadr dbId~>bBox) via1ImpEnc)
					)
				  )
			    )
	 )
   (dbAddFigToNet dbId net)
   )

 ;; based on the via1 contacts, calculate layer2 bounding box
 (setq layer2Bbox (list (list (difference layer1EncVia1 layer2XEncVia1)
			      (difference layer1EncVia1 layer2YEncVia1)
			      )
			(list (max layer2Width
				   (plus (times 2 layer2XEncVia1) (times column via1Width)
					 (times (difference column 1) via1Space)
					 )
				   )
			      (max layer2Width
				   (plus (times 2 layer2YEncVia1) (times row via1Width)
					 (times (difference row 1) via1Space)
					 )
				   )
			      )))
 (setq layer2X1Coord (caar layer2Bbox))
 (setq layer2Y1Coord (cadar layer2Bbox))
 
 (when layer3
     ;; we calculate layer2 based on via2 and what was calculated before
     (setq layer2Bbox (list (list (min (caar layer2Bbox)
				       (difference layer1EncVia1 layer2EncVia2)
				       )
				  (min (cadar layer2Bbox)
				       (difference layer1EncVia1 layer2EncVia2)
				       )
				  )
			    (list (max (caadr layer2Bbox)
				       (plus (times 2 layer2EncVia2) (times column via2Width)
					     (times (difference column 1) via2Space)
					     layer1EncVia1 
					     (minus (max layer2EncVia2 layer2XEncVia1))
					     )
				       )
				  (max (cadadr layer2Bbox)
				       (plus (times 2 layer2EncVia2) (times row via2Width)
					     (times (difference row 1) via2Space)
					     layer1EncVia1 
					     (minus (max layer2EncVia2 layer2YEncVia1))
					     )
				       ))))
     (setq layer2X1Coord (caar layer2Bbox))
     (setq layer2Y1Coord (cadar layer2Bbox))
     
     ;; calculate the length of layer3 as well
     (setq layer3length (max (plus (times 2.0 layer3XEncVia2)
				   (times column via2Width)
				   (times (difference column 1) via2Space))
			     layer3Width))
     
     ;; calculate the width of layer3.
     (setq layer3width (max (plus (times 2.0 layer3YEncVia2)
				  (times row via2Width)
				  (times (difference row 1) via2Space))
			    layer3Width))

     ;; set the contact pitch for via2
     (setq contactPitch (plus via2Space via2Width))
     ;; initialize the X and Y coordinates for via2
     (setq theY (plus layer2Y1Coord layer2EncVia2))
     (setq theX (plus layer2X1Coord layer2EncVia2))
     ;; From the X coordinates calculate the layer3 coordinates
     (setq layer3X1Coord (difference theX layer3XEncVia2))
     (setq layer3Y1Coord (difference theY layer3YEncVia2))
     (for r 1 row
	  ;; Calculate the via2 X coordinate
	  (setq theX (plus layer2X1Coord layer2EncVia2))
	  (for col 1 column
	       (setq dbId (dbCreateRect tcCellView via2Layer
					(list (list theX theY)
					      (list (plus theX via2Width)
						    (plus theY via2Width)))))
	       (dbAddFigToNet dbId net)
	       (setq theX (plus theX contactPitch))
	  )
	  (setq theY (plus theY contactPitch))
     )
 
     (when (and implant via2Implant)
       (setq dbId (dbCreateRect tcCellView via2Implant
				(list (list (plus layer2X1Coord layer2EncVia2 -via2ImpEnc)
					    (plus layer2Y1Coord layer2EncVia2 -via2ImpEnc)
					    )
				      (list (plus (caadr  dbId~>bBox) via2ImpEnc)
					    (plus (cadadr dbId~>bBox) via2ImpEnc)
					    )
				      )
				)
	     )
       (dbAddFigToNet dbId net)
       )
 )

 ;; we do this here since the dbId of layer2 rectangle is used later
 (when (and implant layer2Implant)
   (setq dbId (dbCreateRect tcCellView layer2Implant
			    (list (list (difference layer2X1Coord layer2ImpEnc)
					(difference layer2Y1Coord layer2ImpEnc)
					)
				  (list (plus (caadr layer2Bbox) layer2ImpEnc)
					(plus (cadadr layer2Bbox) layer2ImpEnc)
					)
				  )
			    )
	 )
   (dbAddFigToNet dbId net)
   )

 ;; draw layer2
 (setq dbId (dbCreateRect tcCellView layer2 layer2Bbox))
 ;; Create a pin for this rectangle. This will allow us to route in layer2
 (dbAddFigToNet dbId net)
 (setq pinId (dbCreatePin net dbId))
 pinId~>accessDir = allDir
 

 ;; Check if layer3 has to be drawn.
 (cond ((null layer3)
	;; If layer3 does not need to be drawn, then we are done.
	(dbCreateProp tcCellView "topLayer" "list" layer2)
	(dbCreateProp tcCellView "topLayerPinBbox" "list" dbId~>bBox)
       )
     (t
      ;; draw the layer3 rectangle and put the topLayer pin property
      (setq dbId (dbCreateRect tcCellView layer3
			       (list layer3X1Coord:layer3Y1Coord
				     (list (plus layer3X1Coord layer3length)
					   (plus layer3Y1Coord layer3width))))
      )
      ;; create a pin from the layer3 rectangle.
      (dbAddFigToNet dbId net)
      (setq pinId (dbCreatePin net dbId))
      pinId~>accessDir = allDir
      
      (dbCreateProp tcCellView "topLayer" "list" layer3)
      (dbCreateProp tcCellView "topLayerPinBbox" "list" dbId~>bBox)
      (when (and implant layer3Implant)
	(setq dbId (dbCreateRect tcCellView layer3Implant
				 (list (list (difference layer3X1Coord layer3ImpEnc)
					     (difference layer3Y1Coord layer3ImpEnc)
					     )
				       (list (plus layer3X1Coord layer3length layer3ImpEnc)
					     (plus layer3Y1Coord layer3width  layer3ImpEnc)
					     )
				       )
				 )
	      )
	(dbAddFigToNet dbId net)
	)
     )
 )
)

(tfcDefineDeviceClassProp
;;(viewName       devClassName           propName          propValue)
;;;-------------------------------------------------------------------
 (symbolic        rc3InterConImpClass        function          "contact")
)
;;; 
;;; $Id: rc3InterConPolImpClass.il,v 1.3 2003/04/08 17:21:23 kmi Exp $
;;; 
;;; rc3InterConPolImpClass.il
;;; 
;;; Copyright (c) 1996 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Oct 17, 1996
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This file defines the class for the row and column based
;;; 2 and 3 layer interconnect contact.
;;; 
;;; Revision History:
;;;   syr 11/21/96  Changed the class property function
;;;   gtc 12/10/96  fixed bug with enclosures
;;;   syr 12/16/96  row and column should apply to both 
;;;                 via1 and via2 (designer review).
;;;   gtc 12/07/98  ported over and renamed in a hurry for v20 compatability
;;;                 with 3 layer contacts
;;;   cry 08/21/01  Copied from rc3InterConClass.il and
;;;                 added toggleable implant capability.
;;;   cry 08/21/01  Copied from rc3InterConImpClass.il
;;;                 and added inWell polarity
;;;   lpn 02/08/02  Added an option to draw diffCoreImplant layer enclosing Diff layer 
;;;   kmi 04/08/03  Added contactWidth and contactSpace params (SPR 15627)
;;;


(putpropqq rc3InterConClass "$Id: rc3InterConPolImpClass.il,v 1.3 2003/04/08 17:21:23 kmi Exp $" SCCS)

(tcCreateDeviceClass
 "symbolic" "rc3InterConPolImpClass"
 ;; class parameters
 (
  (layer1 "hilite")     ; the layer (& purpose) of layer1
  (layer2 "prBoundary") ; the layer (& purpose) of layer2
  (layer3         nil)  ; the layer (& purpose) of layer3
  (maxvLayer      nil)  ; the (optional) recognition layer to be drawn
                        ; identical to layer1
  (via1Layer     "y4")  ; the layer (& purpose) of layer1-2 contacts
  (via2Layer      nil)  ; the layer (& purpose) of layer2-3 contacts
  (wellLayer      nil)  ; the layer (& purpose) of the well layer drawn around layer1
  (wellLayerEnc   0.0)  ; enclosure of layer1 by wellLayer
  (layer1Implant  nil)  ; layer1 implant list (nil for none) (inWell=nil : inWell=t)
  (layer2Implant  nil)  ; layer2 implant list (nil for none) (inWell=nil : inWell=t)
  (layer3Implant  nil)  ; layer3 implant list (nil for none) (inWell=nil : inWell=t)
  (layer1CoreImplant       nil)         ; layer 1 Core implant layer list (inWell=nil:inWell=t)
  (layer1CoreImpEnc     (list 0.0 0.0)) ; layer 1 Core implant enclosure list (inWell=nil:inWell=t)
  (via1Implant    nil)  ; via1 implant list (nil for none) (inWell=nil : inWell=t)
  (via2Implant    nil)  ; via2 implant list (nil for none) (inWell=nil : inWell=t)
  (layer1Width    0.0)  ; the minimum width for layer1
  (layer2Width    0.0)  ; the minimum width for layer2
  (layer3Width    0.0)  ; the minimum width for layer3
  (via1Width      0.0)  ; the width of layer1-2 contacts
  (via1Space      0.0)  ; the spacing between layer1-2 contacts
  (via2Width      0.0)  ; the width of layer2-3 contacts
  (via2Space      0.0)  ; the spacing between layer2-3 contacts
  (layer1EncVia1  0.0)  ; layer 1 enclosure of layer1-2 contact
  (layer2XEncVia1 0.0)  ; layer 2 enclosure of layer1-2 contact
  (layer2YEncVia1 0.0)  ; layer 2 enclosure of layer1-2 contact
  (layer2EncVia2  0.0)  ; layer 2 enclosure of layer2-3 contact
  (layer3XEncVia2 0.0)  ; layer 3 enclosure of layer2-3 contact
  (layer3YEncVia2 0.0)  ; layer 3 enclosure of layer2-3 contact
  (layer1ImpEnc (list 0.0 0.0))  ; layer1 implant enclosure list
  (layer2ImpEnc (list 0.0 0.0))  ; layer2 implant enclosure list
  (layer3ImpEnc (list 0.0 0.0))  ; layer3 implant enclosure list
  (via1ImpEnc   (list 0.0 0.0))  ; via1 implant enclosure list
  (via2ImpEnc   (list 0.0 0.0))  ; via2 implant enclosure list
 )

 ;; formal parameters
 (
  (row           1) ; the number of rows of via1 and via2 contacts to place
  (column        1) ; the number of columns of via1 and via2 contacts to place
  (implant "FALSE") ; determines whether or not to draw implants
  (inWell  "FALSE") ; whether the contact is in the well or not
 )
 
 ;; convert all boolean parameters to either t or nil
 ;; this way we can use the simple (when parameter) syntax
 ;; and speed up pcell evaluation and make code simpler
 (if (or (equal implant t) (equal implant "TRUE")) then
   (setq implant t)
   else
   (setq implant nil)
   )
 (if (or (equal inWell t) (equal inWell "TRUE")) then
   (setq inWell t)
   else
   (setq inWell nil)
   )
 ;; derive the real enclosure to use based on polarity
 (when implant
   (when layer1Implant
     (if inWell then
       (setq layer1Implant (cadr layer1Implant))
       (setq layer1ImpEnc  (cadr layer1ImpEnc))
       else
       (setq layer1Implant (car layer1Implant))
       (setq layer1ImpEnc  (car layer1ImpEnc))
       )
     )

   (when layer1CoreImplant
       (if inWell then
	   (setq layer1CoreImplant (cadr layer1CoreImplant))
	   (setq layer1CoreImpEnc  (cadr layer1CoreImpEnc))
	  else
	   (setq layer1CoreImplant (car layer1CoreImplant))
	   (setq layer1CoreImpEnc  (car layer1CoreImpEnc))
       )
   )
   
   
   (when layer2Implant
       (if inWell then
	   (setq layer2Implant (cadr layer2Implant))
       (setq layer2ImpEnc  (cadr layer2ImpEnc))
	else
	   (setq layer2Implant (car layer2Implant))
	   (setq layer2ImpEnc  (car layer2ImpEnc))
       )
   )
   (when layer3Implant
       (if inWell then
       (setq layer3Implant (cadr layer3Implant))
       (setq layer3ImpEnc  (cadr layer3ImpEnc))
       else
       (setq layer3Implant (car layer3Implant))
       (setq layer3ImpEnc  (car layer3ImpEnc))
       )
     )
   (when via1Implant
     (if inWell then
       (setq via1Implant (cadr via1Implant))
       (setq via1ImpEnc  (cadr via1ImpEnc))
       else
       (setq via1Implant (car via1Implant))
       (setq via1ImpEnc  (car via1ImpEnc))
       )
     )
   (when via2Implant
     (if inWell then
       (setq via2Implant (cadr via2Implant))
       (setq via2ImpEnc  (cadr via2ImpEnc))
       else
       (setq via2Implant (car via2Implant))
       (setq via2ImpEnc  (car via2ImpEnc))
       )
     )
   )
 ; variables used in this pcell
 ; allDir       - list of right, left, top, bottom for pin access direction
 ; c23column    - the number of columns of via2 contacts that can be placed
 ; c23row       - the number of rows of via2 contacts that can be placed
 ; col          - loop control variable, looping through all the columns
 ; contactPitch- the distance between the LL of two consecutive contacts
 ; dbId         - temporary database id of the most recently created object
 ; layer1length - the length of layer1
 ; layer1width  - the width of layer1
 ; layer2Bbox   - the bounding box of layer2
 ; layer3length - the length of layer3
 ; layer3width  - the width of layer3
 ; net          - the net all of the shapes will be attached to
 ; pinId        - temporary pin id of the most recently created pin
 ; r            - loop control variable, looping through all the rows
 ; theX         - loop variable; the X origin of the next via to create
 ; theY         - loop variable; the Y origin of the next via to create
 ; via1XEncDifference- the difference in the X enclosures of via1 between layer1 and layer2
 ; via1YEncDifferenc- the difference in the Y enclosures of via1 between layer1 and layer2
 ; via2XEncDifference- the difference in the X enclosures of via2 between layer2 and layer3
 ; via2YEncDifference- the difference in the Y enclosures of via2 between layer2 and layer3

 (setq allDir (list "right" "left" "top" "bottom"))

 (setq net (dbMakeNet tcCellView "ppd"))

 (when (stringp layer1)
     (setq layer1 (list layer1 "drawing"))
 )
 (when (stringp layer2)
     (setq layer2 (list layer2 "drawing"))
 )
 
 (when (and layer3 (stringp layer3))
     (setq layer3 (list layer3 "drawing"))
 )

 ;; calculate the layer1 length
 (setq layer1length (max (plus (times 2 layer1EncVia1) (times column via1Width)
			       (times (difference column 1) via1Space))
			 layer1Width))

 ;; calculate the layer1 width
 (setq layer1width (max (plus (times 2 layer1EncVia1) (times row via1Width)
			      (times (difference row 1) via1Space))
			layer1Width))

 ;; draw layer1
 (setq dbId (dbCreateRect tcCellView layer1
			  (list (list 0.0 0.0)
				(list layer1length layer1width))))
 (dbAddFigToNet dbId net)
 (setq pinId (dbCreatePin net dbId))
 pinId~>accessDir = allDir
 (dbCreateProp tcCellView "botLayer" "list" layer1)
 (dbCreateProp tcCellView "botLayerBbox" "list" dbId~>bBox)

 (when maxvLayer
     (setq dbId (dbCreateRect tcCellView maxvLayer
			      (list (list 0.0 0.0)
				    (list layer1length layer1width))))
     (dbAddFigToNet dbId net)
     (setq pinId (dbCreatePin net dbId))
     pinId~>accessDir = allDir
 )
 
 (when (and implant layer1Implant)
     (setq dbId (dbCreateRect tcCellView layer1Implant
			    (list (list -layer1ImpEnc -layer1ImpEnc)
				  (list (plus layer1length layer1ImpEnc)
					(plus layer1width layer1ImpEnc)
				  )
			    )
			    )
     )
     (dbAddFigToNet dbId net)
 )
 
 ;; draw layer1 Core implant
 (when (and layer1CoreImplant implant)
     (setq dbId (dbCreateRect tcCellView layer1CoreImplant
			      (list (list (minus layer1CoreImpEnc)
					  (minus layer1CoreImpEnc))
				    (list (plus layer1length layer1CoreImpEnc)
					  (plus layer1width layer1CoreImpEnc)))))
     (dbAddFigToNet dbId net)
 )
 
 
 
 (when (and implant inWell wellLayer)
     (setq dbid (dbCreateRect tcCellView wellLayer
			      (list (list -wellLayerEnc -wellLayerEnc)
				  (list (plus layer1length wellLayerEnc)
					(plus layer1width  wellLayerEnc)
					)
				  )
			    )
	 )
   (dbAddFigToNet dbId net)
   )
 
 ;; draw all of the via1 contacts
 (setq contactPitch (plus via1Space via1Width))
 ;; initialize the y coordinate of the via1 rectangle.
 (setq theY layer1EncVia1)
 (for r 1 row
      ;; initailize the x coordinate as the layer1 enclosure of via1.
      (setq theX layer1EncVia1)
      (for col 1 column
	 (dbId = (dbCreateRect tcCellView via1Layer
			       (list (list theX theY)
				     (list (plus theX via1Width)
					   (plus theY via1Width)))))
	 (dbAddFigToNet dbId net)
	 (setq theX (plus theX contactPitch))
     )
     (setq theY (plus theY contactPitch))
 )
 (dbCreateProp tcCellView "contactWidth" "list" via1Width)
 (dbCreateProp tcCellView "contactSpace" "list" via1Space)
 (dbCreateProp tcCellView "contactLayer" "list" via1Layer)
 (dbCreateProp tcCellView "contactLayerBbox" "list" 
	       (list layer1EncVia1:layer1EncVia1
		     (caadr dbId~>bBox):(cadadr dbId~>bBox)))
 
 (when (and implant via1Implant)
   (setq dbId (dbCreateRect tcCellView via1Implant
			    (list (list (difference layer1EncVia1 via1ImpEnc)
					(difference layer1EncVia1 via1ImpEnc)
					)
				  (list (plus (caadr  dbId~>bBox) via1ImpEnc)
					(plus (cadadr dbId~>bBox) via1ImpEnc)
					)
				  )
			    )
	 )
   (dbAddFigToNet dbId net)
   )

 ;; based on the via1 contacts, calculate layer2 bounding box
 (setq layer2Bbox (list (list (difference layer1EncVia1 layer2XEncVia1)
			      (difference layer1EncVia1 layer2YEncVia1)
			      )
			(list (plus (max layer2Width
					 (plus (times 2 layer2XEncVia1) (times column via1Width)
					       (times (difference column 1) via1Space)
					       )
					 )
				    (difference layer1EncVia1 layer2XEncVia1)
				    )
			      (plus (max layer2Width
					 (plus (times 2 layer2YEncVia1) (times row via1Width)
					       (times (difference row 1) via1Space)
					       )
					 )
				    (difference layer1EncVia1 layer2YEncVia1)
				    )
			      )))
 (setq layer2X1Coord (caar layer2Bbox))
 (setq layer2Y1Coord (cadar layer2Bbox))
 
 (when layer3
     ;; we calculate layer2 based on via2 and what was calculated before
     (setq layer2Bbox (list (list (min (caar layer2Bbox)
				       (difference layer1EncVia1 layer2EncVia2)
				       )
				  (min (cadar layer2Bbox)
				       (difference layer1EncVia1 layer2EncVia2)
				       )
				  )
			    (list (max (caadr layer2Bbox)
				       (plus (times 2 layer2EncVia2) (times column via2Width)
					     (times (difference column 1) via2Space)
					     layer1EncVia1 
					     (minus (max layer2EncVia2 layer2XEncVia1))
					     )
				       )
				  (max (cadadr layer2Bbox)
				       (plus (times 2 layer2EncVia2) (times row via2Width)
					     (times (difference row 1) via2Space)
					     layer1EncVia1 
					     (minus (max layer2EncVia2 layer2YEncVia1))
					     )
				       ))))
     (setq layer2X1Coord (caar layer2Bbox))
     (setq layer2Y1Coord (cadar layer2Bbox))

     ;; calculate the length of layer3 as well
     (setq layer3length (max (plus (times 2.0 layer3XEncVia2)
				   (times column via2Width)
				   (times (difference column 1) via2Space))
			     layer3Width))
     
     ;; calculate the width of layer3.
     (setq layer3width (max (plus (times 2.0 layer3YEncVia2)
				  (times row via2Width)
				  (times (difference row 1) via2Space))
			    layer3Width))

     ;; set the contact pitch for via2
     (setq contactPitch (plus via2Space via2Width))
     ;; initialize the X and Y coordinates for via2
     (setq theY (plus layer2Y1Coord layer2EncVia2))
     (setq theX (plus layer2X1Coord layer2EncVia2))
     ;; From the X coordinates calculate the layer3 coordinates
     (setq layer3X1Coord (difference theX layer3XEncVia2))
     (setq layer3Y1Coord (difference theY layer3YEncVia2))
     (for r 1 row
	  ;; Calculate the via2 X coordinate
	  (setq theX (plus layer2X1Coord layer2EncVia2))
	  (for col 1 column
	       (setq dbId (dbCreateRect tcCellView via2Layer
					(list (list theX theY)
					      (list (plus theX via2Width)
						    (plus theY via2Width)))))
	       (dbAddFigToNet dbId net)
	       (setq theX (plus theX contactPitch))
	  )
	  (setq theY (plus theY contactPitch))
     )
 
     (when (and implant via2Implant)
       (setq dbId (dbCreateRect tcCellView via2Implant
				(list (list (plus layer2X1Coord layer2EncVia2 -via2ImpEnc)
					    (plus layer2Y1Coord layer2EncVia2 -via2ImpEnc)
					    )
				      (list (plus (caadr  dbId~>bBox) via2ImpEnc)
					    (plus (cadadr dbId~>bBox) via2ImpEnc)
					    )
				      )
				)
	     )
       (dbAddFigToNet dbId net)
       )
 )

 ;; we do this here since the dbId of layer2 rectangle is used later
 (when (and implant layer2Implant)
   (setq dbId (dbCreateRect tcCellView layer2Implant
			    (list (list (difference layer2X1Coord layer2ImpEnc)
					(difference layer2Y1Coord layer2ImpEnc)
					)
				  (list (plus (caadr layer2Bbox) layer2ImpEnc)
					(plus (cadadr layer2Bbox) layer2ImpEnc)
					)
				  )
			    )
	 )
   (dbAddFigToNet dbId net)
   )

 ;; draw layer2
 (setq dbId (dbCreateRect tcCellView layer2 layer2Bbox))
 ;; Create a pin for this rectangle. This will allow us to route in layer2
 (dbAddFigToNet dbId net)
 (setq pinId (dbCreatePin net dbId))
 pinId~>accessDir = allDir
 

 ;; Check if layer3 has to be drawn.
 (cond ((null layer3)
	;; If layer3 does not need to be drawn, then we are done.
	(dbCreateProp tcCellView "topLayer" "list" layer2)
	(dbCreateProp tcCellView "topLayerPinBbox" "list" dbId~>bBox)
       )
     (t
      ;; draw the layer3 rectangle and put the topLayer pin property
      (setq dbId (dbCreateRect tcCellView layer3
			       (list layer3X1Coord:layer3Y1Coord
				     (list (plus layer3X1Coord layer3length)
					   (plus layer3Y1Coord layer3width))))
      )
      ;; create a pin from the layer3 rectangle.
      (dbAddFigToNet dbId net)
      (setq pinId (dbCreatePin net dbId))
      pinId~>accessDir = allDir
      
      (dbCreateProp tcCellView "topLayer" "list" layer3)
      (dbCreateProp tcCellView "topLayerPinBbox" "list" dbId~>bBox)
      (when (and implant layer3Implant)
	(setq dbId (dbCreateRect tcCellView layer3Implant
				 (list (list (difference layer3X1Coord layer3ImpEnc)
					     (difference layer3Y1Coord layer3ImpEnc)
					     )
				       (list (plus layer3X1Coord layer3length layer3ImpEnc)
					     (plus layer3Y1Coord layer3width  layer3ImpEnc)
					     )
				       )
				 )
	      )
	(dbAddFigToNet dbId net)
	)
     )
 )
)

(tfcDefineDeviceClassProp
;;(viewName       devClassName           propName          propValue)
;;;-------------------------------------------------------------------
 (symbolic        rc3InterConPolImpClass    function          "contact")
)
;;; 
;;; $Id: rcInterConEnhClass.il,v 1.12 2005/02/12 02:30:56 kmi Exp $
;;; 
;;; rcInterConEnhClass.il
;;; 
;;; Copyright (c) 2003 by Cypress Semiconductor
;;; 
;;; Date  : Sep 19, 2003
;;; Author: Kresimir Mihic (kmi) @KYCC
;;; 
;;; Description:
;;;   This file defines the class for the Row and Column based
;;;   2 and 3 layer interconnect contact.
;;; 
;;; Revision History:
;;;  kmi 09/15/03 Initial version 
;;;  agktmp12 08/10/04  Fixed some min enclosure bugs.
;;;                      for max width volation , pcell eval fail is printed.
;;;  kmi 10/12/04 replacing hard coded snapgrid value with (TECHgetProp snapGrid)
;;;  agktmp12 10/13/04  Reverted back to revision 1.1 becoz of backward compatibilty issues with revision 1.2
;;;  kmi 11/08/04 adding contact Layer on XY capability
;;;  agktmp2 11/13/04 added code switch for compatibility issues of rev 1.4.
;;;  kmi 12/16/04 adding via1ConImplant
;;;  kmi 01/26/05 adding via1ConImplantOn
;;;  kmi 02/03/05 adding via1ImplantOn
;;;  kmi 03/11/05 adding via1SingleImplant
;;;

(putpropqq rcInterConEnhClass "$Id: rcInterConEnhClass.il,v 1.12 2005/02/12 02:30:56 kmi Exp $" SCCS)

 (tcCreateDeviceClass
  "symbolic" "rcInterConEnhClass"
  ;; class parameters
  (
   (layer1              nil)    ; the layer (& purpose) of layer1
   (layer2     "prBoundary")    ; the layer (& purpose) of layer2
   (layer3              nil)    ; the layer (& purpose) of layer3
   (wellLayer           nil)    ; well layer
   (wellLayerEnc        0.0)    ; layer1 enclosure by wellLayer
   (idLayer             nil)    ; recognition layer to be drawn identical to layer1
   (via1Layer          "y4")    ; the layer (& purpose) of layer1-2 contacts
   (via2Layer           nil)    ; the layer (& purpose) of layer2-3 contacts
   (via1Width           0.0)    ; width of the via1
   (via1Length          0.0)    ; length of the via1
   (via2Width           0.0)    ; width of the via2
   (via2Length          0.0)    ; length of the via2
   (via1ConLayer        nil)    ; contact between layer1 and via1
   (via1ConWidth        0.0)    ; width of the contact
   (via1ConMinL         0.0)    ; length of the contact
   (via1ConMaxL         0.0)    ; max allowed L for via1Con
   (via1ConEnc          0.0)    ; enclosure of via1 by via1Con
   (via1ConEncSq        0.0)    ; enclosure of via1 by via1Con (square)
   (via1ConXEnc         0.0)    ; X enclosure of via1 by via1Con
   (via1ConYEnc         0.0)    ; Y enclosure of via1 by via1Con
   (via1ConLay1Enc      0.0)    ; enclosure of via1Con by layer1
   (via1ConLay1EncSq    0.0)    ; enclosure of via1Con by layer1 (square)
   (via1ConLay1XEnc     0.0)    ; X enclosure of via1Con by layer1
   (via1ConLay1YEnc     0.0)    ; Y enclosure of via1Con by layer1
   (via1ConLay1YExt     0.0)    ; extension of via1Con beyond layer1; used when via1DoRoute is t
   (via1ConAll          nil)    ; all via1 enclosed by one contact (on/off)
   (via1ConCol          nil)    ; each via1 via1Column enclosed by a contact (on/off) 
   (via1Lay1Enc         0.0)    ; layer 1 enclosure of via1
   (via1Lay1EncSq       0.0)    ; layer 1 enclosure of via1 (square)
   (via1Lay1XEnc        0.0)    ; layer 1 X enclosure of via1
   (via1Lay1YEnc        0.0)    ; layer 1 Y enclosure of via1
   (via1Lay2Enc         0.0)    ; layer 2 enclosure of via1
   (via1Lay2EncSq       0.0)    ; layer 2 enclosure of via1 (square)
   (via1Lay2XEnc        0.0)    ; layer 2 X enclosure of via1
   (via1Lay2YEnc        0.0)    ; layer 2 Y enclosure of via1
   (via2Lay2Enc         0.0)    ; layer 2 enclosure of via2
   (via2Lay2EncSq       0.0)    ; layer 2 enclosure of via2 (square)
   (via2Lay2XEnc        0.0)    ; layer 2 X enclosure of via2
   (via2Lay2YEnc        0.0)    ; layer 2 Y enclosure of via2
   (via2Lay3Enc         0.0)    ; layer 3 enclosure of via2
   (via2Lay3EncSq       0.0)    ; layer 3 enclosure of via2 (square)
   (via2Lay3XEnc        0.0)    ; layer 3 X enclosure of via2
   (via2Lay3YEnc        0.0)    ; layer 3 Y enclosure of via2
   (layer1Implant       nil)    ; implant layer to draw around layer 1
   (layer1ImpEnc       (list 0.0 0.0))    ; enclosure of layer 1 by implant layer (list)
   (lay1ImpInWell       nil)    ; second implant layer to draw around layer 1
   (lay1ImpInWellEnc    0.0)    ; enclosure of layer 1 by second implant layer
   (layer2Implant       nil)    ; implant layer to draw around layer 2
   (layer2ImpEnc        0.0)    ; enclosure of layer 2 by implant layer
   (layer3Implant       nil)    ; implant layer to draw around layer 3
   (layer3ImpEnc        0.0)    ; enclosure of layer 3 by implant layer
   (via1LayerImplant    nil)    ; implant layer to draw around via1Layer
   (via1LayerImpEnc     0.0)    ; enclosure of via1Layer by implant layer
   (via1ImplantOn       nil)    ; force via1Implant ON (ignore "implant" user param)
   (via1ImplantSingle   nil)    ; single contact enclosure by the implant
   (via1ConImplant      nil)    ; implant layer to draw around via1Con
   (via1ConImplantOn    nil)    ; force via1ConImplant ON (ignore "implant" user param)
   (via1ConImpEnc       0.0)    ; enclosure of via1Con by implant layer
   (via2LayerImplant    nil)    ; implant layer to draw around via2Layer
   (via2LayerImpEnc     0.0)    ; enclosure of via2Layer by implant layer
   (snapGrid            (TECHgetProp snapGrid))
   (useSquareEnc        nil)    ; when t eqEnc uses *Sq enclosures, otherwise it uses (max *XEnc *YEnc)
   (useVia1Off          nil)    ; enables via1Off switch; via1ConLayer must be defined
   (contactOnX          nil)    ; aligns via1 layer with X
   (contactOnY          nil)    ; aligns via1 layer with Y
   (contactOnXY         nil)    ; puts via1 in origin
   (minvia1Lay1XEnc     nil)    ; min via1Lay1X enclosures
   (minW                nil)    ; min width for layer1 
   (minL                nil)    ; min length for layer1
   (minvia2Lay2XEnc     nil)    ; min via2Lay2X enclosures
   (specialLayer        nil)    ; layer which has maximum dimension constraints in width or length. syntax (list "layerName" maxdimension)
 )

 ;; formal parameters
 (
  (implant         "FALSE")
  (via1DoRoute     "FALSE")
  (via1Off         "FALSE")    ; turns on/off via1
  (inWell          "FALSE")
  (eqEnc           "FALSE")    ; make x&y enclosures the same
  (sqBottom        "FALSE")    ; make layer1 square
  (center          "FALSE")
  (via1SpaceX          0.0)    ; space between via1 (X)
  (via1SpaceY          0.0)    ; space between via1 (Y)
  (via2SpaceX          0.0)    ; space between via2 (X)
  (via2SpaceY          0.0)    ; space between via2 (Y)
  (W                   1.0)
  (L                   1.0)      
  (wlDriven        "FALSE")
  (row                   1)    ; number of rows
  (column                1)    ; number of columns
  (rotateMiddle    "FALSE")    ; reverse the layer1 X and Y enclosures
  (rotateTop       "FALSE")    ; reverse the layer3 X and Y enclosures
 )


(if (or (equal via1ImplantSingle t) (equal via1ImplantSingle "TRUE")) then
 (setq via1ImplantSingle t)
 else
 (setq via1ImplantSingle nil)
)
(if (or (equal wlDriven t) (equal wlDriven "TRUE")) then
 (setq wlDriven t)
 else
 (setq wlDriven nil)
)
(when (or (equal contactOnXY t) (equal contactOnXY "TRUE"))
 (setq contactOnX t)
 (setq contactOnY t)
)

(setq useShrinkLayer1 nil) 
(if (and (and (nequal minL nil) (greaterp minL 0.0)) 
		 (and (nequal minW nil) (greaterp minW 0.0))) then
	(setq useShrinkLayer1 t)
else
	(setq useShrinkLayer1 nil)	
)

(if (equal useShrinkLayer1 t) then
	;; Checking the minEnclosure for layer1.
	(when (minvia1Lay1XEnc && (not wlDriven) && (column == 1))
		 via1Lay1XEnc = minvia1Lay1XEnc
	)
	(when (minvia2Lay2XEnc && (not wlDriven) && (column == 1))
		 via2Lay2XEnc = minvia2Lay2XEnc
	)
)

(if (equal useShrinkLayer1 t) then
	;; TO check the minimum dimensions in W/L mode.
	;; This is based on the assumption that W & L values are used to determine
	;; the layer1 enclosure.
	(when wlDriven && (minW || minL)
	 (when minW
	  (setq W (max W  minW))
	 )
	 (when minL
	  (setq L (max L  minL))
	 )
	)
)


(setq allDir (list "right" "left" "top" "bottom"))
(setq net (dbMakeNet tcCellView "ppd"))

(when (stringp layer1)
 (setq layer1 (list layer1 "drawing"))
)
(when (stringp layer2)
 (setq layer2 (list layer2 "drawing"))
)

(when (stringp layer3)
 (setq layer3 (list layer3 "drawing"))
)
(when (stringp via1ConLayer)
 (setq via1ConLayer (list via1ConLayer "drawing"))
)
(if (or (equal via1Off t) (equal via1Off "TRUE")) then
 (setq via1Off (if (and via1ConLayer useVia1Off) t nil))
 else
 (setq via1Off nil)
)

(if (or (equal via1DoRoute t) (equal via1DoRoute "TRUE")) then
 (setq via1DoRoute t)
 (setq via1DoRouteW (plus W (times 2 via1ConLay1YExt)))
 else
 (setq via1DoRoute nil)
)
(if (or (equal center t) (equal center "TRUE")) then
 (setq center t)
 else
 (setq center nil)
)
(if (or (equal inWell t) (equal inWell "TRUE")) then
 (setq inWell t)
 else
 (setq inWell nil)
)
(if (or (equal implant t) (equal implant "TRUE")) then
 (setq implant t)
 else
 (setq implant nil)
)
(if (or (equal via1ConImplantOn t) (equal via1ConImplantOn "TRUE")) then
 (setq via1ConImplantOn t)
 else
 (setq via1ConImplantOn nil)
)
(if (or (equal via1ImplantOn t) (equal via1ImplantOn "TRUE")) then
 (setq via1ImplantOn t)
 else
 (setq via1ImplantOn nil)
)
(when layer1Implant
 (if (and wellLayer inWell) then
  (setq layer1Implant (if (cadr layer1Implant) (cadr layer1Implant) (car layer1Implant)))
  (setq layer1ImpEnc  (if (cadr layer1ImpEnc) (cadr layer1ImpEnc) (car layer1ImpEnc)))
  else
  (setq layer1Implant (car layer1Implant))
  (setq layer1ImpEnc  (car layer1ImpEnc))
 )
)

;; handle enclosures
(cond ((equal via1Lay1Enc 0.0)
       (setq via1Lay1XEnc via1Lay1XEnc)
       (setq via1Lay1YEnc via1Lay1YEnc))
 (t 
  (setq via1Lay1XEnc via1Lay1Enc)
  (setq via1Lay1YEnc via1Lay1Enc))
)
(cond ((equal via1Lay2Enc 0.0)
       (setq via1Lay2XEnc via1Lay2XEnc)
       (setq via1Lay2YEnc via1Lay2YEnc))
 (t 
  (setq via1Lay2XEnc via1Lay2Enc)
  (setq via1Lay2YEnc via1Lay2Enc))
)
(cond ((equal via2Lay2Enc 0.0)
       (setq via2Lay2XEnc via2Lay2XEnc)
       (setq via2Lay2YEnc via2Lay2YEnc))
 (t 
  (setq via2Lay2XEnc via2Lay2Enc)
  (setq via2Lay2YEnc via2Lay2Enc))
)
(cond ((equal via2Lay3Enc 0.0)
       (setq via2Lay3XEnc via2Lay3XEnc)
       (setq via2Lay3YEnc via2Lay3YEnc))
 (t 
  (setq via2Lay3XEnc via2Lay3Enc)
  (setq via2Lay3YEnc via2Lay3Enc))
)
(cond ((equal via1ConEnc  0.0)
       (setq via1ConXEnc via1ConXEnc)
       (setq via1ConYEnc via1ConYEnc))
 (t
  (setq via1ConXEnc via1ConEnc)
  (setq via1ConYEnc via1ConEnc))
)

(cond ((equal via1ConLay1Enc  0.0)
       (setq via1ConLay1XEnc via1ConLay1XEnc)
       (setq via1ConLay1YEnc via1ConLay1YEnc))
 (t
  (setq via1ConLay1XEnc via1ConLay1Enc)
  (setq via1ConLay1YEnc via1ConLay1Enc))
)
(when via1ConLayer
 (setq via1Lay1XEnc (if via1DoRoute via1ConXEnc (plus via1ConLay1XEnc via1ConXEnc)))
 (setq via1Lay1YEnc (if via1DoRoute via1ConYEnc (plus via1ConLay1YEnc via1ConYEnc)))
 (setq via1Lay1EncSq (if via1DoRoute via1ConEncSq (plus via1ConLay1EncSq via1ConEncSq))) 
)
;; swap top layer enclosures for a "rotate" effect
(when !layer3
 (setq rotateMiddle rotateTop)
 (setq rotateTop nil)
)
(when (or (equal rotateTop t) (equal rotateTop "TRUE"))
 (setq swapTemp   via2Lay3XEnc)
 (setq via2Lay3XEnc via2Lay3YEnc)
 (setq via2Lay3YEnc swapTemp)
)
(when (or (equal rotateMiddle t) (equal rotateMiddle "TRUE"))
 (setq swapTemp   via1Lay2XEnc)
 (setq via1Lay2XEnc via1Lay2YEnc)
 (setq via1Lay2YEnc swapTemp)
 (setq swapTemp   via2Lay2XEnc)
 (setq via2Lay2XEnc via2Lay2YEnc)
 (setq via2Lay2YEnc swapTemp)
)

;; make x&y enclosures the same
(when (or (equal eqEnc  t) (equal eqEnc  "TRUE"))
 (setq sqBottom     t)
 (if useSquareEnc then
  (setq via1Lay2XEnc via1Lay2EncSq)
  (setq via1Lay2YEnc via1Lay2EncSq)
  (setq via2Lay2XEnc via2Lay2EncSq)
  (setq via2Lay2YEnc via2Lay2EncSq)
  (setq via2Lay3XEnc via2Lay3EncSq)
  (setq via2Lay3YEnc via2Lay3EncSq)
  else
  (setq via1Lay2XEnc (max via1Lay2XEnc via1Lay2YEnc))
  (setq via1Lay2YEnc via1Lay2XEnc)
  (setq via2Lay2XEnc (max via2Lay2XEnc via2Lay2YEnc))
  (setq via2Lay2YEnc via2Lay2XEnc)
  (setq via2Lay3XEnc (max via2Lay3XEnc via2Lay3YEnc))
  (setq via2Lay3YEnc via2Lay3XEnc)
 )
)
(when (or (equal sqBottom  t) (equal sqBottom  "TRUE"))
 (if useSquareEnc then
  ;; via1 must not move
  (setq via1Lay1EqXOff (difference via1Lay1EncSq via1Lay1XEnc))
  (setq via1Lay1EqYOff (difference via1Lay1EncSq via1Lay1YEnc))
  (setq via1Lay1XEnc via1Lay1EncSq)
  (setq via1Lay1YEnc via1Lay1EncSq)
  else
  ;; via1 must not move
  (setq via1Lay1EqXOff (max 0.0 (difference via1Lay1YEnc via1Lay1XEnc)))
  (setq via1Lay1EqYOff (max 0.0 (difference via1Lay1XEnc via1Lay1YEnc)))
  (setq via1Lay1XEnc (max via1Lay1XEnc via1Lay1YEnc))
  (setq via1Lay1YEnc via1Lay1XEnc)
 )
)

;; number of rows/columns is determined by min pitch
(setq via1PitchW (plus via1Width via1SpaceY)) 
(setq via1PitchL (plus via1Length via1SpaceX)) 
(if via2Layer then 
 (setq via2PitchW (plus via2Width via2SpaceY)) 
 (setq via2PitchL (plus via2Length via2SpaceX)) 
 (if wlDriven then 
  (setq viaW1 (difference (if via1DoRoute via1DoRouteW W) (times 2 via1Lay1YEnc)))
  (setq viaL1 (difference L (times 2 via1Lay1XEnc)))
  (setq viaW2 (difference (if via1DoRoute via1DoRouteW W) (times 2 (max via2Lay3YEnc via2Lay2YEnc))))
  (setq viaL2 (difference L (times 2 (max via2Lay3XEnc via2Lay2XEnc))))
  ;; 1e-6 added because of opus skill bug: fix() rounds incorrectly 
  (setq via1Row    (max 1 (fix (plus (quotient (plus viaW1 via1SpaceY) via1PitchW) 1e-6))))
  (setq via1Column (max 1 (fix (plus (quotient (plus viaL1 via1SpaceX) via1PitchL) 1e-6))))
  (setq via2Row    (max 1 (fix (plus (quotient (plus viaW2 via2SpaceY) via2PitchW) 1e-6))))
  (setq via2Column (max 1 (fix (plus (quotient (plus viaL2 via2SpaceX) via2PitchL) 1e-6))))
  else
  (setq viaW       (min (plus via1Width  (times (difference row 1) via1PitchW))
                    (plus via2Width  (times (difference row 1) via2PitchW))))
  (setq viaL       (min (plus via1Length (times (difference column 1) via1PitchL))
                    (plus via2Length (times (difference column 1) via2PitchL))))
  ;; 1e-6 added because of opus skill bug: fix() rounds incorrectly 
  (setq via1Row    (max 1 (fix (plus (quotient (plus viaW via1SpaceY) via1PitchW) 1e-6))))
  (setq via1Column (max 1 (fix (plus (quotient (plus viaL via1SpaceX) via1PitchL) 1e-6))))
  (setq via2Row    (max 1 (fix (plus (quotient (plus viaW via2SpaceY) via2PitchW) 1e-6))))
  (setq via2Column (max 1 (fix (plus (quotient (plus viaL via2SpaceX) via2PitchL) 1e-6))))
 )
 else
(if wlDriven then 
 (setq viaW1 (difference (if via1DoRoute via1DoRouteW W) (times 2 via1Lay1YEnc)))
 (setq viaL1 (difference L (times 2 via1Lay1XEnc)))
 ;; 1e-6 added because of opus skill bug: fix() rounds incorrectly
 (setq via1Row    (max 1 (fix (plus (quotient (plus viaW1 via1SpaceY) via1PitchW) 1e-6))))
 (setq via1Column (max 1 (fix (plus (quotient (plus viaL1 via1SpaceX) via1PitchL) 1e-6))))
 else
 (setq via1Row row)
 (setq via1Column column)
)
)

;; adjust bottom layer enclosures

(when wlDriven 
 (setq via1Lay1YEnc (quotient (difference W (plus via1Width  (times (difference via1Row 1) via1PitchW))) 2))
 (setq via1Lay1XEnc (quotient (difference L (plus via1Length (times (difference via1Column 1) via1PitchL))) 2))
 (setq via1Lay1YEnc (times (fix (plus (quotient via1Lay1YEnc snapGrid) 1e-6)) snapGrid))
 (setq via1Lay1XEnc (times (fix (plus (quotient via1Lay1XEnc snapGrid) 1e-6)) snapGrid))
 (setq via1WRest    (difference W (plus via1Width  (times (difference via1Row 1) via1PitchW) 
                                   (times via1Lay1YEnc 2))))
 (setq via1LRest    (difference L (plus via1Length (times (difference via1Column 1) via1PitchL)
                                   (times via1Lay1XEnc 2))))
)

;; calc layer1 coordinates
(if contactOnX (setq layer1X1 -via1Lay1XEnc) (setq layer1X1 0.0))
(if contactOnY (setq layer1Y1 -via1Lay1YEnc) (setq layer1Y1 0.0))

;; adjust for eqEnc
(when via1Lay1EqXOff (setq layer1X1 (difference layer1X1 via1Lay1EqXOff)))
(when via1Lay1EqYOff (setq layer1Y1 (difference layer1Y1 via1Lay1EqYOff)))
(setq layer1XOff 0.0)
(setq layer1YOff 0.0)
(setq layer1X2 (plus layer1X1 (times 2 via1Lay1XEnc) (if via1LRest via1LRest 0.0) 
                via1Length (times (difference via1Column 1) via1PitchL)))
(setq layer1Y2 (plus layer1Y1 (times 2 via1Lay1YEnc) (if via1WRest via1WRest 0.0) 
                via1Width (times (difference via1Row 1) via1PitchW)))

;; draw via1 and via1Con
(setq via1X1 (plus layer1X1 via1Lay1XEnc))
(setq via1Y1 (plus layer1Y1 via1Lay1YEnc))
(setq via1ConXOff 0.0)
(setq via1ConYOff 0.0)
(setq theX via1X1)
(for col 1 via1Column
 (setq theY via1Y1)
 (for r 1 via1Row
  (setq via1XY (list (list theX theY)
                (list (plus theX via1Length) (plus theY via1Width))
               ))
  (when !via1Off (setq dbId (dbCreateRect tcCellView via1Layer via1XY)))
  (when (and via1ConLayer (and !via1ConAll !via1ConCol))
   (setq via1ConX1 (difference (caar via1XY) via1ConXEnc))
   (setq via1ConY1 (difference (cadar via1XY) via1ConYEnc))
   (setq via1ConX2 (plus (caadr via1XY) via1ConXEnc))
   (setq via1ConY2 (plus (cadadr via1XY) via1ConYEnc))
   (setq dbIdCon   (dbCreateRect tcCellView via1ConLayer
                    (list (list via1ConX1 via1ConY1)
                     (list via1ConX2 via1ConY2))))
  )
  (when (and (or via1ImplantOn implant) via1LayerImplant via1ImplantSingle)
   (setq via1ImpX1 (difference (caar via1XY) via1LayerImpEnc))
   (setq via1ImpY1 (difference (cadar via1XY) via1LayerImpEnc))
   (setq via1ImpX2 (plus (caadr via1XY) via1LayerImpEnc))
   (setq via1ImpY2 (plus (cadadr via1XY) via1LayerImpEnc))
   (setq dbIdImp   (dbCreateRect tcCellView via1LayerImplant
                    (list (list via1ImpX1 via1ImpY1)
                     (list via1ImpX2 via1ImpY2))))
  )
  (setq theY (plus theY via1PitchW))
 )
 (when (and via1ConLayer (and !via1ConAll via1ConCol))
  (setq via1ConYOff 0.0)
  (setq via1ConXOff 0.0)
  (setq via1ConX1 (difference theX via1ConXEnc))
  (setq via1ConY1 (difference via1Y1 via1ConYEnc))
  (setq via1ConX2 (plus (caadr via1XY) via1ConXEnc))
  (setq via1ConY2 (plus (cadadr via1XY) via1ConYEnc))
  (setq via1ConW  (difference via1ConY2 via1ConY1))
  (setq via1ConL  (difference via1ConX2 via1ConX1))
  ;; adjust for min L
  (if via1ConL < via1ConW then
   (setq via1ConYOff (max 0.0 (quotient (difference via1ConMinL via1ConW) 2)))
   (when (nequal via1ConYOff 0.0)
     (setq via1ConYOff (times (ceiling (plus (quotient via1ConYOff snapGrid) 1e-6)) snapGrid)))
   else
   (setq via1ConXOff (max 0.0 (quotient (difference via1ConMinL via1ConL) 2)))
   (when (nequal via1ConXOff 0.0)
     (setq via1ConXOff (times (ceiling (plus (quotient via1ConXOff snapGrid) 1e-6)) snapGrid)))
  )
  ;; via1Con's X dimension must follow via1; but in Y dimension it is allowed
  ;; to follow layer1 (as set by via1ConLay1YEnc)
  (setq via1ConX1 (difference via1ConX1 via1ConXOff))
  (setq via1ConY1 (if via1DoRoute
                   (difference (difference layer1Y1 via1ConLay1YExt) via1ConYOff)
                   (difference via1ConY1 via1ConYOff)
                  ))
(setq via1ConX2 (plus via1ConX2 via1ConXOff))
(setq via1ConY2 (if via1DoRoute
                 (plus (plus layer1Y2 via1ConLay1YExt) via1ConYOff)
                 (plus via1ConY2 via1ConYOff)
                ))
(setq via1ConW  (difference via1ConY2 via1ConY1))
(setq via1ConL  (difference via1ConX2 via1ConX1))
(when (and via1ConMaxL>via1ConMinL (or via1ConW>via1ConMaxL via1ConL>via1ConMaxL))
 (error (sprintf nil "rcInterConEnhClass:%L longer than max allowed (%L)\n" via1ConLayer via1ConMaxL))
)
(setq dbIdCon   (dbCreateRect tcCellView via1ConLayer
                 (list (list via1ConX1 via1ConY1) (list via1ConX2 via1ConY2))))

)
(setq theX (plus theX via1PitchL))
)
(when (and via1ConLayer (and via1ConAll !via1ConCol))
 (setq via1ConYOff 0.0)
 (setq via1ConXOff 0.0)
 (setq via1ConX1 (difference via1X1 via1ConXEnc))
 (setq via1ConY1 (difference via1Y1 via1ConYEnc))
 (setq via1ConX2 (plus (caadr via1XY) via1ConXEnc))
 (setq via1ConY2 (plus (cadadr via1XY) via1ConYEnc))
 (setq via1ConW  (difference via1ConY2 via1ConY1))
 (setq via1ConL  (difference via1ConX2 via1ConX1))
 (if via1ConL < via1ConW then
  (setq via1ConYOff (max 0.0 (quotient (difference via1ConMinL via1ConW) 2)))
  (when (nequal via1ConYOff 0.0)
    (setq via1ConYOff (times (ceiling (plus (quotient via1ConYOff snapGrid) 1e-6)) snapGrid)))
  else
  (setq via1ConXOff (max 0.0 (quotient (difference via1ConMinL via1ConL) 2)))
  (when (nequal via1ConXOff 0.0)
    (setq via1ConXOff (times (ceiling (plus (quotient via1ConXOff snapGrid) 1e-6)) snapGrid)))
 )
 (setq via1ConX1 (difference via1ConX1 via1ConXOff))
 (setq via1ConY1 (if via1DoRoute
                  (difference (difference layer1Y1 via1ConLay1YExt) via1ConYOff)
                  (difference via1ConY1 via1ConYOff)
                 ))
 (setq via1ConX2 (plus via1ConX2 via1ConXOff))
(setq via1ConY2 (if via1DoRoute
                 (plus (plus layer1Y2 via1ConLay1YExt) via1ConYOff)
                 (plus via1ConY2 via1ConYOff)
                ))
(setq via1ConW  (difference via1ConY2 via1ConY1))
(setq via1ConL  (difference via1ConX2 via1ConX1))
(when (and via1ConMaxL>via1ConMinL (or via1ConW>via1ConMaxL via1ConL>via1ConMaxL))
 (error (sprintf nil "rcInterConEnhClass:%L longer than max allowed (%L)\n" via1ConLayer via1ConMaxL))
)
(setq dbIdCon   (dbCreateRect tcCellView via1ConLayer
                 (list (list via1ConX1 via1ConY1) (list via1ConX2 via1ConY2))))
 )
(if !via1Off then
 (setq contactBbox (list (list via1X1 via1Y1) (list (caadr via1XY) (cadadr via1XY))))
 else
 (setq contactBbox (list (list (difference via1X1 via1ConXEnc) (difference via1Y1 via1ConYEnc)) 
                    (list (caadr dbIdCon~>bBox) (cadadr dbIdCon~>bBox))))
)
(dbCreateProp tcCellView "contactLayerBbox" "list" contactBbox)

;; create properties to be used by other classes
(dbCreateProp tcCellView "contactWidth"  "float" via1Width) 
(dbCreateProp tcCellView "contactLength" "float" via1Length)
(dbCreateProp tcCellView "contactSpace"  "float" (max via1SpaceX via1SpaceY))
(dbCreateProp tcCellView "contactYEnc"    "float" via1Lay1YEnc)
(dbCreateProp tcCellView "contactXEnc"    "float" via1Lay1XEnc)



(when (and via1ConLayer (or via1ConAll via1ConCol))
 (if via1ConL < via1ConW then
  (setq layer1YOff  (if wlDriven 0.0 via1ConYOff))
  else
  (setq layer1XOff  (if wlDriven 0.0 via1ConXOff))
 )
)

(when !layer1
 (dbAddFigToNet dbIdCon net)
 (setq pinId (dbCreatePin net dbIdCon))
 pinId~>accessDir = allDir
 (dbCreateProp tcCellView "botLayer" "list" via1ConLayer)
 (dbCreateProp tcCellView "botLayerBbox" "list" 
  (list (list via1X1 via1Y1)
   (list (caadr dbIdCon~>bBox) (cadadr dbIdCon~>bBox))))
)

;; draw via1Layer implant
(when (and (or via1ImplantOn implant) via1LayerImplant !via1ImplantSingle)
 (setq via1ImpX1 (difference via1X1 via1LayerImpEnc))
 (setq via1ImpY1 (difference via1Y1 via1LayerImpEnc))
 (setq via1ImpX2 (plus (caadr via1XY) via1LayerImpEnc))
 (setq via1ImpY2 (plus (cadadr via1XY) via1LayerImpEnc))
 (setq dbId (dbCreateRect tcCellView via1LayerImplant
             (list (list via1ImpX1 via1ImpY1)
              (list via1ImpX2 via1ImpY2))))
)

;; draw via1Con implant
(when (and (or via1ConImplantOn implant) via1ConImplant)
      (setq via1ConXY (list (list (difference via1X1 via1ConXEnc) (difference via1Y1 via1ConYEnc))
                            (list (plus (caadr via1XY) via1ConXEnc) (plus (cadadr via1XY) via1ConYEnc))))
      (setq via1ConImpX1 (difference (caar via1ConXY) (plus via1ConXOff via1ConImpEnc)))
      (setq via1ConImpY1 (difference (cadar via1ConXY)(plus via1ConYOff via1ConImpEnc)))
      (setq via1ConImpX2 (plus (caadr via1ConXY) via1ConImpEnc via1ConXOff))
      (setq via1ConImpY2 (plus (cadadr via1ConXY) via1ConImpEnc via1ConYOff))
      (setq dbId (dbCreateRect tcCellView via1ConImplant
             (list (list via1ConImpX1 via1ConImpY1)
              (list via1ConImpX2 via1ConImpY2))))
)

;; draw via2 
(when via2Layer
 ;; if not center start where via1 starts
 (if center then
  (setq via1W      (difference (cadadr tcCellView~>contactLayerBbox) 
                    (cadar tcCellView~>contactLayerBbox)))
  (setq via2W      (plus via2Width  (times (difference via2Row 1) via2PitchW)))
  (setq via2YOffset (quotient (difference via1W via2W) 2))
  (setq via2YOffset (times (fix (plus (quotient via2YOffset snapGrid) 1e-6)) snapGrid))
  (setq via1L      (difference (caadr tcCellView~>contactLayerBbox) 
                    (caar  tcCellView~>contactLayerBbox)))
  (setq via2L      (plus via2Length (times (difference via2Column 1) via2PitchL)))
  (setq via2XOffset (quotient (difference via1L via2L) 2))
  (setq via2XOffset (times (fix (plus (quotient via2XOffset snapGrid) 1e-6)) snapGrid))
  (setq via2X1 (plus via1X1 via2XOffset))
  (setq via2Y1 (plus via1Y1 via2YOffset))
  else
  (setq via2X1 via1X1)
  (setq via2Y1 via1Y1)
 )
 (setq theX via2X1)
 (for col 1 via2Column
  (setq theY via2Y1)
  (for r 1 via2Row
   (setq dbId (dbCreateRect tcCellView via2Layer
               (list (list theX theY)
                (list (plus theX via2Length)
                 (plus theY via2Width)))))
   (setq theY (plus theY via2PitchW))
  )
  (setq theX (plus theX via2PitchL))
 )
 (dbCreateProp tcCellView "contact2Layer" "list" via2Layer)
(dbCreateProp tcCellView "contact2LayerBbox" "list"
 (list (list via2X1 via2Y1)
  (list (caadr dbId~>bBox) (cadadr dbId~>bBox))))

;; draw via2Layer implant
(when (and implant via2LayerImplant)
 (setq via2ImpX1 (difference via2X1 via2LayerImpEnc))
 (setq via2ImpY1 (difference via2Y1 via2LayerImpEnc))
 (setq via2ImpX2 (plus (caadr dbId~>bBox) via2LayerImpEnc))
 (setq via2ImpY2 (plus (cadadr dbId~>bBox) via2LayerImpEnc))
 (setq dbId (dbCreateRect tcCellView via2LayerImplant
             (list (list via2ImpX1 via2ImpY1)
              (list via2ImpX2 via2ImpY2))))
)
)

;; draw layer1
(setq layer1X1 (difference layer1X1 layer1XOff))
(setq layer1Y1 (difference layer1Y1 layer1YOff))
(setq layer1X2 (plus layer1X2 layer1XOff))
(setq layer1Y2 (plus layer1Y2 layer1YOff))

 (when layer1
  (setq dbId (dbCreateRect tcCellView layer1
              (list (list layer1X1 layer1Y1)
               (list layer1X2 layer1Y2))))
  (dbAddFigToNet dbId net)
  (setq pinId (dbCreatePin net dbId))
  pinId~>accessDir = allDir
  (dbCreateProp tcCellView "botLayer" "list" layer1)
  (dbCreateProp tcCellView "botLayerBbox" "list" dbId~>bBox)
 )

 ;; draw idLayer
 (when idLayer
  (setq dbId (dbCreateRect tcCellView idLayer
              (list (list layer1X1 layer1Y1)
               (list layer1X2 layer1Y2))))
 )

;; draw layer1 implant
(when (and implant layer1Implant)
 (setq dbId (dbCreateRect tcCellView layer1Implant
             (list (list (difference layer1X1 layer1ImpEnc)
                    (difference layer1Y1 layer1ImpEnc))
              (list (plus layer1X2 layer1ImpEnc)
               (plus layer1Y2 layer1ImpEnc)))))
)

;; draw layer1 implantII
(when (and implant lay1ImpInWell inWell wellLayer)
 (setq dbId (dbCreateRect tcCellView lay1ImpInWell
             (list (list (difference layer1X1 lay1ImpInWellEnc)
                    (difference layer1Y1 lay1ImpInWellEnc))
              (list (plus layer1X2 lay1ImpInWellEnc)
               (plus layer1Y2 lay1ImpInWellEnc)))))
)

;; draw wellLayer
(when (and inWell wellLayer)
 (setq dbId (dbCreateRect tcCellView wellLayer
             (list (list (difference layer1X1 wellLayerEnc)
                    (difference layer1Y1 wellLayerEnc))
              (list (plus layer1X2 wellLayerEnc)
               (plus layer1Y2 wellLayerEnc)))))
 (dbCreateProp tcCellView "wellLayer" "list" wellLayer)
 (dbCreateProp tcCellView "wellLayerBbox" "list" dbId~>bBox)
)

;; draw layer2
(if !via1Off then
 (if via2Layer then
  (setq layer2X1_I  (difference (caar tcCellView~>contactLayerBbox) via1Lay2XEnc))
  (setq layer2Y1_I  (difference (cadar tcCellView~>contactLayerBbox) via1Lay2YEnc))
  (setq layer2X2_I  (plus (caadr tcCellView~>contactLayerBbox) via1Lay2XEnc))
  (setq layer2Y2_I  (plus (cadadr tcCellView~>contactLayerBbox) via1Lay2YEnc))
  (setq layer2X1_II (difference (caar tcCellView~>contact2LayerBbox) via2Lay2XEnc))
  (setq layer2Y1_II (difference (cadar tcCellView~>contact2LayerBbox) via2Lay2YEnc))
  (setq layer2X2_II (plus (caadr tcCellView~>contact2LayerBbox) via2Lay2XEnc))
  (setq layer2Y2_II (plus (cadadr tcCellView~>contact2LayerBbox) via2Lay2YEnc))
  (setq layer2X1    (min layer2X1_I layer2X1_II))
  (setq layer2Y1    (min layer2Y1_I layer2Y1_II))
  (setq layer2X2    (max layer2X2_I layer2X2_II))
  (setq layer2Y2    (max layer2Y2_I layer2Y2_II))
  else
  (setq layer2X1    (difference (caar tcCellView~>contactLayerBbox) via1Lay2XEnc))
  (setq layer2Y1    (difference (cadar tcCellView~>contactLayerBbox) via1Lay2YEnc))
  (setq layer2X2    (plus (caadr tcCellView~>contactLayerBbox) via1Lay2XEnc))
  (setq layer2Y2    (plus (cadadr tcCellView~>contactLayerBbox) via1Lay2YEnc))
 )
 (setq dbId (dbCreateRect tcCellView layer2
             (list (list layer2X1 layer2Y1)
              (list layer2X2 layer2Y2))))
(dbAddFigToNet dbId net)
(setq pinId (dbCreatePin net dbId))
 pinId~>accessDir = allDir
 (if !layer3 then
  (dbCreateProp tcCellView "topLayer" "list" layer2)
  (dbCreateProp tcCellView "topLayerPinBbox" "list" dbId~>bBox)
  else
  (dbCreateProp tcCellView "middleLayer" "list" layer2)
  (dbCreateProp tcCellView "middleLayerPinBbox" "list" dbId~>bBox)
 )
 (dbCreateProp tcCellView "topLayerIsVia"   "boolean" "FALSE")

;; draw layer2 implant
(when (and implant layer2Implant)
 (setq dbId (dbCreateRect tcCellView layer2Implant
             (list (list (difference layer2X1 layer2ImpEnc)
                    (difference layer2Y1 layer2ImpEnc))
              (list (plus layer2X2 layer2ImpEnc)
               (plus layer2Y2 layer2ImpEnc)))))
)
else
;; via1Con is the top layer
(dbAddFigToNet dbIdCon net)
(setq pinId (dbCreatePin net dbIdCon))
 pinId~>accessDir = allDir
 (dbCreateProp tcCellView "topLayer" "list" via1ConLayer)
 (dbCreateProp tcCellView "topLayerPinBbox" "list" contactBbox)
 (dbCreateProp tcCellView "topLayerIsVia"   "boolean" "TRUE")
 )

 ;; draw layer3
(when layer3
 (setq layer3X1 (difference (caar tcCellView~>contact2LayerBbox) via2Lay3XEnc))
 (setq layer3Y1 (difference (cadar tcCellView~>contact2LayerBbox) via2Lay3YEnc))
 (setq layer3X2 (plus (caadr tcCellView~>contact2LayerBbox) via2Lay3XEnc))
 (setq layer3Y2 (plus (cadadr tcCellView~>contact2LayerBbox) via2Lay3YEnc))
 (setq dbId (dbCreateRect tcCellView layer3
             (list (list layer3X1 layer3Y1)
              (list layer3X2 layer3Y2))))
 (dbAddFigToNet dbId net)
 (setq pinId (dbCreatePin net dbId))
 pinId~>accessDir = allDir
 (dbCreateProp tcCellView "topLayer" "list" layer3)
 (dbCreateProp tcCellView "topLayerPinBbox" "list" dbId~>bBox)

 ;; draw layer3 implant
 (when (and implant layer3Implant)
  (setq dbId (dbCreateRect tcCellView layer3Implant
              (list (list (difference layer3X1 layer3ImpEnc)
                     (difference layer3Y1 layer3ImpEnc))
               (list (plus layer3X2 layer3ImpEnc)
                (plus layer3Y2 layer3ImpEnc)))))
 )
 )

(if (equal useShrinkLayer1 t) then
(when specialLayer
 (when (tcCellView~>topLayer && (equal (car tcCellView~>topLayer) (car specialLayer)))
  (if ((abs (difference (caadr tcCellView~>topLayerPinBbox) (caar tcCellView~>topLayerPinBbox))) > 
       (cadr specialLayer)) && 
   ((abs (difference (cadadr tcCellView~>topLayerPinBbox) (cadar tcCellView~>topLayerPinBbox))) > 
    (cadr specialLayer))
   then
   (error (sprintf nil "rcInterConEnhClass:%L longer than (%L) not max allowed \n" (car specialLayer) (cadr specialLayer)))
  )
 )
 (when (tcCellView~>middleLayer && (equal (car tcCellView~>middleLayer) (car specialLayer)))
  (if ((abs (difference (caadr tcCellView~>middleLayerPinBbox) (caar tcCellView~>middleLayerPinBbox))) > 
       (cadr specialLayer)) && 
   ((abs (difference (cadadr tcCellView~>middleLayerPinBbox) (cadar tcCellView~>middleLayerPinBbox))) > 
    (cadr specialLayer))
   then
   (error (sprintf nil "rcInterConEnhClass:%L longer than (%L) not max allowed \n" (car specialLayer) (cadr specialLayer)))
  )
 )
 (when (tcCellView~>botLayer && (equal (car tcCellView~>botLayer) (car specialLayer)))
  (if ((abs (difference (caadr tcCellView~>botLayerBbox) (caar tcCellView~>botLayerBbox))) > 
       (cadr specialLayer)) && 
   ((abs (difference (cadadr tcCellView~>botLayerBbox) (cadar tcCellView~>botLayerBbox))) > 
    (cadr specialLayer))
   then
   (error (sprintf nil "rcInterConEnhClass:%L longer than (%L) not max allowed \n" (car specialLayer) (cadr specialLayer)))
  )
 )
 )
)



 ;; add bBoxEff property 
(dbCreateProp tcCellView "bBoxEff" "list"
 (list (list (min (caar tcCellView~>topLayerPinBbox)
              (caar tcCellView~>botLayerBbox))
        (min (cadar tcCellView~>topLayerPinBbox)
         (cadar tcCellView~>botLayerBbox))
       )
  (list (max (caadr tcCellView~>topLayerPinBbox)
         (caadr tcCellView~>botLayerBbox))
   (max (cadadr tcCellView~>topLayerPinBbox)
    (cadadr tcCellView~>botLayerBbox))
  ))
)

)


(tfcDefineDeviceClassProp
;;(viewName       devClassName           propName          propValue)
;;;-------------------------------------------------------------------
 (symbolic        rcInterConEnhClass        function          "contact")
)
;;; 
;;; $Id: ringClass.il,v 1.2 2002/05/13 05:18:18 lpn Exp $ %T%
;;; 
;;; ringClass.il
;;; 
;;; Copyright (c) 1997 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Feb 18, 1997
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This is the device library code for a generic ring.  Many devices
;;; in the device library use a ring type of structure.  Using this device,
;;; a lot of code will not have to be rewritten.
;;;   All of the parameters are formal parameters.  This ring is not meant
;;; to be placed by designers, but by other devices in the device library.
;;; 
;;; Revision History:
;;;   gtc 04/22/97  Giving sensible default parameter values
;;;   gtc 07/25/97  Adding option to break into 4 polygons to work around
;;;                 a vampire drc bug
;;;   lpn 04/02/2002 Added the bevelTheOutsideNoInside switch to have bevel on the 
;;;                  outside and no bevel inside.
;;; 

(putpropqq ringClass "$Id: ringClass.il,v 1.2 2002/05/13 05:18:18 lpn Exp $ %T%" SCCS)

(tcCreateDeviceClass
 "symbolic" "ringClass"
 ;; Class parameters
 (
 )
 ;; Formal parameters
 (
  (w                      50.0)
  (l                      50.0)
  (xOffset                0.0)
  (yOffset                0.0)
  (ringLayer              (list "hilite" "drawing"))
  (ringWidth              4.0)
  (additionalWidthInBevel 0.0)
  (llBevelLength          0.0)
  (ulBevelLength          0.0)
  (lrBevelLength          0.0)
  (urBevelLength          0.0)
  (bevelTheOutside        "FALSE")
  (bevelTheOutsideNoInside "FALSE")
  (grid                   0.05)
  (breakupPolygons        "FALSE")
 )

 ;; in some situations, it is desirable to bevel the inside of the corners,
 ;; but not the outside.  If so, "bevelTheOutside" should be false/nil
 (when (equal bevelTheOutside "FALSE")
     (setq bevelTheOutside nil)
 )

 ;; in some situations, it is desirable to bevel the inside of the corners,
 ;; but not the outside.  If so, "bevelTheOutside" should be false/nil
 (when (equal bevelTheOutsideNoInside "FALSE")
     (setq bevelTheOutsideNoInside nil)
 )

 ;; in some situations, vampire cannot handle the complex geometries that
 ;; this pcell can  spit out.  Therefore, we must breakup this one polygon
 ;; into four polygons that still make up the same shape.  This seems to
 ;; appease the current vampire bug
 (when (equal breakupPolygons "FALSE")
     (setq breakupPolygons nil)
 )

 ;; there is a big load of geometry/math behind this equation, but it
 ;; all boils down to the following equation.  (See the design document
 ;; for the geometry/math.)  The "bevelInsideOffset" is necessary to
 ;; maintain the minimum width throughout the bevel.  bevelInsideOffset is:
 ;;    o how much higher point 1 is wrt point 9  (points are in figure below)
 ;;    o how much further to the right point 2 is wrt point 10
 (setq s2 (sqrt 2.0))
 (setq bevelInsideOffset
       (quotient (plus (times ringWidth (difference s2 1.0))
		       (times s2 additionalWidthInBevel))
		 grid))


 ;; now use a "ceiling" function to snap it up to the next grid.
 ;; this assumes that the grid is < 1.0
 (setq fixedBev (fix (plus 1e-6 bevelInsideOffset)))
 (cond ((lessp (difference bevelInsideOffset fixedBev) 1e-6)
	(setq bevelInsideOffset (times grid fixedBev))
       )
     (t
      (setq bevelInsideOffset (times grid (plus 1.0 fixedBev)))
     )
 )


 ;; "cannotBevelLength" is the point at which the inside bevel will be
 ;; pinched off.  We do not allow bevels to occur when the bevel length
 ;; in a corner is less than this value
 (setq cannotBevelLength (difference ringWidth bevelInsideOffset))


 ;; determine whether it should bevel in each corner
 (cond ((setq llBevel (greaterp llBevelLength cannotBevelLength))
	(setq arraySize 4)
       )
     (t (setq arraySize 2))
 )

 (cond ((setq lrBevel (greaterp lrBevelLength cannotBevelLength))
	(setq arraySize (plus arraySize 4))
       )
     (t (setq arraySize (plus arraySize 2)))
 )

 (cond ((setq urBevel (greaterp urBevelLength cannotBevelLength))
	(setq arraySize (plus arraySize 4))
       )
     (t (setq arraySize (plus arraySize 2)))
 )

 (cond ((setq ulBevel (greaterp ulBevelLength cannotBevelLength))
	(setq arraySize (plus arraySize 4))
       )
     (t (setq arraySize (plus arraySize 2)))
 )

 ;;     15_____________________________14
 ;;      /                              ;;     /    _______________________     ;;    /    /7                     6\     ;; 16/    /                         \    \13
 ;;  |    /8                         5\    |
 ;;  |   |                             |   |
 ;;  |   |                             |   |
 ;;  |   |                             |   |
 ;;  |   |1                           4|   |
 ;;  | /  \                           /    |
 ;;  9\    \                         /    /12
 ;;    \    \2_____________________3/    /
 ;;     \                               /
 ;;    10\_____________________________/11
 ;;
 ;; There is a point at each vertex of the ring that will be used to create
 ;; the ring.  The list of points that will be used to create the ring is:
 ;; (1, 8, 7, 6, 5, 4, 3, 2, 1, 9, 10, 11, 12, 13, 14, 15, 16, 9, 1)
 ;; If they opt to create the ring in four sections, the sections will be:
 ;; section 1:  (1, 2, 3, 11, 10, 9)
 ;; section 2:  (3, 4, 5, 13, 12, 11)
 ;; section 3:  (5, 6, 7, 15, 14, 13)
 ;; section 4:  (7, 8, 1, 9, 16, 15)
 ;;
 ;; This will have the cut in the ring between points 1 and 9.
 ;; Whenever there is not going to be a bevel in a corner, the points
 ;; will be merged in that corner.  For example, if there was not a
 ;; bevel in the LL (lower left) corner, points 1 & 2 will become one point,
 ;; and points 9 and 10 will become one point.
 ;;
 ;; The order in which it calculates the points and puts them in the array is:
 ;; 
 ;; time   --->
 ;;index  corner
 ;;              [0]                             1
 ;;              [1]        UL                8
 ;;              [2]        UL             7
 ;;              [3]      UR            6  |
 ;;              [4]      UR         5     |
 ;;     /\       [5]    LR        4        |
 ;;     |        [6]    LR     3  |        |
 ;;     |        [7]  LL    2     |        |
 ;; insideIndex  [8]  LL 1        |        |
 ;; outsideIndex [9]  LL 9        |        |
 ;;     |        [10] LL   10     |        |
 ;;     |        [11]   LR    11  |        |
 ;;     \/       [12]   LR       12        |
 ;;              [13]     UR        13     |
 ;;              [14]     UR           14  |
 ;;              [15]       UL            15
 ;;              [16]       UL               16
 ;;              [17]                            9
 ;;              [18]                            1
 ;;
 ;; For each non-bevelled corner, the two entries for that corner in the
 ;; first half of the array will be merged, and the two entries for that
 ;; corner in the second half of the array will be merged.  For example,
 ;; if the UR (upper right) corner was not bevelled, array entries number
 ;; 3 and 4 will be merged, and entries 13 and 14 will be merged.

 ;; the insideIndex will start in the middle and count down to 0
 (setq insideIndex (xquotient arraySize 2))

 ;; the outsideIndex will start in the middle +1 and count up to arraySize
 (setq outsideIndex (plus insideIndex 1))
 (setq arraySize (plus arraySize 3))  ;; to handle a cut in the ring

 ;; Initialize the ring points
 (declare theRingPoints[arraySize])
 (setq theOutsideX xOffset)
 (setq theOutsideY yOffset)

 ;; Start with the lower left corner
 (cond ((null llBevel)  ;; no bevel in the ll corner
	(setq theInsideX (plus theOutsideX ringWidth))
	(setq theInsideY (plus theOutsideY ringWidth))

	(setq beginningInsidePoint theInsideX:theInsideY)
	(setq beginningOutsidePoint theOutsideX:theOutsideY)

	;; add the inside points to the beginning of the ring points,
	;; and the outside points to the end of the ring points
	theRingPoints[insideIndex] = beginningInsidePoint
	theRingPoints[outsideIndex] = beginningOutsidePoint
	(setq insideIndex (difference insideIndex 1))
	(setq outsideIndex (plus outsideIndex 1))
       )

     (t ;; there is a bevel in the ll corner
      (setq theOutsideY (plus theOutsideY llBevelLength))
      (setq theInsideY (plus theOutsideY bevelInsideOffset))
     
      (setq theInsideX (plus theOutsideX ringWidth))

      (setq beginningInsidePoint theInsideX:theInsideY)
      (setq beginningOutsidePoint theOutsideX:theOutsideY)
 
      (cond (bevelTheOutsideNoInside
	     (setq theInsideY1 (plus yOffset ringWidth))
	     (setq beginningInsidePoint1 theInsideX:theInsideY1)
	     theRingPoints[insideIndex] = beginningInsidePoint1
	    )
	  (t
	   theRingPoints[insideIndex] = beginningInsidePoint
	  )
      )	  
      
      (setq insideIndex (difference insideIndex 1))
      (when bevelTheOutside
	  theRingPoints[outsideIndex] = beginningOutsidePoint
	  (setq outsideIndex (plus outsideIndex 1))
      )

      (setq theOutsideX (plus theOutsideX llBevelLength))
      (setq theOutsideY yOffset)
      (setq theInsideX (plus theOutsideX bevelInsideOffset))
      (setq theInsideY (plus theOutsideY ringWidth))
 

      (cond (bevelTheOutsideNoInside
	     theRingPoints[insideIndex] = beginningInsidePoint1
	    )
	  (t
	   theRingPoints[insideIndex] = theInsideX:theInsideY
	  )
      )
      
      (setq insideIndex (difference insideIndex 1))
      (cond (bevelTheOutside
	     theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	    )
	  (t
	   theRingPoints[outsideIndex] = xOffset:theOutsideY
	   beginningOutsidePoint = theRingPoints[outsideIndex]
	  )
      )
      (setq outsideIndex (plus outsideIndex 1))

     ) ;; done with the LL bevelled case
 ) ;; done with the LL corner

 (cond ((null lrBevel) ;; no bevel in the lr corner
	(setq theOutsideX (plus xOffset l))
	(setq theInsideX (difference theOutsideX ringWidth))

	theRingPoints[insideIndex] = theInsideX:theInsideY
	theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	(setq insideIndex (difference insideIndex 1))
	(setq outsideIndex (plus outsideIndex 1))
       )

     (t ;; there is a bevel in the lr corner
      (setq theOutsideX (plus xOffset l -lrBevelLength))
      (setq theInsideX (difference theOutsideX bevelInsideOffset))
      (cond (bevelTheOutsideNoInside
	     (setq theInsideX1 (plus xOffset l -ringWidth))
	     theRingPoints[insideIndex] = theInsideX1:theInsideY
	    )
	  (t
	   theRingPoints[insideIndex] = theInsideX:theInsideY
	  )
      )
      (setq insideIndex (difference insideIndex 1))
      (when bevelTheOutside
	  theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	  (setq outsideIndex (plus outsideIndex 1))
      )

      (setq theOutsideX (plus theOutsideX lrBevelLength))
      (setq theOutsideY (plus theOutsideY lrBevelLength))
      

      (cond (bevelTheOutsideNoInside
	     theRingPoints[insideIndex] = theInsideX1:theInsideY
	    )
	  (t
	   (setq theInsideX (difference theOutsideX ringWidth))
	   (setq theInsideY (plus theOutsideY bevelInsideOffset))
	   theRingPoints[insideIndex] = theInsideX:theInsideY
	  )
      )
      
      (setq insideIndex (difference insideIndex 1))
      (cond (bevelTheOutside
	     theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	    )
	  (t
	   theRingPoints[outsideIndex] = theOutsideX:yOffset
	  )
      )
      (setq outsideIndex (plus outsideIndex 1))
     ) ;; done with the LR bevelled case
 ) ;; done with the LR corner

 (cond ((null urBevel) ;; no bevel in the UR corner
	(setq theOutsideY (plus yOffset w))
	(setq theInsideY (difference theOutsideY ringWidth))

	theRingPoints[insideIndex] = theInsideX:theInsideY
	theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	(setq insideIndex (difference insideIndex 1))
	(setq outsideIndex (plus outsideIndex 1))
       )

     (t ;; there is a bevel in the UR corner
      (setq theOutsideY (plus yOffset w -urBevelLength))
      (setq theInsideY (difference theOutsideY bevelInsideOffset))
      (cond (bevelTheOutsideNoInside   
	     (setq theInsideY1 (plus yOffset w -ringWidth))
	     theRingPoints[insideIndex] = theInsideX1:theInsideY1
	    )
	  (t
	   theRingPoints[insideIndex] = theInsideX:theInsideY
	  )
      )
      (setq insideIndex (difference insideIndex 1))
      (when bevelTheOutside
	  theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	  (setq outsideIndex (plus outsideIndex 1))
      )
      
      (setq theOutsideY (plus yOffset w))
      (setq theOutsideX (difference theOutsideX urBevelLength))
      
      (cond (bevelTheOutsideNoInside
	     theRingPoints[insideIndex] = theInsideX1:theInsideY1
	    )
	  (t
	   (setq theInsideX (difference theOutsideX bevelInsideOffset))
	   (setq theInsideY (difference theOutsideY ringWidth))
	   theRingPoints[insideIndex] = theInsideX:theInsideY
	  )
      )
    
      (setq insideIndex (difference insideIndex 1))
      (cond (bevelTheOutside
	     theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	    )
	  (t
	   theRingPoints[outsideIndex] = (plus xOffset l):theOutsideY
	  )
      )
      (setq outsideIndex (plus outsideIndex 1))
     ) ;; done with the UR bevelled case
 ) ;; done with the UR corner

 (cond ((null ulBevel) ;; no bevel in the UL corner
	(setq theOutsideX xOffset)
	(setq theInsideX (plus theOutsideX ringWidth))

	theRingPoints[insideIndex] = theInsideX:theInsideY
	theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	(setq insideIndex (difference insideIndex 1))
	(setq outsideIndex (plus outsideIndex 1))
       )

     (t ;; there is a bevel in the UL corner
      (setq theOutsideX (plus xOffset ulBevelLength))
      (setq theInsideX (plus theOutsideX bevelInsideOffset))
      (cond (bevelTheOutsideNoInside
	     (setq theInsideX1 (plus xOffset ringWidth))
	     theRingPoints[insideIndex] = theInsideX1:theInsideY1
	    )
	  (t
	   theRingPoints[insideIndex] = theInsideX:theInsideY
	  )
      )      
      (setq insideIndex (difference insideIndex 1))
      (when bevelTheOutside
	  theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	  (setq outsideIndex (plus outsideIndex 1))
      )

      (setq theOutsideX xOffset)
      (setq theOutsideY (difference theOutsideY ulBevelLength))
     

      (cond (bevelTheOutsideNoInside
	     theRingPoints[insideIndex] = theInsideX1:theInsideY1
	    )
	  (t
	   (setq theInsideX (plus theOutsideX ringWidth))
	   (setq theInsideY (difference theOutsideY bevelInsideOffset))
	   theRingPoints[insideIndex] = theInsideX:theInsideY
	  )
      )
          
      (setq insideIndex (difference insideIndex 1))
      (cond (bevelTheOutside
	     theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	    )
	  (t
	   theRingPoints[outsideIndex] = theOutsideX:(plus yOffset w)
	  )
      )
      (setq outsideIndex (plus outsideIndex 1))
     ) ;; done with the UL bevelled case
 ) ;; done with the UL corner

 
 (cond (bevelTheOutsideNoInside
	theRingPoints[insideIndex] = beginningInsidePoint1
	theRingPoints[outsideIndex] = beginningOutsidePoint
	(setq outsideIndex (plus outsideIndex 1))
	theRingPoints[outsideIndex] = beginningInsidePoint1
       )
     (t
      theRingPoints[insideIndex] = beginningInsidePoint
      theRingPoints[outsideIndex] = beginningOutsidePoint
      (setq outsideIndex (plus outsideIndex 1))
      theRingPoints[outsideIndex] = beginningInsidePoint
     )
 )


 (cond (breakupPolygons ; create four polygons for the ring shape

	     ;; the insideIndex will start in the middle and count down to 0
	     (setq insideIndex (xquotient (difference arraySize 3) 2))

	     ;; the outsideIndex will start in the middle +1 and count up
	     (setq outsideIndex (plus insideIndex 1))


	(cond (bevelTheOutside
	       ;; LL corner is 6 points if LL is bevelled, 4 points if not
	       (cond (llBevel
		      (setq ringList1 (list theRingPoints[insideIndex]
					    theRingPoints[insideIndex - 1]
					    theRingPoints[insideIndex - 2]
					    theRingPoints[outsideIndex + 2]
					    theRingPoints[outsideIndex + 1]
					    theRingPoints[outsideIndex]))
		      (setq insideIndex (difference insideIndex 2))
		      (setq outsideIndex (plus outsideIndex 2))
		     )
		   (t
		    (setq ringList1 (list theRingPoints[insideIndex]
					  theRingPoints[insideIndex - 1]
					  theRingPoints[outsideIndex + 1]
					  theRingPoints[outsideIndex]))
		    (setq insideIndex (difference insideIndex 1))
		    (setq outsideIndex (plus outsideIndex 1))
		   )
	       )

	       ;; LR corner is 6 points if LR is bevelled, 4 points if not
	       (cond (lrBevel
		      (setq ringList2 (list theRingPoints[insideIndex]
					    theRingPoints[insideIndex - 1]
					    theRingPoints[insideIndex - 2]
					    theRingPoints[outsideIndex + 2]
					    theRingPoints[outsideIndex + 1]
					    theRingPoints[outsideIndex]))
		      (setq insideIndex (difference insideIndex 2))
		      (setq outsideIndex (plus outsideIndex 2))
		     )
		   (t
		    (setq ringList2 (list theRingPoints[insideIndex]
					  theRingPoints[insideIndex - 1]
					  theRingPoints[outsideIndex + 1]
					  theRingPoints[outsideIndex]))
		    (setq insideIndex (difference insideIndex 1))
		    (setq outsideIndex (plus outsideIndex 1))
		   )
	       )

	       ;; UR corner is 6 points if UR is bevelled, 4 points if not
	       (cond (urBevel
		      (setq ringList3 (list theRingPoints[insideIndex]
					    theRingPoints[insideIndex - 1]
					    theRingPoints[insideIndex - 2]
					    theRingPoints[outsideIndex + 2]
					    theRingPoints[outsideIndex + 1]
					    theRingPoints[outsideIndex]))
		      (setq insideIndex (difference insideIndex 2))
		      (setq outsideIndex (plus outsideIndex 2))
		     )
		   (t
		    (setq ringList3 (list theRingPoints[insideIndex]
					  theRingPoints[insideIndex - 1]
					  theRingPoints[outsideIndex + 1]
					  theRingPoints[outsideIndex]))
		    (setq insideIndex (difference insideIndex 1))
		    (setq outsideIndex (plus outsideIndex 1))
		   )
	       )

	       ;; UL corner is 6 points if UL is bevelled, 4 points if not
	       (cond (ulBevel
		      (setq ringList4 (list theRingPoints[insideIndex]
					    theRingPoints[insideIndex - 1]
					    theRingPoints[insideIndex - 2]
					    theRingPoints[outsideIndex + 2]
					    theRingPoints[outsideIndex + 1]
					    theRingPoints[outsideIndex]))
		      (setq insideIndex (difference insideIndex 2))
		      (setq outsideIndex (plus outsideIndex 2))
		     )
		   (t
		    (setq ringList4 (list theRingPoints[insideIndex]
					  theRingPoints[insideIndex - 1]
					  theRingPoints[outsideIndex + 1]
					  theRingPoints[outsideIndex]))
		    (setq insideIndex (difference insideIndex 1))
		    (setq outsideIndex (plus outsideIndex 1))
		   )
	       )

	     ;;***** no bevel in the outside corners case
	      )
	    (t ; the outside corners are not bevelled

	     ;; LL corner is 5 points if the LL is bevelled, 4 points if not
	     (cond (llBevel
		    (setq ringList1 (list theRingPoints[insideIndex]
					  theRingPoints[insideIndex - 1]
					  theRingPoints[insideIndex - 2]
					  theRingPoints[outsideIndex + 1]
					  theRingPoints[outsideIndex]))
		    (setq insideIndex (difference insideIndex 2))
		    (setq outsideIndex (plus outsideIndex 1))
		   )
		 (t
		  (setq ringList1 (list theRingPoints[insideIndex]
					theRingPoints[insideIndex - 1]
					theRingPoints[outsideIndex + 1]
					theRingPoints[outsideIndex]))
		  (setq insideIndex (difference insideIndex 1))
		  (setq outsideIndex (plus outsideIndex 1))
		 )
	     )

	     ;; LR corner is 5 points if the LR is bevelled, 4 points if not
	     (cond (lrBevel
		    (setq ringList2 (list theRingPoints[insideIndex]
					  theRingPoints[insideIndex - 1]
					  theRingPoints[insideIndex - 2]
					  theRingPoints[outsideIndex + 1]
					  theRingPoints[outsideIndex]))
		    (setq insideIndex (difference insideIndex 2))
		    (setq outsideIndex (plus outsideIndex 1))
		   )
		 (t
		  (setq ringList2 (list theRingPoints[insideIndex]
					theRingPoints[insideIndex - 1]
					theRingPoints[outsideIndex + 1]
					theRingPoints[outsideIndex]))
		  (setq insideIndex (difference insideIndex 1))
		  (setq outsideIndex (plus outsideIndex 1))
		 )
	     )

	     ;; UR corner is 5 points if the UR is bevelled, 4 points if not
	     (cond (urBevel
		    (setq ringList3 (list theRingPoints[insideIndex]
					  theRingPoints[insideIndex - 1]
					  theRingPoints[insideIndex - 2]
					  theRingPoints[outsideIndex + 1]
					  theRingPoints[outsideIndex]))
		    (setq insideIndex (difference insideIndex 2))
		    (setq outsideIndex (plus outsideIndex 1))
		   )
		 (t
		  (setq ringList3 (list theRingPoints[insideIndex]
					theRingPoints[insideIndex - 1]
					theRingPoints[outsideIndex + 1]
					theRingPoints[outsideIndex]))
		  (setq insideIndex (difference insideIndex 1))
		  (setq outsideIndex (plus outsideIndex 1))
		 )
	     )

	     ;; UL corner is 5 points if the UL is bevelled, 4 points if not
	     (cond (ulBevel
		    (setq ringList4 (list theRingPoints[insideIndex]
					  theRingPoints[insideIndex - 1]
					  theRingPoints[insideIndex - 2]
					  theRingPoints[outsideIndex + 1]
					  theRingPoints[outsideIndex]))
		    (setq insideIndex (difference insideIndex 2))
		    (setq outsideIndex (plus outsideIndex 1))
		   )
		 (t
		  (setq ringList4 (list theRingPoints[insideIndex]
					theRingPoints[insideIndex - 1]
					theRingPoints[outsideIndex + 1]
					theRingPoints[outsideIndex]))
		  (setq insideIndex (difference insideIndex 1))
		  (setq outsideIndex (plus outsideIndex 1))
		 )
	     )
	    )
	)

	(when ringLayer
	    (setq net (dbMakeNet tcCellView "ppd"))
	    (dbCreateTerm net "" "inputOutput")
	    (setq dbid (dbCreatePolygon tcCellView ringLayer ringList1))
	    (dbAddFigToNet dbid net)
	    (setq dbid (dbCreatePolygon tcCellView ringLayer ringList2))
	    (dbAddFigToNet dbid net)
	    (setq dbid (dbCreatePolygon tcCellView ringLayer ringList3))
	    (dbAddFigToNet dbid net)
	    (setq dbid (dbCreatePolygon tcCellView ringLayer ringList4))
	    (dbAddFigToNet dbid net)
	)

	(dbCreateProp tcCellView "ringPoints1" "list" ringList1)
	(dbCreateProp tcCellView "ringPoints2" "list" ringList2)
	(dbCreateProp tcCellView "ringPoints3" "list" ringList3)
	(dbCreateProp tcCellView "ringPoints4" "list" ringList4)

       )

     (t ; create one complex polygon for the ring
      (setq ringList nil)
      (for i 1 outsideIndex
	   (setq ringList (cons theRingPoints[outsideIndex - i] ringList))
      )

      (when ringLayer
	  (setq net (dbMakeNet tcCellView "ppd"))
	  (dbCreateTerm net "" "inputOutput")
	  (setq dbid (dbCreatePolygon tcCellView ringLayer ringList))
	  (dbAddFigToNet dbid net)
      )

      (dbCreateProp tcCellView "ringPoints" "list" ringList)
     )
 )

)
;;; 
;;; $Id: rivetClass.il,v 1.6 2003/08/06 20:10:53 kmi Exp $
;;;
;;; rivetClass.il
;;; 
;;; Copyright (c) 2000 by Cypress Semiconductor
;;; Cypress India Design Center (INDC)
;;; 
;;; Date  : Nov 7, 2000
;;; Author: David John/CAD @ INDC
;;; 
;;; Description:
;;;   This class has been developed to declare rivets
;;;   that are used with wide metal buses.
;;;
;;;   The design document can be viewed online from
;;;   CAD Projects Documentation->
;;;           Device Library Pcells->
;;;                 Phase II Design Document
;;;   or from the UNIX path
;;;   release-v-tree/4.4/doc/projects/devLib/design2.pdf
;;;
;;;   Spec. 01-70001 (8.12 - 8.13) contains the details of Metal Stress Relief 
;;;   Rules and the rivet structure.
;;;
;;; Revision History:
;;;  
;;; dxj 01/24/01 Checking in file for the first time.
;;; dxj 01/30/01 Modified the value of tanCal
;;; dxj 03/12/01 Fix for SPR 8552
;;; kmi 10/23/02 Update for SPR 13423: - min slot length not followed in all cases
;;;                                    - ram technologies cannot have staggered slots
;;;                                    - bent rivets: slot lenght was determined by rivetLengthX
;;;                                                   maxSpaceToEdge not followed for small rivetLengthX/Y
;;;              As old technologies did not report any problem with rivets (rivets not used in 
;;;              critical zone, stress rules bugs) leaving the old code to avoid LVL errors
;;; kmi 11/14/02 Additional updates to the new Alg.
;;; kmi 08/06/03 Adding EndOfLine Enclosure
;;;

(tcCreateDeviceClass
 "symbolic" "rivetClass"
 ;; class parameters
 ;; all parameters default to ram7x technology
 (
  (rivetLayers        '("met1" "met2")) ; All the following values are in drawn dimension
  (metExt              2.500)           ; Extension of the met2 beyond met1
					; met3 beyond met2 etc...
  ;; 
  ;; Each element of the list is a list of 
  ;; layername contactWidth contactSpacing metEncCon endOfLineEnc
  ;;
  ;; metEncCon - Enclosure of contact by metal layer
  ;;
  (rivetContacts      '(
			'("via" 0.500 1.050 0.225)
		       ))
  (grid                0.025)
  
  ;; All the following class parameters deal with the slot
  ;; generation on a rivetted bus. Since there is no obvious way
  ;; to organise them, they are listed one after the other
  ;; Refer Spec. 01-70001 for details of the rules.
  (minRivetWidth         62.500)  ; Minimum bus width to have slots
  (minSlotWidth           5.750)  ; min slot width
  (minSlotLength        750.000)  ; min slot length
  (minBusLength        1000.000)  ; min bus length
  (maxSlotLength       1500.000)  ; max slot length
  (minSlotLengthP         0.750)  ; min length of a slot for bus lengths < 400 um (% of minBusLength)
  (maxSlotSpacingH       62.500)  ; max spacing between slots in common row
  (maxSpacingtoEdge      62.500)  ; max spacing between slots and metal edges
  (maxSlotSpacingV       62.500)  ; max spacing between rows of slots
  (minOverlap           250.000)  ; min overlap between staggered slots 
  (slotExt                2.500)  ; enclosure of lower metal bu upper metal
  (minOverlapP            0.200)  ; min overlap between staggered slots for bus lengths < 400 um (% slot length) 
  (ramTech                  nil)  ; true for ram technologies
  (newAlg                   t  )  ; if nil then old alg. is enabled 
 )
 
 ;; formal parameters
 ;; 
 ;; rivetWidth   - width of the rivet
 ;; rivetLengthX - length in X dimension. This is the only parameter that is
 ;;                considered when drawing a straight rivet.
 ;; rivetLengthY - length in Y dimension. Used when drawing a bent rivet.
 ;; rivetLengthZ - length along the bend for a bent rivet. The length is
 ;;                measured along the outer edge of the bend.
 ;; noBent       - If true, a straight rivet is drawn. Otherwise, a bent rivet
 ;;                is drawn.
 ;; standAlone   - If the rivet is standalone, it does not need to be connected
 ;;                to other rivets. So, the slots will be contained in the
 ;;                rivet. If the rivet is not standalone, the slots are
 ;;                extended so that they can merge with slots on another
 ;;                connected rivet.
 ;; ySlotOffset  - Used to adjust minor misalignments when slots on two
 ;;                rivets are interconnected.
 ;; multiLayer   - Usually, a rivet is drawn with all the metal layers in that
 ;;                technology. Sometimes, single metal layer rivets are needed.
 ;; layerName    - If multiLayer is nil, then a layerName has to be given.
 ;;                Rivets will be drawn using this layer.
 ;;                This facility draws the rivet only for one layer. In future
 ;;                the code may be modified for drawing rivets for any arbitrary
 ;;                number of layers given by the user. 
 ;; For more details and drawings, please refer to the design document.
 (
  (useEOLenc          "FALSE")
  (layerName          "met1")
  (multiLayer         t)
  (ySlotOffset        0)
  (standAlone         t)
  (noBent             t)
  (rivetLengthZ       100.00)
  (rivetLengthY       100.00)
  (rivetLengthX       100.00)
  (rivetWidth         12.50)
 )

 (if (or (equal useEOLenc t) (equal useEOLenc  "TRUE")) then
   (setq useEOLenc t)
   else
   (setq useEOLenc nil)
 )

 /* geometry */
 ;;
 ;; Constants used throughout this class
 ;;
 root2 = sqrt(2)
 ;; tan(22.5) = 0.414213562
 tanCal = 0.414213562
 ;; The operation grid*ceiling(somevalue*gridMult) will snap somevalue to grid.
 ;; Sometimes, this operation brings a value that is already on grid to the next
 ;; grid. To avoid this grid*ceiling(somevalue*gridMult-ceilFix) is used.
 ceilFix = 0.001
 ;;
 ;; Derive any parameters needed and snap all to grid
 ;;
 gridMult = round(1.0/grid)
 minRivetWidth = grid*ceiling(minRivetWidth*gridMult-ceilFix)
 ;;
 ;; One extra grid spacing given so that minimum
 ;; slot width rule is not violated on bend
 ;;
 minSlotWidth = grid*ceiling(minSlotWidth*gridMult-ceilFix)+grid
 minSlotLength = grid*ceiling(minSlotLength*gridMult-ceilFix)
 maxSlotSpacingH = grid*ceiling(maxSlotSpacingH*gridMult-ceilFix)
 maxSpacingtoEdge = grid*ceiling(maxSpacingtoEdge*gridMult-ceilFix)
 maxSlotSpacingV = grid*ceiling(maxSlotSpacingV*gridMult-ceilFix)
 minOverlap = grid*ceiling(minOverlap*gridMult-ceilFix)
 ySlotOffset = ySlotOffset*grid	  
 ;; Get the list containing via specific values
 viaValues = car(rivetContacts)
 ;; Get the values
 viaWidth  = (cadr viaValues)
 viaSpacing= (caddr viaValues)
 met1EncVia= (cadddr viaValues)
 met1EOLenc= (if useEOLenc (nth 4 viaValues) nil)
 
 numLayers   = length(rivetLayers)
 numContacts = length(rivetContacts)
 minWidth    = 2*met1EncVia + 2*viaWidth + viaSpacing
 (if met1EOLenc
     minLength   = 2*met1EOLenc + viaWidth
     minLength   = 2*met1EncVia + viaWidth
 )
 viaPitch    = viaWidth + viaSpacing 
 slack1      = 2*grid
 metExt      = grid*ceiling((metExt+slack1)*gridMult-ceilFix)
 slotExt1    = grid*ceiling((slotExt+slack1)*gridMult-ceilFix)
 metExt1Side = (numLayers-1)*metExt
 

 ;; Start drawing from the inside layer and grow the outer layers
 ;; The final dimension should be that specified by the user.
 ;; So the inner layer is drawn to a smaller dimension
 rivetWidth= rivetWidth - metExt1Side*2 
 ;;
 ;; If any of the dimensions are below the minimum dimension,
 ;; the minimum dimension is used so that rules are not violated.
 ;;
 ;; minWidth   - the minimum width below which it is not possible
 ;;              to accommodate the rivet contacts.
 ;; minLength  - minimum length below which it is not possible
 ;;              to obey the min layer overlap rule
 ;; minLengthZ - length below which it is not possible for the
 ;;              rivet to take a bend. It is root2*rivetWidth
 ;;
 (when (rivetWidth < minWidth)
     rivetWidth = minWidth)
 rivetWidth   = grid*ceiling(rivetWidth*gridMult-ceilFix)
 totalWidth = rivetWidth + 2*metExt1Side
 (when (rivetLengthX < minLength)
     rivetLengthX = minLength)
 (when (rivetLengthY < minLength)
     rivetLengthY = minLength)
 minLengthZ= totalWidth*root2  
 (when (rivetLengthZ < minLengthZ)
     rivetLengthZ = minLengthZ)
 
 rivetLengthX = grid*ceiling(rivetLengthX*gridMult-ceilFix)
 rivetLengthY = grid*ceiling(rivetLengthY*gridMult-ceilFix)
 rivetLengthZ = grid*ceiling(rivetLengthZ*gridMult-ceilFix)
 
 /* Start device definition */
 
 ;; This list collects all the metal layer polygons
 ;; that are drawn
 dbId0 = '()
 dbId1 = '()
 
 ;; Modify the class parameters if the user requests
 ;; a single layer rivet
 (unless multiLayer
     rivetLayers = list(layerName)
     rivetContacts = '()
 ) ;end changes for single layer rivet
 reverseLayers = reverse( rivetLayers )  
 
 ;; Start code for straight rivet
 (if noBent then
     
     ;; Draw the multiple layer stack and rivet contacts
     ;; Straight rivet multi layer stack
     i = 1
     x0 = 0.0 
     y0 = 0.0      
     (foreach thisLayer rivetLayers
	 xl = x0
	 yl = y0+(numLayers-i)*metExt
	 xu = x0+rivetLengthX
	 yu = y0+totalWidth-(numLayers-i)*metExt
	 dbId0 = (cons 
		  (dbCreateRect tcCellView (list thisLayer "drawing")
				(list xl:yl xu:yu))
		  dbId0)
	 i = i+1
     )
     ;; Draw the non-stacked rivet contacts for straight rivet
     ;;
     ;; x0,y0           - point at which the first contact is drawn. This point
     ;;                   remains constant while drawing one row of contacts.
     ;; (xl,yl) (xu,yu) - defines one contact.
     ;; numContacts     - The number of contacts to be drawn on a layer.
     ;;
     x0 = 0.0
     y0 = 0.0
     i = 0
     (foreach contact rivetContacts
	 ;; Get the required values
	 contactWidth   = cadr(contact)
	 contactSpacing = caddr(contact)
	 metEncCon      = cadddr(contact)
         metEOLenc      = (if useEOLenc (nth 4 contact) nil)
	 contactPitch   = contactWidth+contactSpacing
	 numContacts = floor(rivetLengthX/contactPitch-(if metEOLenc metEOLenc 0.5))
	 
	 x0 = (if metEOLenc metEOLenc metEncCon)
	 y0 = 0
	 ;; Start drawing the contacts
	 (for j 1 2
	      (for k 1 numContacts
		   ;; Calculate the box co-ordinates
		   xl = x0 + (k-1)*contactPitch
		   yl = y0 + (numLayers-i-1)*metExt*(2-j) + metEncCon
		   xu = xl + contactWidth
		   yu = yl + contactWidth
		   (dbCreateRect tcCellView (list car(contact) "drawing")
				 (list xl:yl xu:yu))
	      )
	      ;; Lower row of contacts done.
	      ;; Move to upper row.
	      y0 = y0 + totalWidth - (numLayers-i-1)*metExt - (2*metEncCon+contactWidth)
	 )
	 
	 ;; Finish drawing contacts on one layer
	 ;; Move to next layer
	 i = i+1
     ) ; non-stacked rivet contacts for straight rivet
     ;; End code for straight rivet
     
     ;; Start code for drawing bent rivet
  else
     ;;      8_______________7
     ;;      |                     ;;      |_____________         ;;      1            2\         ;;                     \    \6
     ;;                     3\    |
     ;;                       |   |
     ;;                       |   |
     ;;      FIGURE 1         |   |
     ;;                      4|___|5
     ;;                       
     ;; bevelInsideOffset is:
     ;;    o how much further to the right point 7 is wrt point 2
     ;;    o how much higher point 6 is wrt point 3
     ;;
     ;; lOffset = (x3-x2) = (y2-y3)
     ;; uOffset = (x6-x7) = (y7-y6)
     ;;
     bevelOffset = grid*ceiling(tanCal*totalWidth*gridMult-ceilFix)

     ;; check for min X and Y length when bent to avoid strange shapes
     ;; X/Y length can not be smaller that totalWidth*tan(22.5)
    (if rivetLengthX<bevelOffset (error "rivetClass: rivetLengthX must be >= %L" bevelOffset))
    (if (and rivetLengthY<bevelOffset !noBent) (error "rivetClass: rivetLengthY must be >= %L" bevelOffset))

     lOffset = grid*ceiling((rivetLengthZ - 2*bevelOffset)/root2*gridMult-ceilFix)
     uOffset = grid*ceiling(rivetLengthZ/root2*gridMult-ceilFix)
     arraySize = 9
     
     ;; Array theBentPoints[] contain the co-ordinates for the outermost polygon
     ;; of the rivet. This array is preserved for use in further calculations.
     ;; The array workingArray[] is used for calculating further polygons
     ;; based on the values available in theBentPoints[]
     
     (declare theBentPoints[arraySize])
     (declare workingArray[arraySize])
     (declare WA[arraySize])
     x=0 y=0
     (for i 0 arraySize-1
	  (cond
	      (i == 0 x=0                  
		 y=0)
	      (i == 1 x=x+(rivetLengthX-bevelOffset))
	      (i == 2 x=x+lOffset
		 y=y-lOffset)
	      (i == 3                  
		 y=y-(rivetLengthY-bevelOffset))
	      (i == 4 x=x+totalWidth)
	      (i == 5 		  
		 y=cadr(theBentPoints[2])+bevelOffset)
	      (i == 6 x=car(theBentPoints[1])+bevelOffset
		 y=totalWidth)
	      (i == 7 x=0)
	      (i == 8 x=0
		 y=0)
	  )
	  theBentPoints[i] = x:y
     ) ; for
     
     ;; Draw the outermost polygon
     workingList = '()
     (for j 0 arraySize-1
	  workingList = (cons theBentPoints[j] workingList)
     )
     dbId1 = cons(dbCreatePolygon(tcCellView list(car(reverseLayers) "drawing")
					     workingList) dbId1)
     ;; Calculate further polygons
     ;; Whenever a co-ordinate is snapped to grid, it is given an
     ;; allowance of 1 grid. This is done by offsetting the
     ;; co-ordinate by i*grid
     i = 1
     (foreach thisLayer cdr(reverseLayers)
	 workingArray[0]=list(car(theBentPoints[0])
				 cadr(theBentPoints[0])+i*metExt)
	 
	 x = grid*round((car(theBentPoints[1])+i*tanCal*metExt)*gridMult-ceilFix)+i*grid
	 workingArray[1]=list(x
			      cadr(theBentPoints[1])+i*metExt)
	 
	 y = grid*round((cadr(theBentPoints[2])+i*tanCal*metExt)*gridMult-ceilFix)+i*grid
	 workingArray[2]=list(car(theBentPoints[2])+i*metExt
				 y)
	 
	 workingArray[3]=list(car(theBentPoints[3])+i*metExt
				 cadr(theBentPoints[3]))
	 
	 workingArray[4]=list(car(theBentPoints[4])-i*metExt
				 cadr(theBentPoints[4]))
	 
	 y = grid*round((cadr(theBentPoints[5])-i*tanCal*metExt)*gridMult-ceilFix)-i*grid
	 workingArray[5]=list(car(theBentPoints[5])-i*metExt
				 y)
	 
	 x = grid*round((car(theBentPoints[6])-i*tanCal*metExt)*gridMult-ceilFix)-i*grid
	 workingArray[6]=list(x
			      cadr(theBentPoints[6])-i*metExt)
	 
	 workingArray[7]=list(car(theBentPoints[7])
				 cadr(theBentPoints[7])-i*metExt)
	 
	 workingArray[8]=list(car(theBentPoints[8])
				 cadr(theBentPoints[8])+i*metExt)
	 ;; Draw the calculated polygon
	 workingList = '()
	 (for j 0 arraySize-1
	      workingList = (cons workingArray[j] workingList)
	 )
	 dbId1 = cons(dbCreatePolygon(tcCellView list(thisLayer "drawing")
						 workingList) dbId1)
	 i++
     ) ; foreach
     
     ;; Start code for drawing the rivet contacts
     ;;
     ;; The code for drawing rivet contacts is split up into 6 sections
     ;; according to the value of j (see figure above).
     ;; 1: point 1 to point 2
     ;; 2: point 2 to point 3
     ;; 3: point 3 to point 4
     ;; 4: point 5 to point 6
     ;; 5: point 6 to point 7
     ;; 6: point 7 to point 8
     ;;
     ;; For each row of rivet contacts, the parameters      
     ;; xstart xend ystart yend xstep ystep are calculated
     ;; Then, from (xstart,ystart) till (xend,yend), the maximum possible number
     ;; of contacts are drawn with a stepping distance of xstep and ystep
     ;; in x and y dimensions      
     ;;
     ;; Instead of snapping each co-ordinate to grid during calculation,
     ;; they are snapped to grid just before drawing
     i = 1     
     reverseContacts = reverse(rivetContacts)
     (foreach thisContact reverseContacts
	 ;; Get the required class parameters
	 thisLayer = car(thisContact)
	 contactWidth = cadr(thisContact)
	 contactSpacing = caddr(thisContact)+grid ;For errors on bent rivet
	 metEncCon = cadddr(thisContact)
         metEOLenc = (if useEOLenc (nth 4 thisContact) nil)
	 (for j 1 6
	      (cond
		  (j == 1
		     xstart = car(theBentPoints[0])+(if metEOLenc metEOLenc metEncCon)
		     xend   = car(theBentPoints[1])-metEncCon
		     ystart = cadr(theBentPoints[0])+i*metExt+metEncCon
		     yend   = ystart
		     xstep  = contactWidth+contactSpacing
		     ystep  = 0)
		  (j == 2
		     xstart = car(theBentPoints[1])+i*tanCal*metExt+i*metExt+metEncCon/root2+2*grid
		     xend   = car(theBentPoints[2])+i*metExt+metEncCon/root2+2*grid
		     ystart = cadr(theBentPoints[1])+metEncCon/root2 
		     yend   = cadr(theBentPoints[2])+i*tanCal*metExt+metEncCon/root2
		     ;; To avoid minimum space violations, an extra spacing of
		     ;; one grid is given between contacts
		     xstep  = (contactWidth*root2+contactSpacing+grid)/root2
		     ystep  = -xstep)
		  (j == 3
		     xstart = car(theBentPoints[2])+i*metExt+metEncCon
		     xend   = xstart
		     ystart = cadr(theBentPoints[2])-(contactSpacing+contactWidth)
		     yend   = cadr(theBentPoints[3])+(contactSpacing+contactWidth)
		     xstep  = 0
		     ystep  = -(contactWidth+contactSpacing))
		  (j == 4
		     xstart = car(theBentPoints[4])-(contactWidth+i*metExt+metEncCon)
		     xend   = xstart
		     ystart = cadr(theBentPoints[4])+(if metEOLenc metEOLenc metEncCon)
		     yend   = cadr(theBentPoints[5])-(i*tanCal*metExt+
						      contactSpacing+contactWidth)
		     xstep  = 0
		     ystep  = contactWidth+contactSpacing)
		  (j == 5
		     ;; An allowance of one grid is put into xstart
		     ;; to avoid the contact coming too close to the
		     ;; metal when the co-ordinates are snapped to grid
		     xstart = car(theBentPoints[5])-(i*metExt*(1+tanCal)
							      +2*(metEncCon/root2+contactWidth)
							      +4*grid)
		     xend   = car(theBentPoints[6])-4*grid
		     ystart = cadr(theBentPoints[5])
		     yend   = cadr(theBentPoints[6])-(i*metExt+metEncCon+contactWidth*root2)*root2
		     xstep  = -(contactWidth*root2+contactSpacing+grid)/root2
		     ystep  = -xstep)
		  (j == 6
		     xstart = car(theBentPoints[6])-(contactSpacing+contactWidth
						     +i*tanCal*metExt)
		     xend   = car(theBentPoints[7])+(if metEOLenc metEOLenc metEncCon)
		     ystart = cadr(theBentPoints[6])-(contactWidth+i*metExt+metEncCon)
		     yend   = ystart
		     xstep  = -(contactWidth+contactSpacing)
		     ystep  = 0)
	      ) ; cond
	      
	      ;; A small value 0.001 is subtracted so that an integer value
	      ;; is not accidentally approximated to the next higher grid
	      x = xstart y = ystart
	      (while (((j <= 3) && (x <= xend) && (y >= yend)) ||
		      ((j > 3)  && (x >= xend) && (y <= yend)))
		  xDraw = grid*ceiling(x*gridMult-ceilFix)
		  yDraw = grid*ceiling(y*gridMult-ceilFix)
		  dbCreateRect(tcCellView list(thisLayer "drawing")
					  list(xDraw:yDraw
					       xDraw+contactWidth:yDraw+contactWidth))
		  x = x+xstep
		  y = y+ystep
	      )	  
	 ) ; for	  
	 i++
     ) ; foreach
 ) ; else
 
 ;; Start code for slotting the rivetted bus
 ;;
 ;; This is the most complicated code section of the rivetted bus class.
 ;; Most of the rules in Spec. 01-70001 (8.13) deal with the slots on
 ;; the rivet. The inherent geometric complexity of slots makes their
 ;; generation equally difficult.
 ;;
 ;; The following paragraph contains code for straight rivets.
 ;;
 ;; minReqLengthX - Below this length of a rivet in X dimension, it is 
 ;;                 impossible to draw a slot in X dimension.
 ;; slotPitchV    - Maximum vertical pitch possible for adjacent rows of slots.
 ;; slotSpacingV  - Vertical distance for slots adjusted so that the slots are
 ;;                 at equal distance from metal edges, both on top and bottom.
 ;; slotPitchH    - Horizontal pitch of slots in a row.
 ;; 
 ;; Procedure for calculating the parameters given above:
 ;; 1. slotPitchV is calculated. It is the max vertical pitch.
 ;; 2. numRows is calculated and is ceiled so that the number of rows does
 ;;    not fall below the required value.
 ;; 3. slotSpacingV is the spacing between adjacent rows of slots. It is
 ;;    adjusted for the value of numRows.
 ;; 4. slotLength is calculated. It will make the length of all slots equal.
 ;; 5. slotPitchH is calculated accordingly.
 ;;
 ;; dbIdMet - the metal layers already drawn by rivet bus code.
 ;; dbIdy0  - the layer which denotes the areas to be cut away.
 ;; 
 ;;
 ;; Start cutting slots on the straight bus
 ;;
 ;; Each slot is defined by the points (xl,yl) and (xu,yu).
 ;; xstagger - used to stagger the slots in adjacent rows.
 ;; dx       - horizontal slot pitch.
 ;; dy       - vertical slot pitch.
 ;;
 ;; The Cadence layerAndNot function is used for cutting slots on the
 ;; rivet. This is an undocumented function. It does an AndNot operation
 ;; between 2 given layers and returns the resulting layer. The original
 ;; layers have to be deleted after the required layer is derived.
 ;;
;KMI
 (when (totalWidth >= minRivetWidth)
   tolerance = 5
   slotPitchV = minSlotWidth+maxSlotSpacingV
   numRows = ceiling((totalWidth - 2*maxSpacingtoEdge +maxSlotSpacingV+tolerance)/slotPitchV)
   slotSpacingVN = (totalWidth - numRows*minSlotWidth)/(numRows+1)
   slotSpacingV  = grid*floor(slotSpacingVN*gridMult-ceilFix)
   ;; OLD ALG
   (when !newAlg
       minReqLengthX = maxSpacingtoEdge + rivetLengthX*minSlotLengthP
       slotPitchH = maxSlotLength+maxSlotSpacingH
       numSlots = floor(rivetLengthX/slotPitchH+1)

       ;; Adjust the slot length and slot pitch so that
       ;; all slots are equal in length
       slotLength = grid*floor((rivetLengthX - (numSlots-1)*maxSlotSpacingH
                                           - maxSpacingtoEdge)/numSlots*gridMult-ceilFix)
       slotPitchH = slotLength+maxSlotSpacingH
       (when rivetLengthX < minBusLength
           maxSlotLength = rivetLengthX*minSlotLengthP
       )
       ;; To avoid having too small slots
       (when (numSlots > 1) && (slotLength < minSlotLength)
           numSlots = numSlots-1
           slotLength = slotLength*2
           slotPitchH = slotLength+maxSlotSpacingH
       )
   )


 (if noBent then
   ;;;;;;;;;;;;;;;;;;;;;;;;
   ;; new algorithm
   ;;;;;;;;;;;;;;;;;;;;;;;;

   (if newAlg then
     ; the bus joins to other buses; slots extended
     (if !standAlone maxSpacingtoEdge = 0.0)
     (declare staggerLength[2])
     (declare slotPitchH[2])
     (declare slotLength[2])
     maxSpacingtoEdgeB = maxSpacingtoEdge
     maxSpacingtoEdgeE = maxSpacingtoEdge
     xstagger = minOverlap
     (cond 
        ((rivetLengthX < minBusLength)
          numSlots = 1
          slotLength[0] = rivetLengthX * minSlotLengthP
          maxSpacingtoEdgeB = (rivetLengthX-slotLength[0])/2
          (if maxSpacingtoEdgeB > maxSpacingtoEdge then
              slotLength[0] = rivetLengthX
              maxSpacingtoEdgeB = maxSpacingtoEdge
          )
          maxSpacingtoEdgeE = maxSpacingtoEdgeB
          slotPitchH[0] = slotLength[0]
          slotPitchH[1] = slotLength[0]
          slotLength[1] = slotLength[0]
        )
        ( ramTech 
          slotPitchH[0] = minSlotLength+maxSlotSpacingH
          effectiveLength = rivetLengthX - 2*maxSpacingtoEdge
          numSlots = ceiling((effectiveLength+maxSlotSpacingH)/slotPitchH[0])
          slotLength[0] = floor((effectiveLength - (numSlots-1)*maxSlotSpacingH )/numSlots)
          slotPitchH[0] = slotLength[0]+maxSlotSpacingH
          (if (and numSlots > 1 slotLength[0]<minSlotLength) then
              numSlots = numSlots-1
              slotLength[0] = ceiling((effectiveLength - (numSlots-1)*maxSlotSpacingH )/numSlots)
              slotPitchH[0] = slotLength[0]+maxSlotSpacingH
          )
          slotLength[1] = slotLength[0]
          slotPitchH[1] = slotLength[0]
          ;; spacing from the last slot in the row to the edge may be smaller than maxSpacingtoEdge
          maxSpacingtoEdgeE = rivetLengthX-numSlots*slotLength[0]-(numSlots-1)*maxSlotSpacingH-maxSpacingtoEdgeB
          ;; prevent slots to be too short on mod(j 2) rows
          slotLenEnd = slotLength[0] - xstagger
          minSpaceToEdge = length(rivetLayers)*slotExt1+slotExt1
          slotLenDiff = slotLength[0] - slotLenEnd
          (if slotLenEnd < minSlotLength then
              maxSpacingtoEdgeB = (max minSpaceToEdge (maxSpacingtoEdgeB - slotLenDiff/2 ))
              maxSpacingtoEdgeE = (max minSpaceToEdge (maxSpacingtoEdgeE - slotLenDiff/2 ))
          )
              
        )
        ( t
          (for i 0 1
             staggerLength[i] = rivetLengthX - 2*xstagger*mod(i 2)
             slotPitchH[i] = minSlotLength+maxSlotSpacingH
             effectiveLength = staggerLength[i] - 2*maxSpacingtoEdge
             numSlots = ceiling((effectiveLength+maxSlotSpacingH)/slotPitchH[i])
             slotLength[i] = floor((effectiveLength - (numSlots-1)*maxSlotSpacingH )/numSlots)
             slotPitchH[i] = slotLength[i]+maxSlotSpacingH
             (if (and numSlots > 1 slotLength[i]<minSlotLength) then
                 numSlots = numSlots-1
                 slotLength[i] = ceiling((effectiveLength - (numSlots-1)*maxSlotSpacingH )/numSlots)
                 slotPitchH[i] = slotLength[i]+maxSlotSpacingH
             )
          )
        )
     ) 

     i=0
     (foreach thisLayer reverseLayers
       cutLayer = '()
       yl = slotSpacingV - i*slotExt1 + ySlotOffset
       yu = yl + minSlotWidth + 2*i*slotExt1
       dy = minSlotWidth + slotSpacingV
       (for j 0 numRows-1
         ; no staggering for buses < minBusLength
         (if standAlone then
             (if (and !ramTech staggerLength[mod(j 2)]>minBusLength) then
	         xl = maxSpacingtoEdgeB - i*slotExt1 + xstagger*mod(j 2)
              else
	         xl = maxSpacingtoEdgeB - i*slotExt1
             )
          else
             xl = 0.0 - i*slotExt1
         )
	 xu = xl + slotLength[mod(j 2)] + 2*i*slotExt1
         dx = slotPitchH[mod(j 2)]
	 yl = grid*ceiling(yl*gridMult-ceilFix)
	 yu = grid*ceiling(yu*gridMult-ceilFix)

         (for k 1 numSlots
             xl = grid*ceiling(xl*gridMult-ceilFix)
	     xu = grid*ceiling(xu*gridMult-ceilFix)
     
             (if (and !standAlone k==numSlots) xu = rivetLengthX)
             ;; keep minOverlap of staggered slots
             (if (and ramTech mod(j 2)==1 k==1) xu=xu+xstagger  )
             ;; adjust last slots
             (if (and ramTech standAlone k==numSlots) xu = rivetLengthX-maxSpacingtoEdgeE+i*slotExt1)
	     dbIdy0 = dbCreateRect(tcCellView '("y0" "drawing") list(xl:yl xu:yu))
	     cutLayer = cons(dbIdy0 cutLayer)
	     xl=xu+maxSlotSpacingH-2*i*slotExt1
             xu=xl+slotLength[mod(j 2)]+2*i*slotExt1
	 )     
	 yl = yl+dy
	 yu = yu+dy
       ) ; the numRows loop
       i++
       ;; Get the dbId for the particular metal layer polygon
       dbIdMet = (list (nthelem i dbId0))
       (layerAndNot tcCellView thisLayer dbIdMet cutLayer)
       ;; Delete the original rivet metal shapes.
       (foreach thisObject dbIdMet (when thisObject dbDeleteObject(thisObject)))
       ;; Delete the y0 shapes used  for cutting slots.
       (foreach thisObject cutLayer dbDeleteObject(thisObject))
     ) ; foreach

   else     

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ;;;  old algorithm
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
         i = 0
         (foreach thisLayer reverseLayers
             cutLayer = '()
             xstagger = minOverlap
             yl = slotSpacingV - i*slotExt1 + ySlotOffset
             yu = yl + minSlotWidth + 2*i*slotExt1
             dx = slotPitchH
             dy = minSlotWidth + slotSpacingV
             (for j 1 numRows
                  xl = maxSpacingtoEdge/2 - i*slotExt1
                  xu = xl + slotLength + 2*i*slotExt1
                  ;; Stagger the slots
                  ;; Slots on even number rows will be staggered at
                  ;; the beginning
                  (when numSlots > 1
                      (if xstagger > 0 then
                          xstagger = 0
                       else
                          xstagger = minOverlap
                      )
                  )
                  (for k 1 numSlots
                       ;; No staggering for rivet with only one slot
                       (when numSlots > 1
                           (cond
                               (k == 1        xl = xl+xstagger xu = xu+xstagger)
                               (k == numSlots                  xu = xu-xstagger)
                           )
                       )

                       (cond
                           (standAlone
                            drawSlot = ((numSlots == 1) ||
                                        (((xu-xl) >= minSlotLength) &&
                                         (rivetLengthX >= minReqLengthX))))
                           (!standAlone
                            (when k==numSlots
                                xu = rivetLengthX)
                            drawSlot = (rivetLengthX >= minReqLengthX))
                       )
                       (when drawSlot
                           xl = grid*ceiling(xl*gridMult-ceilFix)
                           xu = grid*ceiling(xu*gridMult-ceilFix)
                           yl = grid*ceiling(yl*gridMult-ceilFix)
                           yu = grid*ceiling(yu*gridMult-ceilFix)
                           dbIdy0 = dbCreateRect(tcCellView
                                                 '("y0" "drawing")
                                                 list(xl:yl xu:yu))
                           cutLayer = cons(dbIdy0 cutLayer)
                           xl=xl+dx  xu=xu+dx
                       )
                  )
                  yl = yl+dy
                  yu = yu+dy
             ) ; the numRows loop
             ;; Get the dbId for the particular metal layer polygon
             i = i+1
             dbIdMet = (list (nthelem i dbId0))
             (layerAndNot tcCellView thisLayer dbIdMet cutLayer)
             ;; Delete the original rivet metal shapes.
             (foreach thisObject dbIdMet
                 (when thisObject
                     dbDeleteObject(thisObject)))
             ;; Delete the y0 shapes used  for cutting slots.
             (foreach thisObject cutLayer
                 dbDeleteObject(thisObject))

         ) ; foreach
     )  ;END OLD ALG	

 
 else
	 ;;
	 ;; Start cutting slots on the bent rivet
	 ;;
	 ;;
	 ;;      --- rivetLengthX ------|   
	 ;;     8________________________7   __
	 ;;                               \   	 ;;                                \   	 ;;                                 \   	 ;;                                  \   rivetLengthZ
	 ;;      met1+met2                    \   	 ;;      _________________2.1          \   	 ;;       currentLengthX  \             \   	 ;;                        \             \   	 ;;      met2               \             \   	 ;;      _____________       \             \   	 ;;     1             2\      \             \  _\_
	 ;;                     \      \ 3.1         \6  _
	 ;;                     3\      |             |  | 
	 ;;                       |     |             |  rivetLengthY
	 ;;                       |     |             |  |
	 ;;     FIGURE 2          |     |             |  |
	 ;;                      4|     |             |5 |  
	 ;;                       metExt
	 ;;       
	 ;;
	 ;; The rivet bus has a structure shown above towards the edges. The
	 ;; higher order metal layer extends beyond the lower order layer.
	 ;; For example, met2 extends beyond met1 by metExt. 
	 ;;
	 ;; allowance      - used for avoiding errors in marginal cases.
	 ;; rivetLengthT   - The total linear length of the rivet.
	 ;; slotCalU       - Width of a layer on the slot. The slot width varies
	 ;;                  for each layer because of layer extension.
	 ;; slotCalL       - Vertical distance to the beginning of a slot. The
	 ;;                  parameters slotCalL and slotCalU will define the y
	 ;;                  dimension of a slot.
	 ;; currentOffset  - Suppose the current layer for which the slot is 
	 ;;                  drawn is met1. currentOffset is how much to the
	 ;;                  right point 7 is with respect to(w.r.t) point 2.1.
	 ;;                  (rivetLengthX-currentOffset) will give the length
	 ;;                  of the rivet from the start to the point 2.1.
	 ;; currentLengthX - These are the dimensions of the rivet for the
	 ;; currentLengthY   current layer. They are derived from the original
	 ;; currentLengthZ   dimensions, rivetLengthX, Y and Z.
	 ;; slotPitchH     - Horizontal slot pitch.
	 ;; numSlots       - number of slots in a row.
	 ;; slotLength     - length of a slot.
	 ;; (x1,y1)        - point 2.1 for met1 layer.
	 ;; (x2,y2)        - point 3.1 for met1 layer.
	 ;; (xs,ys)        - start point for the rivet(point 1).
	 ;; (xe,ye)        - end point for the rivet(point 4).
	 ;;
	 ;; Slots are drawn based on 6 categories.
	 ;; 1. (xs<x1) && (xe<x1)     
	 ;;    Slot is between point 1 and 2. It is a straight one.
	 ;; 2. (xs<x1) && (xe>x1) && (ye>y2)
	 ;;    It starts between point 1 and point 2 and continues to the bend
	 ;;    and ends somewhere on the bend, ie before point 3 is reached.
	 ;; 3. (xs<x1) && (xe>=x2) && (ye<y2)
	 ;;    It starts between point 1 and point 2 and continues through the
	 ;;    bend and ends somewhere beyond point 3.
	 ;; 4. (xs>x1) && (ys>y2) && (ye<y2)
	 ;;    It starts on the bend(between point 2 and 3) and ends beyond
	 ;;    point 3.
	 ;; 5. (xs>x1) && (xe<x2) && (ye>y2)
	 ;;    It starts on the bend(between point 2 and 3) and ends on the bend.
	 ;; 6. (ys<y2) && (ye<y2)
	 ;;    It starts beyond point 3 and ends beyond point 3.
	 ;;
	 ;; The points (xs,ys) and (xe,ye) along with slotCalL, slotCalU defines
	 ;; one slot. The points (xs,ys) and (xe,ye) are calculated for the
	 ;; next slot after a slot is drawn. Then, according to these points
	 ;; the next slot falls in one the 6 categories and gets drawn. This
	 ;; process continues till "numSlots" slots are drawn.
	 ;;
	 i = 0
	 allowance = 5*grid
	 dbId1 = reverse(dbId1)
         ;;;;;;;;;;;;;;;;;;;;
         ;;   NEW ALG
         ;;;;;;;;;;;;;;;;;;;;
         (when newAlg
             X0 = rivetLengthX - bevelOffset + slotSpacingV*tanCal
             (if standAlone then
                 maxSpacingtoEdge = min(maxSpacingtoEdge X0)
              else
                 ; the bus joins to other buses; slots extend
                 maxSpacingtoEdge = 0.0
             )
         ) ;END NEW ALG

	 (foreach thisLayer reverseLayers
	     dbIdy0 = '()
	     dbIdMet = '()
	     slotCalU = minSlotWidth + 2*i*slotExt1
	     rivetLengthT = rivetLengthX + rivetLengthY + rivetLengthZ
	     (for j 0 numRows-1     
		  slotCalL = slotSpacingV + j*(slotSpacingV+minSlotWidth) 
		  currentOffset = bevelOffset - tanCal*slotCalL
		  currentOffset = grid*ceiling(currentOffset*gridMult-ceilFix)
		  currentLengthX = rivetLengthX - currentOffset
		  currentLengthZ = rivetLengthZ - 2*currentOffset
		  currentLengthY = rivetLengthY - currentOffset
		  currentLengthT = currentLengthX+currentLengthY+currentLengthZ
  
                  (if newAlg then
                      ;;;;;;;;;;;;;;;;;;;;
                      ;;   NEW ALG
                      ;;;;;;;;;;;;;;;;;;;;

                      staggerLength = currentLengthT - 2*minOverlap*mod(j 2)
                      (if staggerLength < minBusLength then 
                          numSlots = 1
  	                  slotLength = currentLengthT - 2*maxSpacingtoEdge 
		          slotPitchH = slotLength
                       else
                          slotPitchH = minSlotLength+maxSlotSpacingH
                          effectiveLength = staggerLength - 2*maxSpacingtoEdge 
                          numSlots = ceiling((effectiveLength+maxSlotSpacingH)/slotPitchH)
  	                  slotLength = floor((effectiveLength - (numSlots-1)*maxSlotSpacingH )/numSlots)
		          slotPitchH = slotLength+maxSlotSpacingH
                      )
                      (while (and numSlots>1 slotLength<minSlotLength)
                           numSlots = numSlots-1
  	                   slotLength = ceiling((effectiveLength - (numSlots-1)*maxSlotSpacingH )/numSlots)
                           slotPitchH = slotLength+maxSlotSpacingH
                      )
                      ;; no staggering for buses < minBusLength
		      (if (and (and !ramTech standAlone) staggerLength>minBusLength) then 
                          xs = maxSpacingtoEdge + minOverlap*mod(j 2) 
                       else
                          xs = maxSpacingtoEdge 
                      )
                  else
                      ;;;;;;;;;;;;;;;;;;;;
                      ;;   OLD ALG
                      ;;;;;;;;;;;;;;;;;;;;

                      slotPitchH = maxSlotLength+maxSlotSpacingH
                      numSlots = ceiling(currentLengthT/slotPitchH)
                      slotLength = ceiling((currentLengthT - numSlots*maxSlotSpacingH)/numSlots)
                      slotPitchH = slotLength+maxSlotSpacingH 
                      xs = maxSpacingtoEdge + minOverlap*mod(j 2) - 4*grid
                  )  ;END OLD ALG
                  
		  x1 = rivetLengthX - bevelOffset + tanCal*slotCalL 
		  x1 = grid*ceiling(x1*gridMult-ceilFix)
		  y1 = slotCalL 
		  x2 = x1 + (rivetLengthZ - 2*bevelOffset + 2*tanCal*slotCalL)/root2
		  y2 = y1 - (rivetLengthZ - 2*bevelOffset + 2*tanCal*slotCalL)/root2
		  x2 = grid*ceiling(x2*gridMult-ceilFix)
		  y2 = grid*ceiling(y2*gridMult-ceilFix)
		  ys = slotCalL
		  xe = xs+slotLength
		  (cond
		      ((xe<x1)
		       ye = slotCalL)
		      ((xs>x1) && (slotLength<currentLengthZ)
		       xs = x1 + grid
		       xe = xs + slotLength/root2
		       ys = y1 - grid
		       ye = ys - slotLength/root2)
		      ((xs>x1) && (slotLength>currentLengthZ)
		       xs = x1 + grid
		       ys = y1 - grid
		       offsetCal = currentLengthZ/root2 + (slotLength-currentLengthZ)
		       xe = x2
		       ye = ys - offsetCal)
		      ((xe>x1) && ((xe-x1)<currentLengthZ)
		       offsetCal = (xe-x1)/root2
		       offsetCal = grid*ceiling(offsetCal*gridMult-ceilFix)
		       xe = x1 + offsetCal
		       ye = y1 - offsetCal)
		      ((xe>x1) && ((xe-x1)>currentLengthZ)
		       xe = x2
		       ye = y2-(slotLength-((x1-xs)+currentLengthZ)))
		  )

		  (for k 0 numSlots-1
		       workingList = '()
		       numPoints = 0
                       ;; slots begin at maxSpacingToEdge
		       (setq firstSlotExt nil)

                      (if newAlg then
                          ;;;;;;;;;;;;;;;;;;;;
                          ;;   NEW ALG
                          ;;;;;;;;;;;;;;;;;;;;

                          ;; open the last slot in a row (extend slots beyond rivetLengthY)
		          (if k == numSlots-1 then
		              xe = x2
			      ye = -(lOffset+rivetLengthY-bevelOffset)
                          )
                          (if standAlone  then
                              offsetCal = -(lOffset+rivetLengthY-bevelOffset)
                              offsetCal = grid*ceiling(offsetCal*gridMult-ceilFix)
		              (if ramTech then
                                  ;; close the last slot in a row at maxSpacingToEdge
                                  (if k == numSlots-1 ye = offsetCal+maxSpacingtoEdge)
                               else
                                  ;; close the last slot in a row at maxSpacingToEdge+minOverlap
                                  ;; no staggering for staggerLength<minBusLength
                                  (if staggerLength<minBusLength then
                                       ye = offsetCal+maxSpacingtoEdge
                                   else
                                      (when  k == numSlots-1 
                                             ye = offsetCal+maxSpacingtoEdge+minOverlap*mod(j 2))
                                  )
                              )
                           else
                              ;; open the first slot in a row
                              (if k==0 (setq firstSlotExt t))
                           )

                       else
                          ;;;;;;;;;;;;;;;;;;;;
                          ;;   OLD ALG
                          ;;;;;;;;;;;;;;;;;;;;

                          ;; Adjust the last slot length so that it stays within
                          ;; the metal bus if the bus is standAlone
                          (if standAlone then
                              offsetCal = -(lOffset+rivetLengthY-bevelOffset)
                              offsetCal = grid*ceiling(offsetCal*gridMult-ceilFix)
                              (when ye<(offsetCal+allowance)
                                  ye = offsetCal+maxSpacingtoEdge+allowance
                                  ;; If there is not enough space to draw the slot
                                  ;; take the slot outside the pcell so that it is
                                  ;; not drawn
                                  (when (ys-ye)<minSlotLength
                                      ys = 2*offsetCal
                                      ye = ys)
                              )
                           else
                              ;; In this case, the bus joins to other buses.
                              ;; So extend the slots to both ends so that
                              ;; they can merge with slots on the next bus.
                              (when k == 0 (setq firstSlotExt t))
                              (when k == numSlots-1
                                  xe = x2
                                  ye = -(lOffset+rivetLengthY-bevelOffset))
                           )
                       )  ;END OLD ALG


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; END CHANGES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		       (cond
			   ( (xs<x1) && (xe<x1)
			     numPoints = 5
			     (if firstSlotExt then
				 WA[0] = list(0 ys-i*slotExt1)
			      else
				 WA[0] = list(xs-i*slotExt1 ys-i*slotExt1)
			     )
			     WA[1] = list(xe+i*slotExt1 ye-i*slotExt1)
			     WA[2] = list(car(WA[1]) cadr(WA[1])+slotCalU)
			     WA[3] = list(car(WA[0]) cadr(WA[0])+slotCalU)
			     WA[4] = WA[0]
			     
			     xs = xs + slotPitchH
			     xe = xe + slotPitchH
			     (cond
				 ((xe<x1) && (xs<x1)
				  ye = slotCalL)
				 ((xe>x1) && ((xe-x1)<currentLengthZ) && (xs<x1)
				  offsetCal = (xe-x1)/root2
				  offsetCal = grid*ceiling(offsetCal*gridMult-ceilFix)
				  xe = x1 + offsetCal
				  ye = y1 - offsetCal)
				 ((xe>x1) && ((xe-x1)>currentLengthZ) && (xs<x1)
				  xe = x2
				  ye = y2-(slotLength-((x1-xs)+currentLengthZ)))
				 ((xs>x1) && ((xs-x1+slotLength)<currentLengthZ)
				  offsetCal = (xs-x1)/root2
				  offsetCal = grid*ceiling(offsetCal*gridMult-ceilFix)
				  xs = x1 + offsetCal
				  xe = xs + slotLength/root2
				  xe = grid*ceiling(xe*gridMult-ceilFix)
				  ys = ys - offsetCal
				  ye = ys - slotLength/root2
				  ye = grid*ceiling(ye*gridMult-ceilFix))
				 ((xs>x1) && ((xs-x1+slotLength)>currentLengthZ)
				  offsetCal = (xs-x1)/root2
				  offsetCal = grid*ceiling(offsetCal*gridMult-ceilFix)
				  xs = x1 + offsetCal
				  xe = x2
				  ys = ys - offsetCal
				  ye = ys - ((xe-xs)+(slotLength-(xe-xs)*root2))
				  ye = grid*ceiling(ye*gridMult-ceilFix))
			     )
			   )
			   ( (xs<x1) && (xe>x1) && (ye>y2)
			     numPoints = 7
			     (if firstSlotExt then
				 WA[0] = list(0 ys-i*slotExt1)
			      else
				 WA[0] = list(xs-i*slotExt1 ys-i*slotExt1)
			     )
			     offsetCal = grid*ceiling((x1-i*slotExt1*tanCal)*gridMult-ceilFix)
			     WA[1] = list(offsetCal ys-i*slotExt1)
			     offsetCal = grid*ceiling((ye-i*slotExt1*root2)*gridMult-ceilFix)
			     WA[2] = list(xe offsetCal)
			     offsetCal = slotCalU/root2
			     offsetCal = grid*ceiling(offsetCal*gridMult-ceilFix)
			     WA[3] = list(car(WA[2])+offsetCal cadr(WA[2])+offsetCal)
			     offsetCal = slotCalU*tanCal
			     offsetCal = grid*ceiling(offsetCal*gridMult-ceilFix)
			     WA[4] = list(car(WA[1])+offsetCal cadr(WA[1])+slotCalU)
			     WA[5] = list(car(WA[0]) cadr(WA[0])+slotCalU)
			     WA[6] = WA[0]
			     
			     ;; This piece of code is used to make sure that
			     ;; slots on bent rivet are at 45 degree. It checks
			     ;; if the projections of the slot in x and y are
			     ;; equal. If not equal, one length is adjusted to 
			     ;; make them equal.
			     xFinal = car(WA[1]) + ((car(WA[2])-car(WA[1])) -
						    (cadr(WA[1])-cadr(WA[2])))
			     WA[1] = list(xFinal cadr(WA[1]))
			     xFinal = car(WA[4]) + ((car(WA[3])-car(WA[4])) -
						    (cadr(WA[4])-cadr(WA[3])))
			     WA[4] = list(xFinal cadr(WA[4]))
			     ;; End 45 degree code
			     
			     ys = ye - maxSlotSpacingH/root2
			     ye = ye - slotPitchH/root2
			     (cond
				 ((ys>y2) && (ye>y2)
				  xs = xe + maxSlotSpacingH/root2
				  xe = xe + slotPitchH/root2)
				 ((ys>y2) && (ye<y2)
				  xs = xe + maxSlotSpacingH/root2
				  xe = x2
				  ye = y2 - (slotPitchH-((ys-y2)*root2)))
				 ((ys<y2) && (ye<y2)
				  xs = x2
				  xe = x2
				  ys = y2
				  ye = y2 + slotLength)
			     )	
			   )		     			      
			   ( (xs<x1) && (xe>=x2) && (ye<y2)
			     numPoints = 9
			     (if firstSlotExt then				 
				 WA[0] = list(0 ys-i*slotExt1)
			      else
				 WA[0] = list(xs-i*slotExt1 ys-i*slotExt1)
			     )
			     offsetCal = x1-i*slotExt1*tanCal
			     offsetCal = grid*ceiling(offsetCal*gridMult-ceilFix)
			     WA[1] = list(offsetCal ys-i*slotExt1)
			     offsetCal =  y2-i*slotExt1*tanCal
			     offsetCal = grid*ceiling(offsetCal*gridMult-ceilFix)
			     WA[2] = list(x2-i*slotExt1
					  offsetCal)
			     WA[3] = list(x2-i*slotExt1 ye-i*slotExt1)
			     WA[4] = list((car(WA[3])+slotCalU)
					  cadr(WA[3]))
			     offsetCal = slotCalU*tanCal
			     offsetCal = grid*ceiling(offsetCal*gridMult-ceilFix)
			     WA[5] = list(car(WA[2])+slotCalU cadr(WA[2])+offsetCal)
			     WA[6] = list(car(WA[1])+offsetCal cadr(WA[1])+slotCalU)
			     WA[7] = list(car(WA[0]) cadr(WA[0])+slotCalU)
			     WA[8] = WA[0]
			     
			     yFinal = cadr(WA[2]) - ((car(WA[2])-car(WA[1])) -
						     (cadr(WA[1])-cadr(WA[2])))
			     WA[2] = list(car(WA[2]) yFinal)
			     yFinal = cadr(WA[5]) - ((car(WA[5])-car(WA[6])) -
						     (cadr(WA[6])-cadr(WA[5])))
			     WA[5] = list(car(WA[5]) yFinal)
			     
			     xs = x2
			     xe = x2
			     ys = ye - maxSlotSpacingH
			     ye = ye - slotPitchH
			   )					   
			   ( (xs>x1) && (ys>y2) && (ye<y2)
			     numPoints = 7
			     offsetCal = xs-i*slotExt1*root2
			     offsetCal = grid*ceiling(offsetCal*gridMult-ceilFix)
			     WA[0] = list(offsetCal ys)
			     offsetCal = y2-i*slotExt1*tanCal
			     offsetCal = grid*ceiling(offsetCal*gridMult-ceilFix)
			     WA[1] = list(x2-i*slotExt1 offsetCal)
			     WA[2] = list(xe-i*slotExt1 ye-i*slotExt1)
			     WA[3] = list(car(WA[2])+slotCalU cadr(WA[2]))
			     offsetCal = grid*ceiling(slotCalU*tanCal*gridMult-ceilFix)
			     WA[4] = list((car(WA[1])+slotCalU)
					  (cadr(WA[1])+offsetCal))
			     offsetCal = grid*ceiling((minSlotWidth/root2+i*slotExt1*root2)*gridMult-ceilFix)
			     WA[5] = list((car(WA[0])+offsetCal)
					  (cadr(WA[0])+offsetCal))
			     WA[6] = WA[0]
			     
			     yFinal = cadr(WA[1]) - ((car(WA[1])-car(WA[0])) -
						     (cadr(WA[0])-cadr(WA[1])))
			     WA[1] = list(car(WA[1]) yFinal)
			     yFinal = cadr(WA[4]) - ((car(WA[4])-car(WA[5])) -
						     (cadr(WA[5])-cadr(WA[4])))
			     WA[4] = list(car(WA[4]) yFinal)
			     
			     xs = x2
			     xe = x2
			     ys = ye - maxSlotSpacingH
			     ye = ye - slotPitchH
			   )
			   ( (xs>x1) && (xe<x2) && (ye>y2)
			     numPoints = 5
			     xe = xs + slotLength/root2
			     xe = grid*ceiling(xe*gridMult-ceilFix)
			     offsetCal = grid*ceiling(i*slotExt1*root2*gridMult-ceilFix)
			     WA[0] = list(xs-offsetCal ys)
			     WA[1] = list(xe ye-offsetCal)
			     offsetCal = grid*ceiling(slotCalU/root2*gridMult-ceilFix)
			     WA[2] = list((car(WA[1])+offsetCal)
					  (cadr(WA[1])+offsetCal))
			     WA[3] = list((car(WA[0])+offsetCal)
					  (cadr(WA[0])+offsetCal))
			     WA[4] = WA[0]
			     
			     ys = ye - maxSlotSpacingH/root2			      
			     ye = ye - slotPitchH/root2
			     (cond
				 ((ys>y2) && (ye>y2)
				  xs = xe + maxSlotSpacingH/root2
				  xe = xe + slotPitchH/root2)
				 ((ys>y2) && (ye<y2)
				  xs = xe + maxSlotSpacingH/root2
				  xe = x2
				  ye = y2 - (slotPitchH-((ys-y2)*root2)))
				 ((ys<y2) && (ye<y2)
				  xs = x2
				  xe = x2
				  ys = y2 - (y2-ys)*root2
				  ye = ys - slotLength)
			     )
			   )			      
			   ( (ys<y2) && (ye<y2)
			     numPoints = 5
			     WA[0] = list(xs-i*slotExt1 ys+i*slotExt1)
			     WA[1] = list(xs-i*slotExt1 ye-i*slotExt1)
			     WA[2] = list(car(WA[1])+slotCalU cadr(WA[1]))
			     WA[3] = list(car(WA[0])+slotCalU cadr(WA[0]))
			     WA[4] = WA[0]
			     
			     ys = ys-slotPitchH
			     ye = ye-slotPitchH
			   )
		       ) ; cond
		       xs = grid*ceiling(xs*gridMult-ceilFix)
		       xe = grid*ceiling(xe*gridMult-ceilFix)
		       ys = grid*ceiling(ys*gridMult-ceilFix)
		       ye = grid*ceiling(ye*gridMult-ceilFix)		
		       (when numPoints >= 4
			   (for p 0 numPoints-1
				workingList = (cons WA[p] workingList)
			   )
			   dbIdy0 = cons(dbCreatePolygon(tcCellView list("y0" "drawing")
								    workingList) dbIdy0)
		       )
		  ) ; for numSlots
	     ) ; for numRows
	     i++
	     dbIdMet = (list (nthelem i dbId1))
	     (layerAndNot tcCellView thisLayer dbIdMet dbIdy0)
	     (foreach thisObject dbIdMet
		 (when thisObject 
		     dbDeleteObject(thisObject)))
	     (foreach thisObject dbIdy0
		 dbDeleteObject(thisObject))
	 ) ; foreach
     ) ; if then else  
 ) ; when 

 
) ; tcCreateDeviceClass

;; todo - enable ySlotOffset for bent rivet
  

;;; 
;;; $Id: rivetRingClass.il,v 1.4 2004/10/23 01:53:52 kmi Exp $ %T%
;;; 
;;; rivetRingClass.il
;;; 
;;; Copyright (c) 1997 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Feb 20, 1997
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This is a part of the device library.  It will be used to generate
;;; rivets within a ring structure.  All of the parameters are formal
;;; parameters.  It is not intended to be used directly by designers,
;;; but it is intended to be instantiated by other device in the device lib.
;;; 
;;; Revision History:
;;;   gtc 04/17/97  added an optional "rivetLayer2" that it can alternate
;;;                 placing rivets in
;;;   gtc 04/22/97  adding sensible default parameter values
;;;   lpn 01/28/04  Updated the class to draw different spacing in X and y direction
;;;                 and also updated the corner sections to meet c8 diesealr in TCS 790
;;;   kmi 10/19/04 replacing hard coded grid value with (TECHgetProp snapGrid)
;;;

(putpropqq rivetRingClass "$Id: rivetRingClass.il,v 1.4 2004/10/23 01:53:52 kmi Exp $ %T%" SCCS)

(tcCreateDeviceClass
 "symbolic" "rivetRingClass"
 ;; Class parameters
 ( 
 )
 ;; Formal parameters
 (
  (w                      50.0)
  (l                      50.0)
  (xOffset                 0.0)
  (yOffset                 0.0)
  (rivetLayer             (list "hilite" "drawing"))
  (rivetLayer2             nil)
  (ringWidth               6.0)
  (rivetWidth              0.6)
  (rivetSpace              0.8)  ;; Y direction
  (rivetSpaceX	           0.0)  ;; X direction
  (llBevelLength          10.0)
  (ulBevelLength          10.0)
  (lrBevelLength          10.0)
  (urBevelLength          10.0)
  (autoIncreaseBevelWidth "FALSE")
  (grid     (TECHgetProp snapGrid))
  (lessConNearbevel    "FALSE")
  (numColsLess               0) ;; control number of cols in 45 degree corners Default should be zero	
  (updatedClass        "FALSE") ;; to control new options  
  (altCorCon           "FALSE") ;; alternate the contacts in the 45 degree corner region for the updatedClass 
 )

 ;; s2 is the square root of 2.0
 (setq s2 (sqrt 2.0))
 
 (declare thisLayer[2])
 thisLayer[0] = rivetLayer
 thisLayer[1] = (or rivetLayer2 rivetLayer)
 (setq contactNum 0)
 
 (setq rivetSpaceY rivetSpace)
 (when (equal rivetSpaceX 0.0)
     (setq rivetSpaceX rivetSpace)
 )


 (setq rivetPitchY (plus rivetWidth rivetSpaceY))
 (setq rivetPitchX (plus rivetWidth rivetSpaceX))
 (setq rivetPitchX_orig  rivetPitchX)
 (setq rivetPitchY_orig  rivetPitchY)
 (setq rivetPitchMax (max rivetPitchY rivetPitchX))	
 (setq rivetPitchMin (min rivetPitchY rivetPitchX))

 (if (rivetPitchY > rivetPitchX) then	
     (setq rivetPitchOffset (difference  rivetPitchY rivetPitchX))
  else	
     (setq rivetPitchOffset (difference  rivetPitchX rivetPitchY))
 )
 
 
 (setq rivetPitchOffsetHalf (quotient rivetPitchOffset 2))
 
 ;; find out how many column can fit within the "ringWidth"
 
(setq numCols (fix (plus (quotient (plus ringWidth rivetSpaceX) rivetPitchX) 1e-5)))
 
 ;; the rivets it places will be along the outside edge of the ring.
 ;; find out how much of the ring width it will actually use to place
 ;; numCols of rivets
 (setq usedRingWidth (difference (times numCols rivetPitchX) rivetSpaceX))
 
 ;; it might need to increase the ringWidth in the corners in order to
 ;; fit in a rivet.  Only do this when "autoIncreaseBevelWith" is true.
 ;; It will also determine how many columns of rivets can be placed
 ;; horizontally or vertically in the bevelled corners.
 (cond ((and (equal autoIncreaseBevelWidth "TRUE")
	     (lessp ringWidth (times s2 rivetWidth)))
	(setq additionalBevelWidth
	      (quotient (plus rivetWidth
			      (times (difference 1 s2) usedRingWidth))
			s2))
	(setq numColsInBevel numCols)
       )
     (t
      (setq additionalBevelWidth 0.0)
      (setq numColsInBevel
	    (fix (plus 1e-5 (quotient (difference (plus rivetSpaceX (times s2 ringWidth))
						  rivetWidth)
				      rivetPitchX))))
     )
 )

 ;; create a property of how much additional width is placed in the bevels
 (dbCreateProp tcCellView "additionalBevelWidth" "float" additionalBevelWidth)
 
 ;; determine what the minimum bevel cut length is in order to contain a
 ;; rivet in the bevelled corner
 (setq minBevelCutForRivet (difference (times 2.0 rivetPitchX) 1e-5))
 
 ;; the bevelInsideOffset is necessary to maintain a constant width
 ;; throughout the corner
 (setq bevelInsideOffset
       (quotient (plus (times ringWidth (difference s2 1.0))
		       (times s2 additionalBevelWidth))
		 grid))
 
 ;; now use a "ceiling" function to snap it up to the next grid.
 ;; this assumes that the grid is < 1.0
 (setq fixedBev (fix (plus 0.999 bevelInsideOffset)))
 (setq bevelInsideOffset (times grid fixedBev))
 
 ;; "cannotBevelLength" is the point at which the inside bevel will be
 ;; pinched off.  We do not allow bevels to occur when the bevel length
 ;; in a corner is less than this value
 (setq cannotBevelLength (difference ringWidth bevelInsideOffset))
 
 ;; determine whether it should bevel in each corner
 (setq llBevel (greaterp llBevelLength cannotBevelLength))
 (setq lrBevel (greaterp lrBevelLength cannotBevelLength))
 (setq urBevel (greaterp urBevelLength cannotBevelLength))
 (setq ulBevel (greaterp ulBevelLength cannotBevelLength))
 
 ;; It will draw the rivets in 8 steps:
 ;;   1.  Draw the rivets along the bottom edge
 ;;   2.  Draw the rivets in the lower right corner
 ;;   3.  Draw the rivets along the right edge
 ;;   4.  Draw the rivets in the upper right corner
 ;;   5.  Draw the rivets along the top edge
 ;;   6.  Draw the rivets in the upper left corner
 ;;   7.  Draw the rivets along the left edge
 ;;   8.  Draw the rivets in the lower left corner
 
 ;;
 ;; Prepare to draw the rivets along the bottom edge.  See if there is a
 ;; bevel in the lower left corner, and set the xOrigin and yOrigin
 ;; of the rivets accordingly.  As it is looping around, it will use the
 ;; following variables:
 ;;
 ;; xOrigin     is the x origin of the rivets
 ;; xLoopOrigin is the x origin of the rivets as it is looping through rows
 ;; xStop       when it is looping through columns, do not place a column
 ;;             beyond this x stopping point
 ;; yOrigin     is the y origin of the rivets
 ;; yLoopOrigin is the y origin of the rivets as it is looping through columns
 ;; yStop       when it is looping through rows, do not place a row
 ;;             beyond this y stopping point
 ;;
 ;; prepare origins for the row of rivets on the bottom
 (cond  (llBevel
	 (setq xOrigin (plus xOffset llBevelLength))
	 (setq yOrigin yOffset)
	)
     (t
      (setq xOrigin xOffset)
      (setq yOrigin yOffset)
     )
 )
 
 ;; make sure that there will not be a spacing error between the rivets
 ;; along the left edge and the rivets along the bottom edge.  If necessary,
 ;; increase the x origin of the rivets along the bottom edge.
 (when (lessp llBevelLength (plus usedRingWidth rivetSpaceX))
     (setq xOrigin (plus xOffset (max (plus usedRingWidth rivetSpaceX)
				      rivetPitchX)))
 

)

 ;; set the stopping condition for the row of rivets on the bottom
 (cond (lrBevel
	(setq xStop (plus xOffset l -lrBevelLength -rivetWidth))
       )
     (t
      (setq xStop (plus xOffset l -rivetWidth))
     )
 )

 (when (equal lessConNearbevel "TRUE")
     (setq xStop (plus xStop -rivetPitchX))
 )
 ;;
 ;; 1.  Draw the rivets along the bottom edge
 ;;
 (setq tempContactNum contactNum)
 (setq yLoopOrigin yOrigin)
 (for col 1 numCols
      (setq contactNum (mod (plus tempContactNum 1) 2))
      (setq tempContactNum contactNum)
      (setq xLoopOrigin xOrigin)
      
      (when (equal lessConNearbevel "TRUE")
	  (setq xLoopOrigin (plus xOrigin rivetPitchY))
	  
      )
      (while (xLoopOrigin < xStop)
	  (dbCreateRect tcCellView thisLayer[contactNum]
			(list xLoopOrigin:yLoopOrigin
			      (plus xLoopOrigin rivetWidth):
			      (plus yLoopOrigin rivetWidth)))
	  (setq contactNum (mod (plus contactNum 1) 2))
	  (setq xLoopOrigin (plus xLoopOrigin rivetPitchY))
      )
      (setq yLoopOrigin (plus yLoopOrigin rivetPitchX))
 )
(when (equal lessConNearbevel "TRUE")
    (setq xLoopOrigin (plus xLoopOrigin rivetPitchX))
)


;; this is to aviod update to algo draw correctly in 45 degree

(when (equal updatedClass "TRUE")
    (setq rivetPitchX  rivetPitchMax )
    (setq rivetPitchY  rivetPitchMax )
    thisLayer[0] = rivetLayer  
    thisLayer[1] = rivetLayer2
    (setq rivetPitchOffsetHalf  0.0 )        ;; rivetPitchX = rivetPitchY
    (setq rivetPitchOffset      0.0 )        ;; rivetPitchX = rivetPitchY
)

(setq numColsLR        (plus numCols -numColsLess))
(setq numColsInBevelLR (plus numColsInBevel -numColsLess))

;;
;; 2.  Draw the rivets in the lower right corner
;;
(cond ((and lrBevel (greaterp lrBevelLength minBevelCutForRivet))
       
       ;; In centering the rivets in a bevelled corner, the following
       ;; variables will be used:
       ;;
       ;; slackFromLastRun - how much space there is between the last rivet
	;;    in the last run and the beginning of the bevel in this corner.
	;; delta - non-zero only when the next run of rivets must be pushed
	;;    out to prevent them from overlapping the last run of rivets.
	;;    This is how much extra space there is in the corner.
	;; totalSlack - the total amount of slack that will be used to
	;;    center the rivets in the corner.
	;; extraOffset - half of totalSlack nicely snapped to the grid
	;; theStartRow - what row to start drawing the rivets.  This will
	;;    usually be 1.  It will be > 1 when the corner is being pinched
	;;    when the next run of rivets is going to be pushed out to prevent
	;;    them from overlapping the last run of rivets.
	;;
	
	(setq slackFromLastRun (plus xOffset l -lrBevelLength -xLoopOrigin rivetSpaceX))

	;; see if it needs to massage the y origin.  This is a condition when
	;; the y origin of the rivets along the right edge must be pushed
	;; up to prevent them from overlapping the rivets along the bottom edge
	(cond ((lessp lrBevelLength (plus usedRingWidth rivetSpaceX))
	       (setq delta (min (plus -lrBevelLength usedRingWidth rivetSpaceX)
				rivetPitchX))
	       (setq theStartRow (difference 1 (fix (plus 1e-5 (quotient (plus usedRingWidth rivetSpaceX -lrBevelLength) rivetPitchX)))))
	      )
	    (t	    
	     (setq delta 0.0)
	     (setq theStartRow 1)
	    )
	)
	;; calculate the total slack space available to use to center the
	;; rivets in the corner
	(setq totalSlack (difference
			  (plus lrBevelLength delta slackFromLastRun)
			  (times rivetPitchX (fix (plus 1e-5 (quotient (plus lrBevelLength delta slackFromLastRun) rivetPitchX))))))
	;; half of the totalSlack will be on each side of the corner rivets
	(setq halfTotalSlack (times 0.5 totalSlack))
	
	;; snap the slack offset to the grid
	(setq fixedHalfSlack (fix (plus 0.999 (quotient halfTotalSlack grid))))
	(setq extraOffset (times fixedHalfSlack grid))
	;; set the x and y origins for beginning the corner rivet fill

	(setq xOrigin
	      (plus xOffset l -rivetPitchX -rivetWidth -extraOffset delta rivetPitchOffsetHalf))
	(setq yOrigin
	      (plus yOffset lrBevelLength -rivetPitchY -extraOffset delta -rivetPitchOffsetHalf))	

	;; set the stopping condition
	(setq xStop (plus xOffset l -lrBevelLength rivetSpaceX
			  -slackFromLastRun -1e-5))
	(setq col 1)
	
	;; loop through all of the columns in this corner
	(while (xOrigin >= xStop)
	    
	    ;; set the stopping row based on what column it is currently
	    ;; looped at, and the number of columns it can fit in the bevel
	    (setq stopRow (min col numColsInBevelLR))
	    
	    ;; set the starting row.  Usually this is 1, but there are
	    ;; curcumstances where it is not.
	    (cond ((and (greaterp numColsInBevelLR numColsLR)
			(col >= numColsLR))
		   ;; this is to fill in a few rivets in the inside bevel
		   ;; cut in the upper side of the lower right corner
		   (setq startRow stopRow - numColsInBevelLR + 1)
		  )
		(t
		 (setq startRow theStartRow)
		)
	    )
	    ;; loop through all of the rows in this corner creating a rivet
	    (for row startRow stopRow
		 (setq yLoopOrigin
		       (plus yOrigin
			     (times (difference row 1) -rivetPitchY)))
		 (dbCreateRect tcCellView thisLayer[contactNum]
			       (list xOrigin:yLoopOrigin
				     (plus xOrigin rivetWidth):
				     (plus yLoopOrigin rivetWidth)))
		 (setq contactNum (mod (plus contactNum 1) 2))

		 (when (and (equal updatedClass "TRUE") (equal altCorCon "TRUE"))
		     (dbCreateRect tcCellView thisLayer[contactNum]		
				   (list xOrigin:yLoopOrigin
					 (plus xOrigin rivetWidth):(plus yLoopOrigin rivetWidth)))
		     (setq contactNum (mod (plus contactNum 1) 2))
		 ) 
		 
	    )
	   (setq yOrigin (difference yOrigin rivetPitchOffset))

	    (setq col (plus col 1))
	    (when (greaterp col numColsInBevelLR)
		(setq yOrigin  (difference yOrigin rivetPitchY))		
	    )
	    (setq xOrigin (difference xOrigin rivetPitchX))
	)
	
	;; this is to fill in a few rivets in the inside bevel cut in the
	;; left side of the lower right corner
	(when (and (greaterp numColsInBevelLR numColsLR)
		   (greaterp lrBevelLength ringWidth))
	    (setq yStop (plus yOffset usedRingWidth rivetSpaceY))
	    (setq yLoopOrigin yOrigin)
	    (while (xOrigin >=
			    (plus xOffset l -lrBevelLength -bevelInsideOffset))
		(while (yLoopOrigin > yStop)
		    (dbCreateRect tcCellView thisLayer[contactNum]
				  (list xOrigin:yLoopOrigin
					(plus xOrigin rivetWidth):(plus yLoopOrigin rivetWidth)))
		    (setq contactNum (mod (plus contactNum 1) 2))		
		  
		    
		    (setq yLoopOrigin (difference yLoopOrigin rivetPitchY))
		)
		(setq yOrigin (difference yOrigin rivetPitchY))
		(setq yLoopOrigin yOrigin)
		(setq xOrigin (difference xOrigin rivetPitchX))
	    )
	)
	
	;; prepare origins for the row of rivets on the right
	(setq xOrigin (plus xOffset l -usedRingWidth))
	(setq yOrigin (plus yOffset lrBevelLength))
       )
     (lrBevel
      ;; prepare origins for the row of rivets on the right
      (setq xOrigin (plus xOffset l -usedRingWidth))
      (setq yOrigin (plus yOffset lrBevelLength))
     )
     (t
      ;; prepare origins for the row of rivets on the right
      (setq xOrigin (plus xOffset l -usedRingWidth))
      (setq yOrigin (plus yOffset usedRingWidth rivetSpaceY))
     )
 )
 
 (when (lessp lrBevelLength (plus usedRingWidth rivetSpaceY))
     (setq yOrigin (plus yOffset usedRingWidth rivetSpaceY))
 )
 
 ;; set the stopping condition for the row of rivets on the right
 (cond (urBevel
	(setq yStop (plus yOffset w -urBevelLength -rivetWidth))
       )
     (t
      (setq yStop (plus yOffset w -rivetWidth))
     )
 )

 (when (equal lessConNearbevel "TRUE")
     (setq yStop (plus yStop -rivetPitchY))
 )

(when  (equal updatedClass "TRUE") 
    (setq rivetPitchX  rivetPitchX_orig )
    (setq rivetPitchY  rivetPitchY_orig )
    thisLayer[0] = rivetLayer
     thisLayer[1] = (or rivetLayer2 rivetLayer)
)
;;
;; 3.  Draw the rivets along the right edge
;;
(setq xLoopOrigin xOrigin)
 (for col 1 numCols
      (setq contactNum (mod (plus tempContactNum 1) 2))
      (setq tempContactNum contactNum)
      (setq yLoopOrigin yOrigin)
      
      (when (equal lessConNearbevel "TRUE")
	  (setq yLoopOrigin (plus yOrigin rivetPitchY))
      )
      (while (yLoopOrigin < yStop)
	  (dbCreateRect tcCellView thisLayer[contactNum]
			(list xLoopOrigin:yLoopOrigin
			      (plus xLoopOrigin rivetWidth):
			      (plus yLoopOrigin rivetWidth)))
	  (setq contactNum (mod (plus contactNum 1) 2))
	  (setq yLoopOrigin (plus yLoopOrigin rivetPitchY))
      )
      (setq xLoopOrigin (plus xLoopOrigin rivetPitchX))
 )

(when (equal lessConNearbevel "TRUE")
    (setq yLoopOrigin (plus yLoopOrigin rivetPitchY))
)

(when  (equal updatedClass "TRUE") 
    (setq rivetPitchX  rivetPitchMax )
    (setq rivetPitchY  rivetPitchMax )
    thisLayer[0] = rivetLayer
    thisLayer[1] = rivetLayer2
    (setq rivetPitchOffsetHalf  0.0 )        ;; rivetPitchX = rivetPitchY
    (setq rivetPitchOffset  0.0  )           ;; rivetPitchX = rivetPitchY
)

(setq numColsUR        (plus numCols -numColsLess))
(setq numColsInBevelUR (plus numColsInBevel -numColsLess))
;;
;; 4.  Draw the rivets in the upper right corner
;;
(cond ((and urBevel (greaterp urBevelLength minBevelCutForRivet))
       
       (setq slackFromLastRun (plus yOffset w -urBevelLength
				    -yLoopOrigin rivetSpaceY))

       ;; see if it needs to massage the x origin.  This is a condition when
       ;; the x origin of the rivets along the top edge must be pushed
       ;; to the left to prevent them from overlapping the rivets along
       ;; the right edge.
       (cond ((lessp urBevelLength (plus usedRingWidth rivetSpaceX))
	      (setq delta (min (plus -urBevelLength usedRingWidth rivetSpaceX)
			       rivetPitchX))
	      (setq theStartRow (difference 1 (fix (plus 1e-5 (quotient (plus usedRingWidth rivetSpaceX -urBevelLength) rivetPitchX)))))
	     )
	   (t
	     (setq delta 0.0)
	     (setq theStartRow 1)
	   )
       )
       
       ;; calculate the total slack space available to use to center the
       ;; rivets in the corner
	(setq totalSlack (difference
			  (plus urBevelLength delta)
			  (times rivetPitchX (fix (plus 1e-5 (quotient (plus urBevelLength delta) rivetPitchX))))))
	(cond ((greaterp (plus totalSlack slackFromLastRun 1e-5) rivetPitchX)
	       (setq totalSlack (plus -rivetPitchX totalSlack slackFromLastRun))
	      )
	    (t
	     (setq totalSlack (plus totalSlack slackFromLastRun))
	    )
	)
	
	;; half of the totalSlack will be on each side of the corner rivets
	(setq halfTotalSlack (times 0.5 totalSlack))
	
	;; snap the offset to the grid
	(setq fixedHalfSlack (fix (plus 0.999 (quotient halfTotalSlack grid))))
	(setq extraOffset (times fixedHalfSlack grid))
	
	
	
	;; set the x and y origins for beginning the corner rivet fill
	(setq xOrigin (plus xOffset l -rivetWidth -rivetPitchX -extraOffset slackFromLastRun
			    rivetPitchOffsetHalf ))
	(setq yOrigin (plus yLoopOrigin extraOffset rivetPitchOffsetHalf))
	
	;; depending upon how much slack there was from the run on the right
	;; edge and on how much extra offset there is to center the upper
	;; right corner rivets, it might not can place the first column
	;; of extra rivets in the lower side inside bevel cut
	(cond ((greaterp 0.0 (plus slackFromLastRun -extraOffset))
	       (setq drawExtraInsideColumn t)
	      )
	    (t (setq drawExtraInsideColumn nil))
	)

	;; set the stopping condition
	(setq xStop (min (plus xOffset l -urBevelLength rivetSpaceX -1e-5)
			 (plus xOffset l -usedRingWidth -1e-5)))
	(setq col 1)
	
	

	;; loop through all of the columns
	(while (xOrigin >= xStop)
	    
	    ;; set the stopping row
	    (setq stopRow (min col numColsInBevelUR))
	    
	    ;; set the starting row
	    (cond ((and (greaterp numColsInBevelUR numColsUR)
			(col >= numColsUR))
		   (cond (drawExtraInsideColumn
			  ;; this is to fill in a few rivets in the inside
			  ;; bevel cut in the lower side of the upper right
			  ;; corner
			  (setq startRow stopRow - numColsInBevelUR + 1)
			 )
		       (t (setq drawExtraInsideColumn t))
		   )
		  )
		(t
		 (setq startRow theStartRow)
		)
	    )
	    
	    ;; loop through all of the rows while drawing rivets
	    (for row startRow stopRow
		 (setq yLoopOrigin
		       (plus yOrigin
			     (times (difference row 1) rivetPitchY)))
		 (dbCreateRect tcCellView thisLayer[contactNum]
			       (list xOrigin:yLoopOrigin
				     (plus xOrigin rivetWidth):
				     (plus yLoopOrigin rivetWidth)))
		 (setq contactNum (mod (plus contactNum 1) 2))
	 
		 (when (and (equal updatedClass "TRUE") (equal altCorCon "TRUE"))		

		     (dbCreateRect tcCellView thisLayer[contactNum]
				   (list xOrigin:yLoopOrigin
					 (plus xOrigin rivetWidth):
				     (plus yLoopOrigin rivetWidth)))
		     (setq contactNum (mod (plus contactNum 1) 2))	 
		 )
	    )
	    (setq yOrigin (plus yOrigin rivetPitchOffset))
	    

	    (setq col (plus col 1))
	    (when (greaterp col numColsInBevelUR)
		(setq yOrigin (plus yOrigin rivetPitchY))
	    )
	    (setq xOrigin (difference xOrigin rivetPitchX))
	)
	
	(when (col <= numColsInBevelUR)
	    (setq yOrigin (plus yOrigin (times startRow rivetPitchY)))
	)
	
	;; this is to fill in a few rivets in the inside bevel cut in the
	;; left side of the upper right corner
	(when (and (greaterp numColsInBevelUR numColsUR)
		   (greaterp urBevelLength ringWidth))
	    (setq yStop (plus yOffset w -usedRingWidth -rivetPitchY))
	    (setq yLoopOrigin yOrigin)
	    (while (xOrigin >= (plus xOffset l -urBevelLength -bevelInsideOffset))
		(while (yLoopOrigin <= yStop)
		    (dbCreateRect tcCellView thisLayer[contactNum]
				  (list xOrigin:yLoopOrigin
					(plus xOrigin rivetWidth):(plus yLoopOrigin rivetWidth)))
		    (setq contactNum (mod (plus contactNum 1) 2))
		    (setq yLoopOrigin (plus yLoopOrigin rivetPitchY))
		)
		(setq yOrigin (plus yOrigin rivetPitchY))
		(setq yLoopOrigin yOrigin)
		(setq xOrigin (difference xOrigin rivetPitchX))
	    )
	)
	
	;; prepare origins for the row of rivets on the top
	(setq xOrigin (plus xOffset l -urBevelLength -rivetWidth))
	(setq yOrigin (plus yOffset w -usedRingWidth))
      )
    (lrBevel
     ;; prepare origins for the row of rivets on the top
     (setq xOrigin (plus xOffset l -urBevelLength -rivetWidth))
     (setq yOrigin (plus yOffset w -usedRingWidth))
    )
     (t
      ;; prepare origins for the row of rivets on the top
      (setq xOrigin (plus xOffset l -usedRingWidth -rivetSpaceX))
      (setq yOrigin (plus yOffset w -usedRingWidth))
     )
)

;; if necessary, adjust the starting condition for the row of rivets on top
;; to make sure that the rivets along the top edge to not overlap the rivets
;; along the right edge
(when (greaterp xOrigin (plus xOffset l -usedRingWidth -rivetPitchX))
    (setq xOrigin (plus xOffset l -usedRingWidth -rivetPitchX))
)

;; set the stopping condition for the row of rivets on the top
(cond (ulBevel
       (setq xStop (plus xOffset ulBevelLength -1e-5))
       )
    (t
     (setq xStop (plus xOffset -1e-5))
    )
)

(when (equal lessConNearbevel "TRUE")
    (setq xStop (plus xStop rivetPitchX))
)
(when  (equal updatedClass "TRUE") 
    (setq rivetPitchX  rivetPitchX_orig )
    (setq rivetPitchY  rivetPitchY_orig )
    thisLayer[0] = rivetLayer
     thisLayer[1] = (or rivetLayer2 rivetLayer)
)
;;
;; 5.  Draw the rivets along the top edge
;;
(setq yLoopOrigin yOrigin)
(for col 1 numCols
      (setq contactNum (mod (plus tempContactNum 1) 2))
      (setq tempContactNum contactNum)
      (setq xLoopOrigin xOrigin)
 
      (when (equal lessConNearbevel "TRUE")
	  (setq xLoopOrigin (plus xOrigin -rivetPitchX))
      )

      (while (xLoopOrigin > xStop)
	  (dbCreateRect tcCellView thisLayer[contactNum]
			(list xLoopOrigin:yLoopOrigin
			      (plus xLoopOrigin rivetWidth):
			      (plus yLoopOrigin rivetWidth)))
	  (setq contactNum (mod (plus contactNum 1) 2))
	  (setq xLoopOrigin (difference xLoopOrigin rivetPitchY))
       )
      (setq yLoopOrigin (plus yLoopOrigin rivetPitchX))
)

(when (equal lessConNearbevel "TRUE")
    (setq xLoopOrigin (plus xLoopOrigin -rivetPitchX))
)

(when  (equal updatedClass "TRUE") 
    (setq rivetPitchX  rivetPitchMax )
    (setq rivetPitchY  rivetPitchMax )
    thisLayer[0] = rivetLayer
    thisLayer[1] = rivetLayer2
    (setq rivetPitchOffsetHalf  0.0 )        ;; rivetPitchX = rivetPitchY
    (setq rivetPitchOffset  0.0  )           ;; rivetPitchX = rivetPitchY
)

(setq numColsUL        (plus numCols -numColsLess))
(setq numColsInBevelUL (plus numColsInBevel -numColsLess))

;;
;; 6.  Draw the rivets in the upper left corner
;;
(cond ((and ulBevel (greaterp ulBevelLength minBevelCutForRivet))
       
       (setq slackFromLastRun (plus xLoopOrigin rivetPitchX -xOffset -ulBevelLength))
       
       ;; see if it needs to massage the y origin.  This is a condition when
       ;; the y origin of the rivets along the left edge must be pushed down
       ;; to prevent them from overlapping the rivets along the top edge.
       ;;
       (cond ((lessp ulBevelLength (plus usedRingWidth rivetSpaceX))
	      (setq delta (min (plus -ulBevelLength usedRingWidth rivetSpaceX)
			       rivetPitchX))
	       (setq theStartRow (difference 1 (fix (plus 1e-5 (quotient (plus usedRingWidth rivetSpaceX -ulBevelLength) rivetPitchX)))))
	     )
	   (t
	     (setq delta 0.0)
	     (setq theStartRow 1)
	   )
       )
       
       ;; calculate the total slack space available to use to center the
       ;; rivets in the corner
       (setq totalSlack (difference
			  (plus ulBevelLength delta slackFromLastRun)
			  (times rivetPitchX (fix (plus 1e-5 (quotient (plus ulBevelLength delta slackFromLastRun) rivetPitchX))))))
       
       ;; half of the totalSlack will be on each side of the corner rivets
       (setq halfTotalSlack (times 0.5 totalSlack))
       
       ;; snap the offset to the grid
       (setq fixedHalfSlack (fix (plus 0.999 (quotient halfTotalSlack grid))))
       (setq extraOffset (times fixedHalfSlack grid))

       ;; set the x and y origins for beginning the corner rivet fill
       
       
       (setq xOrigin (plus xOffset rivetPitchX extraOffset -delta -rivetPitchOffsetHalf))
       (setq yOrigin (plus yOffset w -ulBevelLength rivetSpaceY extraOffset -delta rivetPitchOffsetHalf))
       
       ;; set the stopping condition
       (setq xStop (difference (plus xOffset ulBevelLength slackFromLastRun 1e-5)
			       rivetPitchX))
       (setq col 1)
       

       ;; loop through all of the columns
       (while (xOrigin <= xStop)
	   
	   ;; set the stopping row
	   (setq stopRow (min col numColsInBevelUL))
	   
	   ;; set the starting row
	   (cond ((and (greaterp numColsInBevelUL numColsUL)
		       (col >= numColsUL))
		  ;; this is to fill in a few rivets in the inside bevel
		  ;; cut in the lower side of the upper left corner
		  (setq startRow stopRow - numColsInBevelUL + 1)
		 )
	       (t
		 (setq startRow theStartRow)
	       )
	   )
	   
	   ;; loop through all the rows while creating rivets
	   (for row startRow stopRow
		 (setq yLoopOrigin
		       (plus yOrigin
			     (times (difference row 1) rivetPitchY)))
		 (dbCreateRect tcCellView thisLayer[contactNum]
			       (list xOrigin:yLoopOrigin
				     (plus xOrigin rivetWidth):
				     (plus yLoopOrigin rivetWidth)))
		 (setq contactNum (mod (plus contactNum 1) 2))

		 (when (and (equal updatedClass "TRUE") (equal altCorCon "TRUE"))
		     
		     (dbCreateRect tcCellView thisLayer[contactNum]
				   (list xOrigin:yLoopOrigin
					 (plus xOrigin rivetWidth):
					 (plus yLoopOrigin rivetWidth)))
		     (setq contactNum (mod (plus contactNum 1) 2))
		 )
	   )
	   (setq col (plus col 1))
	   (setq yOrigin 	(plus yOrigin rivetPitchOffset)) 

	   (when (greaterp col numColsInBevelUL)
	       (setq yOrigin (plus yOrigin rivetPitchY))
	   )
	   (setq xOrigin (plus xOrigin rivetPitchX))
       )
       
       ;; this is to fill in a few rivets in the inside bevel cut in the
	;; right side of the upper left corner
       (when (and (greaterp numColsInBevelUL numColsUL)
		  (greaterp ulBevelLength ringWidth))
	   (setq yStop (plus yOffset w -usedRingWidth -rivetPitchY))
	   (setq yLoopOrigin yOrigin)
	   (while (xOrigin <= (plus xOffset ulBevelLength bevelInsideOffset))
	       (while (yLoopOrigin <= yStop)
		    (dbCreateRect tcCellView thisLayer[contactNum]
				  (list xOrigin:yLoopOrigin
					(plus xOrigin rivetWidth):(plus yLoopOrigin rivetWidth)))
		    (setq contactNum (mod (plus contactNum 1) 2))
		    (setq yLoopOrigin (plus yLoopOrigin rivetPitchY))
	       )
	       (setq yOrigin (plus yOrigin rivetPitchY))
	       (setq yLoopOrigin yOrigin)
	       (setq xOrigin (plus xOrigin rivetPitchX))
	   )
       )

       ;; prepare origins for the row of rivets on the left
       (setq xOrigin xOffset)
       (setq yOrigin (plus yOffset w -ulBevelLength -rivetWidth))
       
       )
    (ulBevel
     ;; prepare origins for the row of rivets on the left
     (setq xOrigin xOffset)
     (setq yOrigin (plus yOffset w -ulBevelLength -rivetWidth))
    )
    (t
     ;; prepare origins for the row of rivets on the left
     (setq xOrigin xOffset)
     (setq yOrigin (plus yOffset w -usedRingWidth -rivetPitchY))
    )
)

;; make sure that the rivets along the left edge do not overlap the
;; rivets along the top edge/upper left corner
(when (greaterp yOrigin (plus yOffset w -usedRingWidth -rivetPitchY))
    (setq yOrigin (plus yOffset w -usedRingWidth -rivetPitchY))
)

;; set the stopping condition for the row of rivets on the left
(cond (llBevel
	(setq yStop (plus yOffset llBevelLength))
      )
    (t
     (setq yStop yOffset)
    )
)

(when (equal lessConNearbevel "TRUE")
     (setq yStop (plus yStop rivetPitchY))
)
(when  (equal updatedClass "TRUE") 
    (setq rivetPitchX  rivetPitchX_orig )
    (setq rivetPitchY  rivetPitchY_orig )
    thisLayer[0] = rivetLayer
    thisLayer[1] = (or rivetLayer2 rivetLayer)
)

;;
;; 7.  Draw the rivets along the left edge
;;
(setq xLoopOrigin xOrigin)
(for col 1 numCols
     (setq contactNum (mod (plus tempContactNum 1) 2))
     (setq tempContactNum contactNum)
     (setq yLoopOrigin yOrigin)
     
     (when (equal lessConNearbevel "TRUE")
	 (setq yLoopOrigin (plus yOrigin -rivetPitchY))
     )
      (while (yLoopOrigin > yStop)
	  (dbCreateRect tcCellView thisLayer[contactNum]
			(list xLoopOrigin:yLoopOrigin
			      (plus xLoopOrigin rivetWidth):
			      (plus yLoopOrigin rivetWidth)))
	  (setq contactNum (mod (plus contactNum 1) 2))
	  (setq yLoopOrigin (difference yLoopOrigin rivetPitchY))
      )
      (setq xLoopOrigin (plus xLoopOrigin rivetPitchX))
)

(when (equal lessConNearbevel "TRUE")
    (setq yLoopOrigin (plus yLoopOrigin -rivetPitchY))
)
(when  (equal updatedClass "TRUE") 
    (setq rivetPitchX  rivetPitchMax )
    (setq rivetPitchY  rivetPitchMax )
    thisLayer[0] =   rivetLayer
    thisLayer[1] =  rivetLayer2
    (setq rivetPitchOffsetHalf  0.0 )        ;; rivetPitchX = rivetPitchY
    (setq rivetPitchOffset  0.0  )           ;; rivetPitchX = rivetPitchY
)

(setq numColsLL        (plus numCols -numColsLess))
(setq numColsInBevelLL (plus numColsInBevel -numColsLess))
;;
;; 8.  Draw the rivets in the lower left corner
;;
(cond ((and llBevel (greaterp llBevelLength minBevelCutForRivet))
       
       (setq slackFromLastRun (plus yLoopOrigin rivetPitchX
				    -yOffset -llBevelLength))

       ;; see if it needs to massage the x origin.  This is a condition when
       ;; the x origin of the rivets along the bottom edge must be pushed
       ;; to the right to prevent them from overlapping the rivets along
       ;; the top edge.
       (cond ((lessp llBevelLength (plus usedRingWidth rivetSpaceX))
	      (setq delta (min (plus -llBevelLength usedRingWidth rivetSpaceX)
			       rivetPitchX))
	      (setq theStartRow (difference 1 (fix (plus 1e-5 (quotient (plus usedRingWidth rivetSpaceX -llBevelLength) rivetPitchX)))))
	      )
	   (t
	    (setq delta 0.0)
	    (setq theStartRow 1)
	   )
       )

       ;; calculate the total slack space available to use to center the
       ;; rivets in the corner
       (setq totalSlack (difference
			 (plus llBevelLength delta)
			 (times rivetPitchX (fix (plus 1e-5 (quotient (plus llBevelLength delta) rivetPitchX))))))
       (cond ((greaterp (plus totalSlack slackFromLastRun 1e-5) rivetPitchX)
	       (setq totalSlack (plus -rivetPitchX totalSlack slackFromLastRun))
	     )
	   (t
	    (setq totalSlack (plus totalSlack slackFromLastRun))
	   )
	)
       
       ;; half of the totalSlack will be on each side of the corner rivets
       (setq halfTotalSlack (times 0.5 totalSlack))
       
       ;; snap the offset to the grid
       (setq fixedHalfSlack (fix (plus 0.999 (quotient halfTotalSlack grid))))
       (setq extraOffset (times fixedHalfSlack grid))
       
       
       ;; set the x and y origins for beginning the corner rivet fill
       (setq xOrigin (plus xOffset rivetPitchX -slackFromLastRun extraOffset))
       (setq yOrigin (plus yLoopOrigin -extraOffset))
       
       ;; depending upon how much slack there was from the run on the left
       ;; edge and on how much extra offset there is to center the lower
       ;; left rivets, it might not can place the first column of extra
       ;; rivets in the upper side inside bevel cut
       (cond ((greaterp 0.0 (plus slackFromLastRun -extraOffset))
	      (setq drawExtraInsideColumn t)
	     )
	   (t (setq drawExtraInsideColumn nil))
	)
       
       ;; set the stopping condition
       (setq xStop (max (plus xOffset llBevelLength 1e-5 -rivetPitchX)
			(plus xOffset usedRingWidth 1e-5 -rivetWidth)))
       (setq col 1)
       

       
       ;; loop through the columns
       (while (xOrigin <= xStop)
	   
	   ;; set the stopping row
	   (setq stopRow (min col numColsInBevelLL))
	   
	   ;; set the starting row
	   (cond ((and (greaterp numColsInBevelLL numColsLL)
		       (col >= numColsLL))
		  (cond (drawExtraInsideColumn
			 ;; this is to fill in a few rivets in the inside
			 ;; bevel cut in the top side of the lower left corner
			 (setq startRow stopRow - numColsInBevelLL + 1)
			 )
		      (t (setq drawExtraInsideColumn t))
		  )
		 )
	       (t
		 (setq startRow theStartRow)
	       )
	   )
	   
	   ;; loop through all the rows while drawing the rivets
	   (for row startRow stopRow
		(setq yLoopOrigin
		      (plus yOrigin
			     (times (difference row 1) -rivetPitchY)))
		
		(dbCreateRect tcCellView thisLayer[contactNum]
			      (list xOrigin:yLoopOrigin
				    (plus xOrigin rivetWidth):
				     (plus yLoopOrigin rivetWidth)))
		(setq contactNum (mod (plus contactNum 1) 2))

		(when (and (equal updatedClass "TRUE") (equal altCorCon "TRUE"))
	
		    (dbCreateRect tcCellView thisLayer[contactNum]
				  (list xOrigin:yLoopOrigin
					(plus xOrigin rivetWidth):
					(plus yLoopOrigin rivetWidth)))
		    (setq contactNum (mod (plus contactNum 1) 2))
		)
	   )
	   (setq col (plus col 1))
	   (setq yOrigin (difference yOrigin rivetPitchOffset))
	   (when (greaterp col numColsInBevelLL)
	       (setq yOrigin (difference yOrigin rivetPitchY))
	   )
	   (setq xOrigin (plus xOrigin rivetPitchX))
       )
       
	(when (col <= numColsInBevelLL)
	    (setq yOrigin (plus yOrigin (times -startRow rivetPitchY)))
	)
	
	;; this is to fill in a few rivets in the inside bevel cut in the
	;; right side of the lower left corner
	(when (and (greaterp numColsInBevelLL numColsLL)
		   (greaterp llBevelLength ringWidth))
	    (setq yStop (plus yOffset usedRingWidth rivetSpaceY))
	    (setq yLoopOrigin yOrigin)
	    (while (xOrigin <= (plus xOffset llBevelLength bevelInsideOffset))
		(while (yLoopOrigin > yStop)
		    (dbCreateRect tcCellView thisLayer[contactNum]
				  (list xOrigin:yLoopOrigin
					(plus xOrigin rivetWidth):(plus yLoopOrigin rivetWidth)))
		    (setq contactNum (mod (plus contactNum 1) 2))
		    (setq yLoopOrigin (difference yLoopOrigin rivetPitchY))
		)
		(setq yOrigin (difference yOrigin rivetPitchY))
		(setq yLoopOrigin yOrigin)
		(setq xOrigin (plus xOrigin rivetPitchX))
	    )
	)
       )
 )
)

;;; 
;;; $Id: rivetRingMirrorClass.il,v 1.3 2003/09/29 19:14:16 kmi Exp $
;;; 
;;; rivetRingMirrorClass.il
;;; 
;;; Copyright (c) 1997 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Dec 29, 2000
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This is a part of the device library.  It will be used to generate
;;; rivets within a ring structure.  All of the parameters are formal
;;; parameters.  It is not intended to be used directly by designers,
;;; but it is intended to be instantiated by other device in the device lib.
;;;
;;;   This is a majorly hacked version of rivetRingClass.il in order to
;;; mirror the contacts.  The formal parameters are deliberately kept the
;;; same as rivetRingClass.il, even though some do not work here. These are:
;;;
;;;   llBevelLength, ulBevelLength, lrBevelLength, urBevelLength -
;;;     There is no bevel support for contacts in the corners.  It takes
;;;     the max of these as a uniform corner exclusion region.
;;;
;;;
;;;   autoIncreaseBevelWidth - completely ignored
;;;
;;;   This code does assume that there is some decent substance to the ring.
;;; It may not work as expected if there is only enough room for one or two
;;; rivets along an edge.  Three or more rivets should be no problem.
;;; 
;;; Revision History:
;;;   gtc 12/29/00  Copied and majorly hacked from rivetRingClass.il
;;;   ymx 08/01/02  Added widthEqLength for rect. rivets 
;;;   kmi 09/15/03  Adding rivet2Layer 
;;; 

(putpropqq rivetRingMirrorClass "$Id: rivetRingMirrorClass.il,v 1.3 2003/09/29 19:14:16 kmi Exp $" SCCS)

(tcCreateDeviceClass
 "symbolic" "rivetRingMirrorClass"
 ;; Class parameters
 (
  (widthEqLength          t)
 )
 ;; Formal parameters
 (
  (w                      50.0) ; size in Y direction
  (l                      50.0) ; size in X direction
  (xOffset                0.0)
  (yOffset                0.0)
  (rivetLayer             (list "y3" "drawing"))
  (rivet2Layer            nil)
  (rivetLayer2            nil) ; completely ignored
  (ringWidth              6.0)
  (rivetWidth             0.6) ; width of rivets (y-dir)
  (rivetLength            1.0) ; length of rivet (x-dir)
  (rivetSpace             0.8)
  (rivet2Width            0.0) ; width of rivets2 (y-dir)
  (rivet2Length           0.0) ; length of rivet2 (x-dir)
  (rivet2Space            0.0)
  (rivet2EncByRivet1L              0.0) ; rivet2 enclosure by rivet1 (X)
  (rivet2EncByRivet1W              0.0) ; rivet2 enclosure by rivet1 (Y)
  (llBevelLength          10.0) ; the max of the 4 bevels is used for all
  (ulBevelLength          10.0) ; 4 of the corners as a cornerExcludeWidth
  (lrBevelLength          10.0)
  (urBevelLength          10.0)
  (autoIncreaseBevelWidth "FALSE") ; completely ignored
  (grid                   0.05)
 )

 (when widthEqLength
    (setq rivetLength rivetWidth)
 )

 (setq cornerExcludeWidth
       (max 0.0 llBevelLength ulBevelLength lrBevelLength urBevelLength))

 (setq rivetPitchY (plus rivetWidth rivetSpace))  ;pitch in Y-dir
 (setq rivetPitchX (plus rivetLength rivetSpace)) ;pitch in X-dir

 ;; set rivet2 params
 (when rivet2Layer
    (setq rivet2PitchL (plus rivet2Length rivet2Space)) ;pitch in X-dir
    (setq rivet2ActiveL (difference rivetLength (times 2 rivet2EncByRivet1L)))
    (setq numCol2 (fix (plus (quotient (plus rivet2ActiveL rivet2Space) rivet2PitchL) 1e-6)))
    (setq rivet1RealL (difference (times numCol2 rivet2PitchL) rivet2Space))
    (setq rivet2OffsetL (quotient (difference rivet2ActiveL rivet1RealL) 2))
    (setq rivet2OffsetL (times (fix (plus (quotient rivet2OffsetL grid) 1e-6)) grid))
 )

 ;; find out how many column can fit within the "ringWidth"
 (setq numCols (fix (plus (quotient (plus ringWidth rivetSpace) rivetPitchY) 1e-5)))

 ;; It will draw the rivets in 2 big steps:
 ;;   1.  Draw the rivets along the top and bottom edges
 ;;   2.  Draw the rivets along the left and right edges
 ;;

 ;; 1.  Draw the rivets along the top and bottom edges
 ;;
 ;; First, determine how many rivets can fit along these edges.  Due to the
 ;; processing order, it must do the condition of the even # of rivets first,
 ;; and then for the odd # of rivets.
 ;;
 ;; if the # of rivets is even
 ;;   We need to make sure that we can perfectly mirror the rivets
 ;;   if total width is an even grid multiple
 ;;     rivet space must also be an even grid multiple
 ;;     else if rivet space is an odd grid multiple
 ;;       we would like to get away with increasing the center width by 1 grid,
 ;;       but that may make it too large to fit within the working width.
 ;;       if there is enough room to add 1 grid to center rivet space
 ;;         add 1 grid to center rivet space
 ;;       else
 ;;         decrement the rivet count by 1 (to an odd number)
 ;;         (It will do the sanity checks when the rivet count is odd)
 ;;       end if
 ;;     end else if
 ;;   else if total width is an odd grid multiple
 ;;     rivet space must also be odd
 ;;     else if rivet space is even
 ;;       if there is enough room to add 1 grid to center rivet space
 ;;         add 1 grid to center rivet space
 ;;       else
 ;;         decrement the rivet count by 1 (to an odd number)
 ;;         (It will do the sanity checks when the rivet count is odd)
 ;;       end if
 ;;     end else if
 ;;   end else if
 ;; end if
 ;;
 ;; if # of rivets is odd
 ;;   We need to make sure that we can perfectly center the center rivet.
 ;;   if total width is an even grid multiple then
 ;;     rivet width must also be even grid multiple
 ;;     else if rivet width is odd grid multiple
 ;;       decrement the rivet count by 1 (to an even number)
 ;;       if rivet space is odd multiple of grid
 ;;         add 1 grid to the middle rivet space only
 ;;       end if
 ;;     end else if
 ;;   else if total width is odd
 ;;     rivet width must be an odd grid
 ;;     else if rivet width is even
 ;;       decrement the rivet count by 1 (to an even number)
 ;;       if rivet space is an even multiple of grid
 ;;         add 1 grid to the middle rivet space only
 ;;       end if
 ;;     end else if
 ;;   end else if
 ;; end if
 ;;
 ;; This will result in some conditions where there is a spacing between
 ;; two rivets that is 1 grid larger than minimum and what is used
 ;; everywhere else.
 ;;

 (setq rivetWidthGrids (fix (plus 0.999 (quotient rivetWidth grid))))
 (setq rivetSpaceGrids (fix (plus 0.999 (quotient rivetSpace grid))))

 ;; Also be careful when you get close to the far left/right edge so that
 ;; it will not create a spacing error or a rectangular rivet if two instances
 ;; are shared left-right.
 ;;
 (cond
     ((lessp cornerExcludeWidth (quotient rivetSpace 2.0))
      (setq xWorkingWidth (difference l rivetSpace))
      ;; if the rivet space is an odd multiple of the snap grid, knock
      ;; off one more grid width to preserve the evenness/oddness of the
      ;; xWorkingWidth number of grids
      (when (oddp rivetSpaceGrids)
	  (setq xWorkingWidth (difference xWorkingWidth grid))
      )
     )
     (t
      (setq xWorkingWidth (difference l (times 2 cornerExcludeWidth)))
     )
 )

 (setq xWorkingGrids (fix (plus 0.999 (quotient xWorkingWidth grid))))

 ;; get the maximum number of rivets we could fit in
 (setq numRivets (fix (plus 1e-5 (quotient (plus xWorkingWidth rivetSpace)
					   (plus rivetLength rivetSpace)))))

 ;; deltaWidth is the amount of extra width if there are numRivets placed
 (setq deltaWidth (difference xWorkingWidth
			      (plus
			       (times numRivets rivetLength)
			       (times (difference numRivets 1) rivetSpace))))

 ;; in some cases, the center space may be increased by 1 grid, but start
 ;; it out with the rivetSpace
 (setq centerSpace rivetSpace)

 ;; must do when an even number of rivets first because in some conditions
 ;; it will decrement to an odd number of rivets requiring the odd massaging
 ;; to be done
 (when (evenp numRivets)
     (cond
	 ;; if the total working width is an even number of grids
	 ((evenp xWorkingGrids)
	  ;; when rivet space is an even number of grids, we are OK.
	  ;; when rivet space is an odd number of grids, we must massage
	  (when (oddp rivetSpaceGrids)
	      (cond
		  ;; if there is enough room to increase the center space
		  ;; by 1 grid
		  ((geqp deltaWidth grid)
		   (setq centerSpace (plus centerSpace grid))
		  )
		  ;; otherwise, decrement the number of rivets by 1 to an
		  ;; odd number, and let it do the odd processing on it
		  (t
		   (setq numRivets (difference numRivets 1))
		  )
	      )
	  )
	 )
	 ;; else the total working width is an odd number of grids
	 (t
	  ;; when rivet space is an odd number of grids, we are OK.
	  ;; when rivet space is an even number of grids, we must massage
	  (when (evenp rivetSpaceGrids)
	      (cond
		  ;; if there is enough room to increase the center space
		  ;; by 1 grid
		  ((geqp deltaWidth grid)
		   (setq centerSpace (plus centerSpace grid))
		  )
		  ;; otherwise, decrement the number of rivets by 1 to an
		  ;; odd number, and let it do the odd processing on it
		  (t
		   (setq numRivets (difference numRivets 1))
		  )
	      )
	  )
	 )
     ) ; end cond if working width is even or odd number of grids
 ) ; end when there are an even number of rivets

 ;; must keep this after the condition when there are an even number of rivets
 (when (oddp numRivets)
     (cond
	 ;; when the total working width is an even grid multiple
	 ((evenp xWorkingGrids)
	  ;; when rivet width is an even number of grids, we are OK.
	  ;; when rivet width is an odd number of grids, we must massage
	  (when (oddp rivetWidthGrids)
	      ;; decrement the rivet count by 1 (to an even number)
	      (setq numRivets (difference numRivets 1))
	      ;; if the rivet space is an even number of grids, we are OK.
	      ;; if the rivet space is an odd number of grids, we must massage
	      (when (oddp rivetSpaceGrids)
		  ;; add 1 grid to the center space only
		  (setq centerSpace (plus centerSpace grid))
	      )
	  )
	 )
	 ;; else the total working width is an odd grid multiple
	 (t
	  ;; when rivet width is an odd number of grids, we are OK.
	  ;; when rivet width is an even number of grids, we must massage
	  (when (evenp rivetWidthGrids)
	      ;; decrement the rivet count by 1 (to an even number)
	      (setq numRivets (difference numRivets 1))
	      ;; if the rivet space is an odd number of grids, we are OK.
	      ;; if the rivet space is an even number of grids, we must massage
	      (when (evenp rivetSpaceGrids)
		  ;; add 1 grid to the center space only
		  (setq centerSpace (plus centerSpace grid))
	      )
	  )
	 )
     ) ; end cond if working width is even or odd number of grids
 ) ; end when there are an odd number of rivets

 ;; now we have got these rivets prepared so that they can be shared & mirrored
 ;; but we need to work out the initial locations.  We will draw from left to
 ;; right with the special centerSpace at the center rivet
 (setq xOrigin
       (difference (plus xOffset (quotient l 2.0))
		   (quotient (plus (times numRivets rivetLength)
				   (times (difference numRivets 2) rivetSpace)
				   centerSpace
			     )
			     2.0)
       )
 )

 (when (or (equal numRivets 0) (equal numCols 0))
    (error nil "riverRingMirrorClass: number of viaCons less than zero")
 )
 (when (and rivet2Layer (equal numCol2 0))
    (error nil "riverRingMirrorClass: number of viaCons less than zero")
 )

 ;; now we are in business to start drawing some rivets (top, bottom).
 (for row 1 numRivets
      (setq yOriginBot yOffset)
      (setq yOriginTop (plus yOffset w))

      (for col 1 numCols
	   ;; first create the rivet on the bottom
	   (dbCreateRect tcCellView rivetLayer
			 (list xOrigin:yOriginBot
			      (plus xOrigin rivetLength):
			      (plus yOriginBot rivetWidth)))
	   ;; second create the rivet on the top
	   (dbCreateRect tcCellView rivetLayer
			 (list xOrigin:yOriginTop
			      (plus xOrigin rivetLength):
			      (difference yOriginTop rivetWidth)))
           ;; create rivet2 within rivet (along the rivet lenght)
           (when rivet2Layer
             (setq yOriginBot2 (plus yOriginBot rivet2EncByRivet1W))
             (setq yOriginTop2 (difference yOriginTop rivet2EncByRivet1W))
             (setq xOrigin2    (plus xOrigin rivet2EncByRivet1L rivet2OffsetL))
             (for col2 1 numCol2
	        (dbCreateRect tcCellView rivet2Layer
			 (list xOrigin2:yOriginBot2
			      (plus xOrigin2 rivet2Length):
			      (plus yOriginBot2 rivet2Width)))
	        (dbCreateRect tcCellView rivet2Layer
			 (list xOrigin2:yOriginTop2
			      (plus xOrigin2 rivet2Length):
			      (difference yOriginTop2 rivet2Width)))
	        (setq xOrigin2 (plus xOrigin2 rivet2PitchL))
             )
           )
        
	   ;; adjust the yOrigins
	   (setq yOriginBot (plus yOriginBot rivetPitchY))
	   (setq yOriginTop (difference yOriginTop rivetPitchY))
      )

      ;; adjust the xOrigin
      (cond
	  ;; if this is between the center rivets, the center space may be
	  ;; slightly larger than the regular minimum space in order to
	  ;; better support mirroring and sharing
	  ((and (evenp numRivets)
		(lessp (abs (difference row (quotient numRivets 2.0)))
		       1e-5))
	   (setq xOrigin (plus xOrigin rivetLength centerSpace))
	  )
	  (t
	   (setq xOrigin (plus xOrigin rivetPitchX))
	  )
      )
 )

 ;; 2.  Draw the rivets along the left and right edges
 ;;
 ;; A lot of this is very similar to how it is drawn for the top and bottom

 ;; Be careful when you get close to the far top/bottom edge so that
 ;; it will not create a spacing error or a rectangular rivet with the
 ;; rivets created along the top and bottom edges
 ;;
 (cond
     ((lessp cornerExcludeWidth (times numCols rivetPitchY))
      (setq yWorkingWidth (difference w (times 2 numCols rivetPitchY)))
     )
     (t
      (setq yWorkingWidth (difference w (times 2 cornerExcludeWidth)))
     )
 )
 (setq yWorkingGrids (fix (plus 0.999 (quotient yWorkingWidth grid))))

 ;; get the maximum number of rivets we could fit in
 (setq numRivets (fix (plus 1e-5 (quotient (plus yWorkingWidth rivetSpace)
					   (plus rivetLength rivetSpace)))))

 ;; deltaWidth is the amount of extra width if there are numRivets placed
 (setq deltaWidth (difference yWorkingWidth
			      (plus
			       (times numRivets rivetLength)
			       (times (difference numRivets 1) rivetSpace))))

 ;; in some cases, the center space may be increased by 1 grid, but start
 ;; it out with the rivetSpace
 (setq centerSpace rivetSpace)

 ;; must do when an even number of rivets first because in some conditions
 ;; it will decrement to an odd number of rivets requiring the odd massaging
 ;; to be done
 (when (evenp numRivets)
     (cond
	 ;; if the total working width is an even number of grids
	 ((evenp yWorkingGrids)
	  ;; when rivet space is an even number of grids, we are OK.
	  ;; when rivet space is an odd number of grids, we must massage
	  (when (oddp rivetSpaceGrids)
	      (cond
		  ;; if there is enough room to increase the center space
		  ;; by 1 grid
		  ((geqp deltaWidth grid)
		   (setq centerSpace (plus centerSpace grid))
		  )
		  ;; otherwise, decrement the number of rivets by 1 to an
		  ;; odd number, and let it do the odd processing on it
		  (t
		   (setq numRivets (difference numRivets 1))
		  )
	      )
	  )
	 )
	 ;; else the total working width is an odd number of grids
	 (t
	  ;; when rivet space is an odd number of grids, we are OK.
	  ;; when rivet space is an even number of grids, we must massage
	  (when (evenp rivetSpaceGrids)
	      (cond
		  ;; if there is enough room to increase the center space
		  ;; by 1 grid
		  ((geqp deltaWidth grid)
		   (setq centerSpace (plus centerSpace grid))
		  )
		  ;; otherwise, decrement the number of rivets by 1 to an
		  ;; odd number, and let it do the odd processing on it
		  (t
		   (setq numRivets (difference numRivets 1))
		  )
	      )
	  )
	 )
     ) ; end cond if working width is even or odd number of grids
 ) ; end when there are an even number of rivets

 ;; must keep this after the condition when there are an even number of rivets
 (when (oddp numRivets)
     (cond
	 ;; when the total working width is an even grid multiple
	 ((evenp yWorkingGrids)
	  ;; when rivet width is an even number of grids, we are OK.
	  ;; when rivet width is an odd number of grids, we must massage
	  (when (oddp rivetWidthGrids)
	      ;; decrement the rivet count by 1 (to an even number)
	      (setq numRivets (difference numRivets 1))
	      ;; if the rivet space is an even number of grids, we are OK.
	      ;; if the rivet space is an odd number of grids, we must massage
	      (when (oddp rivetSpaceGrids)
		  ;; add 1 grid to the center space only
		  (setq centerSpace (plus centerSpace grid))
	      )
	  )
	 )
	 ;; else the total working width is an odd grid multiple
	 (t
	  ;; when rivet width is an odd number of grids, we are OK.
	  ;; when rivet width is an even number of grids, we must massage
	  (when (evenp rivetWidthGrids)
	      ;; decrement the rivet count by 1 (to an even number)
	      (setq numRivets (difference numRivets 1))
	      ;; if the rivet space is an odd number of grids, we are OK.
	      ;; if the rivet space is an even number of grids, we must massage
	      (when (evenp rivetSpaceGrids)
		  ;; add 1 grid to the center space only
		  (setq centerSpace (plus centerSpace grid))
	      )
	  )
	 )
     ) ; end cond if working width is even or odd number of grids
 ) ; end when there are an odd number of rivets

 ;; now we have got these rivets prepared so that they can be shared & mirrored
 ;; but we need to work out the initial locations.  We will draw from bottom to
 ;; top with the special centerSpace at the center rivet
 (setq yOrigin
       (difference (plus yOffset (quotient w 2.0))
		   (quotient (plus (times numRivets rivetLength)
				   (times (difference numRivets 2) rivetSpace)
				   centerSpace
			     )
			     2.0)
       )
 )

 ;; now we are in business to start drawing some rivets.
 (for row 1 numRivets
      (setq xOriginLeft xOffset)
      (setq xOriginRight (plus xOffset l))

      (for col 1 numCols
	   ;; first create the rivet on the left
	   (dbCreateRect tcCellView rivetLayer
			 (list xOriginLeft:yOrigin
			      (plus xOriginLeft rivetWidth):
			      (plus yOrigin rivetLength)))
	   ;; second create the rivet on the right
	   (dbCreateRect tcCellView rivetLayer
			 (list xOriginRight:yOrigin
			      (difference xOriginRight rivetWidth):
			      (plus yOrigin rivetLength)))
           ;; create rivet2 within rivet (along the rivet lenght)
           (when rivet2Layer
             (setq xOriginLeft2 (plus xOriginLeft rivet2EncByRivet1W))
             (setq xOriginRight2 (difference xOriginRight rivet2EncByRivet1W))
             (setq yOrigin2    (plus yOrigin rivet2EncByRivet1L rivet2OffsetL))
             (for col2 1 numCol2
	       (dbCreateRect tcCellView rivet2Layer
			 (list xOriginLeft2:yOrigin2
			      (plus xOriginLeft2 rivet2Width):
			      (plus yOrigin2 rivet2Length)))
	       (dbCreateRect tcCellView rivet2Layer
			 (list xOriginRight2:yOrigin2
			      (difference xOriginRight2 rivet2Width):
			      (plus yOrigin2 rivet2Length)))
                (setq yOrigin2 (plus yOrigin2 rivet2PitchL))
             )
           )

	   ;; adjust the xOrigins
	   (setq xOriginLeft (plus xOriginLeft rivetPitchY))
	   (setq xOriginRight (difference xOriginRight rivetPitchY))
      )

      ;; adjust the yOrigin
      (cond
	  ;; if this is between the center rivets, the center space may be
	  ;; slightly larger than the regular minimum space in order to
	  ;; better support mirroring and sharing
	  ((and (evenp numRivets)
		(lessp (abs (difference row (quotient numRivets 2.0)))
		       1e-5))
	   (setq yOrigin (plus yOrigin rivetLength centerSpace))
	  )
	  (t
	   (setq yOrigin (plus yOrigin rivetPitchX))
	  )
      )
 )
)
;;; 
;;; $Id: shortClass.il,v 1.1 1998/02/10 13:22:25 gtc Exp $ %T%
;;; 
;;; shortClass.il
;;; 
;;; Copyright (c) 1996 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Nov 19, 1996
;;; Author: Sanjay Rekhi/Senior CAD (syr) @ CSDC
;;; 
;;; Description:
;;;   The short class is used to define the short devices for the
;;;   metal1, metal2 and metal3 layers.
;;;
;;; Revision History:
;;; 
;;; 

(putpropqq shortClass "$Id: shortClass.il,v 1.1 1998/02/10 13:22:25 gtc Exp $ %T%" SCCS)

(tcCreateDeviceClass
 "symbolic" "shortClass"
 ;;; Class Parameters
 (
  (shortOnLayer  "marker")  ;;; Provides the layer which will be shorted.
  (minPinWidth   0.0)       ;;; minimum width of the pin.
  (shortLayer    (list "short" "drawing")) ;;; The short recognition layer
  (minShortWidth 0.0)       ;;; minimum width of the short idLayer
  ;;; This width should be as small as possible. The region under the short
  ;;; is not included for the calculation of the parasitics.
 )

 ;;; Formal Parameters
 (
  (w  0.0)     ;;; width of the short device
  (l  0.0)     ;;; length of the short device
 )

 ;;; make the nets and the terminals for the two nets of the device.
 (setq net0 (dbMakeNet tcCellView "m0"))  ;;; same as schematic symbol
 (dbCreateTerm net0 "m0" "inputOutput")   ;;; same as schematic symbol
 (setq net1 (dbMakeNet tcCellView "m1"))  ;;; same as schematic symbol
 (dbCreateTerm net1 "m1" "inputOutput")   ;;; same as schematic symbol

 ;;; make a bogus net for the body of the shortOnLayer.
 (setq netB (dbMakeNet tcCellView "ppd"))
 
 ;;; Ensure that shortOnLayer is a list parameter.
 (when (stringp shortOnLayer)
     (setq shortOnLayer (list shortOnLayer "drawing"))
 )

 ;;; Draw the shortOnLayer rectangle
 (setq dbid (dbCreateRect tcCellView shortOnLayer 
			  (list 0.0:0.0 l:w))
 )
 ;;; Add the shortOnLayer to the bogus net.
 (dbAddFigToNet dbid netB)

 ;;; Create the two pins for the geometry
 (setq dbid (dbCreateRect tcCellView shortOnLayer 
			  (list (minus minPinWidth):0.0 0.0:w))
 )
 (setq pinid (dbCreatePin net0 dbid))
 pinid~>accessDir = (list "top" "bottom" "left")
 
 (setq dbid (dbCreateRect tcCellView shortOnLayer 
			  (list l:0.0 (plus l minPinWidth):w))
 )
 (dbCreatePin net1 dbid)
 pinid~>accessDir = (list "top" "bottom" "right")

 ;;; Create the short layer in the center of the shortOnLayer rectangle
 (setq x1Coord (quotient (difference l minShortWidth) 2.0))
 (setq dbid (dbCreateRect tcCellView shortLayer (list x1Coord:0.0
						      (plus x1Coord minShortWidth):w))
 )

 ;;; Create the recognition textLayer based on the class parameters
 ;;; These could be fixed or class parameters, class parameters will give us
 ;;; the flexbility to control them in future (if required).
 ;;; If the textValue is not defined, we create that based on the specified
 ;;; shortOnLayer.
;; (when (or (null textValue) (equal textValue ""))
;;     (setq textValue (strcat "short" (car shortOnLayer)))
;; )
 ;;;; draw the label
;; (setq labelId (dbCreateLabel tcCellView textLayer
;;			      (quotient l 2.0):(quotient w 2.0)
;;			      textValue "centerCenter" "R90" "stick" textWidth))
)
       
(tfcDefineDeviceClassProp
;;(viewName       devClassName  propName          propValue)
 (symbolic        shortClass    function          "transistor")
)

;;; 
;;; $Id: syEnhContact.il,v 1.10 2004/12/17 19:33:13 kmi Exp $
;;; 
;;; syEnhContact.il
;;; 
;;; Copyright (c) 1996 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Sep 11, 1996
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This file is a part of the device library specific to LAS.
;;; This file declares the syEnhContact class, which is a centered
;;; row and column based 2 or 3 layer interconnect contact.  This
;;; has a LAS exclusive feature that makes it confusing for normal
;;; use:  the number of rows drawn is one less than the number
;;; specified as a parameter.
;;;   This pcell might require massaging of the class parameters
;;; in order for all of the shapes to land on grid.
;;; 
;;; Revision History:
;;;   jim 11/14/96  Made layer3 nil when not used
;;;   gtc 12/10/96  Updates to handle grid issues
;;;   syr 01/10/97  Added the width and length formal parameter
;;;                 to allow mcon and vias to be spaced.
;;;   gtc 05/27/97  Make same number of via2s as via1s
;;;   syr 05/30/97  For three layers, put mcons center aligned.
;;;   akr 12/07/98  Added X and Y enc of layer1
;;;   akr 01/05/99  Backed out X and Y enc changes
;;;   akr 01/06/99  Added X and Y enc of layer1 again
;;;   cry 09/04/01  Added implants for all layers
;;;   lpn 02/08/02  Added an option to draw diffCoreImplant layer enclosing Diff layer 
;;;   ryk 02/28/02  Changed input class parameter via1Layer
;;;                 and via2Layer to viaLayer and viaLayer2 (spr 10854)
;;;   kmi 12/04/04  Adding via1ImpEncX, via1ImpEncY and via1Implant2
;;;

(putpropqq syEnhContact "$Id: syEnhContact.il,v 1.10 2004/12/17 19:33:13 kmi Exp $" SCCS)

(tcCreateDeviceClass
 "symbolic" "syEnhContact"
 ;; class parameters
 (
  (layer1 "hilite")     ; the layer (& purpose) of layer1
  (layer2 "prBoundary") ; the layer (& purpose) of layer2
  (layer3 nil)          ; the layer (& purpose) of layer3
  (viaLayer "y5")      ; the layer (& purpose) of layer1-2 contacts
  (viaLayer2 nil)       ; the layer (& purpose) of layer2-3 contacts
  (layer1Implant nil)   ; the layer (& purpose) of the layer1 Implant
  (layer1CoreImplant nil)   ; the layer (& purpose) of the layer1 Implant
  (layer2Implant nil)   ; the layer (& purpose) of the layer2 Implant
  (layer3Implant nil)   ; the layer (& purpose) of the layer3 Implant
  (via1Implant   nil)   ; the layer (& purpose) of the via1 Implant
  (via1Implant2  nil)   ; the layer (& purpose) of the via1 Implant2
  (via2Implant   nil)   ; the layer (& purpose) of the via2 Implant
  (layer1ImpEnc  0.0)   ; enclosure of layer1 by layer1Implant
  (layer1CoreImpEnc  0.0)   ; enclosure of layer1 by layer1Implant
  (layer2ImpEnc  0.0)   ; enclosure of layer2 by layer2Implant
  (layer3ImpEnc  0.0)   ; enclosure of layer3 by layer3Implant
  (via1ImpEnc    0.0)   ; enclosure of viaLayer by via1Implant
  (via1ImpEncX   0.0)   ; X enclosure of viaLayer by via1Implant
  (via1ImpEncY   0.0)   ; Y enclosure of viaLayer by via1Implant
  (via1Imp2Enc   0.0)   ; enclosure of viaLayer by via1Implant2
  (via1Imp2EncX  0.0)   ; X enclosure of viaLayer by via1Implant2
  (via1Imp2EncY  0.0)   ; Y enclosure of viaLayer by via1Implant1
  (via2ImpEnc    0.0)   ; enclosure of viaLayer2 by via21Implant
  (via1Width 0.0)       ; the width of layer1-2 contacts
  (via1Space 0.0)       ; the spacing between layer1-2 contacts
  (via2Width 0.0)       ; the width of layer2-3 contacts
  (via2Space 0.0)       ; the spacing between layer2-3 contacts
  (layer1EncVia1 0.0)   ; layer 1 enclosure of layer1-2 contact
  (layer1XEncVia1 0.0)  ; layer 1 enclosure of layer1-2 contact
  (layer1YEncVia1 0.0)  ; layer 1 enclosure of layer1-2 contact
  (layer2XEncVia1 0.0)  ; layer 2 enclosure of layer1-2 contact
  (layer2YEncVia1 0.0)  ; layer 2 enclosure of layer1-2 contact
  (layer2EncVia2 0.0)   ; layer 2 enclosure of layer2-3 contact
  (layer3XEncVia2 0.0)  ; layer 3 enclosure of layer2-3 contact
  (layer3YEncVia2 0.0)  ; layer 3 enclosure of layer2-3 contact
  (halfgrid 0.025)
 )

 ;; formal parameters
 (
  (row 1)             ; the number of rows of layer1-2 contacts to place
  (column 1)          ; the number of columns of layer1-2 contacts to place
  (xPitch 0.0)        ; the x distance between the LL origins of 2 via1s
  (yPitch 0.0)        ; the y distance between the LL origins of 2 via1s
  (w 0.0)             ; the via1Width parameter
  (l 0.0)             ; the via1Length parameter
  (justify "FALSE")
 )

 ; variables used in this pcell:
 ; allDir         - list of right, left, top, bottom for the pin access dir.
 ; col            - column loop control variable
 ; contactOffset  - the space between the LL of two consecutive contacts
 ; c23column      - the number of columns of via2's that can fit
 ; c23row         - the number of rows of via2's that can fit
 ; dbId           - temporary database ID of the most recently created object
 ; layer1length   - the length of layer1
 ; layer1width    - the width of layer1
 ; layer2length   - the length of layer2
 ; layer2width    - the width of layer2
 ; layer3length   - the length of layer3
 ; layer3width    - the width of layer3
 ; l1xOffset      - half of layer1length
 ; l1yOffset      - half of layer1width
 ; l2xOffset      - half of layer2length
 ; l2yOffset      - half of layer2width
 ; l3xOffset      - half of layer3length
 ; l3yOffset      - half of layer3width
 ; minLayer2width - the minimum layer2 width to hold a via2
 ; minLayer2length- the minimum layer2 length to hold a via1
 ; net            - the net that all of the shapes are attached to
 ; pinId          - temporary pin ID of the most recently created pin
 ; r              - row loop control variable
 ; row            - one less than the specified rows; an LAS feature
 ; theX           - loop variable; the current X value to start a contact at
 ; theY           - loop variable; the current Y value to start a contact at



 (setq allDir (list "right" "left" "top" "bottom"))

 (setq net (dbMakeNet tcCellView "ppd"))

 (setq row (max (difference row 1) 1))

 ;; handle enclosures
 (when (nequal via1ImpEnc  0.0)
        (setq via1ImpEncX  via1ImpEnc)
        (setq via1ImpEncY  via1ImpEnc)
 )

 (when (nequal via1Imp2Enc  0.0)
        (setq via1Imp2EncX  via1Imp2Enc)
        (setq via1Imp2EncY  via1Imp2Enc)
 )

 ; calculate the layer1 x offset
 (cond ((equal layer1EncVia1 0.0)
	(setq layer1X layer1XEncVia1)
	(setq layer1Y layer1YEncVia1))
       (t
	(setq layer1X layer1EncVia1)
	(setq layer1Y layer1EncVia1))
 )
 (setq layer1length (plus (times 2 layer1X) (times column via1Width)
			  (times (difference column 1) via1Space)))
 (setq l1xOffset (quotient layer1length 2.0))
 (and (oddp (round (quotient l1xOffset halfgrid)))
      (setq l1xOffset (difference l1xOffset halfgrid))
 )

 ; calculate the layer1 y offset
 (setq layer1width (plus (times 2 layer1Y) (times row via1Width)
			 (times (difference row 1) via1Space)))
 (setq l1yOffset (quotient layer1width 2.0))
 (and (oddp (round (quotient l1yOffset halfgrid)))
      (setq l1yOffset (difference l1yOffset halfgrid))
 )

 ; draw layer1
 (setq dbId (dbCreateRect tcCellView layer1
			  (list (list -l1xOffset -l1yOffset)
				(list (difference layer1length l1xOffset)
				      (difference layer1width l1yOffset)))))
 (dbAddFigToNet dbId net)
 (setq pinId (dbCreatePin net dbId))
 pinId~>accessDir = allDir
 
 ;; draw layer1Implant
 (when layer1Implant
   (setq dbId (dbCreateRect tcCellView layer1Implant
			    (list (list (plus -l1xOffset -layer1ImpEnc)
					(plus -l1yOffset -layer1ImpEnc)
					)
				  (list (plus layer1length 
					      -l1xOffset layer1ImpEnc)
					(plus layer1width 
					      -l1yOffset layer1ImpEnc)
					))))
   (dbAddFigToNet dbId net)
 )
 

 ;; draw layer1CoreImplant
 (when layer1CoreImplant
   (setq dbId (dbCreateRect tcCellView layer1CoreImplant
			    (list (list (plus -l1xOffset -layer1CoreImpEnc)
					(plus -l1yOffset -layer1CoreImpEnc)
					)
				  (list (plus layer1length 
					      -l1xOffset layer1CoreImpEnc)
					(plus layer1width 
					      -l1yOffset layer1CoreImpEnc)
					))))
   (dbAddFigToNet dbId net)
 )
 

 ; draw all of the via1 contacts
 (setq contactOffset (plus via1Space via1Width))
 (setq theY (plus layer1Y -l1yOffset))
 (for r 1 row
     (setq theX (plus layer1X -l1xOffset))
     (for col 1 column
	 (dbId = (dbCreateRect tcCellView viaLayer
			       (list (list theX theY)
				     (list (plus theX via1Width)
					   (plus theY via1Width)))))
	 (dbAddFigToNet dbId net)
	 (setq theX (plus theX contactOffset))
     )
     (setq theY (plus theY contactOffset))
 )
 
 ;; draw via1Implant
 (when via1Implant
   (setq dbId (dbCreateRect tcCellView via1Implant
			    (list (list (plus layer1X -l1xOffset -via1ImpEncX)
					(plus layer1Y -l1yOffset -via1ImpEncY)
					)
				  (list (plus layer1X -l1xOffset via1ImpEncX
					      (times row contactOffset)
					      -via1Space)
					(plus layer1Y -l1yOffset via1ImpEncY
					      (times column contactOffset)
					      -via1Space)
					))))
   (dbAddFigToNet dbId net)
 )
 ;; draw via1Implant2
 (when via1Implant2
   (setq dbId (dbCreateRect tcCellView via1Implant2
                            (list (list (plus layer1X -l1xOffset -via1Imp2EncX)
                                        (plus layer1Y -l1yOffset -via1Imp2EncY)
                                        )
                                  (list (plus layer1X -l1xOffset via1Imp2EncX
                                              (times row contactOffset)
                                              -via1Space)
                                        (plus layer1Y -l1yOffset via1Imp2EncY
                                              (times column contactOffset)
                                              -via1Space)
                                        ))))
   (dbAddFigToNet dbId net)
 )
 
 ; based on the layer1-2 contacts, calculate layer2's width & length
 (setq layer2length (plus (times 2 layer2XEncVia1) (times column via1Width)
			  (times (difference column 1) via1Space)))
 (setq layer2width (plus (times 2 layer2YEncVia1) (times row via1Width)
			 (times (difference row 1) via1Space)))

 (cond 
     ((null layer3)
      t)
     (t
      ; don't draw layer2 until you verify that it is large enough
      ; to handle at least row and column layer2-3 contact
      (setq minLayer2width (plus (times 2.0 layer2EncVia2) via2Width))
      (setq minLayer2length (plus (times 2.0 layer2EncVia2) via2Width))

      (and (lessp layer2length minLayer2length)
	   (setq layer2length minLayer2length))
      (and (lessp layer2width minLayer2width)
	   (setq layer2width minLayer2width))
     )
 )

 ; calculate the layer2 x offset
 (setq l2xOffset (plus (difference (max layer2XEncVia1 layer2EncVia2) layer1X)
		       l1xOffset))

 ; calculate the layer2 y offset
 (setq l2yOffset (plus (difference (max layer2YEncVia1 layer2EncVia2) layer1Y)
		       l1yOffset))

 ; draw layer2
 (setq dbId (dbCreateRect tcCellView layer2
			  (list (list -l2xOffset -l2yOffset)
				(list (difference layer2length l2xOffset)
				      (difference layer2width l2yOffset)))))
 (dbAddFigToNet dbId net)
 (setq pinId (dbCreatePin net dbId))
 pinId~>accessDir = allDir
 
 ;; draw layer2Implant
 (when layer2Implant
   (setq dbId (dbCreateRect tcCellView layer2Implant
			    (list (list (plus -l2xOffset -layer2ImpEnc)
					(plus -l2yOffset -layer2ImpEnc)
					)
				  (list (plus layer2length 
					      -l1xOffset layer2ImpEnc)
					(plus layer2width 
					      -l2yOffset layer2ImpEnc)
					))))
   (dbAddFigToNet dbId net)
 )
 
 (cond 
     ((null layer3)
      t)
     (t
      ; use the same number of layer2-3 contacts as layer1-2 contacts
      ;;;(setq c23row row)
      ;;;(setq c23column column)

      ;; calculate the number of layer2-3 contacts that can be placed
      (setq c23row (fix (quotient (plus layer2width (times -2 layer2EncVia2)
					via2Space)
				  (plus via2Width via2Space))))
      (setq c23column (fix (quotient (plus layer2length
					   (times -2 layer2EncVia2) via2Space)
				     (plus via2Width via2Space))))

      ;; calculate the x offset for layer3
      (setq layer3length (plus (times 2 layer3XEncVia2)
			       (times c23column via2Width)
			       (times (difference c23column 1) via2Space)))
      (setq tmpx (plus (difference layer3XEncVia2 layer2EncVia2)
		       l2xOffset))
      (setq tmpx1 (difference l2xOffset 
				  (quotient (difference layer2length layer3length) 2.0)))

      (and (oddp (round (quotient tmpx1 halfgrid)))
	   (setq tmpx1 (difference tmpx1 halfgrid))
      )

      ;; calculate the y offset for layer3
      (setq layer3width (plus (times 2 layer3YEncVia2) (times c23row via2Width)
			      (times (difference c23row 1) via2Space)))
      (setq tmpy (plus (difference layer3YEncVia2 layer2EncVia2)
			    l2yOffset))
      (setq tmpy1 (difference l2yOffset
				  (quotient (difference layer2width layer3width) 2.0)))
				  
      (and (oddp (round (quotient tmpy1 halfgrid)))
	   (setq tmpy1 (difference tmpy1 halfgrid))
      )
      
      (setq l3xOffset tmpx)
      (setq l3yOffset tmpy)

      (when justify
	  (setq l3xOffset tmpx1)
	  (setq l3yOffset tmpy1)
      )

      ;; draw layer3
      (setq dbId (dbCreateRect tcCellView layer3
			       (list 
				(list -l3xOffset -l3yOffset)
				(list (difference layer3length l3xOffset)
				      (difference layer3width l3yOffset)))
		 )
      )
      (dbAddFigToNet dbId net)
      (setq pinId (dbCreatePin net dbId))
      pinId~>accessDir = allDir
      ;; draw layer3Implant
      (when layer3Implant
	(setq dbId (dbCreateRect tcCellView layer3Implant
				 (list (list (plus -l3xOffset -layer3ImpEnc)
					     (plus -l3yOffset -layer3ImpEnc)
					     )
				       (list (plus layer3length 
						   -l3xOffset layer3ImpEnc)
					     (plus layer1width 
						   -l3yOffset layer3ImpEnc)
					     ))))
	(dbAddFigToNet dbId net)
	)

      ;; draw all of the layer2-3 contacts
      (setq contactOffset (plus via2Space via2Width))
      (setq theY (plus layer3YEncVia2 -l3yOffset))
      (for r 1 c23row
	  (setq theX (plus layer3XEncVia2 -l3xOffset))
	  (for col 1 c23column
	      (setq dbId (dbCreateRect tcCellView viaLayer2
				       (list (list theX theY)
					     (list (plus theX via2Width)
						   (plus theY via2Width)))))
	      (dbAddFigToNet dbId net)
	      (setq theX (plus theX contactOffset))
	  )
	  (setq theY (plus theY contactOffset))
      )
      (when via2Implant
	(setq dbId (dbCreateRect tcCellView via2Implant
				 (list (list (plus layer3XEncVia2 -l3xOffset -via2ImpEnc)
					     (plus layer3YEncVia2 -l3yOffset -via2ImpEnc)
					     )
				       (list (plus layer3XEncVia2 -l3xOffset via2ImpEnc
						   (times c23row contactOffset)
						   -via2Space)
					     (plus layer3YEncVia2 -l3yOffset via2ImpEnc
						   (times c23column contactOffset)
						   -via2Space)
					     ))))
	(dbAddFigToNet dbId net)
	)
     )
 )
)

(tfcDefineDeviceClassProp
;;(viewName       devClassName      propName          propValue)
;;;-------------------------------------------------------------------
 (symbolic        syEnhContact      function          "contact")
)
;;; 
;;; $Id: syMGEnhancement.il,v 1.3 2002/02/12 14:27:00 lpn Exp $ %T%
;;; 
;;; syMGEnhancement.il
;;; 
;;; Copyright (c) 1996 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Sep 25, 1996
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   Copied over Cadence's sample into this file.
;;;   This is a transistor pcell for use with LAS.  It supports the
;;; use of area pins for the CY flow.
;;; 
;;; Revision History:
;;;   jim 11/14/96  Made sdImpLayer  nil when not used
;;;   syr 11/14/96  Cleaned up the file to eliminate excess "("
;;;   xgs 09/29/00  Changing gateExt to formal parameter ( SPR 7745 )
;;;   lpn 02/08/02  Added an option to draw diffCoreImplant layer enclosing Diff layer
;;; 
;;; 

;
; Create "syMGEnhancement" device class
;
(tcCreateDeviceClass 
 "symbolic" "syMGEnhancement"
 ;;;class parameters
 (
  (sdLayer "hilite") 
  (gateLayer "hilite")
  (sdExt 0.0)
  (sdImpLayer nil) 
  (sdImpEnc 0.0)
  (sdCoreImpLayer nil) 
  (sdCoreImpEnc 0.0)
  (gatePinWidth 0.1)
  (areaSDPin nil) 
  (areaPinH 0.1) 
 )
 ;;; formal parameters
 ( 
  (w 0.0) 
  (l 0.0) 
  (gateExt 0.0) 
 )
 ;;; geometry
 W2 = w/2.0
 L2 = l/2.0
 netId = dbMakeNet(tcCellView "G")
 (dbId = dbCreateRect(tcCellView gateLayer 
				 list(((-W2 - gateExt):-L2)
				      (((-W2 - gateExt) + gatePinWidth):L2)
				     )))
 dbId = dbCreatePin(netId dbId "gl")
 dbSetq(dbId list("left") accessDir)
 (dbId = dbCreateRect(tcCellView gateLayer 
				 list((((W2 + gateExt) - gatePinWidth):-L2) 
				      ((W2 + gateExt):L2)
				     )
		     ))
 
 dbId = dbCreatePin(netId dbId "gr")
 dbSetq(dbId list("right") accessDir)
 dbId = dbCreateRect(tcCellView gateLayer
				list(-W2-gateExt:-L2 W2+gateExt:L2))
 dbAddFigToNet(dbId netId)
					;
 netId = dbMakeNet(tcCellView "S")
 if( areaSDPin then
	       (dbId = dbCreateRect(tcCellView sdLayer list(-W2:L2 W2:(L2+areaPinH))))
	       else
	       (dbId = dbCreateDot(tcCellView sdLayer 0:L2))
   )
 dbId = dbCreatePin(netId dbId "s")
 dbSetq(dbId list("top") accessDir)
 dbId = dbCreateRect(tcCellView sdLayer list(-W2:0 W2:L2+sdExt))
 dbAddFigToNet(dbId netId)
					;
 netId = dbMakeNet(tcCellView "D")
 if( areaSDPin then
	       dbId = dbCreateRect(tcCellView sdLayer list(-W2:(-L2-areaPinH) W2:-L2))
	       else
	       dbId = dbCreateDot(tcCellView sdLayer 0:-L2)
   )
 dbId = dbCreatePin(netId dbId "d")
 dbSetq(dbId list("bottom") accessDir)
 dbId = dbCreateRect(tcCellView sdLayer list(-W2:-L2-sdExt W2:0))
 dbAddFigToNet(dbId netId)
					;
 (if sdImpLayer then
     (dbCreateRect tcCellView sdImpLayer
		   list(-W2-sdImpEnc:-L2-sdExt-sdImpEnc
			W2+sdImpEnc:L2+sdExt+sdImpEnc))
 )

 (if sdCoreImpLayer then
     (dbCreateRect tcCellView sdCoreImpLayer
		   list(-W2-sdCoreImpEnc:-L2-sdExt-sdCoreImpEnc
			W2+sdCoreImpEnc:L2+sdExt+sdCoreImpEnc))
 )
  
)


(tfcDefineDeviceClassProp
 ;;(viewName       devClassName      propName          propValue)
;;;-------------------------------------------------------------------
 (symbolic        syMGEnhancement   function          "transistor")
)
;;; 
;;; $Id: varactorClass.il,v 1.9 2008/03/06 21:15:57 kuc Exp $
;;; 
;;; varactorClass.il
;;; 
;;; Copyright (c) 2005 by Cypress Semiconductor
;;; Cypress Kentucky CAD Center (KYCC)
;;; 
;;; Date  : Nov 15, 2005
;;; Author: Kungyen Chang (kuc) @ KYCC
;;; 
;;; Description:
;;;    Pcell code for the varactor cell.
;;;
;;; Revision History:
;;;   kuc 11/15/05  copied from mNormTranClass, modified heavily
;;;   kuc 12/21/05  added option for merged gate contacts
;;;   kuc 07/27/06  fixed class to use new contacts
;;;   vun 10/03/07  added well implant layer
;;;   kuc 03/06/08  added varactor channel implant
;;; 

(tcCreateDeviceClass
 "symbolic" "varactorClass"
 ;;; Class parameters
 (
  (tapLayer         "hilite")                ;;; diffusion layer
  (gateLayer        "marker")                ;;; poly/gate layer
  (wellLayer        nil)                     ;;; well layer, if nil then well is not drawn
  (wellImpLayer     nil)                     ;;; well Imp layer, if nil then well implant layer is not drawn
  (wellImpLayer2    nil)                     ;;; well Imp layer, if nil then well implant layer is not drawn
  (wellImpLayer3    nil)                     ;;; well Imp layer, if nil then well implant layer is not drawn
  (depLayer         nil)                     ;;; depletion layer, if nil then not drawn, other wise it is drawn on gate
  (tapExt           0.0)                     ;;; extension of tap beyond poly. This is drawn for end contacts
                                             ;;; only, if the first/last contact are not specified.
  (wellEncPoly      0.0)
  (wellEncTap       0.0)                     ;;; enclosure of tap by well.
  (depXEnc          0.0)                     ;;; enclosure of gate by dep (in X direction)
  (depYEnc          0.0)                     ;;; enclosure of gate by dep (in Y direction)
  (depSpace         0.0)                     ;;; depletion to depletion space, notch filling will be done to satisfy this.
  (labelLayer       (list "text" "drawing")) ;;; layer on which labels should be drawn, if nil labels are not drawnn
  (labelWidth       0.4)                     ;;; width of the label
  (implantLayer     nil)                     ;;; layer of implant, such as nsdm
  (tapImpEnc        0)                       ;;; enclosure of diff by implant
  (contactGateSpace 0)                       ;;; space between tap contacts and gate
  (topMetal         nil)                     ;;; top metal, determines whether top metal strapping is used
  (topMetalGateDist 0)                       ;;; distance of top metal strapping to gate contacts
  (varChannelImp    nil)                     ;;; varactor channel implant layer
  (varChannelImpEnc 0.0)                     ;;; varactor channel implant enclosure
 )
 ;;; Formal parameters
 (
  (gateContact        "")                    ;;; gate contacts
  (contacts           "")                    ;;; diffusion contacts
  (gateExt            0.0)                   ;;; extension of poly beyond diff
  (bulkOffset         0.0)                   ;;; bulk offset
  (m                  1)
  (l                  0.0)
  (w                  0.0)
  (doubleGateContacts "TRUE")                ;;; determines whether gate contacts are on both sides of device
 )

 ;; sets all contacts to be the same
 (setq sharedContact contacts)
 (setq lastContact contacts)
 (setq firstContact contacts)

 ;;; Make the nets and the terminals that will be used in the cell.
 (setq gNet (dbCreateNet tcCellView "c0"))
 (dbCreateTerm gNet "c0" "input")
 (setq bNet (dbCreateNet tcCellView "c1"))
 (dbCreateTerm bNet "c1" "inputOutput")
 (setq netL "B")
 

 (when (lessp m 1) ;;; The schematic transistor can have an mfactor of 0.
     (setq m 1)    ;;; It will be enforced to a minimum of 1.
 )

 ;;; initialize the lower left corner of all geometries. The y1Coord is not
 ;;; really required, but helps in consistency.
 (setq x1Coord 0.0)
 (setq y1Coord 0.0)
 ;;; The lastx1coord is used to calculate where to place the depLayer 
 ;;; It will store the edge of the last gate.
 (setq lastX1Coord (minus (times 2.0 (plus depXEnc depSpace))))

 ;;; initialize the y coordinates for the depletion layer.
 (when depLayer
     (setq y1DepCoord (difference y1Coord depYEnc))
     (setq y2DepCoord (plus y1Coord w depYEnc))
 )

 ;;; get the dbids of the named contacts
     
 ;;; first the firstContact contact, see if the field is defined and get the id
 ;;; If cannot find the cell -- error. The cell should be in the same library
 ;;; as the current pcell is. Place an instance of the cell (mirrored around Y)
 (when (nequal firstContact "")
     (setq contactId (dbOpenCellView tcCellView~>lib firstContact "symbolic" nil "rn"))
     (unless contactId
	 (error (sprintf nil "Cannot find/open firstContact contact cell `%s'" firstContact))
     )
     (unless contactId~>isParamCell
	 (error (sprintf nil "Named cell is not a pcell `%s'" firstContact))
     )
     (setq offset (plus bulkOffset contactGateSpace))
     (setq inst (dbCreateParamInst tcCellView contactId "c0"
				   (minus offset):0 "MY" 1
				   (list (list "l" "float" w)
					 (list "inWell" "boolean" t)))
     )
     (unless inst
	 (error (sprintf nil "Failed to create instance of `%s'" firstContact))
     )

     ;;; Create a rectangle to fill the space between the contact and the gate,
     ;;; when offset > zero.
     
     (when (greaterp offset 1e-6)
	 (dbCreateRect tcCellView tapLayer (list (difference x1Coord offset):y1Coord
						  x1Coord:w)
	 )
     )

     ;;; Create a rectangle from the top Layer of the contact, given the
     ;;; bounding box of the top Layer. Then make this rectangle a pin
     ;;; or the appropriate net.
     (setq master inst~>master)
     (setq firstConMaster master)
     (unless (and master~>topLayer master~>topLayerPinBbox)
	 (error (sprintf nil "Missing topLayer and/or topLayerPinBbox cell properties in `%s'" firstContact))
     )
     (setq yoffset 0)
     (setq bBox (list (list (minus (plus offset (caar master~>topLayerPinBbox))) (plus yoffset (cadar master~>topLayerPinBbox)))
		      (list (minus (plus offset (caadr master~>topLayerPinBbox))) (plus yoffset (cadadr master~>topLayerPinBbox))))
     )
     (setq firstBbox bBox)
     
     ;;; This pin cannot be accessed from the right side.
     (setq dbid (dbCreateRect tcCellView master~>topLayer bBox))
     (setq pinid (dbCreatePin bNet dbid))
     pinid~>accessDir = (list "top" "bottom" "left")

     ;;; Draw the appropriate label
     (when labelLayer
	 (dbCreateLabel tcCellView labelLayer
			(list (plus (caar bBox) (quotient (difference (caadr bBox) (caar bBox)) 2.0))
			      (plus (cadar bBox) (quotient (difference (cadadr bBox) (cadar bBox)) 2.0)))
			netL "centerCenter" "R0" "roman" labelWidth)
     )

     ;;; Set the lower X and Y Coordinate for the well, when wellLayer is not nil
     (when wellLayer
	 (unless master~>diffLayerBbox
	     (error (sprintf nil "Cannot find diffLayerBbox property for `%s'" firstContact))
	 )
	 ;;; Since this contact is always mirrored, we look at the x2Coord to find how
	 ;;; much does diff Extend beyond the gate. However, the farthest point from
	 ;;; the gate could also be tap. We take the maximum overlap as calculated by
	 ;;; well overlap + (diff/tap ext) beyond the gate. The above is repeated for
	 ;;; the y1 and y2 coordinates. With the assumption, that these (y1,y2) parmaeters may
	 ;;; reset again. This will not occur for now, but it would be easier to extend
	 ;;; the present class to pass parameters for top and bottom tip-Taps, in future.
	 ;;;;;;;;;;
	 (setq x1DiffCoord (caadr master~>diffLayerBbox))
	 (setq x1TapCoord (if master~>tapLayerBbox (abs (caadr master~>tapLayerBbox)) 0.0))
	 (setq x1WellCoord (minus (plus offset (max (plus wellEncTap x1DiffCoord)
						    (plus wellEncTap x1TapCoord))))
	 )
	 (setq y1DiffCoord (cadar master~>diffLayerBbox))
	 (setq y1TapCoord (if master~>tapLayerBbox (abs (cadar master~>tapLayerBbox)) 0.0))
	 (setq y1WellCoord (minus (max (plus wellEncTap y1DiffCoord)
				       (plus wellEncTap y1TapCoord)))
	 )
	 (setq y2DiffCoord (cadadr master~>diffLayerBbox))
	 (setq y2TapCoord (if master~>tapLayerBbox (abs (cadadr master~>tapLayerBbox)) 0.0))
	 (setq y2WellCoord (max (plus wellEncTap y2DiffCoord)
				(plus wellEncTap y2TapCoord))
	 )
     )
     (when implantLayer
	 (unless master~>diffLayerBbox
	     (error (sprintf nil "Cannot find diffLayerBbox property for `%s'" firstContact))
	 )
	 ;;; Since this contact is always mirrored, we look at the x2Coord to find how
	 ;;; much does diff Extend beyond the gate. However, the farthest point from
	 ;;; the gate could also be tap. We take the maximum overlap as calculated by
	 ;;; well overlap + (diff/tap ext) beyond the gate. The above is repeated for
	 ;;; the y1 and y2 coordinates. With the assumption, that these (y1,y2) parmaeters may
	 ;;; reset again. This will not occur for now, but it would be easier to extend
	 ;;; the present class to pass parameters for top and bottom tip-Taps, in future.
	 ;;;;;;;;;;
	 (setq x1DiffCoord (caadr master~>diffLayerBbox))
	 (setq x1TapCoord (if master~>tapLayerBbox (abs (caadr master~>tapLayerBbox)) 0.0))
	 (setq x1ImpCoord (minus (plus offset (max (plus tapImpEnc x1DiffCoord)
						    (plus tapImpEnc x1TapCoord))))
	 )
	 (setq y1DiffCoord (cadar master~>diffLayerBbox))
	 (setq y1TapCoord (if master~>tapLayerBbox (abs (cadar master~>tapLayerBbox)) 0.0))
	 (setq y1ImpCoord (minus (max (plus tapImpEnc y1DiffCoord)
				       (plus tapImpEnc y1TapCoord)))
	 )
	 (setq y2DiffCoord (cadadr master~>diffLayerBbox))
	 (setq y2TapCoord (if master~>tapLayerBbox (abs (cadadr master~>tapLayerBbox)) 0.0))
	 (setq y2ImpCoord (max (plus tapImpEnc y2DiffCoord)
				(plus tapImpEnc y2TapCoord))
	 )
     )
     ;;; Close the opened cell View
     (dbClose contactId)
 )

 ;;; For the first and the last diffusions we should also define a diffusion pin
 ;;; to allow parallel transistor placement.
 (setq dbid (dbCreateRect tcCellView tapLayer 
			  (list (difference x1Coord tapExt):y1Coord
				x1Coord:w)))
 (setq pinid (dbCreatePin bNet dbid))
 pinid~>accessDir = (list "top" "bottom" "left")

 ;;; Calculate the well coordinates and place label.
 (when (equal firstContact "")
     ;;; draw the appropriate label at the center of the difflayer
     (when labelLayer
	 (dbCreateLabel tcCellView labelLayer 
			(list (minus (plus x1Coord (quotient tapExt 2.0))) (plus y1Coord (quotient w 2.0)))
			netL "centerCenter" "R0" "roman" labelWidth)
     )

     ;;; When first Contact is not defined then the lower well coordinate is given by
     ;;; diffusion extension.
     (when wellLayer
	 (setq x1WellCoord (minus (plus x1Coord tapExt wellEncTap)))
	 (setq y1WellCoord (minus (plus y1Coord wellEncTap)))
	 (setq y2WellCoord (plus y1Coord w wellEncTap))
     )
     (when implantLayer
	 (setq x1ImpCoord (minus (plus x1Coord tapExt tapImpEnc)))
	 (setq y1ImpCoord (minus (plus y1Coord tapImpEnc)))
	 (setq y2ImpCoord (plus y1Coord w tapImpEnc))
     )
 )

 ;;; The following only need to be checked if m > 1 (if m == 0, we reset it to 1)
 (when (greaterp m 1)
     ;;; The shared contact, if this field is empty -- error, get the id.
     ;;; If cannot find the cell -- error. The cell should be in the same library
     ;;; as the current pcell is.
     (when (equal sharedContact "")
	 (error "Missing shared contact name property")
     )
     (setq sharedContactId (dbOpenCellView tcCellView~>lib sharedContact "symbolic" nil "rn"))
     (unless sharedContactId
	 (error (sprintf nil "Cannot find/open shared contact cell `%s'" sharedContact))
     )
     (unless sharedContactId~>isParamCell
	 (error (sprintf nil "Named cell is not a pcell `%s'" sharedContact))
     )
     
 )

;;; Open gate contacts
(unless (equal gateContact "")
(setq gateCon (dbOpenCellView tcCellView~>lib gateContact "symbolic" nil "rn"))
(unless gateCon
  (error (sprintf nil "Cannot find/open gate contact cell `%s'" gateCon))
)
(unless gateCon~>isParamCell
  (error (sprintf nil "Named cell is not a pcell `%s'" gateCon))
))
 ;;; now create the rest of the geometries etc.
 (for n 1 m
      ;;; Record first and last coordinates for creating connected gate contact
      (when (equal n 1)
	(setq firstX  x1Coord)
	)
      (when (equal n m)
	(setq lastX   (plus x1Coord l))
	)     

      ;;; Create the gate region and contacts
      (setq dbid (dbCreateRect tcCellView gateLayer (list x1Coord:(difference y1Coord gateExt)
							  (plus x1Coord l):(plus y1Coord w gateExt))
		 )
      )
      (dbAddFigToNet dbid gNet)	      

      ;;; Create channel implant
      (when varChannelImp
	(setq varChannelImpId (dbCreateRect tcCellView varChannelImp (list (difference x1Coord varChannelImpEnc):(difference y1Coord varChannelImpEnc)
									   (plus x1Coord l varChannelImpEnc):(plus y1Coord w varChannelImpEnc))
					    )
	      )
	)

      (when (equal gateContact "")
      
      ;;; Create the two pins (one on top and another on bottom).
      ;;; When "Automatic keepouts for MOS gates" is used with CCT, the abstract
      ;;; creation breaks the pins. However, if we use diffusion as a poly keepout
      ;;; and do not use the automatic keepouts for MOS gates, then the gate
      ;;; pin may be used as a feed through. This pin creation only happens when no
      ;;; gate contacts are present.

      ;;; First Create the top pin
	(setq dbid (dbCreateRect tcCellView gateLayer 
				 (list x1Coord:(plus y1Coord w)
				       (plus x1Coord l):(plus y1Coord w gateExt)))
	      )
	(setq pinid (dbCreatePin gNet dbid))
	pinid~>accessDir = (list "top")

      ;;; Then the bottom pin.
	(setq dbid (dbCreateRect tcCellView gateLayer
				 (list x1Coord:(difference y1Coord gateExt)
				       (plus x1Coord l):y1Coord))
	      )
	(setq pinid (dbCreatePin gNet dbid))
	pinid~>accessDir = (list "bottom")
	)

      (if (and (nequal gateContact "") (equal n m)) then
	(setq dummyGateContact (dbCreateParamInst tcCellView gateCon (sprintf nil "dum%d" n) 0:0 "R0" 1))
	(setq baseGateConMaster dummyGateContact~>master)
	(setq baseGateConBbox baseGateConMaster~>botLayerBbox)
	(setq baseGateConW (abs (difference (caar baseGateConBbox) (caadr baseGateConBbox))))
	(setq baseGateConL (abs (difference (cadar baseGateConBbox) (cadadr baseGateConBbox))))
	(dbDeleteObject dummyGateContact)
	(setq bigGateSize (max baseGateConW (plus (times 2 baseGateConL) (difference lastX firstX))))
	(setq gateConInst (dbCreateParamInst tcCellView gateCon (sprintf nil "g0%d" n)
					     firstX:(difference y1Coord gateExt) "R0" 1
					     (list (list "w" "float" bigGateSize)
						   (list "l" "float" baseGateConL))				     
					     ))
	(if doubleGateContacts
	    then
	  (setq gateConInst2 (dbCreateParamInst tcCellView gateCon (sprintf nil "g1%d" n)
						firstX:(difference y1Coord gateExt) "R0" 1
						(list (list "w" "float" bigGateSize)
						      (list "l" "float" baseGateConL))
						))
	  )
	(unless gateConInst
	  (error "Failed to create instance of gate contact")
	  )

	(setq gateConMaster gateConInst~>master)


	(setq gateConMaster1 gateConInst~>master)
	(setq gateCon1Bbox gateConMaster1~>topLayerPinBbox)
	(setq gateConYOffset (cadadr gateConMaster~>botLayerBbox))
	gateConInst~>xy = list((plus firstX (quotient (difference lastX firstX) 2)) (difference y1Coord gateExt gateConYOffset))
	

	(unless (and gateConMaster1~>topLayer gateConMaster1~>topLayerPinBbox)
	  (error (sprintf nil "Missing topLayer and/or topLayerPinBbox cell properties in `%s'" contactId~>cellName))
	  )
	
	(setq bBox (list (list (plus (caar gateConMaster1~>topLayerPinBbox) (car gateConInst~>xy)) 
			       (plus (cadar gateConMaster1~>topLayerPinBbox) (cadr gateConInst~>xy)))
			 (list (plus (caadr gateConMaster1~>topLayerPinBbox) (car gateConInst~>xy)) 
			       (plus (cadadr gateConMaster1~>topLayerPinBbox) (cadr gateConInst~>xy))))
	      )	
	(setq dbid (dbCreateRect tcCellView gateConMaster1~>topLayer bBox))
	(setq pinid (dbCreatePin gNet dbid))
	pinid~>accessDir = (list "bottom")


	(setq bBox1 (list (list firstX 
				(plus (cadar gateConMaster1~>botLayerBbox) (cadr gateConInst~>xy)))
			  (list lastX 
				(plus (cadadr gateConMaster1~>botLayerBbox) (cadr gateConInst~>xy))))
	      )
	(dbCreateRect tcCellView gateConMaster1~>botLayer bBox1)

	(if doubleGateContacts
	    then
          gateConInst2~>xy = list((plus firstX (quotient (difference lastX firstX) 2)) (plus w y1Coord gateExt gateConYOffset))
	  (setq gateConMaster2 gateConInst2~>master)
	  (setq gateCon2Bbox gateConMaster2~>topLayerPinBbox)

	  (unless (and gateConMaster2~>topLayer gateConMaster2~>topLayerPinBbox)
	    (error (sprintf nil "Missing topLayer and/or topLayerPinBbox cell properties in `%s'" contactId~>cellName))
	    )
	  (setq bBox (list (list (plus (caar gateConMaster2~>topLayerPinBbox) (car gateConInst2~>xy)) 
				 (plus (cadar gateConMaster2~>topLayerPinBbox) (cadr gateConInst2~>xy)))
			   (list (plus (caadr gateConMaster2~>topLayerPinBbox) (car gateConInst2~>xy)) 
				 (plus (cadadr gateConMaster2~>topLayerPinBbox) (cadr gateConInst2~>xy))))
		)
	  (setq dbid (dbCreateRect tcCellView gateConMaster2~>topLayer bBox))

	  pinid~>accessDir = (list "top")

	  (setq bBox2 (list (list firstX 
				  (plus (cadar gateConMaster2~>botLayerBbox) (cadr gateConInst2~>xy)))
			    (list lastX 
				  (plus (cadadr gateConMaster2~>botLayerBbox) (cadr gateConInst2~>xy))))
		)
	  (dbCreateRect tcCellView gateConMaster2~>botLayer bBox2)
	  )

	)
      
      ;;; Create the floating diffusion under the gate region
      (dbCreateRect tcCellView tapLayer (list x1Coord:y1Coord 
					       (plus x1Coord l):(plus y1Coord w))
		    )

      ;;; If the depletion layer is defined draw it on top of the gate region
      (when depLayer
	  (cond 
	      ((lessp (difference x1Coord lastX1Coord (times 2.0 depXEnc)) depSpace)
	       (setq x1DepCoord (plus lastX1Coord depXEnc))
	      )
	      (t
	       (setq x1DepCoord (difference x1Coord depXEnc))
	      )
	  )
	  (dbCreateRect tcCellView depLayer (list x1DepCoord:y1DepCoord
						  (plus x1Coord l depXEnc):y2DepCoord))
      )
      ;;; increment the x1Coord to next gate edge
      (setq x1Coord (plus x1Coord l))
      
      ;;; Create the contact for the second terminal
      (when (nequal n m)
	  (setq contactId sharedContactId)
          (setq offset (plus bulkOffset contactGateSpace))

	  (setq inst (dbCreateParamInst tcCellView contactId (sprintf nil "c%d" n)
					(plus offset x1Coord):y1Coord "R0" 1
					(list (list "l" "float" w)
					      (list "inWell" "boolean" t)))
	  )
	  (unless inst
	      (error (sprintf nil "Failed to create instance of `%s'" contactId~>cellName))
	  )
	  ;;; Create a rectangle from the specified topLayer and topLayerPinBbox of
	  ;;; of the created instance. And put the proper pin on it
	  (setq master inst~>master)
	  (setq sharedConMaster master)
	  (unless (and master~>topLayer master~>topLayerPinBbox)
	      (error (sprintf nil "Missing topLayer and/or topLayerPinBbox cell properties in `%s'" contactId~>cellName))
	  )
	  (setq yoffset 0)
	  (setq bBox (list (list (plus (caar master~>topLayerPinBbox) x1Coord offset) (plus yoffset (cadar master~>topLayerPinBbox)))
			   (list (plus (caadr master~>topLayerPinBbox) x1Coord offset) (plus yoffset (cadadr master~>topLayerPinBbox))))
	  )
	  
	  ;;; Since this source/drain pin is inside, it can only be accessed from top or bottom.
	  (setq dbid (dbCreateRect tcCellView master~>topLayer bBox))
	  (setq pinid (dbCreatePin bNet dbid))
	  pinid~>accessDir = (list "top" "bottom")

	  ;;; Draw the label, if allowed (The label is drawn at the center of the top layer bbox)
	  (when labelLayer
	      (dbCreateLabel tcCellView labelLayer 
			     (list (plus (caar bBox) (quotient (difference (caadr bBox) (caar bBox)) 2.0))
				   (plus (cadar bBox) (quotient (difference (cadadr bBox) (cadar bBox)) 2.0)))
			     netL "centerCenter" "R0" "roman" labelWidth)
	  )
	  ;;; Create a piece of diffusion to cover up the space between the gate and the
	  ;;; contact, if offset > zero.
	  (when (greaterp offset 1e-6)
	      (dbCreateRect tcCellView tapLayer (list x1Coord:y1Coord
						       (plus offset x1Coord):(plus y1Coord w))
	      )
	  )

	  (unless master~>diffLayerBbox
	      (error (sprintf nil "Missing diffLayerBbox cell properties in `%s'" contactId~>cellName))
	  )
	  ;;; increment x1Coord to next gate's first edge, after storing the last gate edge
	  ;;; the offset parameter in the hand of the designers, should be used to
	  ;;; satisfy any li1-li1, poly-poly spacing problems.
	  (setq lastX1Coord x1Coord)
	  (setq x1Coord (plus (times 2.0 offset)
			      (plus x1Coord (difference (caadr master~>diffLayerBbox)
							(caar master~>diffLayerBbox)))
			)
	  )
	  ;;; Create another piece of diffusion to cover up the space between the gate and the
	  ;;; contact, if offset > zero.
	  (when (greaterp offset 1e-6)
	      (dbCreateRect tcCellView tapLayer (list (difference x1Coord offset):y1Coord
						       x1Coord:(plus y1Coord w))
	      )
	  )
	  ;;; Give the master of the contact just placed, recalculate the well overlaps in 
	  ;;; y direction. The maximum well overlaps should be used.
	  (when wellLayer
	      (setq y1DiffCoord (cadar master~>diffLayerBbox))
	      (setq y1TapCoord (if master~>tapLayerBbox (abs (cadar master~>tapLayerBbox)) 0.0))
	      ;;; remember, (max (abs -1) (abs -2)) = (min -1 -2)
	      (setq y1WellCoord (min (minus (max (plus wellEncTap y1DiffCoord)
						 (plus wellEncTap y1TapCoord)))
				     y1WellCoord)
	      )
	      (setq y2DiffCoord (cadadr master~>diffLayerBbox))
	      (setq y2TapCoord (if master~>tapLayerBbox (abs (cadadr master~>tapLayerBbox)) 0.0))
	      (setq y2WellCoord (max (plus wellEncTap y2DiffCoord)
				     (plus wellEncTap y2TapCoord)
				     y2WellCoord)
	      )
	  )
	  (when implantLayer
	      (setq y1DiffCoord (cadar master~>diffLayerBbox))
	      (setq y1TapCoord (if master~>tapLayerBbox (abs (cadar master~>tapLayerBbox)) 0.0))
	      ;;; remember, (max (abs -1) (abs -2)) = (min -1 -2)
	      (setq y1ImpCoord (min (minus (max (plus tapImpEnc y1DiffCoord)
						 (plus tapImpEnc y1TapCoord)))
				     y1ImpCoord)
	      )
	      (setq y2DiffCoord (cadadr master~>diffLayerBbox))
	      (setq y2TapCoord (if master~>tapLayerBbox (abs (cadadr master~>tapLayerBbox)) 0.0))
	      (setq y2ImpCoord (max (plus tapImpEnc y2DiffCoord)
				     (plus tapImpEnc y2TapCoord)
				     y2ImpCoord)
	      )
	  )
      )

 )
 

(when (nequal m 1)
     ;;; Close the opened cell views of the shared src and drn contacts
     (dbClose sharedContactId)
 )


 ;;; Finally the lastContact contact, see if the field is defined and get the id.
 ;;; If cannot find the cell -- error. The cell should be in the same library
 ;;; as the current pcell is.

 (when (nequal lastContact "")
     (setq contactId (dbOpenCellView tcCellView~>lib lastContact "symbolic" nil "rn"))
     (unless contactId
	 (error (sprintf nil "Cannot find/open lastContact contact cell `%s'" lastContact))
     )
     (unless contactId~>isParamCell
	 (error (sprintf nil "Named cell is not a pcell `%s'" lastContact))
     )
     (setq offset (plus bulkOffset contactGateSpace))

     (setq inst (dbCreateParamInst tcCellView contactId (sprintf nil "c%d" m)
				   (plus offset x1Coord):y1Coord "R0" 1
				   (list (list "l" "float" w)
					 (list "inWell" "boolean" t)))
     )
     (unless inst
	 (error (sprintf nil "Failed to create instance of `%s'" lastContact))
     )

     ;;; Create a rectangle to fill the space between the contact and the gate,
     ;;; when offset > zero.
     
     (when (greaterp offset 1e-6)
	 (dbCreateRect tcCellView tapLayer (list  x1Coord:y1Coord
						  (plus offset x1Coord):(plus y1Coord w))
	 )
     )

     ;;; Create a rectangle from the top Layer of the contact, given the
     ;;; bounding box of the top Layer. Then make this rectangle a pin
     ;;; or the appropriate net.
     (setq master inst~>master)
     (setq lastConMaster master)
     (unless (and master~>topLayer master~>topLayerPinBbox)
       (error (sprintf nil "Missing topLayer and/or topLayerPinBbox cell properties in `%s'" lastContact))
       )
     (setq yoffset 0)
     (setq bBox (list (list (plus (caar master~>topLayerPinBbox) x1Coord offset) (plus yoffset (cadar master~>topLayerPinBbox)))
		      (list (plus (caadr master~>topLayerPinBbox) x1Coord offset) (plus yoffset (cadadr master~>topLayerPinBbox))))
     )
     (setq lastBbox bBox)
     
     ;;; This pin can be accessed from top, bottom, and right only.
     (setq dbid (dbCreateRect tcCellView master~>topLayer bBox))
     (setq pinid (dbCreatePin bNet dbid))
     pinid~>accessDir = (list "top" "bottom" "right")

     ;;; draw the label at the center of the top layer
     (when labelLayer
	 (dbCreateLabel tcCellView labelLayer 
			(list (plus (caar bBox) (quotient (difference (caadr bBox) (caar bBox)) 2.0))
			      (plus (cadar bBox) (quotient (difference (cadadr bBox) (cadar bBox)) 2.0)))
			netL "centerCenter" "R0" "roman" labelWidth)
     )

     ;;; If wellLayer is defined, then calculate the upper coordinates of the well layer
     (when wellLayer
	 (unless master~>diffLayerBbox
	     (error (sprintf nil "Cannot find diffLayerBbox property for `%s'" lastContact))
	 )

	 ;;; Given the master of the contact just placed, recalculate the well overlaps in 
	 ;;; y direction. The maximum well overlaps should be used.
	 (setq y1DiffCoord (cadar master~>diffLayerBbox))
	 (setq y1TapCoord (if master~>tapLayerBbox (abs (cadar master~>tapLayerBbox)) 0.0))
	 ;;; remember, (max (abs -1) (abs -2)) = (min -1 -2)
	 (setq y1WellCoord (min (minus (max (plus wellEncTap y1DiffCoord)
					    (plus wellEncTap y1TapCoord)))
				y1WellCoord)
	 )
	 (setq y2DiffCoord (cadadr master~>diffLayerBbox))
	 (setq y2TapCoord (if master~>tapLayerBbox (abs (cadadr master~>tapLayerBbox)) 0.0))
	 (setq y2WellCoord (max (plus wellEncTap y2DiffCoord)
				(plus wellEncTap y2TapCoord)
				y2WellCoord)
	 )
	 ;;; Calculate the x2Coord of the well, from the x2Coordinates of the diffLayerBbox and
	 ;;; tapLayerBbox.
	 (setq x2DiffCoord (caadr master~>diffLayerBbox))
	 (setq x2TapCoord (if master~>tapLayerBbox (abs (caadr master~>tapLayerBbox)) 0.0))
	 (setq x2WellCoord (plus offset x1Coord (max (plus wellEncTap x2DiffCoord)
						     (plus wellEncTap x2TapCoord)))
	 )
     )
     (when implantLayer
	 (unless master~>diffLayerBbox
	     (error (sprintf nil "Cannot find diffLayerBbox property for `%s'" lastContact))
	 )

	 ;;; Given the master of the contact just placed, recalculate the well overlaps in 
	 ;;; y direction. The maximum well overlaps should be used.
	 (setq y1DiffCoord (cadar master~>diffLayerBbox))
	 (setq y1TapCoord (if master~>tapLayerBbox (abs (cadar master~>tapLayerBbox)) 0.0))
	 ;;; remember, (max (abs -1) (abs -2)) = (min -1 -2)
	 (setq y1ImpCoord (min (minus (max (plus tapImpEnc y1DiffCoord)
					    (plus tapImpEnc y1TapCoord)))
				y1ImpCoord)
	 )
	 (setq y2DiffCoord (cadadr master~>diffLayerBbox))
	 (setq y2TapCoord (if master~>tapLayerBbox (abs (cadadr master~>tapLayerBbox)) 0.0))
	 (setq y2ImpCoord (max (plus tapImpEnc y2DiffCoord)
				(plus tapImpEnc y2TapCoord)
				y2ImpCoord)
	 )
	 ;;; Calculate the x2Coord of the well, from the x2Coordinates of the diffLayerBbox and
	 ;;; tapLayerBbox.
	 (setq x2DiffCoord (caadr master~>diffLayerBbox))
	 (setq x2TapCoord (if master~>tapLayerBbox (abs (caadr master~>tapLayerBbox)) 0.0))
	 (setq x2ImpCoord (plus offset x1Coord (max (plus tapImpEnc x2DiffCoord)
						     (plus tapImpEnc x2TapCoord)))
	 )
     )
     ;;; Close the opened cell view of the lastContact
     (dbClose contactId)
 )

 ;;; Create a diffusion pin to allow transistors to be placed in parallel.
 (setq dbid (dbCreateRect tcCellView tapLayer (list x1Coord:y1Coord
						     (plus x1Coord tapExt):(plus y1Coord w)))
 )
 (setq pinid (dbCreatePin bNet dbid))
 pinid~>accessDir = (list "top" "bottom" "right")

 ;; draw the label and calculate the well coordinates.
 (when (equal lastContact "")
     ;;; draw the label (at the center of the diff)
     (when labelLayer
	 (dbCreateLabel tcCellView labelLayer
			(list (plus x1Coord (quotient tapExt 2.0)) (plus y1Coord (quotient w 2.0)))
			netL "centerCenter" "R0" "roman" labelWidth)
     )
			
     ;;; When lastContact is not defined, the upper coordinates of the well are given by the
     ;;; tapExt.
     (when wellLayer
	 (setq x2WellCoord (plus x1Coord tapExt wellEncTap))
	 (setq y2WellCoord (max (plus y1Coord w wellEncTap)
				y2WellCoord)
	 )
     )
     (when implantLayer
	 (setq x2ImpCoord (plus x1Coord tapExt tapImpEnc))
	 (setq y2ImpCoord (max (plus y1Coord w tapImpEnc)
				y2WellCoord)
	 )
     )
 )

 ;; creates top metal strapping
 (setq topMetalBotY (cadar firstBbox))
 (setq topMetalTopY (cadadr firstBbox))
 (when topMetal
   (if (nequal gateContact nil) then
     (if (equal gateConMaster1~>topLayer topMetal) then
       (setq topMetalBotY (max (caadr firstBbox) (plus topMetalGateDist (cadadr gateConMaster1~>topLayerPinBbox) (cadr gateConInst~>xy))))
       (if doubleGateContacts then
	 (setq topMetalTopY (min (cadadr firstBbox) (difference (plus (cadar gateConMaster2~>topLayerPinBbox) (cadr gateConInst2~>xy)) topMetalGateDist)))
	 )
       )
     )
   (if (equal firstConMaster~>topLayer topMetal) then
     (dbCreateRect tcCellView topMetal (list (list (caar firstBbox) topMetalBotY) (list (caar lastBbox) topMetalTopY)))
     )
   )
 ;;; While we are at it, we could as well draw the tap contacts to satisfy the new
 ;;; latchup rules. A tap contact (provided by the user) to left/right or both
 ;;; 1. get the id of the contact
 ;;; 2. place an instance at the offset given by a class property
 ;;; 3. get the master
 ;;; 4. get the topLayerBbox and place a pin with body net
 ;;; 5. get the botLayerBbox and recalculate x1WellCoord and x2WellCoord as required
 ;;; 6. close the opened contact cell
 
 ;;; Draw the well Layer if defined, all the coordinates have already
 ;;; been defined
 
 (when wellLayer
     (unless (equal gateContact "")
       (setq y1WellCoord (difference (difference (difference y1Coord gateExt) wellEncPoly) (times 2 gateConYOffset)))
       (if doubleGateContacts
	   then
	   (setq y2WellCoord (plus (plus (plus (plus y1Coord gateExt) wellEncPoly) (times 2 gateConYOffset)) w))
	   else
	   (setq y2WellCoord (plus (plus (plus y1Coord w) gateExt) wellEncPoly))
       )
     )

     (if (equal gateContact "")
	 then
       (setq y1WellCoord (difference (difference y1Coord wellEncPoly) gateExt))
       (setq y2WellCoord (plus (plus (plus y1Coord wellEncPoly) gateExt) w))
     )

     (dbCreateRect tcCellView wellLayer (list (list x1WellCoord y1WellCoord)
					      (list x2WellCoord y2WellCoord))
     )
     (when wellImpLayer
     (dbCreateRect tcCellView wellImpLayer (list (list x1WellCoord y1WellCoord)
					      (list x2WellCoord y2WellCoord))
     ))
     (when wellImpLayer2
     (dbCreateRect tcCellView wellImpLayer2 (list (list x1WellCoord y1WellCoord)
					      (list x2WellCoord y2WellCoord))
     ))
     (when wellImpLayer3
     (dbCreateRect tcCellView wellImpLayer3 (list (list x1WellCoord y1WellCoord)
					      (list x2WellCoord y2WellCoord))
     ))


 )

 (when implantLayer
     (dbCreateRect tcCellView implantLayer (list (list x1ImpCoord y1ImpCoord)
						(list x2ImpCoord y2ImpCoord))
     )
 )
)

;;; Define the function of the class.

(tfcDefineDeviceClassProp
;;(viewName       devClassName      propName          propValue)
 (symbolic        varactorClass    function          "transistor")
)
;;; 
;;; $Id: simpleContactClass.il,v 1.1 2006/07/27 15:04:01 kuc Exp $
;;; 
;;; simpleContactClass.il
;;; 
;;; Copyright (c) 2006 by Cypress Semiconductor
;;; Cypress Kentucky CAD Center (KYCC)
;;; 
;;; Date  : Jun 28, 2006
;;; Author: Kungyen Chang (kuc) @ KYCC
;;; 
;;; Description:
;;;   This class is a simple contact class
;;;   that supports n layers with basic
;;;   implant and nwell support.
;;; 
;;; Revision History:
;;;   kuc 07/27/06  initial version
;;; 

(putpropqq simpleContactClass "$Id: simpleContactClass.il,v 1.1 2006/07/27 15:04:01 kuc Exp $" SCCS)

(tcCreateDeviceClass
 "symbolic" "simpleContactClass"
 ;; Class parameters
 (
  (layerparams nil)          ;;; determines contact layers - the format is as follows:
                             ;;; (list (list layer1Name
                             ;;;             enclosure of layer 1 and via below it (x dir - left side)
                             ;;;             enclosure of layer 1 and via below it (x dir - right side)
                             ;;;             enclosure of layer 1 and via below it (y dir)
                             ;;;             enclosure of layer 1 and via above it (x dir - left side)
                             ;;;             enclosure of layer 1 and via above it (x dir - right side)
                             ;;;             enclosure of layer 1 and via above it (y dir)
                             ;;;             (list (list          ;; first list of implants is for inWell=nil
                             ;;;                    (list implant1ForLayer1Name
                             ;;;                          implant1 enclosure value)
                             ;;;                    (list implant2ForLayer1Name
                             ;;;                          implant2 enclosure value)
                             ;;;                    )
                             ;;;                   (list          ;; second list of implants is for inWell=t
                             ;;;                    (list implant1ForLayer1Name
                             ;;;                          implant1 enclosure value)
                             ;;;                    (list ...)
                             ;;;                    )
                             ;;;              )
                             ;;;       (list via1Name
                             ;;;             min width of via1
                             ;;;             min spacing of via1
                             ;;;             (list via1ImplantName
                             ;;;                   via1 implant enclosure value
                             ;;;              )
                             ;;;        )
                             ;;;       (list layer2Name
                             ;;;             ...
                             ;;;        )
                             ;;;       (list via2Name
                             ;;;             ...
                             ;;;        )
                             ;;;       ...
                             ;;;  )   
                             ;;;
 ) 

 ;; Formal parameters
 (
  (w       0.0)              ;;; This contact's dimensions are only determined by w and l,
  (l       0.0)              ;;; calculate these numbers carefully.
  (inWell  "TRUE")
  (center  "FALSE")          ;;; Centers the contact's origin at 0:0
  )


;; Sample parameters setting:
;;
;; This would be passed into the class via 
;; 
;; (layerparams   `((list ',TPM2params)))
;;
;; in the class declaration.
;;
;;
;; (setq TPM2params (list (list (list "tap" "drawing")
;;			     0.0
;;			     0.0
;;			     0.0 
;;			     0.0
;;			     0.0
;;			     ,(TECHgetRuleWith "minEnclosure" "tap" "licon1")
;;			     (list (list 
;;				    (list (list "psdm" "drawing")
;;					  ,(TECHgetRule "psd_5a")
;;					  ))
;;				   (list 
;;				    (list (list "nsdm" "drawing")
;;					  ,(TECHgetRule "nsd_5a")
;;					  )
;;				    (list (list "nwell" "drawing")
;;					  ,(TECHgetRuleWith "minEnclosure" "nwell" "tap")
;;					  ))
;;				   )
;;			     )			   
;;		       (list (list "licon1" "drawing")
;;			     ,(TECHgetRuleWith "minWidth" "licon1")
;;			     ,(TECHgetRuleWith "minSpacing" "licon1")
;;			     )
;;		       (list (list "li1" "drawing")
;;			     0.0
;;			     0.0
;;			     ,(TECHgetRuleWith "minEnclosure" "li1" "licon1")
;;			     0.0
;;			     0.0
;;			     ,(TECHgetRuleWith "minEnclosure" "li1" "mcon")
;;			     )
;;		       (list (list "mcon" "drawing")
;;			     ,(TECHgetRuleWith "minWidth" "mcon")
;;			     ,(TECHgetRuleWith "minSpacing" "mcon")
;;			     )
;;		       (list (list "met1" "drawing")
;;			     ,(TECHgetRuleWith "minEnclosureAny" "met1" "mcon")
;;			     ,(TECHgetRuleWith "minEnclosureAny" "met1" "mcon")
;;			     ,(TECHgetRuleWith "minEnclosure" "met1" "mcon")
;;			     ,(TECHgetRuleWith "minEnclosureAny" "met1" "via")
;;			     ,(TECHgetRuleWith "minEnclosureAny" "met1" "via")
;;			     ,(TECHgetRuleWith "minEnclosure" "met1" "via")
;;			     )
;;		       (list (list "via" "drawing")
;;			     ,(TECHgetRuleWith "minWidth" "via")
;;			     ,(TECHgetRuleWith "minSpacing" "via")
;;			     )
;;		       (list (list "met2" "drawing")
;;			     ,(TECHgetRuleWith "minEnclosureAny" "met2" "via")
;;			     ,(TECHgetRuleWith "minEnclosureAny" "met2" "via")
;;			     ,(TECHgetRuleWith "minEnclosure" "met2" "via")
;;			     0.0
;;			     0.0
;;			     0.0
;;			     )
;;		       ))
;;



 (if (or (equal inWell t) (equal inWell "TRUE")) then
   (setq inWell t)
   else
   (setq inWell nil)
   )
 (if (or (equal center t) (equal center "TRUE")) then
   (setq center t)
   else
   (setq center nil)
   )
 (setq layerparams (caar layerparams))
 (setq layer1params (car layerparams))

 ;; Draw first layer
 (setq layer1Rect (rodCreateRect
		   ?layer (car layer1params)
		   ?width w
		   ?length l
		   ))
 (if (equal center t) then
   (rodAlign
    ?alignObj layer1Rect
    ?alignHandle "cC"
    ?refPoint (list 0 0)
    )
   )

 ;; sets properties 
 (setq refPoint layer1Rect)
 (setq rectId layer1Rect~>dbId)
 (dbCreateProp tcCellView "botLayer" "list" rectId~>lpp)
 (dbCreateProp tcCellView "botLayerBbox" "list" rectId~>bBox)
 (dbCreateProp tcCellView "diffLayer" "list" rectId~>lpp)
 (dbCreateProp tcCellView "diffLayerBbox" "list" rectId~>bBox)

 ;; draws first layer
 (setq isLayer1 t)
 (unless ((length layer1params) < 8)
   (if inWell then
     (setq layer1ImpParams (cadr (cadddr (cddddr layer1params))))
     else
     (setq layer1ImpParams (car (cadddr (cddddr layer1params))))
     )
   (foreach layer1Imp layer1ImpParams
	    (setq layer1ImpRect (rodCreateRect
				 ?layer (car layer1Imp)
				 ?fromObj layer1Rect
				 ?size (cadr layer1Imp)
				 ))
	    )
   )   
 
 ;; this loop draws each layer until all layerparams are gone
 (while (nequal layerparams nil)

   ;; checks if it is the last layer
   (if ((length layerparams) == 1) then
     (setq topLayerParams (car layerparams))
     (setq layerparams nil)
     (setq viaParams nil)
     (setq botLayerParams nil)
     else
     (setq botLayerParams (car layerparams))
     (setq viaParams (cadr layerparams))
     (setq topLayerParams (caddr layerparams))
     (setq layerparams (cddr layerparams))
     )
   
   ;; gets via parameters
   (if viaParams then
     (setq viaLayer (car viaParams))
     (setq viaWidth (cadr viaParams))
     (setq viaSpacing (caddr viaParams))
     (if ((length viaParams) > 3) then
       (setq viaImpParams (cadddr viaParams))
       (setq viaImpLayer (car viaImpParams))
       (setq viaImpEnc (cadr viaImpParams))
       else
       (setq viaImpParams nil)
       )
     )

   ;; gets parameters for the current bottom metal layer to be drawn
   (if botLayerParams then
     (setq botLayer (car botLayerParams))
     (setq botLayerEncViaXR (cadddr (cdr botLayerParams)))
     (setq botLayerEncViaXL (cadddr (cddr botLayerParams)))
     (setq botLayerEncViaY (cadddr (cdddr botLayerParams)))
     (if ((length botLayerParams) > 7) then
       (setq botLayerImpParams (cadddr (cdddr (cdr botLayerParams))))
       (if inWell then
	 (setq botLayerImpParams (cadr botLayerImpParams))
	 else
	 (setq botLayerImpParams (car botLayerImpParams))
	 )
       )
     )

   ;; gets parameters for the current top metal layer to be drawn
   (setq topLayer (car topLayerParams))
   (setq topLayerEncViaXR (cadr topLayerParams))
   (setq topLayerEncViaXL (caddr topLayerParams))
   (setq topLayerEncViaY (cadddr topLayerParams))
   (if ((length topLayerParams) > 7) then
     (setq topLayerImpParams (cadddr (cdddr (cdr topLayerParams))))
     (if inWell then
       (setq topLayerImpParams (cadr topLayerImpParams))
       else
       (setq topLayerImpParams (car topLayerImpParams))
       )
     )

   ;; Calculate number of via contacts and draw them
   (if viaParams then
     (setq numViaContactsW (floor (quotient w viaWidth)))
     (setq numViaContactsL (floor (quotient l viaWidth)))
     (if isLayer1 then 
       (while (max (difference (plus topLayerEncViaXR topLayerEncViaXL (times numViaContactsW viaWidth) (times (difference numViaContactsW 1) viaSpacing)) 1e-6) (difference (plus botLayerEncViaXR botLayerEncViaXL (times numViaContactsW viaWidth) (times (difference numViaContactsW 1) viaSpacing)) 1e-6)) > w
	      (setq numViaContactsW (difference numViaContactsW 1))
	      )
       (while (max (difference (plus (times 2 topLayerEncViaY) (times numViaContactsL viaWidth) (times (difference numViaContactsL 1) viaSpacing)) 1e-6) (difference (plus (times 2 botLayerEncViaY) (times numViaContactsL viaWidth) (times (difference numViaContactsL 1) viaSpacing)) 1e-6)) > l
	      (setq numViaContactsL (difference numViaContactsL 1))
	      )
       else
       (while (difference (plus (times numViaContactsW viaWidth) (times (difference numViaContactsW 1) viaSpacing)) 1e-6) > w
	      (setq numViaContactsW (difference numViaContactsW 1))
	      )
       (while (max (difference (plus (times 2 topLayerEncViaY) (times numViaContactsL viaWidth) (times (difference numViaContactsL 1) viaSpacing)) 1e-6) (difference (plus (times 2 botLayerEncViaY) (times numViaContactsL viaWidth) (times (difference numViaContactsL 1) viaSpacing)) 1e-6)) > l
	      (setq numViaContactsL (difference numViaContactsL 1))
	      )
       )

     (if (numViaContactsW < 1) then
       (error "simpleContactClass: Width given is too small to fit vias - %L" tcCellView~>cellName)
       )
     (if (numViaContactsL < 1) then
       (error "simpleContactClass: Length given is too small to fit vias - %L" tcCellView~>cellName)
       )

     (setq viaContacts (rodCreateRect
			?layer botLayer
			?width (plus botLayerEncViaXR botLayerEncViaXL
				     (plus (times (difference numViaContactsW 1) viaSpacing) 
	 				   (times numViaContactsW viaWidth)))
			?length (plus (times 2 botLayerEncViaY)
				      (plus (times (difference numViaContactsL 1) viaSpacing) 
					    (times numViaContactsL viaWidth)))
			?subRectArray
			(list (list ?layer viaLayer
				    ?width viaWidth
				    ?length viaWidth
				    ?spaceY viaSpacing
				    ?spaceX viaSpacing
				    ?lowerLeftOffsetY  botLayerEncViaY
				    ?upperRightOffsetY (minus botLayerEncViaY)
				    ?lowerLeftOffsetX botLayerEncViaXL
				    ?upperRightOffsetX (minus botLayerEncViaXR)
				    ?gap "minimum"
				    ))
			  
			))
     (unless ((length botLayerParams) < 8)
       (foreach botLayerImp botLayerImpParams
		(setq botLayerImpRect (rodCreateRect
				       ?layer (car botLayerImp)
				       ?fromObj viaContacts
				       ?size (cadr botLayerImp)
				       ))
		)
       )
     
     ;; Draw via implant if it exists
     (if viaImpParams then
       (setq viaImplant (rodCreateRect
			 ?layer viaImpLayer
			 ?width (plus (times 2 viaImpEnc)
				      (plus (times (difference numViaContactsW 1) viaSpacing) 
					    (times numViaContactsW viaWidth)))
			 ?length (plus (times 2 viaImpEnc)
				       (plus (times (difference numViaContactsL 1) viaSpacing) 
					     (times numViaContactsL viaWidth)))
			 ))
       (rodAlign
	?alignObj viaImplant
	?alignHandle "cC"
	?refObj viaContacts
	?refHandle "cC"
	?xSep (quotient (difference botLayerEncViaXL botLayerEncViaXR) 2)
	)
       )
       
       (if isLayer1 then
	 ;; Draw align via contacts with layer1
	 (rodAlign
	  ?alignObj viaContacts
	  ?alignHandle "cC"
	  ?refObj refPoint
	  ?refHandle "cC"
	  )
	 else
	 (rodAlign
	  ?alignObj viaContacts
	  ?alignHandle "cC"
	  ?refObj refPoint
	  ?refHandle "cC"
	  ?xSep (quotient (difference botLayerEncViaXL botLayerEncViaXR) 2)
	  )
	 )
       	 (setq refPoint viaContacts)
	 
   
     )
   (setq layer2W (plus (times (difference numViaContactsW 1) viaSpacing) (times numViaContactsW viaWidth) topLayerEncViaXR topLayerEncViaXL))
   (setq layer2L (plus (times (difference numViaContactsL 1) viaSpacing) (times numViaContactsL viaWidth) (times 2 topLayerEncViaY)))
   
   (setq layer2Rect (rodCreateRect
		     ?layer topLayer
		     ?width layer2W
		     ?length layer2L
		     ))
   (rodAlign
    ?alignObj layer2Rect
    ?alignHandle "cC"
    ?refObj refPoint
    ?refHandle "cC"
    ?xSep (quotient (difference botLayerEncViaXL botLayerEncViaXR) 2)
    )

   (when (equal layerparams nil)
     (setq rectId layer2Rect~>dbId)
     (dbCreateProp tcCellView "topLayer" "list" rectId~>lpp)
     (dbCreateProp tcCellView "topLayerPinBbox" "list" rectId~>bBox)
     )

   (unless (equal (length layerparams) 1)
     (setq refPoint layer2Rect)
     )

   (unless ((length topLayerParams) < 8)
     (foreach topLayerImp topLayerImpParams
	      (setq topLayerImpRect (rodCreateRect
				     ?layer (car topLayerImp)
				     ?fromObj layer2Rect
				     ?size (cadr topLayerImp)
				     ))
	      )
     )

   (setq isLayer1 nil)
   )
 )



(tfcDefineDeviceClassProp
;;(viewName       devClassName      propName          propValue)
;;;-------------------------------------------------------------------
 (symbolic        simpleContactClass    function          "contact")
)
;;; 
;;; $Id: mExtDrainTranClass.il,v 1.4 2005/12/15 20:25:00 kuc Exp $
;;; 
;;; mExtDrainTranClass.il
;;; 
;;; Copyright (c) 2005 by Cypress Semiconductor
;;; Cypress Kentucky CAD Center (KYCC)
;;; 
;;; Date  : Dec 02, 2005
;;; Author: Kungyen Chang (kuc) @ KYCC
;;; 
;;; Description:
;;;   This is the class for the extended drain pcell.
;;;
;;; Revision History:
;;;   kuc 12/02/05  initial version 
;;;   kuc 12/09/05  modified to have scalable l
;;;   kuc 12/15/05  added hvi implant, shared source width
;;; 


(tcCreateDeviceClass
 "symbolic" "mExtDrainTranClass"
 ;;; Class parameters
 (
  (srcLayer       "hilite")
  (srcImplant     nil)
  (srcImplantEnc 0.0)
  (drnLayer       "hilite")
  (drnImplant     nil)
  (drnImplantEnc 0.0)
  (gateLayer      "hilite")
  (drainWell      "hilite")
  (dnWell      nil)
  (nwellEncDnwell 0.0)
  (dnwellEncNwell 0.0)
  (wellEncSrc  0.0)
  (wellEncDrn  0.0)
  (pFet        "FALSE")
  (via0Layer  "hilite")
  (via0Width  0.0)
  (met0Layer  "hilite")
  (via1Layer  "hilite")
  (via1Width  0.0)
  (met1Layer  "hilite")
  (hviLayer   "hilite")
  (hviEnc     0.0)
  (snapGrid   0.0)
  
  (minEncVia0SrcX 0.0)
  (minEncVia0SrcY 0.0)   
  (minEncVia0DrnX 0.0)
  (minEncVia0DrnY 0.0)  
  (via0MinSpace 0.0)
  (met0EncVia0X 0.0)
  (met0EncVia0Y 0.0)
  (met0EncVia1X 0.00)
  (met0EncVia1Y 0.00)
  (via1MinSpace 0.0)
  (met1EncVia1X 0.0)
  (met1EncVia1Y 0.0)
  (idLayer        nil)
  (wellEncDrain   0.0)
  (minSpaceSrcDrn 0.0)
  (minDrnWidth    0.0)
  (wellBevel  0.0)
  (wellExtHole 0.0)
  (drnBevel 0.0)
  (srcExtFromPoly 0.0)
  (polyExtSource 0.0)
  (minSpaceSrcOverWell 0.0)
  (minSpaceEndTapDrain 0.0)
  (minSpaceEndTapSource 0.0)
  (endTapLayer "hilite")
  (endTapWidth  0.0)
  (endTapImplant nil)
  (endTapImpEnc 0.0)
  (wellEncDiffTap 0.0)
  (wellEncTap 0.0)
  (sharedSrcWidth 0.0)
 )
 ;;; Formal parameters
 (
  (m            1)
  (l            0.0)
  (w            0.0)
  (gateExt        0.0)
  (contacts "no contacts")
  (endTaps  "FALSE")
 )
 
 ;;; The schematic transistor can have an mfactor of 0.
 ;;; It will be enforced to a minimum of 1.
 (setq m             (max 1 m))
 

 (setq srcUnderPoly (plus l minSpaceSrcOverWell)) ;; l is actually the source under poly
 (setq l (plus srcUnderPoly polyExtSource)) ;; the l used in the code is the poly l
 
 (if (nequal contacts "no contacts")
     then
   (setq srcExtFromPoly (max srcExtFromPoly
			     (plus (times 2 minEncVia0SrcX) via0Width)
			     ))
   (setq minDrnWidth (max minDrnWidth
			     (plus (times 2 minEncVia0DrnX) via0Width)
			     ))
   (setq endTapWidth (max endTapWidth (plus (times 2 minEncVia0DrnX) via0Width)
			  ))
   )

 (for n 1 m


      (if ((equal n 1) || ((equal n m) && (equal (mod m 2) 0))) then
	(setq srcExtWidth srcExtFromPoly)
	else
	(setq srcExtWidth sharedSrcWidth)
	)

     ;; Draw gate of fet including extensions
      (setq gateDrawing (rodCreateRect
			 ?layer gateLayer
			 ?width l
			 ?length (plus (times 2 gateExt) w)
			 ?pin t
			 ?termName "G"
			 ?termIOType "input"
			 ?pinAccessDir (list "top" "bottom")
			 ))
      (if (equal n 1)
	  then
	(setq gateDrawingPrev gateDrawing)
	)
      
      (if (nequal n 1)
	  then
	(if (equal (mod n 2) 0)
	    then
	  (rodAlign
	   ?alignObj gateDrawing
	   ?alignHandle "cL"
	   ?refObj gateDrawingPrev
	   ?refHandle "cR"
	   ?xSep (plus (times 2 (difference minSpaceSrcDrn (difference l srcUnderPoly))) minDrnWidth)
	   )
	  else
	  (rodAlign
	   ?alignObj gateDrawing
	   ?alignHandle "cL"
	   ?refObj gateDrawingPrev
	   ?refHandle "cR"
	   ?xSep srcExtWidth
	   )
	  )
	)
      
      ;; Create source
      
      (setq sourceDiff (rodCreateRect
			?layer srcLayer
			?width (plus srcExtWidth srcUnderPoly)
			?length w
			))
      (if (nequal srcImplant nil)
	  then
	(setq sourceImplant (rodCreateRect
			     ?layer srcImplant
			     ?width (plus srcExtWidth srcUnderPoly (times 2 srcImplantEnc))
			     ?length (plus w (times 2 srcImplantEnc))
			     ))
	(rodAlign
	 ?alignObj sourceImplant
	 ?alignHandle "cC"
	 ?refObj sourceDiff
	 ?refHandle "cC"
	 )
	)
      (if (equal (mod n 2) 1)
	  then
	(rodAlign
	 ?alignObj sourceDiff
	 ?alignHandle "cL"
	 ?refObj gateDrawing
	 ?refHandle "cL"
	 ?xSep (minus srcExtWidth)
	 )
	(if (equal n 1) then
	  (setq firstPoly sourceDiff)
	  )
	(if (equal contacts "no contacts")
	    then
	  (setq sourcePin (rodCreateRect
			   ?layer srcLayer
			   ?width srcExtWidth
			   ?length w
			   ?pin t
			   ?termName "S"
			   ?termIOType "inputOutput"
			   ?pinAccessDir (list "top" "bottom")
			   ?pinLabel t
			   ?pinLabelHeight 0.1
			   ?pinLabelLayer (list "text" "drawing")
			   ?pinLabelFont "roman"
			   ))
	  (rodAlign
	   ?alignObj sourcePin
	   ?alignHandle "cL"
	   ?refObj sourceDiff
	   ?refHandle "cL"
	   )
	  )
	else
	(rodAlign
	 ?alignObj sourceDiff
	 ?alignHandle "cR"
	 ?refObj gateDrawing
	 ?refHandle "cL"
	 ?xSep (plus srcExtWidth l)
	 )
	(if (equal n m) then
	  (setq lastPoly sourceDiff)
	  )
	(if (equal contacts "no contacts")
	    then
	  (setq sourcePin (rodCreateRect
			   ?layer srcLayer
			   ?width srcExtWidth
			   ?length w
			   ?pin t
			   ?termName "S"
			   ?termIOType "inputOutput"
			   ?pinAccessDir (list "top" "bottom")
			   ?pinLabel t
			   ?pinLabelHeight 0.1
			   ?pinLabelLayer (list "text" "drawing")
			   ?pinLabelFont "roman"
			   ))
	  (rodAlign
	   ?alignObj sourcePin
	   ?alignHandle "cR"
	   ?refObj sourceDiff
	   ?refHandle "cR"
	   )
	  )
	)

      ;; Create well extending out from source if first
      
      (if ((equal n 1) && (equal pFet t))
	  then
	  (setq wellWidth (max nwellEncDnwell (plus nwellEncDnwell (difference dnwellEncNwell (plus srcExtWidth (difference srcUnderPoly minSpaceSrcOverWell))))))
	  
	  (setq nwellExtSource (rodCreateRect
				?layer drainWell
				?width wellWidth
				?length (plus w (times 2 (plus wellEncDrain nwellEncDnwell dnwellEncNwell)))
				))
	  (rodAlign
	   ?alignObj nwellExtSource
	   ?alignHandle "cR"
	   ?refObj sourceDiff
	   ?refHandle "cL"
	   )
	  (setq firstPoly nwellExtSource)

	  (if (nequal dnWell nil)
	      then
	    (setq dnwellWidth (difference dnwellEncNwell (plus srcExtWidth (difference srcUnderPoly minSpaceSrcOverWell))))
	    (if (dnwellWidth>0)
		then
	      (setq dnwellExtSource (rodCreateRect
				     ?layer dnWell
				     ?width dnwellWidth
				     ?length (plus w (times 2 (plus wellEncDrain dnwellEncNwell)))
				     ))
	      (rodAlign
	       ?alignObj dnwellExtSource
	       ?alignHandle "cR"
	       ?refObj sourceDiff
	       ?refHandle "cL"
	       )
	      )
	    )
	  )
      ;; Create well for extended drain
      (if (equal pFet nil)
	  then
	(if ((equal (mod n 2) 1) && (equal n m))
	    then
	  (setq bevelDrainWell (rodCreatePolygon
				?layer drainWell
				    ?pts (list (list wellBevel 0.0) 
					       (list (difference (plus wellEncDrain minSpaceSrcDrn minDrnWidth minSpaceSrcOverWell) wellBevel) 0.0)
					       (list (plus wellEncDrain minSpaceSrcDrn minDrnWidth minSpaceSrcOverWell) wellBevel)
					       (list (plus wellEncDrain minSpaceSrcDrn minDrnWidth minSpaceSrcOverWell) (difference (plus (times 2 wellEncDrain) w) wellBevel))
					       (list (difference (plus wellEncDrain minSpaceSrcDrn minDrnWidth minSpaceSrcOverWell) wellBevel) (plus (times 2 wellEncDrain) w))
					       (list wellBevel (plus (times 2 wellEncDrain) w) )
					       (list 0.0 (difference (plus (times 2 wellEncDrain) w) wellBevel))
					       (list 0.0 wellBevel)
					       )
				    ))
	 (rodAlign
	  ?alignObj bevelDrainWell
	  ?alignHandle "cL"
	  ?refObj sourceDiff
	  ?refHandle "cR"
	  ?xSep (minus minSpaceSrcOverWell)
	  )
	 (setq lastPoly bevelDrainWell)
	 else
	 (setq bevelDrainWell (rodCreatePolygon
			       ?layer drainWell
			       ?pts (list (list wellBevel 0.0) 
					  (list (difference (plus (times 2 minSpaceSrcDrn) minDrnWidth (times 2 minSpaceSrcOverWell)) wellBevel) 0.0)
					  (list (plus (times 2 minSpaceSrcDrn) minDrnWidth (times 2 minSpaceSrcOverWell)) wellBevel)
					  (list (plus (times 2 minSpaceSrcDrn) minDrnWidth (times 2 minSpaceSrcOverWell)) (difference (plus (times 2 wellEncDrain) w) wellBevel))
					  (list (difference (plus (times 2 minSpaceSrcDrn) minDrnWidth (times 2 minSpaceSrcOverWell)) wellBevel) (plus (times 2 wellEncDrain) w))
					  (list wellBevel (plus (times 2 wellEncDrain) w))
					  (list 0.0 (difference (plus (times 2 wellEncDrain) w) wellBevel))
					  (list 0.0 wellBevel)
					  )
			       ))
	 (if (equal (mod n 2) 1)
	     then
	   (rodAlign
	    ?alignObj bevelDrainWell
	    ?alignHandle "cL"
	    ?refObj sourceDiff
	    ?refHandle "cR"
	    ?xSep (minus minSpaceSrcOverWell)
	    )
	   else
	   (rodAlign
	    ?alignObj bevelDrainWell
	    ?alignHandle "cR"
	    ?refObj sourceDiff
	    ?refHandle "cL"
	    ?xSep minSpaceSrcOverWell
	    )
	   )
	 )
       else
       (setq cornerOfWellX (difference (plus srcExtWidth srcUnderPoly) minSpaceSrcOverWell))
       (if ((equal n m) && (equal (mod m 2) 1))
	   then
	 (setq wellWidth (plus minSpaceSrcDrn minDrnWidth wellEncDrain minSpaceSrcOverWell))
	 else
	 (setq wellWidth (plus (times 2 (plus minSpaceSrcDrn minSpaceSrcOverWell)) minDrnWidth))
	 )
	(if (equal (mod n 2) 1)
	    then 
	  (setq pFetDrainWell (rodCreatePolygon
			       ?layer drainWell
			       ?pts (list (list 0.0  (plus w wellEncDrain dnwellEncNwell nwellEncDnwell))
					  (list (plus cornerOfWellX wellWidth nwellEncDnwell wellExtHole)
						(plus w wellEncDrain nwellEncDnwell dnwellEncNwell))
					  (list (plus cornerOfWellX  wellWidth nwellEncDnwell wellExtHole)
						(difference 0 wellEncDrain nwellEncDnwell dnwellEncNwell))
					  (list 0.0 (difference 0 wellEncDrain nwellEncDnwell dnwellEncNwell))
					  (list 0.0 (difference wellBevel wellEncDrain))
					  
					  (list  cornerOfWellX (difference wellBevel wellEncDrain))
					  (list  (plus cornerOfWellX wellBevel) (minus wellEncDrain))
					  (list  (difference (plus cornerOfWellX wellWidth) wellBevel) (minus wellEncDrain))
					  (list  (plus cornerOfWellX wellWidth) (difference wellBevel wellEncDrain))
					  (list  (plus cornerOfWellX wellWidth) (plus (difference w wellBevel) wellEncDrain))
					  (list  (difference (plus cornerOfWellX wellWidth) wellBevel) (plus w wellEncDrain))
					  (list  (plus cornerOfWellX wellBevel) (plus wellEncDrain w))
					  (list  cornerOfWellX (plus (difference w wellBevel) wellEncDrain))
					  
					  (list cornerOfWellX (difference wellBevel wellEncDrain))
					  (list 0.0 (difference wellBevel wellEncDrain))
					  )
			       ))
	  else
	  (setq pFetDrainWell (rodCreatePolygon
			       ?layer drainWell
			       ?pts (list (list 0.0  (plus w wellEncDrain nwellEncDnwell dnwellEncNwell))
					  (list (minus (plus cornerOfWellX wellWidth  wellExtHole nwellEncDnwell))
						(plus w wellEncDrain nwellEncDnwell dnwellEncNwell))
					  (list (minus (plus cornerOfWellX  wellWidth wellExtHole nwellEncDnwell))
						(difference 0 wellEncDrain nwellEncDnwell dnwellEncNwell))
					  (list 0.0 (difference 0 wellEncDrain nwellEncDnwell dnwellEncNwell))
					  (list 0.0 (difference wellBevel wellEncDrain))
					  
					  (list  (minus cornerOfWellX) (difference wellBevel wellEncDrain))
					  (list  (minus (plus cornerOfWellX wellBevel)) (minus wellEncDrain))
					  (list  (minus (difference (plus cornerOfWellX wellWidth) wellBevel)) (minus wellEncDrain))
					  (list  (minus (plus cornerOfWellX wellWidth)) (difference wellBevel wellEncDrain))
					  (list  (minus (plus cornerOfWellX wellWidth)) (plus (difference w wellBevel) wellEncDrain))
					  (list  (minus (difference (plus cornerOfWellX wellWidth) wellBevel)) (plus w wellEncDrain))
					  (list  (minus (plus cornerOfWellX wellBevel)) (plus wellEncDrain w))
					  (list  (minus cornerOfWellX) (plus (difference w wellBevel) wellEncDrain))
					  
					  (list (minus cornerOfWellX) (difference wellBevel wellEncDrain))
					  (list 0.0 (difference wellBevel wellEncDrain))
					  )
			       ))

	  )
	 (if ((equal n m) && (equal (mod m 2) 1))
	     then
	   (rodAlign
	    ?alignObj pFetDrainWell
	    ?alignHandle "cL"
	    ?refObj sourceDiff
	    ?refHandle "cL"
	    )
	   else
	   (if (equal (mod n 2) 1)
	       then
	     (rodAlign
	      ?alignObj pFetDrainWell
	      ?alignHandle "cL"
	      ?refObj sourceDiff
	      ?refHandle "cL"
	      )
	     else
	     (rodAlign
	      ?alignObj pFetDrainWell
	      ?alignHandle "cR"
	      ?refObj sourceDiff
	      ?refHandle "cR"
	      )
	     )
	   )
	 (if dnWell
	     then
	   (if (equal (mod n 2) 0)
	       then
	     (setq pFetDnWell (rodCreateRect
			       ?layer dnWell
			       ?width (plus cornerOfWellX wellWidth)
			       ?length (plus w (times 2 (plus wellEncDrain dnwellEncNwell)))
			       ))
	     else
	     (setq pFetDnWell (rodCreateRect
			       ?layer dnWell
			       ?width (plus cornerOfWellX wellWidth dnwellEncNwell)
			       ?length (plus w (times 2 (plus wellEncDrain dnwellEncNwell)))
			       ))
	     )
	   (if (equal (mod n 2) 0)
	       then
	     (rodAlign
	      ?alignObj pFetDnWell
	      ?alignHandle "cR"
	      ?refObj pFetDrainWell
	      ?refHandle "cR"
	      )
	     else
	     (rodAlign
	      ?alignObj pFetDnWell
	      ?alignHandle "cL"
	      ?refObj pFetDrainWell
	      ?refHandle "cL"
	      )
	     )
	   )
	 )
     ;; Create extended drain tap
     (setq extendedDrain (rodCreatePolygon
			  ?layer drnLayer
			  ?pts (list (list drnBevel 0.0) 
				     (list (difference minDrnWidth drnBevel) 0.0)
				     (list minDrnWidth drnBevel)
				     (list minDrnWidth (difference w drnBevel))
				     (list (difference minDrnWidth drnBevel) w)
				     (list drnBevel w)
				     (list 0.0 (difference w drnBevel))
				     (list 0.0 drnBevel)
				     )
			  ?pin (eval (equal contacts "no contacts"))
			  ?termName "D"
			  ?termIOType "inputOutput"
			  ?pinAccessDir (list "top" "bottom")
			  ?pinLabel t
			  ?pinLabelHeight 0.1
			  ?pinLabelLayer (list "text" "drawing")
			  ?pinLabelFont "roman"
			  ))
     (if (equal (mod n 2) 1)
	 then
       (rodAlign
	?alignObj extendedDrain
	?alignHandle "cL"
	?refObj sourceDiff
	?refHandle "cR"
	?xSep minSpaceSrcDrn
	)
       else
       (rodAlign
	?alignObj extendedDrain
	?alignHandle "cR"
	?refObj sourceDiff
	?refHandle "cL"
	?xSep (minus minSpaceSrcDrn)
	)
       )

     ;; Create source contacts

     (if (nequal contacts "no contacts")
	 then
       (setq numContacts (floor (quotient w via0Width)))
       (while (plus (times 2 minEncVia0SrcY) (times numContacts via0Width) (times (difference numContacts 1) via0MinSpace)) > w
	      (setq numContacts (difference numContacts 1))
	      )
       (setq numContactsW (floor (quotient srcExtWidth via0Width)))
       (while (plus (times 2 minEncVia0SrcX) (times numContactsW via0Width) (times (difference numContactsW 1) via0MinSpace)) > (plus snapGrid srcExtWidth)
	      (setq numContactsW (difference numContactsW 1))
	      )
        (setq via0Contacts (rodCreateRect
			   ?layer met0Layer
			   ?width  (plus (times 2 met0EncVia0X)
					 (times (difference numContactsW 1) via0MinSpace)
						(times numContactsW via0Width))
			   ?length (plus (times 2 (max minEncVia0SrcY met0EncVia0Y))
					 (times (difference numContacts 1) via0MinSpace)
					 (times numContacts via0Width))
			   ?subRectArray
			   (list (list ?layer via0Layer
				       ?width via0Width
				       ?length via0Width
				       ?spaceY via0MinSpace
				       ?spaceX via0MinSpace
				       ?lowerLeftOffsetY  met0EncVia0Y
				       ?upperRightOffsetY (minus met0EncVia0Y)
				       ?lowerLeftOffsetX  met0EncVia0X
				       ?upperRightOffsetX (minus met0EncVia0X)
				       ?gap "minimum"
				       ))
			   ?pin (eval (equal contacts "first metal"))
			   ?termName "S"
			   ?termIOType "inputOutput"
			   ?pinAccessDir (list "top" "bottom")
			   ?pinLabel t
			   ?pinLabelHeight 0.1
			   ?pinLabelLayer (list "text" "drawing")
			   ?pinLabelFont "roman"
			   ))
       (if (equal (mod n 2) 1)
	   then
	 (rodAlign
	  ?alignObj via0Contacts
	  ?alignHandle "cC"
	  ?refObj sourceDiff
	  ?refHandle "cL"
	  ?xSep (max (quotient srcExtWidth 2)
		      minEncVia0SrcX)
	  )
	 else
	 (rodAlign 
	  ?alignObj via0Contacts
	  ?alignHandle "cC"
	  ?refObj sourceDiff
	  ?refHandle "cR"
	  ?xSep (minus (max (quotient srcExtWidth 2)
		      minEncVia0SrcX))
	  )
	 )

       (if (equal contacts "second metal")
	   then
	 (setq numContacts (floor (quotient w via1Width)))
	 (while (plus (times numContacts via1Width) (times (difference numContacts 1) via1MinSpace)) > w
		(setq numContacts (difference numContacts 1))
	      )
	 (setq numContactsW (floor (quotient srcExtWidth via0Width)))
	 (while (plus (times 2 met1EncVia1X) (times numContactsW via1Width) (times (difference numContactsW 1) via1MinSpace)) > (plus snapGrid srcExtWidth)
		(setq numContactsW (difference numContactsW 1))
		)

	 (setq met0EncVia1 (rodCreateRect
			    ?layer met0Layer
			    ?width (plus (times (difference numContactsW 1) via1MinSpace) 
					 (times numContactsW via1Width)
					 (times 2 (max met1EncVia1X met0EncVia1X)))
			    ?length (plus (times (difference numContacts 1) via1MinSpace) 
					  (times numContacts via1Width)
					  (times 2 (max met1EncVia1Y met0EncVia1Y)))
			    ))
	 (rodAlign
	  ?alignObj met0EncVia1
	  ?alignHandle "cC"
	  ?refObj via0Contacts
	  ?refHandle "cC"
	  )
	 (setq via1Contacts (rodCreateRect
			   ?layer met1Layer
			   ?width (plus (times 2 (max met0EncVia1X met1EncVia1X))
					 (times (difference numContactsW 1) via1MinSpace) 
					 (times numContactsW via1Width))
			   ?length (plus (times 2 (max met0EncVia1Y met1EncVia1Y))
					 (times (difference numContacts 1) via1MinSpace) 
					 (times numContacts via1Width))
			   ?subRectArray
			   (list (list ?layer via1Layer
				       ?width via1Width
				       ?length via1Width
				       ?spaceY via1MinSpace
				       ?spaceX via1MinSpace
				       ?lowerLeftOffsetY (max met0EncVia1Y met1EncVia1Y)
				       ?upperRightOffsetY (minus (max met0EncVia1Y met1EncVia1Y))
				       ?lowerLeftOffsetX (max met0EncVia1X met1EncVia1X)
				       ?upperRightOffsetX (minus (max met0EncVia1X met1EncVia1X))
				       ?gap "minimum"
				       ))
			   ?pin t
			   ?termName "S"
			   ?termIOType "inputOutput"
			   ?pinAccessDir (list "top" "bottom")
			   ?pinLabel t
			   ?pinLabelHeight 0.1
			   ?pinLabelLayer (list "text" "drawing")
			   ?pinLabelFont "roman"
			   ))
	 (rodAlign
	  ?alignObj via1Contacts
	  ?alignHandle "cC"
	  ?refObj met0EncVia1
	  ?refHandle "cC"
	  )	 
	 )
       )				    

     ;; Create drain implant

     (if (nequal drnImplant nil)
	 then
       (setq bevelDrainImplant (rodCreatePolygon
				?layer drnImplant
				?pts (list (list (difference drnBevel drnImplantEnc) (minus drnImplantEnc)) 
					   (list (difference (plus drnImplantEnc minDrnWidth) drnBevel) (minus drnImplantEnc))
					   (list (plus drnImplantEnc minDrnWidth) (difference drnBevel drnImplantEnc))
					   (list (plus drnImplantEnc minDrnWidth) (difference (plus drnImplantEnc w) drnBevel))
					   (list (difference (plus drnImplantEnc minDrnWidth) drnBevel) (plus drnImplantEnc w))
					   (list (difference drnBevel drnImplantEnc) (plus drnImplantEnc w))
					   (list (minus drnImplantEnc) (difference (plus drnImplantEnc w) drnBevel))
					   (list (minus drnImplantEnc) (difference drnBevel drnImplantEnc))
					   )
			))
       (rodAlign
	?alignObj bevelDrainImplant
	?alignHandle "cC"
	?refObj extendedDrain
	?refHandle "cC"
	)
       )


     ;; Create well extending out from source/drain if last
     
     (if ((equal n m) && (equal pFet t))
	 then
       (if (equal (mod m 2) 0)
	   then
	 (setq nwellExtLast (rodCreateRect
			     ?layer drainWell
			     ?width (max wellEncSrc nwellEncDnwell (plus (difference dnwellEncNwell srcExtWidth srcUnderPoly) minSpaceSrcOverWell nwellEncDnwell))
			     ?length (plus w (times 2 (plus wellEncDrain nwellEncDnwell dnwellEncNwell)))
			     ))
	 (rodAlign
	  ?alignObj nwellExtLast
	  ?alignHandle "cL"
	  ?refObj sourceDiff
	  ?refHandle "cR"
	  )
	 (setq lastPoly nwellExtLast)
	 else
	 (setq nwellExtLast (rodCreateRect
			     ?layer drainWell
			     ?width (plus dnwellEncNwell nwellEncDnwell)
			     ?length (plus w (times 2 (plus wellEncDrain nwellEncDnwell dnwellEncNwell)))
			     ))
	 (rodAlign
	  ?alignObj nwellExtLast
	  ?alignHandle "cL"
	  ?refObj extendedDrain
	  ?refHandle "cR"
	  ?xSep wellEncDrain
	  )
	 (setq lastPoly nwellExtLast)
	 )	  
       )
     
     ;; Create drain contacts

     (if (nequal contacts "no contacts")
	 then
       (setq numContacts (floor (quotient w via0Width)))
       (while (plus (times 2 minEncVia0DrnY) (times numContacts via0Width) (times (difference numContacts 1) via0MinSpace)) > (difference w (times 2 drnBevel))
	      (setq numContacts (difference numContacts 1))
	      )
       (setq numContactsW (floor (quotient minDrnWidth via0Width)))
       (while (plus (times 2 minEncVia0DrnX) (times numContactsW via0Width) (times (difference numContactsW 1) via0MinSpace)) >  minDrnWidth
	      (setq numContactsW (difference numContactsW 1))
	      )
       (setq via0Contacts (rodCreateRect
			   ?layer met0Layer
			   ?width (plus (times 2 met0EncVia0X)
					 (plus (times (difference numContactsW 1) via0MinSpace) 
					       (times numContactsW via0Width)))
			   ?length (plus (times 2 (max minEncVia0SrcY met0EncVia0Y))
					 (plus (times (difference numContacts 1) via0MinSpace) 
					       (times numContacts via0Width)))
			   ?subRectArray
			   (list (list ?layer via0Layer
				       ?width via0Width
				       ?length via0Width
				       ?spaceY via0MinSpace
				       ?spaceX via0MinSpace
				       ?lowerLeftOffsetY  met0EncVia0Y
				       ?upperRightOffsetY (minus met0EncVia0Y)
				       ?lowerLeftOffsetX met0EncVia0X
				       ?upperRightOffsetX (minus met0EncVia0X)
				       ?gap "minimum"
				       ))
			   ?pin (eval (equal contacts "first metal"))
			   ?termName "D"
			   ?termIOType "inputOutput"
			   ?pinAccessDir (list "top" "bottom")
			   ?pinLabel t
			   ?pinLabelHeight 0.1
			   ?pinLabelLayer (list "text" "drawing")
			   ?pinLabelFont "roman"
			   ))
       (rodAlign
	?alignObj via0Contacts
	?alignHandle "cC"
	?refObj extendedDrain
	?refHandle "cC"
	)

       (if (equal contacts "second metal")
	   then
	 (setq numContacts (floor (quotient w via1Width)))
	 (while (plus (times numContacts via1Width) (times (difference numContacts 1) via1MinSpace)) > w
	      (setq numContacts (difference numContacts 1))
	      )
	 (setq numContactsW (floor (quotient minDrnWidth via1Width)))
	 (while (plus (times numContactsW via1Width) (times (difference numContactsW 1) via1MinSpace)) > minDrnWidth
	      (setq numContactsW (difference numContactsW 1))
	      )
	 (setq met0EncVia1 (rodCreateRect
			    ?layer met0Layer
			    ?width (plus (max (times 2 met1EncVia1X) (times 2 met0EncVia1X))
					  (times (difference numContactsW 1) via1MinSpace) 
					  (times numContactsW via1Width))
			    ?length (plus (max (times 2 met0EncVia1Y) (times 2 met1EncVia1Y))
					  (times (difference numContacts 1) via1MinSpace) 
					  (times numContacts via1Width))
			    ))
	 (rodAlign
	  ?alignObj met0EncVia1
	  ?alignHandle "cC"
	  ?refObj via0Contacts
	  ?refHandle "cC"
	  )
	 (setq via1Contacts (rodCreateRect
			   ?layer met1Layer
			   ?width (plus (times 2 (max met1EncVia1X met0EncVia1X))
					 (times (difference numContactsW 1) via1MinSpace) 
					 (times numContactsW via1Width))
			   ?length (plus (times 2 (max met0EncVia1Y met1EncVia1Y))
					 (times (difference numContacts 1) via1MinSpace) 
					 (times numContacts via1Width))
			   ?subRectArray
			   (list (list ?layer via1Layer
				       ?width via1Width
				       ?length via1Width
				       ?spaceY via1MinSpace
				       ?spaceX via1MinSpace
				       ?lowerLeftOffsetY (max met0EncVia1Y met1EncVia1Y)
				       ?upperRightOffsetY (minus (max met0EncVia1Y met1EncVia1Y))
				       ?lowerLeftOffsetX (max met1EncVia1X met0EncVia1X)
				       ?upperRightOffsetX (minus (max met1EncVia1X met0EncVia1X))
				       ?gap "minimum"
				       ))
			   ?pin t
			   ?termName "D"
			   ?termIOType "inputOutput"
			   ?pinAccessDir (list "top" "bottom")
			   ?pinLabel t
			   ?pinLabelHeight 0.1
			   ?pinLabelLayer (list "text" "drawing")
			   ?pinLabelFont "roman"
			   ))
	 (rodAlign
	  ?alignObj via1Contacts
	  ?alignHandle "cC"
	  ?refObj met0EncVia1
	  ?refHandle "cC"
	  )	 
	 )
       )				    

     ;; Create id layer
     
     (if (nequal idLayer nil)
	 then
       (setq idRect (rodCreateRect
		     ?layer idLayer
		     ?fromObj (list sourceDiff extendedDrain)
		     ))
       (if (equal (mod n 2) 1)
	   then
	 (rodAlign
	  ?alignObj idRect
	  ?alignHandle "cR"
	  ?refObj extendedDrain
	  ?refHandle "cR"
	  )
	 else
	 (rodAlign
	  ?alignObj idRect
	  ?alignHandle "cL"
	  ?refObj extendedDrain
	  ?refHandle "cL"
	  )	 
	 )
       )

     ;; Draws tap if endTaps is on and this is the first iteration or the last

     (if (equal m 1)
	 then
       (setq runTwice 2)
       else
       (setq runTwice 1)
       )
     (for runs 1 runTwice
	  (if ((equal endTaps "TRUE") && ((equal n 1) || (equal n m)))
	      then
	    (setq endTap (rodCreateRect
			  ?layer endTapLayer
			  ?width endTapWidth
			  ?length w
			  ?pin (eval (equal contacts "no contacts"))
			  ?termName "B"
			  ?termIOType "input"
			  ?pinAccessDir (list "top" "bottom")
			  ?pinLabel t
			  ?pinLabelHeight 0.1
			  ?pinLabelLayer (list "text" "drawing")
			  ?pinLabelFont "roman"
			  ))
	    (if (nequal endTapImplant nil)
		then
	      (setq tapImplant (rodCreateRect
				?layer endTapImplant
				?fromObj endTap
				?size endTapImpEnc
				))
	      (rodAlign
	       ?alignObj tapImplant
	       ?alignHandle "cC"
	       ?refObj endTap
	       ?refHandle "cC"
	       )
	      )
	    (if ((equal n 1) && (equal runs 1))
		then
	      (rodAlign
	       ?alignObj endTap
	       ?alignHandle "cR"
	       ?refObj sourceDiff
	       ?refHandle "cL"
	       ?xSep (minus minSpaceEndTapSource)
	       )
	      (if (equal pFet t)
		  then
		(setq firstTapNwell (rodCreateRect
				     ?layer drainWell
				     ?length (plus w (times 2 (plus wellEncDrain nwellEncDnwell dnwellEncNwell)))
				     ?width (plus wellEncTap endTapWidth minSpaceEndTapSource)
				     ))
		(rodAlign
		 ?alignObj firstTapNwell
		 ?alignHandle "cL"
		 ?refObj endTap
		 ?refHandle "cL"
		 ?xSep (minus (max nwellEncDnwell wellEncTap))
		 )
		(if (nequal dnWell nil)
		    then
		  (setq firstTapDnwell (rodCreateRect
					?layer dnWell
					?length (plus w (times 2 (plus wellEncDrain dnwellEncNwell)))
					?width (plus endTapWidth minSpaceEndTapSource)
					))
		  (rodAlign
		   ?alignObj firstTapDnwell
		   ?alignHandle "cL"
		   ?refObj firstTapNwell
		   ?refHandle "cL"
		   ?xSep nwellEncDnwell
		   )
		  )
		else
		(setq firstPoly endTap)
		)
	      else
	      (if ((equal (mod m 2) 1) || (equal runs 2))
		  then
		(rodAlign
		 ?alignObj endTap
		 ?alignHandle "cL"
		 ?refObj extendedDrain
		 ?refHandle "cR"
		 ?xSep minSpaceEndTapDrain
		 )
		(if (equal pFet t)
		    then
		  (setq lastTapNwell (rodCreateRect
				      ?layer drainWell
				      ?length (plus w (times 2 (plus wellEncDrain nwellEncDnwell dnwellEncNwell)))
				      ?width (plus wellEncTap endTapWidth)
				      ))
		  (rodAlign
		   ?alignObj lastTapNwell
		   ?alignHandle "cR"
		   ?refObj endTap
		   ?refHandle "cR"
		   ?xSep (plus wellEncTap nwellEncDnwell)
		   )
		  (if (nequal dnWell nil)
		      then
		    (setq lastTapDnwell (rodCreateRect
					 ?layer dnWell
					 ?length (plus w (times 2 (plus wellEncDrain dnwellEncNwell)))
					 ?width (plus endTapWidth minSpaceEndTapDrain)
					 ))
		    (rodAlign
		     ?alignObj lastTapDnwell
		     ?alignHandle "cR"
		     ?refObj lastTapNwell
		     ?refHandle "cR"
		     ?xSep (minus nwellEncDnwell)
		     )
		    )
		  else
		  (setq lastPoly endTap)		  
		  )
		else
		(rodAlign
		 ?alignObj endTap
		 ?alignHandle "cL"
		 ?refObj sourceDiff
		 ?refHandle "cR"
		 ?xSep minSpaceEndTapSource
		 )
		(if (equal pFet t)
		    then
		  (setq lastTapNwell (rodCreateRect
				      ?layer drainWell
				      ?length (plus w (times 2 (plus wellEncDrain nwellEncDnwell dnwellEncNwell)))
				      ?width (plus wellEncTap endTapWidth minSpaceEndTapSource)
				      ))
		  (rodAlign
		   ?alignObj lastTapNwell
		   ?alignHandle "cR"
		   ?refObj endTap
		   ?refHandle "cR"
		   ?xSep (max wellEncTap nwellEncDnwell)
		   )
		  (if (nequal dnWell nil)
		      then
		    (setq lastTapDnwell (rodCreateRect
				    ?layer dnWell
				    ?length (plus w (times 2 (plus wellEncDrain dnwellEncNwell)))
				    ?width (plus endTapWidth minSpaceEndTapSource)
				    ))
		    (rodAlign
		     ?alignObj lastTapDnwell
		     ?alignHandle "cR"
		     ?refObj lastTapNwell
		     ?refHandle "cR"
		     ?xSep (minus nwellEncDnwell)
		     )
		    )
		  else
		  (setq lastPoly endTap)
		  )
		)
	      )
	    
	    
	    
	    (if (nequal contacts "no contacts")
		then
	      (setq numContacts (floor (quotient w via0Width)))
	      (while (plus (times 2 minEncVia0DrnY) (times numContacts via0Width) (times (difference numContacts 1) via0MinSpace)) >  w
		     (setq numContacts (difference numContacts 1))
		     )
	      (setq numContactsW (floor (quotient minDrnWidth via0Width)))
	      (while (plus (times 2 minEncVia0DrnX) (times numContactsW via0Width) (times (difference numContactsW 1) via0MinSpace)) > endTapWidth
		     (setq numContactsW (difference numContactsW 1))
		     )
	      (setq via0Contacts (rodCreateRect
				  ?layer met0Layer
				  ?width (plus (times 2 met0EncVia0X)
					       (plus (times (difference numContactsW 1) via0MinSpace) 
						     (times numContactsW via0Width)))
				  ?length (plus (times 2 met0EncVia0Y)
						(plus (times (difference numContacts 1) via0MinSpace) 
						      (times numContacts via0Width)))
				  ?subRectArray
				  (list (list ?layer via0Layer
					      ?width via0Width
					      ?length via0Width
					      ?spaceY via0MinSpace
					      ?spaceX via0MinSpace
					      ?lowerLeftOffsetY met0EncVia0Y
					      ?upperRightOffsetY (minus met0EncVia0Y)
					      ?lowerLeftOffsetX met0EncVia0X
					      ?upperRightOffsetX (minus met0EncVia0X)
					      ?gap "minimum"
					      ))
				  ?pin (eval (equal contacts "first metal"))
				  ?termName "B"
				  ?termIOType "input"
				  ?pinAccessDir (list "top" "bottom")
				  ?pinLabel t
				  ?pinLabelHeight 0.1
				  ?pinLabelLayer (list "text" "drawing")
				  ?pinLabelFont "roman"
			       ))
	      (rodAlign
	       ?alignObj via0Contacts
	       ?alignHandle "cC"
	       ?refObj endTap
	       ?refHandle "cC"
	       )
	      
	      (if (equal contacts "second metal")
	       then
	       (setq numContacts (floor (quotient w via1Width)))
	       (while (plus (times numContacts via1Width) (times (difference numContacts 1) via1MinSpace)) > w
		    (setq numContacts (difference numContacts 1))
		    )
	       (setq numContactsW (floor (quotient minDrnWidth via1Width)))
	       (while (plus (times numContactsW via1Width) (times (difference numContactsW 1) via1MinSpace)) > endTapWidth
		      (setq numContactsW (difference numContactsW 1))
		      )
	       (setq met0EncVia1 (rodCreateRect
				  ?layer met0Layer
				  ?width (plus (times 2 met1EncVia1X)
					       (times (difference numContactsW 1) via1MinSpace) 
					       (times numContactsW via1Width)
					       (times 2 met0EncVia1X))
				  ?length (plus (times 2 met1EncVia1Y)
						(times (difference numContacts 1) via1MinSpace) 
						(times numContacts via1Width)
						(times 2 met0EncVia1Y))
				  ))
	       (rodAlign
		?alignObj met0EncVia1
		?alignHandle "cC"
		?refObj via0Contacts
		?refHandle "cC"
		)
	       (setq via1Contacts (rodCreateRect
				   ?layer met1Layer
				   ?width (plus (times 2 met1EncVia1X)
						(times (difference numContactsW 1) via1MinSpace) 
						(times numContactsW via1Width))
				   ?length (plus (times 2 met1EncVia1Y)
						 (times (difference numContacts 1) via1MinSpace) 
						 (times numContacts via1Width))
				   ?subRectArray
				   (list (list ?layer via1Layer
					       ?width via1Width
					       ?length via1Width
					       ?spaceY via1MinSpace
					       ?spaceX via1MinSpace
					       ?lowerLeftOffsetY met1EncVia1Y
					       ?upperRightOffsetY (minus met1EncVia1Y)
					       ?lowerLeftOffsetX  met1EncVia1X
					       ?upperRightOffsetX (minus met1EncVia1X)
					       ?gap "minimum"
					       ))
				   ?pin t
				   ?termName "B"
				   ?termIOType "input"
				   ?pinAccessDir (list "top" "bottom")
				   ?pinLabel t
				   ?pinLabelHeight 0.1
				   ?pinLabelLayer (list "text" "drawing")
				   ?pinLabelFont "roman"
				   ))
	       (rodAlign
		?alignObj via1Contacts
		?alignHandle "cC"
		?refObj met0EncVia1
		?refHandle "cC"
		)	 
	       )
	      )
	    )
	  )
     
     ;; Makes the current gate the reference point for the next iteration
     
     (setq gateDrawingPrev gateDrawing)

     )
 (if (equal pFet t) then
   (setq hviImp (rodCreateRect
		 ?layer hviLayer
		 ?fromObj (list firstPoly lastPoly pFetDrainWell)
		 ?size hviEnc
		 ))
   else
   (setq hviImp (rodCreateRect
		 ?layer hviLayer
		 ?fromObj (list firstPoly lastPoly bevelDrainWell)
		 ?size hviEnc
		 ))
   )
 )

(tfcDefineDeviceClassProp
;;(viewName       devClassName      propName          propValue)
 (symbolic        mExtDrainTranClass    function          "transistor")
)

;;; 
;;; $Id: mModelFetClass.il,v 1.6 2009/08/19 13:51:43 ipr Exp $
;;; 
;;; mModelFetClass.il
;;; 
;;; Copyright (c) 2006 by Cypress Semiconductor
;;; Cypress Kentucky CAD Center (KYCC)
;;; 
;;; Date  : Jun 18, 2006
;;; Author: Bassem El-Azzami (bae) @ KYCC
;;; 
;;; Description:
;;; 
;;; Revision History:
;;;   bae 06/18/06  initial release (copied from mNormTranImpClass and
;;;                 modified to support unlimited number of idLayers)
;;;   ipr 08/17/06  Added No contact option to shared source drains 
;;;                 (SPR 32184)
;;;   ipr 08/28/06  Fixed nsdm/psdm enclosure (SPR 32590)
;;;   vun 07/18/07  added gateImplant to toggle on and off polyImplant
;;;   ipr 01/13/08  added LOD capability to pcells
;;;   ipr 02/16/08  LOD Pcell Updates (SPR 53771, 53933, 54432)
;;;   ipr 08/18/09  Added Sec Id Layer Support on S and D terminals(MVV Project)  
;;;

(tcCreateDeviceClass
 "symbolic" "mModelFetClass"

 ;;; Class parameters
 (
  (diffLayer    "hilite") ;;; diffusion layer
  (gateLayer    "marker") ;;; poly/gate layer
  (wellLayer    nil)      ;;; well layer, if nil then well is not drawn
  (wellminWidth 0.0)      ;;; the well Layer min width
  (diffExt      0.0)      ;;; extension of diff beyond poly. This is drawn 
                          ;;; for end contacts only, if the first/last 
                          ;;; contact are not specified.
  (wellEncDiff  0.0)      ;;; enclosure of diffusion by well.
  (wellEncTap   0.0)      ;;; enclosure of tap by well.
  (wellLayerWidth 0.0)
  (labelLayer  (list "text" "drawing")) ;;; layer on which labels should be 
                                        ;;; drawn, if nil labels are not drawn
  (labelWidth      0.4)   ;;; width of the label
  (diffImplant     nil)   ;;; implant layer to draw around diff
  (diffImpEnc      0.0)   ;;; enclosure of diff by implant layer
  (diffCoreImplant nil)   ;;; implant layer to draw around diff
  (diffCoreImpEnc  0.0)   ;;; enclosure of diff by implant layer
  (polyImplant     nil)   ;;; boolean to draw impant layer around poly (gate layer)
  (polyImpXEnc     0.0)   ;;; x-coordinate enclosure for poly impant
  (polyImpYEnc     0.0)   ;;; y-coordinate enclosure for poly impant
  (via1MinSpace    0.0)   ;;; first contact layer min space
  (via2MinSpace    0.0)   ;;; second contact layer min space
  (layer2MinSpace  0.0)   ;;; second layer min space
  (layer3MinSpace  0.0)   ;;; third (top) layer min space
  (snapGrid        (TECHgetProp snapGrid)) ; grid size
  (implant         t)      ;;; boolean to draw impant layer around diff
  (tapLayer        (list "tap" "drawing"))   
  (tapImplant      nil)  
  (tapImpEnc       0.0)  
  (lodEnabled      nil)  
  )
 ;;; Formal parameters
 ((sourceFirst    "TRUE")
  (sharedDrain    "")  ;;name of the default contact for shared Drains
  (sharedSource   "")  ;;name of the default contact for shared Sources
  (lastContact    "")  ;;name of the default contact for last contact 
  (firstContact   "")  ;;name of the default contact for first contact
  (gateExt        0.0) ;;; extension of poly beyond diff
  ;; idLayersTable is a list of lists (table) where each list contains an idLayer/mask name and its enclosures
  (idLayersTable  (list (list "none" (list 0.0 0.0 0.0))))
  ;; src and drnSecIdLayersTable is a table where each entry has a secondary id Layer name & its enclosure values
  (srcSecIdLayersTable (list (list "none" (list 0.0 0.0 0.0))))
  (drnSecIdLayersTable (list (list "none" (list 0.0 0.0 0.0))))
  (hspiceModel    "")  ;;name of the default hspiceModel
  (srcOffset      0.0) ;;additional distance between source contacts w.r.t gate
  (drnOffset      0.0) ;;additional distance between drain contacts w.r.t gate
  (m              1)   ;;m-factor
  (l              0.0) ;;length of device
  (w              0.0) ;;width of device
  (gatetogateSpacing 0.0)
  (gateImplant       "FALSE") ;;use to toggle on and off the polyImplant
  ;;LOD settings
  (manualLOD         "FALSE");;use to toggle between numeric and symbolic LOD specification fields
  (sa                0.0) ;;numeric sa value
  (sb                0.0) ;;numeric sb value
  (sd                0.0) ;;numeric sd value
  (buttingGatesSA   0)
  (buttingGatesSB   0)
  ;;Used when symbolic LOD is selected & first term is a non-strapped or a double strapped contact
  ;;When symbolic LOD is used & first term contact is a single strapped contact
  (LODContactMapSStrapped  nil)
  (LODContactMapNDStrapped nil)
  (noContactLOD            0.0)
  (voltageChoices          (list "normal"))
  )

(setq secIdLayersTable (list (list "none" (list 0.0 0.0 0.0))))
(setq wellEncYDiff 0.0)
(when (nequal wellLayerWidth 0.0)
  (setq wellWidth (plus (times (max wellEncDiff wellEncTap) 2) w))
  (if (lessp wellWidth wellLayerWidth) then 
    (setq wellEncYDiff (abs (difference (max wellEncDiff wellEncTap )
					(quotient (difference wellLayerWidth w) 2)))))
  )

;; convert boolean parameters to either t or nil
;; this way we can use the simple (when parameter) syntax
;; and speed up pcell evaluation and make code simpler
(if (or (equal implant t) (equal implant "TRUE")) then
  (setq implant t)
  else
  (setq implant nil)
  )
(if (or (null idLayersTable) (equal idLayersTable "none") 
	(equal idLayersTable "nil")  (equal idLayersTable "FALSE")) then
  (setq idLayer nil)
  else
  (setq idLayer t)
  )
(if (and (listp idLayersTable) (equal (caar idLayersTable) "none"))
    (setq idLayer nil)
  )
(if (or (null srcSecIdLayersTable) (equal srcSecIdLayersTable "none") 
	(equal srcSecIdLayersTable "nil")  (equal srcSecIdLayersTable "FALSE")) then
  (setq srcSecIdLayer nil)
  else
  (setq srcSecIdLayer t)
  )

(if (and (listp srcSecIdLayersTable) (equal (caar srcSecIdLayersTable) "none"))
    (setq srcSecIdLayer nil)
  )
(if (or (null drnSecIdLayersTable) (equal drnSecIdLayersTable "none") 
	(equal drnSecIdLayersTable "nil")  (equal drnSecIdLayersTable "FALSE")) then
  (setq drnSecIdLayer nil)
  else
  (setq drnSecIdLayer t)
  )

(if (and (listp drnSecIdLayersTable) (equal (caar drnSecIdLayersTable) "none"))
    (setq drnSecIdLayer nil)
  )

(if (or (equal sourceFirst t) (equal sourceFirst "TRUE")) then
  (setq sourceFirst t)
  else
  (setq sourceFirst nil)
  )
(if (or (equal gateImplant t) (equal gateImplant "TRUE")) then
  (setq gateImplant t)
  else
  (setq gateImplant nil)
  )
(if (or (equal manualLOD t) (equal manualLOD "TRUE")) then
  (setq manualLOD t)
  else
  (setq manualLOD nil)
  )


(if (lessp gateExt 0.0)
    (error "mModelFetClass: gateExt (%g) must be > 0\n" gateExt)
  )

 ;;; Make the nets and the terminals that will be used in the cell.
(setq gNet (dbCreateNet tcCellView "g"))
(dbCreateTerm gNet "g" "input")
(setq sNet (dbCreateNet tcCellView "s"))
(dbCreateTerm sNet "s" "inputOutput")
(setq dNet (dbCreateNet tcCellView "d"))
(dbCreateTerm dNet "d" "inputOutput")

 ;;; make sure the boolean parameters are set properly
(if sourceFirst then
  (setq cNet sNet)
  (setq netL "S")
  (setq secIdLayer srcSecIdLayer)
  (when secIdLayer
    (setq secIdLayersTable srcSecIdLayersTable)
    )
  else
  (setq cNet dNet)
  (setq netL "D")
  (setq secIdLayer drnSecIdLayer)
  (when secIdLayer
    (setq secIdLayersTable drnSecIdLayersTable)
    )
  )

(when (lessp m 1) ;;; The schematic transistor can have an mfactor of 0.
  (setq m 1)    ;;; It will be enforced to a minimum of 1.
  )

;;; Deriving internal offset required to have a pcell DRC clean from the 
;;; space errors across a gate.

(when (nequal firstContact "")
  (setq contactF (dbOpenCellView tcCellView~>lib firstContact "symbolic" 
				 nil "rn")))
(when (nequal lastContact "")
  (setq contactL (dbOpenCellView tcCellView~>lib lastContact "symbolic" 
				 nil "rn")))
(when (nequal sharedDrain "")
  (setq contactD (dbOpenCellView tcCellView~>lib sharedDrain "symbolic" 
				 nil "rn")))
(when (nequal sharedSource "")
  (setq contactS (dbOpenCellView tcCellView~>lib sharedSource "symbolic"
				 nil "rn")))

;;;getting Contact Length Values to enable extension
;;;calculation under symbolic setting
(when lodEnabled
  (unless (equal firstContact "")
    (when   (equal contactF~>tapLayerBbox nil)
      (setq contactFLength (difference (caadr contactF~>diffLayerBbox)  (caar contactF~>diffLayerBbox)))
      )
    (unless (equal contactF~>tapLayerBbox nil)
      (setq contactFLength (difference (max (caadr contactF~>diffLayerBbox) (caadr contactF~>tapLayerBbox)) 
				       (min (caar  contactF~>diffLayerBbox) (caar contactF~>tapLayerBbox))))
      )
    )

  (when (equal firstContact "")
    (setq contactFLength diffExt)
    )
  
  (unless (equal lastContact "")
    (when   (equal contactL~>tapLayerBbox nil)
      (setq contactLLength (difference (caadr contactL~>diffLayerBbox)  (caar contactL~>diffLayerBbox)))
      )
    (unless (equal contactL~>tapLayerBbox nil)
      (setq contactLLength (difference (max (caadr contactL~>diffLayerBbox) (caadr contactL~>tapLayerBbox)) 
				       (min (caar  contactL~>diffLayerBbox) (caar contactL~>tapLayerBbox))))
      )
    )

  (when (equal lastContact "")
    (setq contactLLength diffExt)
    )

  (unless (equal sharedDrain "")
    (when   (equal contactD~>tapLayerBbox nil)
      (setq contactDLength (difference (caadr contactD~>diffLayerBbox)  (caar contactD~>diffLayerBbox)))
      )
    (unless (equal contactD~>tapLayerBbox nil)
      (setq contactDLength (difference (max (caadr contactD~>diffLayerBbox) (caadr contactD~>tapLayerBbox)) 
				       (min (caar  contactD~>diffLayerBbox) (caar contactD~>tapLayerBbox))))
      )
    )
  (when (equal sharedDrain "")
    (setq contactDLength gatetogateSpacing)
    )
  
  (unless (equal sharedSource "")
    (when   (equal contactS~>tapLayerBbox nil)
      (setq contactSLength (difference (caadr contactS~>diffLayerBbox)  (caar contactS~>diffLayerBbox)))
      )
    (unless (equal contactS~>tapLayerBbox nil)
      (setq contactSLength (difference (max (caadr contactS~>diffLayerBbox) (caadr contactS~>tapLayerBbox)) 
				       (min (caar  contactS~>diffLayerBbox) (caar contactS~>tapLayerBbox))))
      )  
    )
  (when (equal sharedSource "")
    (setq contactSLength gatetogateSpacing)
    )
  );when LOD Enabled



;;; getting coordinates
;;; first and last contacts
;;; should always compare only X1 because contacts are rotated later on
(setq via1XCrdF   (if contactF~>bBoxVia1 
		      (abs (caar contactF~>bBoxVia1)) nil))
(setq layer2XCrdF (if contactF~>bBoxLayer2 
		      (abs (caar contactF~>bBoxLayer2)) nil))
(setq via2XCrdF   (if contactF~>bBoxVia2 
		      (abs (caar contactF~>bBoxVia2)) nil))
(setq layer3XCrdF (if contactF~>bBoxLayer3
		      (abs (caar contactF~>bBoxLayer3)) nil))
(setq layer1XCrdF (if contactF~>diffLayerBbox
		      (abs (caar contactF~>diffLayerBbox)) nil))
(setq via1XCrdL   (if contactL~>bBoxVia1 
		      (abs (caar contactL~>bBoxVia1)) nil))
(setq layer2XCrdL (if contactL~>bBoxLayer2
		      (abs (caar contactL~>bBoxLayer2)) nil))
(setq via2XCrdL   (if contactL~>bBoxVia2 
		      (abs (caar contactL~>bBoxVia2)) nil))
(setq layer3XCrdL (if contactL~>bBoxLayer3
		      (abs (caar contactL~>bBoxLayer3)) nil))
(setq layer1XCrdL (if contactL~>diffLayerBbox
		      (abs (caar contactL~>diffLayerBbox)) nil))

; shared source and drain contacts
(setq via1XCrdS   (if contactS~>bBoxVia1 
		      (abs (caar contactS~>bBoxVia1)) nil))
(setq layer2XCrdS (if contactS~>bBoxLayer2
		      (abs (caar contactS~>bBoxLayer2)) nil))
(setq via2XCrdS   (if contactS~>bBoxVia2 
		      (abs (caar contactS~>bBoxVia2)) nil))
(setq layer3XCrdS (if contactS~>bBoxLayer3
		      (abs (caar contactS~>bBoxLayer3)) nil))
(setq layer1XCrdS (if contactS~>diffLayerBbox
		      (abs (caar contactS~>diffLayerBbox)) nil))
(setq via1XCrdD   (if contactD~>bBoxVia1 
		      (abs (caar contactD~>bBoxVia1)) nil))
(setq layer2XCrdD (if contactD~>bBoxLayer2
		      (abs (caar contactD~>bBoxLayer2)) nil))
(setq via2XCrdD   (if contactD~>bBoxVia2 
		      (abs (caar contactD~>bBoxVia2)) nil))
(setq layer3XCrdD (if contactD~>bBoxLayer3
		      (abs (caar contactD~>bBoxLayer3)) nil))
(setq layer1XCrdD (if contactD~>diffLayerBbox
		      (abs (caar contactD~>diffLayerBbox)) nil))

;;; calculating enclosures
;;; first and last contacts
(if (and  layer1XCrdF via1XCrdF) then 
    (setq via1EncF    (abs (difference layer1XCrdF via1XCrdF))))
(if (and  layer1XCrdF via2XCrdF) then 
    (setq via2EncF    (abs (difference layer1XCrdF via2XCrdF))))
(if (and  layer1XCrdF layer2XCrdF) then 
    (setq layer2EncF  (abs (difference layer1XCrdF layer2XCrdF))))
(if (and  layer1XCrdF layer3XCrdF) then 
    (setq layer3EncF  (abs (difference layer1XCrdF layer3XCrdF))))
(if (and  layer1XCrdL via1XCrdL) then 
    (setq via1EncL    (abs (difference layer1XCrdL via1XCrdL))))
(if (and  layer1XCrdL via2XCrdL) then 
    (setq via2EncL    (abs (difference layer1XCrdL via2XCrdL))))
(if (and  layer1XCrdL layer2XCrdL) then 
    (setq layer2EncL  (abs (difference layer1XCrdL layer2XCrdL))))
(if (and  layer1XCrdL layer3XCrdL) then 
    (setq layer3EncL  (abs (difference layer1XCrdL layer3XCrdL))))

;shared source and drain contacts
(if (and  layer1XCrdS via1XCrdS) then 
  (setq via1EncS    (abs (difference layer1XCrdS via1XCrdS))))
(if (and  layer1XCrdS via2XCrdS) then 
  (setq via2EncS    (abs (difference layer1XCrdS via2XCrdS))))
(if (and  layer1XCrdS layer2XCrdS) then 
  (setq layer2EncS  (abs (difference layer1XCrdS layer2XCrdS))))
(if (and  layer1XCrdS layer3XCrdS) then 
  (setq layer3EncS  (abs (difference layer1XCrdS layer3XCrdS))))
(if (and  layer1XCrdD via1XCrdD) then 
  (setq via1EncD    (abs (difference layer1XCrdD via1XCrdD))))
(if (and  layer1XCrdD via2XCrdD) then 
  (setq via2EncD    (abs (difference layer1XCrdD via2XCrdD))))
(if (and  layer1XCrdD layer2XCrdD) then 
  (setq layer2EncD  (abs (difference layer1XCrdD layer2XCrdD))))
(if (and  layer1XCrdD layer3XCrdD) then 
  (setq layer3EncD  (abs (difference layer1XCrdD layer3XCrdD))))

;;; calculating space over a gate
;;; calculating the total offset
;;; if enclosures do not exist set an offset to zero
;;; First and Last contact (used when m==1)
(if (and via1EncF via1EncL) then 
  (setq via1SpaceFL (plus via1EncF via1EncL l))
  (setq via1OffSetFL (difference via1MinSpace via1SpaceFL ))
  else
  (setq via1OffSetFL 0.0)
)


(if (and via2EncF via2EncL) then 
  (setq via2SpaceFL (plus via2EncF via2EncL l))
  (setq via2OffSetFL (difference via2MinSpace via2SpaceFL)) 
 else 
  (setq via2OffSetFL 0.0)
)
(if (and layer3EncF layer3EncL) then
  (setq layer3SpaceFL (plus layer3EncF layer3EncL l))
  (setq layer3OffSetFL (difference layer3MinSpace layer3SpaceFL)) 
  else 
  (setq layer3OffSetFL 0.0)
  )
(if (and layer2EncF layer2EncL) then
  (setq layer2SpaceFL (plus layer2EncF layer2EncL l))
  (setq layer2OffSetFL (difference layer2MinSpace layer2SpaceFL)) 
  else 
  (setq layer2OffSetFL 0.0)
  )
;; First and shared Source contact 
(if (and via1EncF via1EncS) then 
  (setq via1SpaceFS (plus via1EncF via1EncS l))
  (setq via1OffSetFS (difference via1MinSpace via1SpaceFS )) 
  else 
  (setq via1OffSetFS 0.0)
  )
(if (and via2EncF via2EncS) then 
  (setq via2SpaceFS (plus via2EncF via2EncS l))
  (setq via2OffSetFS (difference via2MinSpace via2SpaceFS)) 
  else 
  (setq via2OffSetFS 0.0)
  )
(if (and layer3EncF layer3EncS) then
  (setq layer3SpaceFS (plus layer3EncF layer3EncS l))
  (setq layer3OffSetFS (difference layer3MinSpace layer3SpaceFS)) 
  else 
  (setq layer3OffSetFS 0.0)
  )
(if (and layer2EncF layer2EncS) then
  (setq layer2SpaceFS (plus layer2EncF layer2EncS l))
  (setq layer2OffSetFS (difference layer2MinSpace layer2SpaceFS))
  else 
  (setq layer2OffSetFS 0.0)
  )
;; First and shared Drain contact 
(if (and via1EncF via1EncD) then 
  (setq via1SpaceFD (plus via1EncF via1EncD l))
  (setq via1OffSetFD (difference via1MinSpace via1SpaceFD )) 
  else 
  (setq via1OffSetFD 0.0)
  )
(if (and via2EncF via2EncD) then 
  (setq via2SpaceFD (plus via2EncF via2EncD l))
  (setq via2OffSetFD (difference via2MinSpace via2SpaceFD)) 
  else 
  (setq via2OffSetFD 0.0)
  )
(if (and layer3EncF layer3EncD) then
  (setq layer3SpaceFD (plus layer3EncF layer3EncD l))
  (setq layer3OffSetFD (difference layer3MinSpace layer3SpaceFD)) 
  else 
  (setq layer3OffSetFD 0.0)
  )
(if (and layer2EncF layer2EncD) then
  (setq layer2SpaceFD (plus layer2EncF layer2EncD l))
  (setq layer2OffSetFD (difference layer2MinSpace layer2SpaceFD)) 
  else 
  (setq layer2OffSetFD 0.0)
  )
;; Last and shared Source contact 
(if (and via1EncL via1EncS) then 
  (setq via1SpaceLS (plus via1EncL via1EncS l))
  (setq via1OffSetLS (difference via1MinSpace via1SpaceLS )) 
  else 
  (setq via1OffSetLS 0.0)
  )
(if (and via2EncL via2EncS) then 
  (setq via2SpaceLS (plus via2EncL via2EncS l))
  (setq via2OffSetLS (difference via2MinSpace via2SpaceLS)) 
  else 
  (setq via2OffSetLS 0.0)
  )
(if (and layer3EncL layer3EncS) then
  (setq layer3SpaceLS (plus layer3EncL layer3EncS l))
  (setq layer3OffSetLS (difference layer3MinSpace layer3SpaceLS)) 
  else 
  (setq layer3OffSetLS 0.0)
  )
(if (and layer2EncL layer2EncS) then
  (setq layer2SpaceLS (plus layer2EncL layer2EncS l))
  (setq layer2OffSetLS (difference layer2MinSpace layer2SpaceLS)) 
  else 
  (setq layer2OffSetLS 0.0)
  )
;; Last and shared Drain contact 
(if (and via1EncL via1EncD) then 
  (setq via1SpaceLD (plus via1EncL via1EncD l))
  (setq via1OffSetLD (difference via1MinSpace via1SpaceLD )) 
  else 
  (setq via1OffSetLD 0.0)
  )
(if (and via2EncL via2EncD) then 
  (setq via2SpaceLD (plus via2EncL via2EncD l))
  (setq via2OffSetLD (difference via2MinSpace via2SpaceLD)) 
  else 
  (setq via2OffSetLD 0.0)
  )
(if (and layer3EncL layer3EncD) then
  (setq layer3SpaceLD (plus layer3EncL layer3EncD l))
  (setq layer3OffSetLD (difference layer3MinSpace layer3SpaceLD)) 
  else 
  (setq layer3OffSetLD 0.0)
  )
(if (and layer2EncL layer2EncD) then
  (setq layer2SpaceLD (plus layer2EncL layer2EncD l))
  (setq layer2OffSetLD (difference layer2MinSpace layer2SpaceLD)) 
  else 
  (setq layer2OffSetLD 0.0)
  )
;; shared Source and shared Drain contact 
(if (and via1EncS via1EncD) then 
  (setq via1SpaceSD (plus via1EncS via1EncD l))
  (setq via1OffSetSD (difference via1MinSpace via1SpaceSD )) 
  else 
  (setq via1OffSetSD 0.0)
  )
(if (and via2EncS via2EncD) then 
  (setq via2SpaceSD (plus via2EncS via2EncD l))
  (setq via2OffSetSD (difference via2MinSpace via2SpaceSD)) 
  else 
  (setq via2OffSetSD 0.0)
  )
(if (and layer3EncS layer3EncD) then
  (setq layer3SpaceSD (plus layer3EncS layer3EncD l))
  (setq layer3OffSetSD (difference layer3MinSpace layer3SpaceSD)) 
  else 
  (setq layer3OffSetSD 0.0)
  )
(if (and layer2EncS layer2EncD) then
  (setq layer2SpaceSD (plus layer2EncS layer2EncD l))
  (setq layer2OffSetSD (difference layer2MinSpace layer2SpaceSD)) 
  else 
  (setq layer2OffSetSD 0.0)
  )

;; if xyzMinSpace is less then xyzSpace (no spacing error) then xyzDiff 
;; will be less than zero. Therefore, max() must include 0.0 in order 
;; to avoid negative offset
(if (equal m 1) then
  (setq maxOffSet (max via1OffSetFL via2OffSetFL layer2OffSetFL 
		       layer3OffSetFL 0.0))
  else
  (if (equal m 2) then
    (if sourceFirst  then
      (setq maxOffSet (max via1OffSetFD   via2OffSetFD   layer2OffSetFD 
			   layer3OffSetFD via1OffSetLD   via2OffSetLD 
			   layer2OffSetLD layer3OffSetLD 0.0))
      else
      (setq maxOffSet (max via1OffSetFS   via2OffSetFS   layer2OffSetFS 
			   layer3OffSetFS via1OffSetLS   via2OffSetLS 
			   layer2OffSetLS layer3OffSetLS 0.0))
      )
    else 
    (if (equal (mod m 2) 0) then   
      (if sourceFirst then
	(setq maxOffSet (max via1OffSetFD   via2OffSetFD   layer2OffSetFD 
			     layer3OffSetFD via1OffSetSD   via2OffSetSD 
			     layer2OffSetSD layer3OffSetSD via1OffSetLD 
			     via2OffSetLD   layer2OffSetLD layer3OffSetLD 0.0))
	else
	(setq maxOffSet (max via1OffSetFS   via2OffSetFS   layer2OffSetFS 
			     layer3OffSetFS via1OffSetSD   via2OffSetSD 
			     layer2OffSetSD layer3OffSetSD via1OffSetLS 
			     via2OffSetLS   layer2OffSetLS layer3OffSetLS 0.0))
	)
      else
      (if sourceFirst then
	(setq maxOffSet (max via1OffSetFD   via2OffSetFD   layer2OffSetFD 
			     layer3OffSetFD via1OffSetSD   via2OffSetSD 
			     layer2OffSetSD layer3OffSetSD via1OffSetLS 
			     via2OffSetLS   layer2OffSetLS layer3OffSetLS 0.0))
	else
	(setq maxOffSet (max via1OffSetFS   via2OffSetFS   layer2OffSetFS 
			     layer3OffSetFS via1OffSetSD   via2OffSetSD 
			     layer2OffSetSD layer3OffSetSD via1OffSetLD 
			     via2OffSetLD   layer2OffSetLD layer3OffSetLD 0.0))
	) 
      )
    )
  ) 

;; Calculating the min offset needed to avoid spacing errors
;; The offset for all contacts is the same because contacts are mirrored.
(setq offsetSide (quotient maxOffSet 2.0))
;; Offset must be on grid     
(setq minSpaceOffSet (times (ceiling (plus (quotient offsetSide snapGrid) -1e-6)) snapGrid))

;; decide on the parameters to pass to the contacts based on our parameters
;; we do this once here rather than typing it 4 or 5 times.
;; since these only work if there are polarized implant contacts
;; we will check each time it's used to see if it's valid.

;; implant selection should pass down the hierarchy
(if implant then
  (setq contactImpParam (list "implant" "boolean" t))
  else
  (setq contactImpParam (list "implant" "boolean" "FALSE"))
  )
;; well polarity is determined from class parameters. This is because
;; nTran and pTran are not allowed to toggle their well, so the presence
;; or absense is set at devLib compile time.
(if wellLayer then
  (setq contactWellParam (list "inWell" "boolean" t))
  else
  (setq contactWellParam (list "inWell" "boolean" "FALSE"))
  )

;; initialize the lower left corner of all geometries. The y1Coord is not
;; really required, but helps in consistency.
(setq x1Coord 0.0)
(setq y1Coord 0.0)

;; Poly implant layer initialization. Not complicated as diff implant
;; but similar to depletion layer. Modelled after dep layer
;; The lastPYix1coord is used to calculate where to place the implant
;; It will store the edge of the last gate.
(setq lastPYiX1Coord (minus (times 2.0 polyImpXEnc)))

;; initialize the y coordinates for the depletion layer.
(when (and polyImplant gateImplant)
  (setq y1PYiCoord (difference y1Coord polyImpYEnc gateExt))
  (setq y2PYiCoord (plus y1Coord w polyImpYEnc gateExt))
  )

(setq idLayersCoordTable (makeTable "idLayersCoordTable" nil))
(setq layerInfo nil)
(setq layerEncs nil)
(setq x1IdCoord 0.0)
(setq y1IdCoord 0.0)
(setq x2IdCoord 0.0)
(setq y2IdCoord 0.0)

(when idLayer
  (foreach layerInfo idLayersTable
	   (setq layerName  (car  layerInfo))
	   (setq layerEncs  (cadr layerInfo))
	   (setq idLayCoords (list x1IdCoord:y1IdCoord x2IdCoord:y2IdCoord))
	   idLayersCoordTable[layerName] = idLayCoords
	   )
  )

(setq secIdLayersCoordTable (makeTable "secIdLayersCoordTable" nil))
(setq secLayerInfo nil)
(setq secLayerEncs nil)
(setq x1SecIdCoord 0.0)
(setq y1SecIdCoord 0.0)
(setq x2SecIdCoord 0.0)
(setq y2SecIdCoord 0.0)

(when secIdLayer
  (foreach secLayerInfo secIdLayersTable
	   (setq secLayerName   (car  secLayerInfo))
	   (setq secLayerEncs   (cadr secLayerInfo))
	   (setq secIdLayCoords (list x1SecIdCoord:y1SecIdCoord x2SecIdCoord:y2SecIdCoord))
	   secIdLayersCoordTable[secLayerName] = secIdLayCoords
	   )
  )

(setq wellEncDiffY wellEncDiff)
(setq wellEncTapY  wellEncTap)
(setq wellEncDiffX wellEncDiff)    
(setq wellEncTapX  wellEncTap)
(setq extension    nil)



(if (equal cNet sNet) then
  (setq offset (plus minSpaceOffSet srcOffset))
  ;;The following variables are used in calculating 
  ;;extension under symbolic LOD selection
  (setq curTermOffset offset);source term offset
  (setq nextTermOffset (plus minSpaceOffSet drnOffset)) ;drain term offset
  (setq curTermShConLength  contactSLength);shared source contact length
  (setq nextTermShConLength contactDLength);shared drain contact length
  else
  (setq offset (plus minSpaceOffSet drnOffset))
  ;;The following variables are used in calculating 
  ;;extension under symbolic LOD selection
  (setq curTermOffset offset);drain term offset
  (setq nextTermOffset (plus minSpaceOffSet srcOffset));source term offset
  (setq curTermShConLength  contactDLength);shared drain contact length
  (setq nextTermShConLength contactSLength);shared source contact length
  )

;; get the dbids of the named contacts
;; first the firstContact contact, see if the field is defined and get the id
;; If cannot find the cell -- error. The cell should be in the same library
;; as the current pcell is. Place an instance of the cell (mirrored around Y)
(when (nequal firstContact "")
  (setq contactId (dbOpenCellView tcCellView~>lib firstContact 
				  "symbolic" nil "rn"))
  (unless contactId
    (error (sprintf nil "Cannot find/open firstContact contact cell `%s'" 
		    firstContact))
    )
  
  (unless contactId~>isParamCell
    (error (sprintf nil "Named cell is not a pcell `%s'" firstContact))
    )
  
  (setq params contactId~>parameters)
  (setq instParams (list (list "w" "float" w)))
  (when params~>implant
    (setq instParams (xcons instParams contactImpParam))
    )
  (when params~>inWell
    (setq instParams (xcons instParams contactWellParam))
    )
  (setq inst (dbCreateParamInst tcCellView contactId "c0"
				(minus offset):0 "MY" 1 instParams )
	)
  (unless inst
    (error (sprintf nil "Failed to create instance of `%s'" firstContact))
    )
  
  (unless lodEnabled
    
    ;; Create a rectangle to fill the space between the contact and the gate,
    ;; when offset > zero.
    (when (greaterp offset 1e-6)
      (dbCreateRect tcCellView diffLayer 
		    (list (difference x1Coord offset):y1Coord x1Coord:w)
		    )
      ;; we depend on the contact to implant itself correctly, and only meet
      ;; enclosure in the Y direction with this piece of implant
      (when (and diffImplant implant)
	(dbCreateRect tcCellView diffImplant 
		      (list (list (difference x1Coord offset)
				  (difference y1Coord diffImpEnc))
			    (list x1Coord
				  (plus w     diffImpEnc))
			    ))
	)
      
      ;; we depend on the contact to implant itself correctly, and only meet
      ;; enclosure in the Y direction with this piece of implant
      (when (and diffCoreImplant implant)
	(dbCreateRect tcCellView diffCoreImplant 
		      (list (list (difference x1Coord offset)
				  (difference y1Coord diffCoreImpEnc))
			    (list x1Coord
				  (plus w     diffCoreImpEnc))
			    ))
	)
      )
    );unless
  
  (when lodEnabled
    (setq isSingleStrapped nil);;Set to true when contact is single-strapped
    (setq isNDStrapped     nil);;Set to true when contact is non-strapped or double-strapped
    ;;When Numeric LOD is selected
    (when manualLOD
      (when LODContactMapSStrapped
	(foreach pair LODContactMapSStrapped
		 (when (equal firstContact (car pair))
		   (setq isSingleStrapped t)
		   (setq innerContact     (cdr pair))
		   )
		 )
	)
      ;;When a single strapped contact is the first terminal contact
      (when isSingleStrapped
	;;Always move the strapped contact to the left edge
	;;Accomodate a non-strapped contact pcell if there is enough room 
	;;between the offset and the strapped-contact
	;;If there isn't enough room, then place the strapped-contact at 
	;;the end
	;;
	;;Net will be placed on the inner contact when inner contact exists
	;;Nets will be placed on the strapped-contact when there is no room for an inner contact
	;;
	
	(dbDeleteObject inst)
	(dbClose contactId)
	;;Replace the single strapped contact with a non-strapped contact
	(setq innerContactId (dbOpenCellView tcCellView~>lib (car innerContact) "symbolic" nil "rn"))
	(unless innerContactId~>isParamCell
	  (error (sprintf nil "Named cell is not a pcell `%s'" innerContact)))
	(setq innerContactLength (difference  (caadr innerContactId~>diffLayerBbox)  (caar innerContactId~>diffLayerBbox)))
	
	;;Calculate required space between inner and outer contact
	(setq via1XCrdInnerCon   (if innerContactId~>bBoxVia1
				     (abs (caar innerContactId~>bBoxVia1)) nil
				     ))
	(setq layer2XCrdInnerCon   (if innerContactId~>bBoxLayer2
				     (abs (caar innerContactId~>bBoxLayer2)) nil
				     ))
	(setq via2XCrdInnerCon   (if innerContactId~>bBoxVia2
				     (abs (caar innerContactId~>bBoxVia2)) nil
				     ))
	(setq layer3XCrdInnerCon   (if innerContactId~>bBoxLayer3
				     (abs (caar innerContactId~>bBoxLayer3)) nil
				     ))
	(setq layer1XCrdInnerCon   (if innerContactId~>diffLayerBbox
				     (abs (caar innerContactId~>diffLayerBbox)) nil
				     ))
	
	(if (and  layer1XCrdInnerCon via1XCrdInnerCon) then 
	  (setq via1EncInnerCon    (abs (difference layer1XCrdInnerCon via1XCrdInnerCon)))
	  )
	(if (and  layer2XCrdInnerCon via2XCrdInnerCon) then 
	  (setq via2EncInnerCon    (abs (difference layer1XCrdInnerCon via2XCrdInnerCon)))
	  )
	
	(if (and via1EncInnerCon via1EncF) then
	  (setq availableVia1Space (plus via1EncInnerCon via1EncF))
	  (if (greaterp via1MinSpace  availableVia1Space) then
	    (setq requiredVia1Sp (difference via1MinSpace availableVia1Space))
	    else
	    (setq requiredVia1Sp 0)
	    )
	  )

	(if (and via2EncInnerCon via2EncF) then
	  (setq availableVia2Space (plus via2EncInnerCon via2EncF))
	  (if (greaterp via2MinSpace  availableVia2Space) then
	    (setq requiredVia2Sp (difference via2MinSpace availableVia2Space))
	    else
	    (setq requiredVia2Sp 0)
	    )
	  )
	
	(when (and requiredVia2Sp requiredVia1Sp)
	  (setq requiredSpace (max requiredVia2Sp requiredVia1Sp))
	  )
	(when (and (not requiredVia2Sp) requiredVia1Sp)
	  (setq requiredSpace requiredVia1Sp)
	  )
	
	;;Draw diff to cover offset first
	(when (greaterp offset 1e-6)
	  (dbCreateRect tcCellView diffLayer 
			(list  (difference x1Coord offset):y1Coord x1Coord:w))
	  (when (and diffImplant implant)
	    (dbCreateRect tcCellView diffImplant 
			  (list (list (difference x1Coord offset)
				      (difference y1Coord diffImpEnc))
				(list x1Coord
				      (plus w     diffImpEnc))
				)))
	  (when (and diffCoreImplant implant)
	    (dbCreateRect tcCellView diffCoreImplant 
			  (list (list (difference x1Coord offset)
				      (difference y1Coord diffCoreImpEnc))
				(list x1Coord
				      (plus w diffCoreImpEnc))
				)))
	  )

	
	;;If (LOD - first terminal contact length) value is such that an inner contact at the specified offset
	;;CAN be accomodated then place the inner contact at specified offset and place the net on the contact near the gate
	(when (geqp (difference sa contactFLength) (plus offset requiredSpace innerContactLength))
	  (setq contactId innerContactId)
	  ;;Place the inner contact
	  (setq inst (dbCreateParamInst tcCellView contactId "c0"
					(minus offset):0 "MY" 1 instParams ))
	  (unless inst
	    (error (sprintf nil "Failed to create instance of `%s'" innerContact)))
	  (setq strappedContactId   (dbOpenCellView tcCellView~>lib firstContact "symbolic" nil "rn"))
	  (unless strappedContactId~>isParamCell
	    (error (sprintf nil "Named cell is not a pcell `%s'" firstContact)))
	  ;;Place the outer contact
	  (setq strappedContactInst (dbCreateParamInst tcCellView strappedContactId nil
						       (minus (difference sa contactFLength)):0 "MY" 1 instParams ))
	  (unless strappedContactInst
	    (error (sprintf nil "Failed to create instance of `%s'" firstContact)))
	  (dbClose strappedContactId)
	  ;;Draw a piece of diff to cover the area between the inner contact and the outer contact
	  (dbCreateRect tcCellView diffLayer 
			(list (difference x1Coord (difference sa contactFLength)):y1Coord (difference x1Coord (plus offset innerContactLength)):w)
			)
	  (when (and diffImplant implant)
	    (dbCreateRect tcCellView diffImplant 
			  (list (list (difference x1Coord (difference sa contactFLength))
				      (difference y1Coord diffImpEnc))
				(list (difference x1Coord (plus offset innerContactLength))
				      (plus w     diffImpEnc))
				)))
	  (when (and diffCoreImplant implant)
	    (dbCreateRect tcCellView diffCoreImplant 
			  (list (list (difference x1Coord (difference sa contactFLength))
				      (difference y1Coord diffCoreImpEnc))
				(list (difference x1Coord (plus offset innerContactLength))
				      (plus w     diffCoreImpEnc))
				)))	  
	  )
	
	;;If (LOD - first terminal contact length) value is such that an inner contact at the specified offset
	;;CANNOT be accomodated then place the outer contact near the left end and place the net on the end contact
	(unless (geqp (difference sa contactFLength) (plus offset requiredSpace innerContactLength))
	  (dbClose innerContactId)
	  (setq strappedContactId (dbOpenCellView tcCellView~>lib firstContact "symbolic" nil "rn"))
	  (unless strappedContactId~>isParamCell
	    (error (sprintf nil "Named cell is not a pcell `%s'" firstContact)))
	  ;;Place the strapped contact
	  (setq strappedContactInst (dbCreateParamInst tcCellView strappedContactId nil
					(minus (difference sa contactFLength)):0 "MY" 1 instParams ))
	  (unless strappedContactInst
	    (error (sprintf nil "Failed to create instance of `%s'" firstContact)))
	  (setq contactId strappedContactId)
	  (setq inst      strappedContactInst)
	  ;;draw a piece of diffusion berween the gate and outer contact
	  (dbCreateRect tcCellView diffLayer 
			(list (difference x1Coord (difference sa contactFLength)):y1Coord x1Coord:w)
			)	
	  (when (and diffImplant implant)
	    (dbCreateRect tcCellView diffImplant 
			  (list (list (difference x1Coord (difference sa contactFLength))
				      (difference y1Coord diffImpEnc))
				(list  x1Coord 
				       (plus w     diffImpEnc))
				)))
	  (when (and diffCoreImplant implant)
	    (dbCreateRect tcCellView diffCoreImplant 
			  (list (list (difference x1Coord (difference sa contactFLength))
				      (difference y1Coord diffCoreImpEnc))
				(list x1Coord 
				      (plus w     diffCoreImpEnc))
				)))	  
	  )
	
	)
      
      (unless isSingleStrapped
	;;when the offset+ contact can be accomodated within the specified sa
	(when (and (or (greaterp sa 1e-6) (geqp offset 0.0)) (greaterp sa (plus offset contactFLength)))
	  ;; Create diffusion as two pieces to avoid creating diff under the tap, when the contacts happen to be strapped
	  ;; Create a rectangle to fill the space between the contact and the gate,
	  ;; when offset > zero.
	  (when (greaterp offset 1e-6)
	    (dbCreateRect tcCellView diffLayer 
			  (list  (difference x1Coord offset):y1Coord x1Coord:w)
			  ))
	  
	  ;; Create a rectangle to fill the space between the expected sa and (contact + offset)
	  (dbCreateRect tcCellView diffLayer 
		    (list  (difference x1Coord offset contactFLength (difference sa contactFLength offset)):y1Coord (difference x1Coord offset contactFLength):w)
		    )
	  
	  ;; we depend on the contact to implant itself correctly, and only meet
	  ;; enclosure for the extra pieces of diffusion (created above) here 
	  (when (and diffImplant implant)
	    (when (greaterp offset 1e-6)
	      (dbCreateRect tcCellView diffImplant 
			    (list (list (difference x1Coord offset)
					(difference y1Coord diffImpEnc))
				  (list x1Coord
					(plus w     diffImpEnc))
				  ))
	      )
	    
	    (dbCreateRect tcCellView diffImplant 
			  (list (list (difference x1Coord offset contactFLength (difference sa contactFLength offset) diffImpEnc)
				      (difference y1Coord diffImpEnc))
				(list (difference x1Coord offset contactFLength)
				      (plus w     diffImpEnc))
				))
	    )
	  ;; we depend on the contact to implant itself correctly, and only meet
	  ;; enclosure for the extra pieces of diffusion (created above) here 
	  (when (and diffCoreImplant implant)
	    (when (greaterp offset 1e-6)
	      (dbCreateRect tcCellView diffCoreImplant 
			    (list (list (difference x1Coord offset)
					(difference y1Coord diffCoreImpEnc))
				  (list x1Coord
					(plus w     diffCoreImpEnc))
				  ))
	      )
	    
	    (dbCreateRect tcCellView diffCoreImplant 
			  (list (list (difference x1Coord offset contactFLength (difference sa contactFLength offset) diffCoreImpEnc)
				      (difference y1Coord diffCoreImpEnc))
				(list (difference x1Coord offset contactFLength)
				      (plus w     diffCoreImpEnc))
				))
	    )
	  );when
	
      
	;;when the offset+ contact CANNOT be accomodated within the specified sa
	(when (or (and (greaterp offset 1e-6) (equal sa 0.0) (geqp (plus offset contactFLength) sa))
		  (and (greaterp offset 1e-6) (greaterp sa 1e-6) (geqp (plus offset contactFLength) sa)))
	  
	;;ignore the specified Sa  and create the diffusion per the specified offset
	  (dbCreateRect tcCellView diffLayer 
			(list  (difference x1Coord offset):y1Coord x1Coord:w)
			)
	  
	  (when (and diffImplant implant)	   
	    (dbCreateRect tcCellView diffImplant 
			  (list (list (difference x1Coord offset)
				      (difference y1Coord diffImpEnc))
				(list x1Coord
				      (plus w     diffImpEnc))
				))
	    )
	  
	  (when (and diffCoreImplant implant)
	    (dbCreateRect tcCellView diffCoreImplant 
			  (list (list (difference x1Coord offset)
				      (difference y1Coord diffCoreImpEnc))
				(list x1Coord
				      (plus w     diffCoreImpEnc))
				))
	    )
	  
	  );when 
	);unless isSingleStrapped
      );when manualLOD

     
    ;;when symbolic LOD is specified
    (when (not manualLOD)
      ;;when the symbolic LOD is selected and buttingGatesSA is atleast zero
      (unless (geqp buttingGatesSA 0)
	(warn (sprintf nil "Cannot specify non-zero number of butting gates for SA %L\n" buttingGatesSA))
	)
      (unless (geqp buttingGatesSA 1)
	(setq extension (plus offset contactFLength))
	)
      ;;Draw a piece of diffusion between the gate and the contact
      (when (greaterp offset 1e-6)
	  (dbCreateRect tcCellView diffLayer 
			(list  (difference x1Coord offset):y1Coord x1Coord:w))
	  )
      
      (when (greaterp offset 1e-6)
	(when (and diffImplant implant)	   
	  (dbCreateRect tcCellView diffImplant 
			(list (list (difference x1Coord offset)
				    (difference y1Coord diffImpEnc))
			      (list x1Coord
				    (plus y1Coord w     diffImpEnc))
			      )))
	
	(when (and diffCoreImplant implant)	   
	  (dbCreateRect tcCellView diffCoreImplant 
			(list (list (difference x1Coord offset)
				    (difference y1Coord diffCoreImpEnc))
			      (list x1Coord
				    (plus y1Coord w     diffCoreImpEnc))
			      )))
	)
      (when (geqp buttingGatesSA 0)
	;;Single Strapped first terminal selection places the strapped contact pcell 
	;;all the way to the left. A non-strapped contact pcell is placed at the 
	;;specified offset from the gate
	;;
	;;When double-strapped or non-strapped contact is selected as first terminal contact
	;;then that contact is placed at a specified offset from the gate.
	;;A non-strapped contact pcell is measured, and the measured space is used in calculating the 
	;;LOD of the imaginary outer-most contact
	;;
	;;Hence it is necessary to know whether the first terminal contact is strapped, 
	;;non-strapped or double-strapped and get the innerContact or outerContact pcell name
	;;as applicable
	;;
	
	;;Needs to happen only when > 1 butting Gates are involved
	(when (geqp buttingGatesSA 1)
	  (when LODContactMapSStrapped
	    (foreach pair LODContactMapSStrapped
		     (when (equal firstContact (car pair))
		       (setq isSingleStrapped t)
		       (setq innerContact     (cdr pair))
		       )
		     ))
	  
	  (when LODContactMapNDStrapped
	    (foreach pair LODContactMapNDStrapped
		     (when (equal firstContact (car pair))
		       (setq isNDStrapped t)
		       (setq outerContact (cdr pair))
		       )
		     ))
	  )
	

	;;When a single strapped contact is chosen for first terminal contact
	;;Contact needs to be pushed to the left-most end of the LOD
	;;Accomodate a contact at the specified offset
	;;between the gate and the strapped contact
	;;Under symbolic LOD there WILL always be enough room to accomodate a contact
	;;between the gate and the strapped contact. 
	(when (and isSingleStrapped (geqp buttingGatesSA 1))
	  (dbDeleteObject inst)
	  (dbClose contactId)
	  ;;Place a single strapped contact with a non-strapped contact
	  (setq contactId (dbOpenCellView tcCellView~>lib (car innerContact) "symbolic" nil "rn"))
	  (unless contactId~>isParamCell
	    (error (sprintf nil "Named cell is not a pcell `%s'" innerContact)))
	  (setq inst (dbCreateParamInst tcCellView contactId "c0"
					(minus offset):0 "MY" 1 instParams ))
	  (unless inst
	    (error (sprintf nil "Failed to create instance of `%s'" innerContact))
	    )
	  
	  (setq innerContactLength (difference  (caadr contactId~>diffLayerBbox)  (caar contactId~>diffLayerBbox)))
	  
	  
	  ;;Place the single strapped contact such that it forms the very end of the LOD
	  (when (geqp buttingGatesSA 1)
	    ;;Even number of imaginary gates
	    (when (equal (mod buttingGatesSA 2) 0)
	      ;;Calculate Extension
	      (setq extension (plus (plus  innerContactLength (times 2 curTermOffset))
				    (times (difference (quotient buttingGatesSA 2) 1) curTermShConLength)
				    (times (difference buttingGatesSA 2) curTermOffset)
				    (times (quotient   buttingGatesSA 2) nextTermShConLength)
				    (times buttingGatesSA nextTermOffset)
				    (plus  contactFLength curTermOffset)
				    (times buttingGatesSA l)
				    ))
	      )
	    ;;Odd number of imaginary gates
	    (unless (equal (mod buttingGatesSA 2) 0)
	      ;;Calculate Extension
	      (setq extension (plus (plus  innerContactLength (times 2 curTermOffset))
				    (times (quotient (difference buttingGatesSA 1) 2) curTermShConLength)
				    (times (difference buttingGatesSA 1) curTermOffset)
				    (times (quotient (difference buttingGatesSA 1) 2) nextTermShConLength)
				    (times (difference buttingGatesSA 1) nextTermOffset)
				    (plus  contactFLength nextTermOffset)
				    (times buttingGatesSA l)
				    ))
	      )
	    )
	  
	  ;;Create a piece of diffusion between the Inner contact and the Outer contact
	  (dbCreateRect tcCellView diffLayer 
			(list  (minus (difference extension contactFLength)):y1Coord (minus (plus offset innerContactLength)):w))
	  (setq outerContactId (dbOpenCellView tcCellView~>lib firstContact "symbolic" nil "rn"))
	  (unless outerContactId~>isParamCell
	    (error (sprintf nil "Named cell is not a pcell `%s'" firstContact)))
	  (setq outerInst      (dbCreateParamInst tcCellView outerContactId nil
						  (minus (difference extension contactFLength)):0 "MY" 1 instParams ))
	  
	  (unless outerInst
	    (error (sprintf nil "Failed to create instance of `%s'" firstContact))
	    )

	  
	  (when (and diffImplant implant)	   
	    (dbCreateRect tcCellView diffImplant 
			  (list (list (difference x1Coord (difference extension contactFLength))
				      (difference y1Coord diffImpEnc))
				(list (difference x1Coord offset innerContactLength)
				      (plus y1Coord w     diffImpEnc))
				)))

	  (when (and diffCoreImplant implant)	   
	    (dbCreateRect tcCellView diffCoreImplant 
			  (list (list (difference x1Coord (difference extension contactFLength))
				      (difference y1Coord diffCoreImpEnc))
				(list (difference x1Coord offset innerContactLength)
				      (plus y1Coord w     diffCoreImpEnc))
				)))
	  
	  )
	
	
	
	
	(when (and (not isSingleStrapped) (geqp buttingGatesSA 1))
	  (setq outerContactId (dbOpenCellView tcCellView~>lib (car outerContact) "symbolic" nil "rn"))
	  (unless outerContactId~>isParamCell
	    (error (sprintf nil "Named cell is not a pcell `%s'" outerContact)))
	  (setq outerContactLength (difference  (caadr outerContactId~>diffLayerBbox)  (caar outerContactId~>diffLayerBbox)))
	  
	  
	  (when (geqp buttingGatesSA 1)
	    ;;Even number of imaginary gates
	    (when (equal (mod buttingGatesSA 2) 0)
	      ;;Calculate extension
	      (setq extension (plus (plus contactFLength (times 2 curTermOffset))
	        		    (times (difference (quotient buttingGatesSA 2) 1) curTermShConLength)
	        		    (times (difference buttingGatesSA 2) curTermOffset)
	        		    (times (quotient   buttingGatesSA 2) nextTermShConLength)
	        		    (times buttingGatesSA nextTermOffset)
	        		    (plus  outerContactLength curTermOffset)
	        		    (times buttingGatesSA l)
	        		    ))
	      )
	    
	    ;;Odd number of imaginary gates
	    (unless (equal (mod buttingGatesSA 2) 0)
	      ;;Calculate extension
	      (setq extension (plus (plus contactFLength (times 2 curTermOffset))
	        		    (times (quotient (difference buttingGatesSA 1) 2) curTermShConLength)
	        		    (times (difference buttingGatesSA 1) curTermOffset)
	        		    (times (quotient (difference buttingGatesSA 1) 2) nextTermShConLength)
	        		    (times (difference buttingGatesSA 1) nextTermOffset)
	        		    (plus  outerContactLength nextTermOffset)
	        		    (times buttingGatesSA l)
	        		    ))
	      )
	    )

	  ;;Next, create a piece of diffusion to cover the area between contact and the left LOD edge
	  (dbCreateRect tcCellView diffLayer 
			(list  (difference x1Coord extension):y1Coord (difference x1Coord offset contactFLength):w))
	  
	  
	  (when (and diffImplant implant)	   
	    (dbCreateRect tcCellView diffImplant 
			  (list (list (difference x1Coord extension diffImpEnc)
				      (difference y1Coord diffImpEnc))
				(list (difference x1Coord offset contactFLength)
				      (plus y1Coord w     diffImpEnc))
				)))
	  
	  (when (and diffCoreImplant implant)	   
	    (dbCreateRect tcCellView diffCoreImplant 
			  (list (list (difference x1Coord extension diffCoreImpEnc)
				      (difference y1Coord diffCoreImpEnc))
				(list (difference x1Coord offset contactFLength)
				      (plus y1Coord w     diffCoreImpEnc))
				)))
	  );;unless isSingleStrapped

	);when butting gates >= 0

      );when symbolic LOD

    );when lodEnabled

  ;;; Create a rectangle from the top Layer of the contact, given the
  ;;; bounding box of the top Layer. Then make this rectangle a pin
  ;;; or the appropriate net.
  (setq master inst~>master)
  (unless (and master~>topLayer master~>topLayerPinBbox)
    (error (sprintf nil 
		    "Missing topLayer and/or topLayerPinBbox cell properties in `%s'" 
		    firstContact))
    )
  
  (setq bBox (list (list (minus (plus offset 
				      (caar master~>topLayerPinBbox))) 
			 (cadar master~>topLayerPinBbox))
		   (list (minus (plus offset 
				      (caadr master~>topLayerPinBbox))) 
			 (cadadr master~>topLayerPinBbox)))
	)
  (when (and lodEnabled manualLOD isSingleStrapped)
    ;;when a single strapped contact is used
    ;;and a contact CANNOT be accomodated within 
    ;;the specified offset
    ;;Let the pin remain on the single-strapped contact
    (unless (geqp (difference sa contactFLength) (plus offset requiredSpace innerContactLength))
      (setq bBox (list (list (minus (plus (difference sa contactFLength)
					  (caar master~>topLayerPinBbox))) 
			     (cadar master~>topLayerPinBbox))
		       (list (minus (plus (difference sa contactFLength)
					  (caadr master~>topLayerPinBbox))) 
			     (cadadr master~>topLayerPinBbox)))
	    )
      )
    )
  
   ;;; This pin cannot be accessed from the right side.
  (setq dbid (dbCreateRect tcCellView master~>topLayer bBox)) 
  (setq pinid (dbCreatePin cNet dbid))
  pinid~>accessDir = (list "top" "bottom" "left")
  
  ;;; Draw the appropriate label
  (when labelLayer
    (dbCreateLabel tcCellView labelLayer
		   (list (plus (caar bBox) (quotient (difference 
						      (caadr bBox) (caar bBox)) 2.0)) (plus (cadar bBox)
											    (quotient (difference (cadadr bBox) 
														  (cadar bBox)) 2.0))) netL 
														  "centerCenter" "R0" "roman" labelWidth)
    )
  
(unless lodEnabled
  ;; Set the lower X and Y Coordinate for the well or id layers when 
  ;; they are defined
  (when (or wellLayer idLayer secIdLayer)
    (unless master~>diffLayerBbox
      (error (sprintf nil "Cannot find diffLayerBbox property for `%s'" 
		      firstContact))
      )
    ;; Since this contact is always mirrored, we look at the x2Coord to 
    ;; find how much does diff Extend beyond the gate. However, the 
    ;; farthest point from the gate could also be tap. We take the maximum
    ;; overlap as calculated by well overlap + (diff/tap ext) beyond the 
    ;; gate. The above is repeated for the y1 and y2 coordinates. With 
    ;; the assumption, that these (y1,y2) parmaeters may reset again. 
    ;; This will not occur for now, but it would be easier to extend the 
    ;; present class to pass parameters for top and bottom tip-Taps, in 
    ;; future.
    (setq x1DiffCoord (caadr master~>diffLayerBbox))
    (setq x1TapCoord (if master~>tapLayerBbox 
			 (abs (caadr master~>tapLayerBbox)) 0.0))
    (setq y2DiffCoord (cadadr master~>diffLayerBbox))
    (setq y2TapCoord (if master~>tapLayerBbox 
			 (abs (cadadr master~>tapLayerBbox)) 0.0))
    (setq y1DiffCoord (cadar master~>diffLayerBbox))
    (setq y1TapCoord (if master~>tapLayerBbox 
			 (abs (cadar master~>tapLayerBbox)) 0.0))
    
    (when wellLayer
      (setq x1WellCoord (minus (plus offset (max (plus wellEncDiffX x1DiffCoord) (plus wellEncTapX x1TapCoord)))))
      (setq y1WellCoord (minus (max (plus wellEncDiffY y1DiffCoord) (plus wellEncTapY y1TapCoord))))
      (setq y2WellCoord (max (plus wellEncDiffY y2DiffCoord) (plus wellEncTapY y2TapCoord)))
      ) 
    
    (when idLayer
      (foreach layerInfo idLayersTable
	       (setq layerName  (car  layerInfo))
	       (setq layerEncs  (cadr layerInfo))
	       
	       (setq idEncXL  (nth 0 layerEncs))
	       (setq idEncXR  (nth 1 layerEncs))
	       (setq idEncY   (nth 2 layerEncs))
	       
	       (setq x1IdCoord (minus (plus offset 
					    (max   (plus idEncXL  x1DiffCoord) 
						   (plus idEncXL  x1TapCoord)))))
	       (setq y1IdCoord (minus (max  (plus  idEncY  y1DiffCoord)
					    (plus  idEncY  y1TapCoord))))
	       (setq y2IdCoord (max   (plus idEncY y2DiffCoord)
				      (plus idEncY y2TapCoord)))
	       
	       (setq layerCoords (list x1IdCoord:y1IdCoord x2IdCoord:y2IdCoord))
	       
	       idLayersCoordTable[layerName] = layerCoords
	       )
      )
    (when secIdLayer
      (foreach secLayerInfo secIdLayersTable
	       (setq secLayerName  (car  secLayerInfo))
	       (setq secLayerEncs  (cadr secLayerInfo))
	       
	       (setq secIdEncXL    (nth 0 secLayerEncs))
	       (setq secIdEncXR    (nth 1 secLayerEncs))
	       (setq secIdEncY     (nth 2 secLayerEncs))
	       
	       (setq x1SecIdCoord (minus (plus offset 
					    (max   (plus secIdEncXL  x1DiffCoord) 
						   (plus secIdEncXL  x1TapCoord)))))
	       (setq y1SecIdCoord (minus (max  (plus  secIdEncY  y1DiffCoord)
					    (plus  secIdEncY  y1TapCoord))))
	       (setq y2SecIdCoord (max   (plus secIdEncY y2DiffCoord)
				      (plus secIdEncY y2TapCoord)))
	       
	       (setq secLayerCoords (list x1SecIdCoord:y1SecIdCoord x2SecIdCoord:y2SecIdCoord))
	       secIdLayersCoordTable[secLayerName] = secLayerCoords
	       )
      )
    )
  
  
  )


(when lodEnabled
  (when (or wellLayer idLayer secIdLayer)
    (unless master~>diffLayerBbox
      (error (sprintf nil "Cannot find diffLayerBbox property for `%s'" 
		      firstContact))
      )
    ;; Since this contact is always mirrored, we look at the x2Coord to 
    ;; find how much does diff Extend beyond the gate. However, the 
    ;; farthest point from the gate could also be tap. We take the maximum
    ;; overlap as calculated by well overlap + (diff/tap ext) beyond the 
    ;; gate. The above is repeated for the y1 and y2 coordinates. With 
    ;; the assumption, that these (y1,y2) parmaeters may reset again. 
    ;; This will not occur for now, but it would be easier to extend the 
    ;; present class to pass parameters for top and bottom tip-Taps, in 
    ;; future.
    (setq x1DiffCoord (caadr master~>diffLayerBbox))
    (setq x1TapCoord (if master~>tapLayerBbox 
			 (abs (caadr master~>tapLayerBbox)) 0.0))
    (setq y2DiffCoord (cadadr master~>diffLayerBbox))
    (setq y2TapCoord (if master~>tapLayerBbox 
			 (abs (cadadr master~>tapLayerBbox)) 0.0))
    (setq y1DiffCoord (cadar master~>diffLayerBbox))
    (setq y1TapCoord (if master~>tapLayerBbox 
			 (abs (cadar master~>tapLayerBbox)) 0.0))
    
    (when manualLOD
      (when wellLayer
	(when isSingleStrapped
	  (setq x1WellCoord (minus (plus (difference sa (max x1DiffCoord x1TapCoord)) (max (plus wellEncDiffX x1DiffCoord) (plus wellEncTapX x1TapCoord)))))
	  )
	(unless isSingleStrapped
	  (when (or  (and (greaterp sa 1e-6) (greaterp offset 1e-6) (greaterp sa (plus offset contactFLength)))
		     (and (greaterp sa 1e-6) (equal offset 0.0) (geqp sa (plus offset contactFLength)))) 
	    (setq x1WellCoord (minus (plus (difference sa (max x1DiffCoord x1TapCoord)) (max (plus wellEncDiffX x1DiffCoord) (plus wellEncTapX x1TapCoord)))))
	    )
	  (when (or (and (greaterp offset 1e-6) (equal sa 0.0) (geqp (plus offset contactFLength) sa))
		    (and (greaterp offset 1e-6) (greaterp sa 1e-6) (geqp (plus offset contactFLength) sa)))
	    (setq x1WellCoord (minus (plus offset (max (plus wellEncDiffX x1DiffCoord) (plus wellEncTapX x1TapCoord)))))
	    )
	  )
	(setq y1WellCoord (minus (max (plus wellEncDiffY y1DiffCoord) (plus wellEncTapY y1TapCoord))))
        (setq y2WellCoord (max (plus wellEncDiffY y2DiffCoord) (plus wellEncTapY y2TapCoord)))
        ) 
      ;; Set the lower X and Y Coordinate for the well or id layers when 
      ;; they are defined
      (when idLayer
        (foreach layerInfo idLayersTable
        	 (setq layerName  (car  layerInfo))
        	 (setq layerEncs  (cadr layerInfo))
        	 
        	 (setq idEncXL  (nth 0 layerEncs))
        	 (setq idEncXR  (nth 1 layerEncs))
        	 (setq idEncY   (nth 2 layerEncs))
        	 
		 (when isSingleStrapped
		   (setq x1IdCoord (minus (plus (difference sa (max x1DiffCoord x1TapCoord)) (max (plus idEncXL x1DiffCoord) (plus idEncXL x1TapCoord)))))
		   )
		 (unless isSingleStrapped
        	 (when  (or  (and (greaterp sa 1e-6) (greaterp offset 1e-6) (greaterp sa (plus offset contactFLength)))
			     (and (greaterp sa 1e-6) (equal offset 0.0) (geqp sa (plus offset contactFLength)))) 
		   (setq x1IdCoord (minus (plus (difference sa (max x1DiffCoord x1TapCoord)) (max (plus idEncXL  x1DiffCoord) (plus idEncXL  x1TapCoord)))))
        	   )
        	 (when (or (and (greaterp offset 1e-6) (equal sa 0.0) (geqp (plus offset contactFLength) sa))
			   (and (greaterp offset 1e-6) (greaterp sa 1e-6) (geqp (plus offset contactFLength) sa)))
		   (setq x1IdCoord (minus (plus offset 
        					(max   (plus idEncXL  x1DiffCoord) 
        					       (plus idEncXL  x1TapCoord)))))
        	   )
		 )
        	 (setq y1IdCoord (minus (max  (plus  idEncY  y1DiffCoord)
        				      (plus  idEncY  y1TapCoord))))
        	 (setq y2IdCoord (max   (plus idEncY y2DiffCoord)
        				(plus idEncY y2TapCoord)))
        	 
        	 (setq layerCoords (list x1IdCoord:y1IdCoord x2IdCoord:y2IdCoord))
        	 
        	 idLayersCoordTable[layerName] = layerCoords
        	 )
        )

      (when secIdLayer
        (foreach secLayerInfo secIdLayersTable
        	 (setq secLayerName  (car  secLayerInfo))
        	 (setq secLayerEncs  (cadr secLayerInfo))
        	 
        	 (setq secIdEncXL  (nth 0 secLayerEncs))
        	 (setq secIdEncXR  (nth 1 secLayerEncs))
        	 (setq secIdEncY   (nth 2 secLayerEncs))
        	 
		 (when isSingleStrapped
		   (setq x1SecIdCoord (minus (plus (difference sa (max x1DiffCoord x1TapCoord)) (max (plus secIdEncXL x1DiffCoord) (plus secIdEncXL x1TapCoord)))))
		   )
		 (unless isSingleStrapped
        	 (when  (or  (and (greaterp sa 1e-6) (greaterp offset 1e-6) (greaterp sa (plus offset contactFLength)))
			     (and (greaterp sa 1e-6) (equal offset 0.0) (geqp sa (plus offset contactFLength)))) 
		   (setq x1SecIdCoord (minus (plus (difference sa (max x1DiffCoord x1TapCoord)) (max (plus secIdEncXL  x1DiffCoord) (plus secIdEncXL  x1TapCoord)))))
        	   )
        	 (when (or (and (greaterp offset 1e-6) (equal sa 0.0) (geqp (plus offset contactFLength) sa))
			   (and (greaterp offset 1e-6) (greaterp sa 1e-6) (geqp (plus offset contactFLength) sa)))
		   (setq x1SecIdCoord (minus (plus offset 
        					(max   (plus secIdEncXL  x1DiffCoord) 
        					       (plus secIdEncXL  x1TapCoord)))))
        	   )
		 )
        	 (setq y1SecIdCoord (minus (max  (plus  secIdEncY  y1DiffCoord)
        				      (plus  secIdEncY  y1TapCoord))))
        	 (setq y2SecIdCoord (max   (plus secIdEncY y2DiffCoord)
        				(plus secIdEncY y2TapCoord)))
        	 
        	 (setq secLayerCoords (list x1SecIdCoord:y1SecIdCoord x2SecIdCoord:y2SecIdCoord))
        	 secIdLayersCoordTable[secLayerName] = secLayerCoords
        	 )
        )
      
      )
   
    (when (not manualLOD)
      (when wellLayer
	(when isSingleStrapped
	  (setq x1WellCoord (minus (plus extension wellEncTapX)))
	  )
	(unless isSingleStrapped
	  (setq x1WellCoord (minus (plus extension wellEncDiffX)))
	  )
	(setq y1WellCoord (minus (max (plus wellEncDiffY y1DiffCoord) (plus wellEncTapY y1TapCoord))))
	(setq y2WellCoord (max (plus wellEncDiffY y2DiffCoord) (plus wellEncTapY y2TapCoord)))
	) 
      ;; Set the lower X and Y Coordinate for the well or id layers when 
      ;; they are defined
      (when idLayer
	(foreach layerInfo idLayersTable
		 (setq layerName  (car  layerInfo))
		 (setq layerEncs  (cadr layerInfo))
		 
		 (setq idEncXL  (nth 0 layerEncs))
		 (setq idEncXR  (nth 1 layerEncs))
		 (setq idEncY   (nth 2 layerEncs))
		 (setq x1IdCoord (minus (plus extension idEncXL)))
		 (setq y1IdCoord (minus (max  (plus  idEncY  y1DiffCoord)
					      (plus  idEncY  y1TapCoord))))
		 (setq y2IdCoord (max   (plus idEncY y2DiffCoord)
					(plus idEncY y2TapCoord)))
		 (setq layerCoords (list x1IdCoord:y1IdCoord x2IdCoord:y2IdCoord))
		 idLayersCoordTable[layerName] = layerCoords
		 )
	);when id layer
      (when secIdLayer
	(foreach secLayerInfo secIdLayersTable
		 (setq secLayerName  (car  secLayerInfo))
		 (setq secLayerEncs  (cadr secLayerInfo))
		 
		 (setq secIdEncXL  (nth 0 secLayerEncs))
		 (setq secIdEncXR  (nth 1 secLayerEncs))
		 (setq secIdEncY   (nth 2 secLayerEncs))
		 (setq x1SecIdCoord (minus (plus extension secIdEncXL)))
		 (setq y1SecIdCoord (minus (max  (plus  secIdEncY  y1DiffCoord)
						 (plus  secIdEncY  y1TapCoord))))
		 (setq y2SecIdCoord (max   (plus secIdEncY y2DiffCoord)
					   (plus secIdEncY y2TapCoord)))
		 (setq secLayerCoords (list x1SecIdCoord:y1SecIdCoord x2SecIdCoord:y2SecIdCoord))
		 secIdLayersCoordTable[secLayerName] = secLayerCoords
		 )
	);when sec id layer
      );when symbolic lod
    );when idlayer or welllayer
  );when lod enabled

(when (and diffImplant implant)
  ;; this shape only meets vertical enclosure to keep from overlapping the 
  ;; contact when there is no contact, we add the horizontal enclosure
  (dbCreateRect tcCellView diffImplant
		(list
		 (list (difference x1Coord diffExt)
		       (difference y1Coord diffImpEnc))
		 (list x1Coord
		       (plus w       diffImpEnc) 
		       )
		 )
		)
  )

(when (and diffCoreImplant implant)
  ;; this shape only meets vertical enclosure to keep from overlapping the 
  ;; contact when there is no contact, we add the horizontal enclosure
  (dbCreateRect tcCellView diffCoreImplant
		(list
		 (list (difference x1Coord diffExt)
		       (difference y1Coord diffCoreImpEnc))
		 (list x1Coord
		       (plus w       diffCoreImpEnc)
		       )
		 )
		)
  )

;; Close the opened cell View
(dbClose contactId)
) ;; end when firstContact

;; For the first and the last diffusions we should also define a 
;; diffusion pin to allow parallel transistor placement.
(setq dbid (dbCreateRect tcCellView diffLayer 
			 (list (difference x1Coord diffExt):y1Coord 
			       x1Coord:w))) 

(setq pinid (dbCreatePin cNet dbid))
pinid~>accessDir = (list "top" "bottom" "left")

(when secIdLayer
  (foreach secLayerInfo secIdLayersTable
	   (setq secLayerName   (car  secLayerInfo))
           (setq secLayerCoords secIdLayersCoordTable[secLayerName])
	   (dbCreateRect tcCellView secLayerName secLayerCoords)
	   )
 )

;; Calculate the well coordinates and place label.
(when (equal firstContact "")
  (when (and diffImplant implant)
    ;; this shape only meets vertical enclosure to keep from overlapping the 
    ;; contact when there is no contact, we add the horizontal enclosure
    (dbCreateRect tcCellView diffImplant
		  (list
		   (list (difference x1Coord diffExt diffImpEnc)
			 (difference y1Coord diffImpEnc))
		   (list x1Coord
			 (plus w       diffImpEnc) 
			 )
		   )
		  )
    )
  
  (when (and diffCoreImplant implant)
    ;; this shape only meets vertical enclosure to keep from overlapping the 
    ;; contact when there is no contact, we add the horizontal enclosure
    (dbCreateRect tcCellView diffCoreImplant
		  (list
		   (list (difference x1Coord diffExt diffCoreImpEnc)
			 (difference y1Coord diffCoreImpEnc))
		   (list x1Coord
			 (plus w       diffCoreImpEnc)
			 )
		   )
		  ) 
    )
  (when (and lodEnabled (not manualLOD) (geqp buttingGatesSA 1))
    
    ;;Even number of imaginary gates
    (when (equal (mod buttingGatesSA 2) 0)
      ;;Calculate extension
      (setq extension (plus contactFLength
			    (times (quotient buttingGatesSA 2) curTermShConLength)
			    (times buttingGatesSA curTermOffset)
			    (times (quotient   buttingGatesSA 2) nextTermShConLength)
			    (times buttingGatesSA nextTermOffset)
			    (times buttingGatesSA l)
			    ))
      )
    
    ;;Odd number of imaginary gates
    (unless (equal (mod buttingGatesSA 2) 0)
      ;;Calculate extension
      (setq extension (plus contactFLength
			    (times (quotient (plus buttingGatesSA 1) 2) curTermShConLength)
			    (times (plus buttingGatesSA 1) curTermOffset)
			    (times (quotient (difference buttingGatesSA 1) 2) nextTermShConLength)
			    (times (difference buttingGatesSA 1) nextTermOffset)
			    (times buttingGatesSA l)
			    ))
      )

    (dbCreateRect tcCellView diffLayer 
			 (list (minus  extension):y1Coord 
			       (difference x1Coord diffExt):w))
    (when (and diffImplant implant)
      ;; this shape only meets vertical enclosure to keep from overlapping the 
      ;; contact when there is no contact, we add the horizontal enclosure
      (dbCreateRect tcCellView diffImplant
		    (list
		     (list (minus (plus extension diffImpEnc))
			   (difference y1Coord diffImpEnc))
		     (list (difference x1Coord diffExt)
			   (plus w       diffImpEnc) 
			   )
		     )
		    )
      )
    (when (and diffCoreImplant implant)
      ;; this shape only meets vertical enclosure to keep from overlapping the 
      ;; contact when there is no contact, we add the horizontal enclosure
      (dbCreateRect tcCellView diffCoreImplant
		    (list
		     (list (minus (plus extension diffCoreImpEnc))
			   (difference y1Coord diffCoreImpEnc))
		     (list (difference x1Coord diffExt)
			   (plus w       diffCoreImpEnc) 
			   )
		     )
		    )
      )

    
    
    );when

  (when (and lodEnabled manualLOD (greaterp sa diffExt))
    (dbCreateRect tcCellView diffLayer 
			 (list (minus  sa):y1Coord 
			       (difference x1Coord diffExt):w))

    (when (and diffImplant implant)
      ;; this shape only meets vertical enclosure to keep from overlapping the 
      ;; contact when there is no contact, we add the horizontal enclosure
      (dbCreateRect tcCellView diffImplant
		    (list
		     (list (minus (plus sa diffImpEnc))
			   (difference y1Coord diffImpEnc))
		     (list (difference x1Coord diffExt)
			   (plus w       diffImpEnc) 
			   )
		     )
		    )
      )
    (when (and diffCoreImplant implant)
      ;; this shape only meets vertical enclosure to keep from overlapping the 
      ;; contact when there is no contact, we add the horizontal enclosure
      (dbCreateRect tcCellView diffCoreImplant
		    (list
		     (list (minus (plus sa diffCoreImpEnc))
			   (difference y1Coord diffCoreImpEnc))
		     (list (difference x1Coord diffExt)
			   (plus w       diffCoreImpEnc) 
			   )
		     )
		    )
      )
    );when
  ;; draw the appropriate label at the center of the difflayer
  (when labelLayer
    (dbCreateLabel tcCellView labelLayer 
		   (list (minus (plus x1Coord (quotient diffExt 2.0))) 
			 (plus y1Coord (quotient w 2.0))) netL 
			 "centerCenter" "R0" "roman" labelWidth)
    )
  
  ;; When first Contact is not defined then the lower well coordinate is 
  ;; given by diffusion extension.
  (when wellLayer
    (setq x1WellCoord (minus (plus x1Coord diffExt wellEncDiffX)))
    ;;overwrite the value under the following conditions
    (when (and lodEnabled (not manualLOD) (geqp buttingGatesSA 1))
      (setq x1WellCoord (minus (plus x1Coord extension wellEncDiffX)))
      )
    (when (and lodEnabled manualLOD (greaterp sa diffExt))
      (setq x1WellCoord (minus (plus x1Coord sa wellEncDiffX)))
      )
    (setq y1WellCoord (minus (plus y1Coord wellEncDiffY)))
    (setq y2WellCoord (plus y1Coord w wellEncDiffY))	
    )
  
  (when idLayer
    (foreach layerInfo idLayersTable
	     (setq layerName  (car  layerInfo))
	     (setq layerEncs  (cadr layerInfo))
	     
	     (setq idEncXL  (nth 0 layerEncs))
	     (setq idEncXR  (nth 1 layerEncs))
	     (setq idEncY   (nth 2 layerEncs))
	     
	     ;;get the coordinates to prevent overwriting them by a prior computation
	     (setq x1IdCoord (nth 0 (car  idLayersCoordTable[layerName])))
	     (setq y1IdCoord (nth 1 (car  idLayersCoordTable[layerName])))
	     (setq x2IdCoord (nth 0 (cadr idLayersCoordTable[layerName])))
	     (setq y2IdCoord (nth 1 (cadr idLayersCoordTable[layerName])))
	     
	     (setq x1IdCoord (minus (plus x1Coord diffExt idEncXL))) 
	     (when (and lodEnabled (not manualLOD) (geqp buttingGatesSA 1))
	       (setq x1IdCoord (minus (plus x1Coord extension idEncXL))) 
	       )
	     (when (and lodEnabled manualLOD (greaterp sa diffExt))
	       (setq x1IdCoord (minus (plus x1Coord sa idEncXL))) 
	       )
	     (setq y1IdCoord (minus (plus y1Coord idEncY)))
	     (setq y2IdCoord (plus y1Coord w idEncY))
	     
	     (setq layerCoords (list x1IdCoord:y1IdCoord x2IdCoord:y2IdCoord))
	     
	     idLayersCoordTable[layerName] = layerCoords
	     )
    )
  
  (when secIdLayer
    (foreach secLayerInfo secIdLayersTable
	     (setq secLayerName  (car  secLayerInfo))
	     (setq secLayerEncs  (cadr secLayerInfo))
	     
	     (setq secIdEncXL    (nth 0 secLayerEncs))
	     (setq secIdEncXR    (nth 1 secLayerEncs))
	     (setq secIdEncY     (nth 2 secLayerEncs))
	     
	     ;;get the coordinates to prevent overwriting them by a prior computation
	     (setq x1SecIdCoord (nth 0 (car  secIdLayersCoordTable[secLayerName])))
	     (setq y1SecIdCoord (nth 1 (car  secIdLayersCoordTable[secLayerName])))
	     (setq x2SecIdCoord (nth 0 (cadr secIdLayersCoordTable[secLayerName])))
	     (setq y2SecIdCoord (nth 1 (cadr secIdLayersCoordTable[secLayerName])))
	     
	     (setq x1SecIdCoord (minus (plus x1Coord diffExt secIdEncXL))) 
	     (when (and lodEnabled (not manualLOD) (geqp buttingGatesSA 1))
	       (setq x1SecIdCoord (minus (plus x1Coord extension secIdEncXL))) 
	       )
	     (when (and lodEnabled manualLOD (greaterp sa diffExt))
	       (setq x1SecIdCoord (minus (plus x1Coord sa secIdEncXL))) 
	       )
	     (setq y1SecIdCoord (minus (plus y1Coord secIdEncY)))
	     (setq y2SecIdCoord (plus y1Coord w secIdEncY))
	     
	     (setq secLayerCoords (list x1SecIdCoord:y1SecIdCoord x2SecIdCoord:y2SecIdCoord))
	     
	     secIdLayersCoordTable[secLayerName] = secLayerCoords
	     )
    (foreach secLayerInfo secIdLayersTable
	     (setq secLayerName   (car  secLayerInfo))
	     (setq secLayerCoords secIdLayersCoordTable[secLayerName])
	     (dbCreateRect tcCellView secLayerName secLayerCoords)
	     )
    )
  
  ) ;; end when not firstContact

 ;;; The following only need to be checked if m > 1 
 ;;; (if m == 0, we reset it to 1)
(when (greaterp m 1)
  ;; The shared source contact, if this field is empty -- error, get the id.
  ;; If cannot find the cell -- error. The cell should be in the same library
  ;; as the current pcell is.
  (when (nequal sharedSource "")
    (setq sharedSrcId (dbOpenCellView tcCellView~>lib sharedSource 
				      "symbolic" nil "rn"))
    
    (unless (nequal sharedSource "")
      (error (sprintf nil "Cannot find/open shared source contact cell `%s'" 
		      sharedSource))
      )
    
    (unless  sharedSrcId~>isParamCell 
      (error (sprintf nil "Named cell is not a pcell `%s'" sharedSource))
      )
    );;when
  
  ;; The shared drain contact, if this field is empty -- error, get the id.
  ;; If cannot find the cell -- error. The cell should be in the same 
  ;; library as the current pcell is.
  (when (nequal sharedDrain "")
    (setq sharedDrnId (dbOpenCellView tcCellView~>lib sharedDrain 
				      "symbolic" nil "rn"))
    (unless sharedDrnId
      (error (sprintf nil "Cannot find/open shared drain contact cell `%s'" 
		      sharedDrain))
      )
    (unless sharedDrnId~>isParamCell
      (error (sprintf nil "Named cell is not a pcell `%s'" sharedDrain))
      )
    );;when
  )

 ;;; reset the current net and the label to be drawn.
(setq cNet (if (equal cNet sNet) dNet sNet))
(setq netL (if (equal netL "S") "D" "S"))

 ;;; now create the rest of the geometries etc.
(for n 1 m

      ;;; Create the gate region
     (setq dbid (dbCreateRect tcCellView gateLayer 
			      (list x1Coord:(difference y1Coord gateExt)
				    (plus x1Coord l):(plus y1Coord w gateExt))
			      )
	   )
     
     (dbAddFigToNet dbid gNet)
     
      ;;; Create the two pins (one on top and another on bottom).
      ;;; When "Automatic keepouts for MOS gates" is used with CCT, the 
      ;;; abstract creation breaks the pins. However, if we use diffusion 
      ;;; as a poly keepout and do not use the automatic keepouts for MOS 
      ;;; gates, then the gate pin may be used as a feed through.
     
      ;;; First Create the top pin
     (setq dbid (dbCreateRect tcCellView gateLayer 
			      (list x1Coord:(plus y1Coord w)
				    (plus x1Coord l):(plus y1Coord w gateExt)))
	   ) 
     (setq pinid (dbCreatePin gNet dbid))
     pinid~>accessDir = (list "top")
     
     ;; Then the bottom pin.
     (setq dbid (dbCreateRect tcCellView gateLayer
			      (list x1Coord:(difference y1Coord gateExt)
				    (plus x1Coord l):y1Coord))
	   )
     (setq pinid (dbCreatePin gNet dbid))
     pinid~>accessDir = (list "bottom")
     
     ;; Create the floating diffusion under the gate region
     (dbCreateRect tcCellView diffLayer (list x1Coord:y1Coord 
					      (plus x1Coord l):(plus y1Coord w))
		    )
      
      
      ;;; Create the implant under this diffusion
      ;;; This implant meets enclosure in the vertical direction.
      ;;; when there is no contact on this end, we draw another
      ;;; shape to meet horizontal enclosure
     (when (and diffImplant implant)
       (dbCreateRect tcCellView diffImplant
		     (list
		      (list x1Coord
			    (difference y1Coord diffImpEnc))
		      (list (plus x1Coord l)
			    (plus (plus y1Coord w) diffImpEnc))
		      )
		     )
       )
     
     (when (and diffCoreImplant implant)
       (dbCreateRect tcCellView diffCoreImplant
		     (list
		      (list x1Coord
			     (difference y1Coord diffCoreImpEnc))
		      (list (plus x1Coord l)
			    (plus (plus y1Coord w) diffCoreImpEnc))
		      )
		     )
       )
     
      ;;; If the poly implant layer is defined draw it on top of the gate region
     (when (and polyImplant implant gateImplant)
       (setq x1PYiCoord (difference x1Coord polyImpXEnc))
       (dbCreateRect tcCellView polyImplant (list x1PYiCoord:y1PYiCoord
						  (plus x1Coord l polyImpXEnc):y2PYiCoord))
       )
     
      ;;; increment the x1Coord to next gate edge
     (setq x1Coord (plus x1Coord l))
     

     
     (if (equal cNet sNet) then
       (setq currentContact sharedSource)
       (setq currentNet sNet)
       (setq offset (plus minSpaceOffSet srcOffset))
       (setq secIdLayer srcSecIdLayer)
       (when secIdLayer
	 (setq secIdLayersTable srcSecIdLayersTable)
	 )
       else
       (setq currentContact sharedDrain)
       (setq currentNet dNet)
       (setq offset (plus minSpaceOffSet drnOffset))
       (setq secIdLayer drnSecIdLayer)
       (when secIdLayer
	 (setq secIdLayersTable drnSecIdLayersTable)
	 )
       )
     
      ;;; Create the contact for the second terminal
     (when (and (nequal n m) (nequal currentContact ""))
       (if (equal cNet sNet) then
	 (setq contactId sharedSrcId)
	 (setq offset        (plus minSpaceOffSet srcOffset))
	 else
	 (setq contactId sharedDrnId)
	 (setq offset (plus minSpaceOffSet drnOffset))
	 )
       
       (setq params contactId~>parameters)
       (setq instParams (list (list "w" "float" w)))
       (when params~>implant
	 (setq instParams (xcons instParams contactImpParam))
	 )
       (when params~>inWell
	 (setq instParams (xcons instParams contactWellParam))
	 )
       
       (setq inst (dbCreateParamInst tcCellView contactId 
				     (sprintf nil "c%d" n)
				     (plus offset x1Coord):y1Coord "R0" 1 instParams)
	     )
       (unless inst
	 (error (sprintf nil "Failed to create instance of `%s'" 
			 contactId~>cellName))
	 )
	  ;;; Create a rectangle from the specified topLayer and 
	  ;;; topLayerPinBbox of of the created instance. And put the 
	  ;;; proper pin on it
       (setq master inst~>master)
	(unless (and master~>topLayer master~>topLayerPinBbox)
	  (error (sprintf nil 
			  "Missing topLayer and/or topLayerPinBbox cell properties in `%s'"
			  contactId~>cellName))
	  )

	(setq bBox (list (list (plus (caar master~>topLayerPinBbox) x1Coord 
				     offset) (cadar master~>topLayerPinBbox))
			 (list (plus (caadr master~>topLayerPinBbox) 
				     x1Coord offset) (cadadr master~>topLayerPinBbox)))
	      )
	
	;; Since this source/drain pin is inside, it can only be accessed 
	;; from top or bottom.
	(setq dbid (dbCreateRect tcCellView master~>topLayer bBox))
	(setq pinid (dbCreatePin cNet dbid))
	pinid~>accessDir = (list "top" "bottom")
	
	;; Draw the label, if allowed (The label is drawn at the center of 
	;; the top layer bbox)
	(when labelLayer
	  (dbCreateLabel tcCellView labelLayer 
			 (list (plus (caar bBox) (quotient (difference 
							    (caadr bBox) (caar bBox)) 2.0)) (plus (cadar bBox) 
												  (quotient (difference (cadadr bBox) (cadar bBox)) 
													    2.0))) 
			 netL "centerCenter" "R0" "roman" labelWidth)
	  )
	  ;;; Create a piece of diffusion to cover up the space between the 
	  ;;; gate and the contact, if offset > zero.
	(when (greaterp offset 1e-6)
	  (dbCreateRect tcCellView diffLayer (list x1Coord:y1Coord
						   (plus offset x1Coord):(plus y1Coord w))
			)
	      ;;; we count on the contact to correctly implant itself, and 
	      ;;; only implant to the contact-diff edge. we do meet vertical 
	      ;;; enclosure
	  (when (and diffImplant implant)
	    (dbCreateRect tcCellView diffImplant
			  (list
			   (list x1Coord
				 (difference y1Coord diffImpEnc))
			   (list (plus offset x1Coord)
				 (plus (plus y1Coord w) diffImpEnc))
			   )
			  )
	    )
	  
	  (when (and diffCoreImplant implant)
	    (dbCreateRect tcCellView diffCoreImplant
			  (list
			   (list x1Coord
				 (difference y1Coord diffCoreImpEnc))
			   (list (plus offset x1Coord)
				 (plus (plus y1Coord w) diffCoreImpEnc))
			   )
			  )
	    )
	  
	  
	  )
	
	
	(unless master~>diffLayerBbox
	  (error (sprintf nil 
			  "Missing diffLayerBbox cell properties in `%s'" 
			  contactId~>cellName))
	  )
	  ;;; increment x1Coord to next gate's first edge, after storing 
	  ;;; the last gate edge the offset parameter in the hand of the 
	  ;;; designers, should be used to satisfy any li1-li1, poly-poly 
	  ;;; spacing problems.
	  (setq x1Coord (plus (times 2.0 offset)
			(plus x1Coord (difference (caadr master~>diffLayerBbox)
				      (caar master~>diffLayerBbox)))
			)
		)
	  ;;; Create another piece of diffusion to cover up the space 
	  ;;; between the gate and the contact, if offset > zero.
	  (when (greaterp offset 1e-6)
	    (dbCreateRect tcCellView diffLayer 
			  (list (difference x1Coord offset):y1Coord
				x1Coord:(plus y1Coord w))
			  )
	    ;; we count on the contact to correctly implant itself, and 
	    ;; only implant to the contact-diff edge. we do meet vertical 
	    ;; enclosure
	    (when (and diffImplant implant)
		(dbCreateRect tcCellView diffImplant 
			      (list
			       (list (difference x1Coord offset)
				     (difference y1Coord diffImpEnc))
			       (list x1Coord
				     (plus (plus y1Coord w) diffImpEnc))
			       )
			      )
		)
	    
	    (when (and diffCoreImplant implant)
	      (dbCreateRect tcCellView diffCoreImplant 
			    (list
			     (list (difference x1Coord offset)
				   (difference y1Coord diffCoreImpEnc))
			     (list x1Coord
				   (plus (plus y1Coord w) diffCoreImpEnc))
			     )
			    )
	      )
	    
	  )
	  

	  ;; Give the master of the contact just placed, recalculate the 
	  ;; well overlaps in y direction. The maximum well overlaps 
	  ;; should be used.
	  (setq x1DiffCoord (caar master~>diffLayerBbox))
	  (setq x1TapCoord (if master~>tapLayerBbox 
			       (abs (caar master~>tapLayerBbox)) 0.0))
	  (setq y1DiffCoord (cadar master~>diffLayerBbox))
	  (setq y1TapCoord  (if master~>tapLayerBbox (abs (cadar master~>tapLayerBbox)) 0.0))
	  (setq y2DiffCoord (cadadr master~>diffLayerBbox))
	  (setq y2TapCoord  (if master~>tapLayerBbox (abs (cadadr master~>tapLayerBbox)) 0.0))
	  (setq x2DiffCoord (caadr master~>diffLayerBbox))
	  (setq x2TapCoord (if master~>tapLayerBbox (abs (caadr master~>tapLayerBbox)) 0.0))
	  (when wellLayer
	    ;;; remember, (max (abs -1) (abs -2)) = (min -1 -2)
	    (setq y1WellCoord (min (minus (max (plus wellEncDiffY y1DiffCoord) (plus wellEncTapY y1TapCoord)))
				   y1WellCoord))
	    (setq y2WellCoord (max (plus wellEncDiffY y2DiffCoord) (plus wellEncTapY y2TapCoord) y2WellCoord))
	    )
	  
	  (when idLayer
	    (foreach layerInfo idLayersTable
		     (setq layerName  (car  layerInfo))
		     (setq layerEncs  (cadr layerInfo))
		     
		     (setq idEncXL  (nth 0 layerEncs))
		     (setq idEncXR  (nth 1 layerEncs))
		     (setq idEncY   (nth 2 layerEncs))
		     
		     ;;get the y1id & y2id coordinates to compare to the new computed one
		     ;;get the other coordinates to prevent overwriting them by a prior computation
		     (setq x1IdCoord (nth 0 (car  idLayersCoordTable[layerName])))
		     (setq y1IdCoord (nth 1 (car  idLayersCoordTable[layerName])))
		     (setq x2IdCoord (nth 0 (cadr idLayersCoordTable[layerName])))
		     (setq y2IdCoord (nth 1 (cadr idLayersCoordTable[layerName])))
		     
                     ;;; remember, (max (abs -1) (abs -2)) = (min -1 -2)
		     (setq y1IdCoord   (min (minus (max (plus idEncY y1DiffCoord) (plus idEncY y1TapCoord))) y1IdCoord))
		     (setq y2IdCoord   (max (plus idEncY y2DiffCoord) (plus idEncY y2TapCoord) y2IdCoord))
		     
		     (setq layerCoords (list x1IdCoord:y1IdCoord x2IdCoord:y2IdCoord))
		     idLayersCoordTable[layerName] = layerCoords
		     )
	    )


	  (when secIdLayer
	    (foreach secLayerInfo secIdLayersTable
		     (setq secLayerName  (car  secLayerInfo))
		     (setq secLayerEncs  (cadr secLayerInfo))
		     
		     (setq secIdEncXL    (nth 0 secLayerEncs))
		     (setq secIdEncXR    (nth 1 secLayerEncs))
		     (setq secIdEncY     (nth 2 secLayerEncs))
		     
		     (setq x1SecIdCoord  x1Coord)
		     (setq y1SecIdCoord  (minus (max  (plus  secIdEncY  y1DiffCoord)
						      (plus  secIdEncY  y1TapCoord))))
		     (setq x2SecIdCoord  (difference x1SecIdCoord (plus (times 2 offset) 
									(max   x2DiffCoord x2TapCoord))))
		     
		     
		     (setq y2SecIdCoord  (max   (plus secIdEncY y2DiffCoord)
					        (plus secIdEncY y2TapCoord)))
		     
		     (setq secLayerCoords (list x1SecIdCoord:y1SecIdCoord x2SecIdCoord:y2SecIdCoord))
		     secIdLayersCoordTable[secLayerName] = secLayerCoords
		     )
	    
	    (foreach secLayerInfo secIdLayersTable
		     (setq secLayerName   (car  secLayerInfo))
		     (setq secLayerCoords secIdLayersCoordTable[secLayerName])
		     (dbCreateRect tcCellView secLayerName secLayerCoords)
		     )
 
	    )
	  
	  
	  )
     
     ;;when the shared source drains have no contact option
     (when (and (nequal n m) (equal currentContact ""))
       (setq oldx1Coord x1Coord)
       (setq x1Coord (plus (times 2.0 offset)
			   (plus x1Coord gatetogateSpacing)			    
			   )
	     )
       
       (setq dbid (dbCreateRect tcCellView diffLayer 
				(list oldx1Coord:y1Coord  
				      x1Coord:w)))
       (setq pinid (dbCreatePin cNet dbid))
       pinid~>accessDir = (list "top" "bottom")
       (setq diffbBox (list oldx1Coord:y1Coord  
			    x1Coord:w))
       (when labelLayer
	 (dbCreateLabel tcCellView labelLayer 
			(list (plus (caar diffbBox) (quotient (difference 
							       (caadr diffbBox) (caar diffbBox)) 2.0)) (plus (cadar diffbBox) 
									      (quotient (difference (cadadr diffbBox) (cadar diffbBox)) 
											2.0))) 
			netL "centerCenter" "R0" "roman" labelWidth)
	 )
       (when (and diffImplant implant)
	 ;; this shape only meets vertical enclosure to keep from overlapping the 
	 ;; contact when there is no contact, we add the horizontal enclosure
	 (dbCreateRect tcCellView diffImplant
		       (list
			(list oldx1Coord
			       (difference y1Coord diffImpEnc))
			(list x1Coord
			      (plus w       diffImpEnc) 
			      )
			)
			) 
	 )
       (when (and diffCoreImplant implant)
	 (dbCreateRect tcCellView diffCoreImplant 
		       (list
			(list oldx1Coord
			      (difference y1Coord diffCoreImpEnc))
			(list x1Coord
			      (plus w diffCoreImpEnc))
			)
		       ) 
	 )
       )
     
      (when (and diffImplant implant)
	;; this shape only meets vertical enclosure to keep from overlapping the 
	;; contact when there is no contact, we add the horizontal enclosure
	(dbCreateRect tcCellView diffImplant
		      (list
		       (list (difference x1Coord diffExt)
			     (difference y1Coord diffImpEnc))
		       (list x1Coord
			     (plus w       diffImpEnc) 
			     )
		       )
		      )  
	)
      
      (when (and diffCoreImplant implant)
	;; this shape only meets vertical enclosure to keep from overlapping the 
	;; contact when there is no contact, we add the horizontal enclosure
	(dbCreateRect tcCellView diffCoreImplant
		      (list
		       (list (difference x1Coord diffExt)
			     (difference y1Coord diffCoreImpEnc))
		       (list x1Coord
			     (plus w       diffCoreImpEnc)
			     )
		       )
		      )  
	)
      
      (setq cNet (if (equal cNet sNet) dNet sNet))
      (setq netL (if (equal netL "S") "D" "S"))
      )

(when (nequal m 1) 
  ;; Close the opened cell views of the shared src and drn contacts
  (when (nequal sharedSource "")
    (dbClose sharedSrcId))
  (when (nequal sharedDrain "")
    (dbClose sharedDrnId))
  )


;; reset the current net and the net labels once again.
(setq cNet (if (equal cNet sNet) dNet sNet))
(setq netL (if (equal netL "S") "D" "S"))
(if (equal cNet sNet) then
    (setq offset (plus minSpaceOffSet srcOffset))
    ;;the following variables are used in extension calculation
    ;;under symbolic LOD selection
    (setq curTermOffset offset);source term offset 
    (setq nextTermOffset (plus minSpaceOffSet drnOffset)) ;drain term offset
    (setq curTermShConLength  contactSLength);shared source contact length
    (setq nextTermShConLength contactDLength);shared drain contact length
    (setq secIdLayer srcSecIdLayer)
    (when secIdLayer
      (setq secIdLayersTable srcSecIdLayersTable)
      )
    else
    (setq offset (plus minSpaceOffSet drnOffset))
    ;;the following variables are used in extension calculation
    ;;under symbolic LOD selection
    (setq curTermOffset offset);drain term offset
    (setq nextTermOffset (plus minSpaceOffSet srcOffset));source term offset
    (setq curTermShConLength  contactDLength);shared drain contact length
    (setq nextTermShConLength contactSLength);shared source contact length
    (setq secIdLayer drnSecIdLayer)
    (when secIdLayer
      (setq secIdLayersTable drnSecIdLayersTable)
      )
    )

 ;;; Finally the lastContact contact, see if the field is defined and get the 
 ;;; id. If cannot find the cell -- error. The cell should be in the same 
 ;;; library as the current pcell is.

(when (nequal lastContact "")
  (setq contactId (dbOpenCellView tcCellView~>lib lastContact 
				  "symbolic" nil "rn"))
  (unless contactId
    (error (sprintf nil "Cannot find/open lastContact contact cell `%s'" 
		    lastContact))
    )
  (unless contactId~>isParamCell
    (error (sprintf nil "Named cell is not a pcell `%s'" lastContact))
    )
  
  (setq params contactId~>parameters)
  (setq instParams (list (list "w" "float" w)))
  (when params~>implant
    (setq instParams (xcons instParams contactImpParam))
    )
  (when params~>inWell
    (setq instParams (xcons instParams contactWellParam))
    )
  
  (setq inst (dbCreateParamInst tcCellView contactId (sprintf nil "c%d" m)
				(plus offset x1Coord):y1Coord "R0" 1 instParams)
	)
  (unless inst
    (error "Failed to create instance of last contact")
    )
  
  
  (unless lodEnabled
    (when (greaterp offset 1e-6)
      (dbCreateRect tcCellView diffLayer (list  x1Coord:y1Coord
						(plus offset x1Coord):(plus y1Coord w))
		    )
      ;; we count on the contact to correctly implant itself, and only 
      ;; draw horizontally to the edge of the contact. we do meet 
      ;; vertical enclosure with this shape
      (when (and diffImplant implant)
	(dbCreateRect tcCellView diffImplant 
		      (list
		       (list x1Coord
			     (difference y1Coord diffImpEnc))
		       (list (plus offset x1Coord)
			     (plus (plus y1Coord w) diffImpEnc))
		       )
		      )
	)
      (when (and diffCoreImplant implant)
	(dbCreateRect tcCellView diffCoreImplant 
		      (list
		       (list x1Coord
			     (difference y1Coord diffCoreImpEnc))
		       (list (plus offset x1Coord)
			     (plus (plus y1Coord w) diffCoreImpEnc))
		       )
		      )
	)
      )
    
    );unless
  
  (when lodEnabled
    (setq isSingleStrapped nil);;Set to true when contact is single-strapped
    (setq isNDStrapped     nil);;Set to true when contact is non-strapped or double-strapped
    ;;When Numeric LOD is selected
    (when manualLOD
      (when LODContactMapSStrapped
	(foreach pair LODContactMapSStrapped
		 (when (equal lastContact (car pair))
		   (setq isSingleStrapped t)
		   (setq innerContact     (cdr pair))
		   )
		 )
	)
      
      (when isSingleStrapped
	;;Always move the strapped contact to the right edge
	;;Accomodate a non-strapped contact pcell if there is enough room 
	;;between the (gate + offset) and the strapped-contact
	;;If there isn't enough room, then place the strapped-contact at 
	;;the end
	;;
	;;Net will be placed on the inner contact when inner contact exists
	;;Nets will be placed on the strapped-contact when there is no room for an inner contact
	;;
	
	(dbDeleteObject inst)
	(dbClose contactId)
	
	(setq innerContactId (dbOpenCellView tcCellView~>lib (car innerContact) "symbolic" nil "rn"))
	(unless innerContactId~>isParamCell
	  (error (sprintf nil "Named cell is not a pcell `%s'" innerContact)))
	;;Calculate the length of inner contact
	(setq innerContactLength (difference  (caadr innerContactId~>diffLayerBbox)  (caar innerContactId~>diffLayerBbox)))
	;;Calculate required space between inner and outer contact
	(setq via1XCrdInnerCon   (if innerContactId~>bBoxVia1
				     (abs (caar innerContactId~>bBoxVia1)) nil
				     ))
	(setq layer2XCrdInnerCon   (if innerContactId~>bBoxLayer2
				     (abs (caar innerContactId~>bBoxLayer2)) nil
				     ))
	(setq via2XCrdInnerCon   (if innerContactId~>bBoxVia2
				     (abs (caar innerContactId~>bBoxVia2)) nil
				     ))
	(setq layer3XCrdInnerCon   (if innerContactId~>bBoxLayer3
				     (abs (caar innerContactId~>bBoxLayer3)) nil
				     ))
	(setq layer1XCrdInnerCon   (if innerContactId~>diffLayerBbox
				     (abs (caar innerContactId~>diffLayerBbox)) nil
				     ))
	
	(if (and  layer1XCrdInnerCon via1XCrdInnerCon) then 
	  (setq via1EncInnerCon    (abs (difference layer1XCrdInnerCon via1XCrdInnerCon)))
	  )
	(if (and  layer2XCrdInnerCon via2XCrdInnerCon) then 
	  (setq via2EncInnerCon    (abs (difference layer1XCrdInnerCon via2XCrdInnerCon)))
	  )
	
	(if (and via1EncInnerCon via1EncL) then
	  (setq availableVia1Space (plus via1EncInnerCon via1EncL))
	  (if (greaterp via1MinSpace  availableVia1Space) then
	    (setq requiredVia1Sp (difference via1MinSpace availableVia1Space))
	    else
	    (setq requiredVia1Sp 0)
	    )
	  )

	(if (and via2EncInnerCon via2EncL) then
	  (setq availableVia2Space (plus via2EncInnerCon via2EncL))
	  (if (greaterp via2MinSpace  availableVia2Space) then
	    (setq requiredVia2Sp (difference via2MinSpace availableVia2Space))
	    else
	    (setq requiredVia2Sp 0)
	    )
	  )
	(when (and requiredVia2Sp requiredVia1Sp)
	  (setq requiredSpace (max requiredVia2Sp requiredVia1Sp))
	  )
	(when (and (not requiredVia2Sp) requiredVia1Sp)
	  (setq requiredSpace requiredVia1Sp)
	  )
	;;offset and the implant over the offset
	(when (greaterp offset 1e-6)
	  (dbCreateRect tcCellView diffLayer (list  x1Coord:y1Coord
						    (plus offset x1Coord):(plus y1Coord w))
			)
	  
	  (when (and diffImplant implant)
	    (dbCreateRect tcCellView diffImplant 
			  (list
			   (list x1Coord
				 (difference y1Coord diffImpEnc))
			   (list (plus offset x1Coord)
				 (plus (plus y1Coord w) diffImpEnc))
			   )
			  )
	    )
	  (when (and diffCoreImplant implant)
	    (dbCreateRect tcCellView diffCoreImplant 
			  (list
			   (list x1Coord
				 (difference y1Coord diffCoreImpEnc))
			   (list (plus offset x1Coord)
				 (plus (plus y1Coord w) diffCoreImpEnc))
			   )
			  )
	    )
	  )
	
	;;If (sb - last terminal contact length) value is such that an inner contact at the specified offset
	;;CAN be accomodated then place the inner contact at specified offset and place the net on the contact near the gate
	(when (geqp (difference sb contactLLength) (plus offset requiredSpace innerContactLength))
	  (setq contactId innerContactId)
	  ;;Place the inner contact
	  (setq inst (dbCreateParamInst tcCellView contactId  nil
					(plus offset x1Coord):y1Coord "R0" 1 instParams)
		)
	  (unless inst
	    (error (sprintf nil "Failed to create instance of `%s'" innerContact)))
	  (setq strappedContactId   (dbOpenCellView tcCellView~>lib lastContact "symbolic" nil "rn"))
	  (unless strappedContactId~>isParamCell
	    (error (sprintf nil "Named cell is not a pcell `%s'" lastContact))
	    )
	  ;;Place the strapped contact
	  (setq strappedContactInst (dbCreateParamInst tcCellView strappedContactId  nil
				                       (plus x1Coord (difference sb contactLLength)):y1Coord "R0" 1 instParams))
	  (unless strappedContactInst
	    (error (sprintf nil "Failed to create instance of `%s'" 
			    lastContact))
	    )
	  (dbClose strappedContactId)
	  ;;draw a piece of diff between inner contact and outer contact
	  (dbCreateRect tcCellView diffLayer 
			(list (plus x1Coord (plus offset innerContactLength)):y1Coord (plus x1Coord (difference sb contactLLength)):w)
			)
	  (when (and diffImplant implant)
	    (dbCreateRect tcCellView diffImplant 
			  (list (list (plus x1Coord (plus offset innerContactLength))
				      (difference y1Coord diffImpEnc))
				(list (plus x1Coord (difference sb contactLLength))
				      (plus w     diffImpEnc))
				)))
	  (when (and diffCoreImplant implant)
	    (dbCreateRect tcCellView diffCoreImplant 
			  (list (list (plus x1Coord (plus offset innerContactLength))
				      (difference y1Coord diffCoreImpEnc))
				(list (plus x1Coord (difference sb contactLLength))
				      (plus w     diffCoreImpEnc))
				)))
	  )
	
	;;If (sb - last terminal contact length) value is such that an inner contact at the specified offset
	;;CANNOT be accomodated then place the outer contact near the left end and place the net on the end contact
	(unless (geqp (difference sb contactLLength) (plus offset requiredSpace innerContactLength))
	  (setq strappedContactId (dbOpenCellView tcCellView~>lib lastContact "symbolic" nil "rn"))
	  (unless strappedContactId~>isParamCell
	    (error (sprintf nil "Named cell is not a pcell `%s'" lastContact))
	    )
	  ;;Place the strapped contact
	  (setq strappedContactInst (dbCreateParamInst tcCellView strappedContactId nil
					 (plus x1Coord (difference sb contactLLength)):y1Coord "R0" 1 instParams ))
	  (unless strappedContactInst
	    (error (sprintf nil "Failed to create instance of `%s'" 
			    strappedContactId~>cellName))
	    )
	  (setq contactId strappedContactId)
	  (setq inst      strappedContactInst)
	  ;;Draw a piece of diff between the gate and the outer strapped contact
	  (dbCreateRect tcCellView diffLayer 
			(list x1Coord:y1Coord (plus x1Coord (difference sb contactLLength)):w)
			)	
	  (when (and diffImplant implant)
	    (dbCreateRect tcCellView diffImplant 
			  (list (list x1Coord
				      (difference y1Coord diffImpEnc))
				(list (plus x1Coord (difference sb contactLLength)) 
				       (plus w     diffImpEnc))
				)))
	  (when (and diffCoreImplant implant)
	    (dbCreateRect tcCellView diffCoreImplant 
			  (list (list x1Coord
				      (difference y1Coord diffCoreImpEnc))
				(list (plus x1Coord (difference sb contactLLength)) 
				       (plus w     diffCoreImpEnc))
				)))
	  )
	);when isSingleStrapped
      
      
      (unless isSingleStrapped
	;;when the offset+ contact can be accomodated within the specified sb
	(when  (and (or (and (greaterp sb 1e-6) (greaterp offset 1e-6)) 
			(and (greaterp sb 1e-6) (geqp offset 0.0))) (greaterp sb (plus offset contactLLength)))
	  ;; Create a rectangle to fill the space between the contact and the gate,
	  ;; when offset > zero.
	  
	  (when (greaterp offset 1e-6)
	    (dbCreateRect tcCellView diffLayer (list  x1Coord:y1Coord
						      (plus offset x1Coord):(plus y1Coord w))
			  ))
	  ;;Draw a piece of diff from the contact to the end of LOD
	  (dbCreateRect tcCellView diffLayer (list  (plus x1Coord offset contactLLength):y1Coord
						  (plus x1Coord offset contactLLength (difference sb offset contactLLength)):w)
			)
	  
	  (when (and diffImplant implant)
	    (when (greaterp offset 1e-6)
	      (dbCreateRect tcCellView diffImplant 
			    (list
			     (list x1Coord
				   (difference y1Coord diffImpEnc))
			     (list (plus offset x1Coord)
				   (plus w diffImpEnc))
			     )
			    ) 
	      )
	    
	    (dbCreateRect tcCellView diffImplant 
			  (list
			   (list (plus x1Coord offset contactLLength)
				 (difference y1Coord diffImpEnc))
			   (list (plus x1Coord offset contactLLength (difference sb offset contactLLength) diffImpEnc)
				 (plus w diffImpEnc))
			   )
			  ) 
	    )
	  
	  (when (and diffCoreImplant implant)
	    (when (greaterp offset 1e-6)
	      (dbCreateRect tcCellView diffCoreImplant 
			    (list
			     (list x1Coord
				   (difference y1Coord diffCoreImpEnc))
			     (list (plus offset x1Coord)
				   (plus w diffCoreImpEnc))
			     )
			    ) 
	      )
	    
	    (dbCreateRect tcCellView diffCoreImplant 
			  (list
			   (list (plus x1Coord offset contactLLength)
				 (difference y1Coord diffCoreImpEnc))
			   (list (plus x1Coord offset contactLLength (difference sb offset contactLLength) diffCoreImpEnc)
				 (plus w diffCoreImpEnc))
			   )
			  ) 
	    
	    )
	  
	  )
	
	;;When sb cannot accomodate the contact at the specified offset
	(when (and (or (and (greaterp offset 1e-6) (geqp sb 0.0)) 
		       (and (greaterp offset 1e-6) (greaterp sb 1e-6)))  (geqp (plus offset contactLLength) sb))
	  
	  (dbCreateRect tcCellView diffLayer (list  x1Coord:y1Coord
						    (plus offset x1Coord):w)
			) 
	  
	  ;; we count on the contact to correctly implant itself, and only 
	  ;; draw horizontally to the edge of the contact. we do meet 
	  ;; vertical enclosure with this shape
	  (when (and diffImplant implant)
	    (dbCreateRect tcCellView diffImplant 
			  (list
			   (list x1Coord
				 (difference y1Coord diffImpEnc))
			   (list (plus offset x1Coord)
				 (plus w diffImpEnc))
			   )
			  ) 
	    )
	  (when (and diffCoreImplant implant)
	    (dbCreateRect tcCellView diffCoreImplant 
			  (list
			   (list x1Coord
				 (difference y1Coord diffCoreImpEnc))
			   (list (plus offset x1Coord)
				 (plus w diffCoreImpEnc))
			   )
			  ) 
	    )
	  )
	);unless isSingleStrapped
      );when manualLOD
    
    (unless manualLOD
      ;;when the symbolic LOD is selected and buttingGatesSB is atleast zero
      (unless (geqp buttingGatesSB 0)
	(warn (sprintf nil "Cannot specify non-zero number of butting gates for SB %L\n" buttingGatesSB))
	)
      (unless (geqp buttingGatesSB 1)
	(setq extension (plus offset contactLLength))
	)
      ;;Draw a piece of diffusion between the gate and the contact
      (when (greaterp offset 1e-6)
	(dbCreateRect tcCellView diffLayer 
		      (list  x1Coord:y1Coord (plus x1Coord offset):w))
	
	(when (and diffImplant implant)	   
	  (dbCreateRect tcCellView diffImplant 
			(list (list x1Coord
				    (difference y1Coord diffImpEnc))
			      (list (plus x1Coord offset)
				    (plus y1Coord w     diffImpEnc))
			      )))
	
	(when (and diffCoreImplant implant)	   
	  (dbCreateRect tcCellView diffCoreImplant 
			(list (list x1Coord
				    (difference y1Coord diffCoreImpEnc))
			      (list (plus x1Coord offset)
				    (plus y1Coord w     diffCoreImpEnc))
			      )))
	)
      (when (geqp buttingGatesSB 0)
	;;Single Strapped last terminal selection places the strapped contact pcell 
	;;all the way to the right. A non-strapped contact pcell is placed at the 
	;;specified offset from the gate
	;;
	;;When double-strapped or non-strapped contact is selected as last terminal contact
	;;then that contact is placed at a specified offset from the gate.
	;;A non-strapped contact pcell is measured, and the measured space is used in calculating the 
	;;LOD of the imaginary outer-most contact
	;;
	;;Hence it is necessary to know whether the last terminal contact is strapped, 
	;;non-strapped or double-strapped and get the innerContact or outerContact pcell name
	;;as applicable
	;;
	
	;;Needs to happen only when > 1 butting Gates are involved
	(when (geqp buttingGatesSB 1)
	  (when LODContactMapSStrapped
	    (foreach pair LODContactMapSStrapped
		     (when (equal lastContact (car pair))
		       (setq isSingleStrapped t)
		       (setq innerContact     (cdr pair))
		       )
		     ))
	  
	  (when LODContactMapNDStrapped
	    (foreach pair LODContactMapNDStrapped
		     (when (equal lastContact (car pair))
		       (setq isNDStrapped t)
		       (setq outerContact (cdr pair))
		       )
		     ))
	  )
	
		  
	
	
	(when (and isSingleStrapped (geqp buttingGatesSB 1))
	  (dbDeleteObject inst)
	  (dbClose contactId)
	  ;;Replace the single strapped contact with a non-strapped contact
	  (setq contactId (dbOpenCellView tcCellView~>lib (car innerContact) "symbolic" nil "rn"))
	  (unless contactId~>isParamCell
	    (error (sprintf nil "Named cell is not a pcell `%s'" innerContact)))
	  (setq inst (dbCreateParamInst tcCellView contactId nil
					(plus x1Coord offset):0 "R0" 1 instParams ))
	  (unless inst
	    (error (sprintf nil "Failed to create instance of `%s'" innerContact))
	    )
	  
	  (setq innerContactLength (difference  (caadr contactId~>diffLayerBbox)  (caar contactId~>diffLayerBbox)))
	  
	  ;;Place the single strapped contact such that it forms the very end of the LOD
	  (when (geqp buttingGatesSB 1)
	    ;;Even number of imaginary gates
	    (when (equal (mod buttingGatesSB 2) 0)
	      ;;Calculate extension
	      (setq extension (plus (plus  innerContactLength (times 2 curTermOffset))
				    (times (difference (quotient buttingGatesSB 2) 1) curTermShConLength)
				    (times (difference buttingGatesSB 2) curTermOffset)
				    (times (quotient   buttingGatesSB 2) nextTermShConLength)
				    (times buttingGatesSB nextTermOffset)
				    (plus  contactLLength curTermOffset)
				    (times buttingGatesSB l)
				    ))
	      )
	    ;;Odd number of imaginary gates
	    (unless (equal (mod buttingGatesSB 2) 0)
	      ;;Calculate extension
	      (setq extension (plus (plus  innerContactLength (times 2 curTermOffset))
				    (times (quotient (difference buttingGatesSB 1) 2) curTermShConLength)
				    (times (difference buttingGatesSB 1) curTermOffset)
				    (times (quotient (difference buttingGatesSB 1) 2) nextTermShConLength)
				    (times (difference buttingGatesSB 1) nextTermOffset)
				    (plus  contactLLength nextTermOffset)
				    (times buttingGatesSB l)
				    ))
	      )
	    )
	  
	  
	  (dbCreateRect tcCellView diffLayer 
			(list  (plus x1Coord (plus offset innerContactLength)):y1Coord (plus x1Coord (difference extension contactLLength)):w))
	  (setq outerContactId (dbOpenCellView tcCellView~>lib lastContact "symbolic" nil "rn"))
	  (unless outerContactId~>isParamCell
	    (error (sprintf nil "Named cell is not a pcell `%s'" lastContact)))
	  (setq outerInst      (dbCreateParamInst tcCellView outerContactId nil
						  (plus x1Coord (difference extension contactLLength)):0 "R0" 1 instParams ))  
	  (unless outerInst
	    (error (sprintf nil "Failed to create instance of `%s'" lastContact))
	    )
	  (dbClose outerContactId)
	  (when (and diffImplant implant)	   
	    (dbCreateRect tcCellView diffImplant 
			  (list (list (plus x1Coord offset innerContactLength)
				      (difference y1Coord diffImpEnc))
				(list (plus x1Coord (difference extension contactLLength))
				      (plus y1Coord w     diffImpEnc))
				)))
	  (when (and diffCoreImplant implant)	   
	    (dbCreateRect tcCellView diffCoreImplant 
			  (list (list (plus x1Coord offset innerContactLength)
				      (difference y1Coord diffCoreImpEnc))
				(list (plus x1Coord (difference extension contactLLength))
				      (plus y1Coord w     diffCoreImpEnc))
				)))
	  
	  );when
	
	
	
	  
	(when (and (not isSingleStrapped) (geqp buttingGatesSB 1))
	  (setq outerContactId (dbOpenCellView tcCellView~>lib (car outerContact) "symbolic" nil "rn"))
	  (unless outerContactId~>isParamCell
	    (error (sprintf nil "Named cell is not a pcell `%s'" outerContact)))
	  (setq outerContactLength (difference  (caadr outerContactId~>diffLayerBbox)  (caar outerContactId~>diffLayerBbox)))
	  (when (geqp buttingGatesSB 1)
	    ;;Even number of imaginary gates
	    (when (equal (mod buttingGatesSB 2) 0)
	      ;;Calculate extension
	      (setq extension (plus (plus contactLLength (times 2 curTermOffset))
				    (times (difference (quotient buttingGatesSB 2) 1) curTermShConLength)
				    (times (difference buttingGatesSB 2) curTermOffset)
				    (times (quotient   buttingGatesSB 2) nextTermShConLength)
				    (times buttingGatesSB nextTermOffset)
				    (plus  outerContactLength curTermOffset)
				    (times buttingGatesSB l)
				    ))
	      )
	    
	    ;;Odd number of imaginary gates
	    (unless (equal (mod buttingGatesSB 2) 0)
	      ;;Calculate extension
	      (setq extension (plus (plus contactLLength (times 2 curTermOffset))
				    (times (quotient (difference buttingGatesSB 1) 2) curTermShConLength)
				    (times (difference buttingGatesSB 1) curTermOffset)
				    (times (quotient (difference buttingGatesSB 1) 2) nextTermShConLength)
				    (times (difference buttingGatesSB 1) nextTermOffset)
				    (plus  outerContactLength nextTermOffset)
				    (times buttingGatesSB l)
				    ))
	      )
	    )
	  
	  
	  ;;Next, create a piece of diffusion to cover the area between edge of diffusion and contact
	  (dbCreateRect tcCellView diffLayer 
			(list  (plus x1Coord (plus offset contactLLength)):y1Coord (plus x1Coord extension):w))
	  
	  (when (and diffImplant implant)	   
	    (dbCreateRect tcCellView diffImplant 
			  (list (list (plus x1Coord offset contactLLength)
				      (difference y1Coord diffImpEnc))
				(list (plus x1Coord extension diffImpEnc)
				      (plus y1Coord w     diffImpEnc))
				)))
	  (when (and diffCoreImplant implant)	   
	    (dbCreateRect tcCellView diffCoreImplant 
			  (list (list (plus x1Coord offset contactLLength)
				      (difference y1Coord diffCoreImpEnc))
				(list (plus x1Coord extension diffCoreImpEnc)
				      (plus y1Coord w     diffCoreImpEnc))
				)))
	  );;unless isSingleStrapped
	);when butting gates >= 0
      );when Symbolic LOD
    );;when lodEnabled
 
  
     ;;; Create a rectangle from the top Layer of the contact, given the
     ;;; bounding box of the top Layer. Then make this rectangle a pin
     ;;; or the appropriate net.
  (setq master inst~>master)
  (unless (and master~>topLayer master~>topLayerPinBbox)
    (error (sprintf nil 
		    "Missing topLayer and/or topLayerPinBbox cell properties in `%s'" 
	  lastContact))
    )
  
  (setq bBox (list (list (plus (caar master~>topLayerPinBbox) x1Coord 
			       offset) (cadar master~>topLayerPinBbox))
		   (list (plus (caadr master~>topLayerPinBbox) x1Coord 
			       offset) (cadadr master~>topLayerPinBbox)))
	)
  (when (and lodEnabled manualLOD isSingleStrapped)
    (unless (geqp (difference sb contactLLength) (plus offset requiredSpace innerContactLength))
      (setq bBox (list (list (plus (caar master~>topLayerPinBbox) x1Coord 
				   (difference sb contactLLength)) (cadar master~>topLayerPinBbox))
		       (list (plus (caadr master~>topLayerPinBbox) x1Coord 
				   (difference sb contactLLength)) (cadadr master~>topLayerPinBbox))))
      )
    )
  
     ;;; This pin can be accessed from top, bottom, and right only.
  (setq dbid (dbCreateRect tcCellView master~>topLayer bBox))
  (setq pinid (dbCreatePin cNet dbid))
  pinid~>accessDir = (list "top" "bottom" "right")
  
     ;;; draw the label at the center of the top layer
  (when labelLayer
    (dbCreateLabel tcCellView labelLayer 
		   (list (plus (caar bBox) (quotient (difference 
						      (caadr bBox) (caar bBox)) 2.0)) (plus (cadar bBox) 
											    (quotient (difference (cadadr bBox) (cadar bBox)) 
												      2.0))) 
		   netL "centerCenter" "R0" "roman" labelWidth)
    )
  
 

  (setq y1DiffCoord (cadar master~>diffLayerBbox))
  (setq y1TapCoord (if master~>tapLayerBbox (abs (cadar master~>tapLayerBbox)) 0.0))
  (setq y2DiffCoord (cadadr master~>diffLayerBbox))
  (setq y2TapCoord (if master~>tapLayerBbox (abs (cadadr master~>tapLayerBbox)) 0.0))
  (setq x2DiffCoord (caadr master~>diffLayerBbox))
  (setq x2TapCoord (if master~>tapLayerBbox (abs (caadr master~>tapLayerBbox)) 0.0))
  
  (unless lodEnabled
    ;;; If wellLayer is defined, then calculate the upper coordinates 
     ;;; of the well layer
     (when wellLayer
	 (unless master~>diffLayerBbox (error (sprintf nil "Cannot find diffLayerBbox property for `%s'" lastContact)))
	 ;;; Given the master of the contact just placed, recalculate the 
	 ;;; well overlaps in y direction. The maximum well overlaps 
	 ;;; should be used.
	 ;;; remember, (max (abs -1) (abs -2)) = (min -1 -2)
	 (setq y1WellCoord (min (minus (max (plus wellEncDiffY y1DiffCoord) (plus wellEncTapY y1TapCoord))) y1WellCoord))
	 (setq y2WellCoord (max (plus wellEncDiffY y2DiffCoord) (plus wellEncTapY y2TapCoord) y2WellCoord))
	 ;;; Calculate the x2Coord of the well, from the x2Coordinates 
	 ;;; of the diffLayerBbox and tapLayerBbox.
	 (setq x2WellCoord (plus offset x1Coord (max (plus wellEncDiffX x2DiffCoord) (plus wellEncTapX x2TapCoord))))
     )

     (when idLayer
       (unless master~>diffLayerBbox (error (sprintf nil "Cannot find diffLayerBbox property for `%s'" lastContact)))
       (foreach layerInfo idLayersTable
		(setq layerName  (car  layerInfo))
		(setq layerEncs  (cadr layerInfo))
		
		(setq idEncXL  (nth 0 layerEncs))
		(setq idEncXR  (nth 1 layerEncs))
		(setq idEncY   (nth 2 layerEncs))

		;;get the y1id & y2id coordinates to compare to the new computed one
		;;get the other coordinates to prevent overwriting them by a prior computation
		(setq x1IdCoord (nth 0 (car  idLayersCoordTable[layerName])))
		(setq y1IdCoord (nth 1 (car  idLayersCoordTable[layerName])))
		(setq x2IdCoord (nth 0 (cadr idLayersCoordTable[layerName])))
		(setq y2IdCoord (nth 1 (cadr idLayersCoordTable[layerName])))
		
        	;;; Given the master of the contact just placed, recalculate the 
	        ;;; id overlaps in y direction. The maximum id overlaps should 
        	;;; be used.
		(setq y1IdCoord   (min    (minus (max (plus idEncY y1DiffCoord) (plus idEncY y1TapCoord))) y1IdCoord))
		(setq y2IdCoord   (max    (plus idEncY y2DiffCoord) (plus idEncY y2TapCoord) y2IdCoord))
		(setq x2IdCoord   (plus   offset x1Coord (max (plus idEncXR x2DiffCoord) (plus idEncXR x2TapCoord))))
		
		(setq layerCoords (list x1IdCoord:y1IdCoord x2IdCoord:y2IdCoord))
		
		idLayersCoordTable[layerName] = layerCoords
		)
       )

     (when secIdLayer
       (unless master~>diffLayerBbox (error (sprintf nil "Cannot find diffLayerBbox property for `%s'" lastContact)))
       (foreach secLayerInfo secIdLayersTable
		(setq secLayerName  (car  secLayerInfo))
		(setq secLayerEncs  (cadr secLayerInfo))
		
		(setq secIdEncXL    (nth 0 secLayerEncs))
		(setq secIdEncXR    (nth 1 secLayerEncs))
		(setq secIdEncY     (nth 2 secLayerEncs))

		;;; Given the master of the contact just placed, recalculate the 
	        ;;; id overlaps in y direction. The maximum id overlaps should 
        	;;; be used.
		(setq x1SecIdCoord   x1Coord)
		(setq y1SecIdCoord   (minus (max (plus secIdEncY y1DiffCoord) (plus secIdEncY y1TapCoord))))
		(setq y2SecIdCoord   (max    (plus secIdEncY y2DiffCoord) (plus secIdEncY y2TapCoord)))
		(setq x2SecIdCoord   (plus   offset x1Coord (max (plus secIdEncXR x2DiffCoord) (plus secIdEncXR x2TapCoord))))
		
		(setq secLayerCoords (list x1SecIdCoord:y1SecIdCoord x2SecIdCoord:y2SecIdCoord))
		
		secIdLayersCoordTable[secLayerName] = secLayerCoords
		)
       )

     
    )


  (when lodEnabled
  (when manualLOD 
     ;;; If wellLayer is defined, then calculate the upper coordinates 
     ;;; of the well layer
    (when wellLayer
      (unless master~>diffLayerBbox (error (sprintf nil "Cannot find diffLayerBbox property for `%s'" lastContact)))
	 ;;; Given the master of the contact just placed, recalculate the 
	 ;;; well overlaps in y direction. The maximum well overlaps 
	 ;;; should be used.
	 ;;; remember, (max (abs -1) (abs -2)) = (min -1 -2)

      (setq y1WellCoord (min (minus (max (plus wellEncDiffY y1DiffCoord) (plus wellEncTapY y1TapCoord))) y1WellCoord))
      (setq y2WellCoord (max (plus wellEncDiffY y2DiffCoord) (plus wellEncTapY y2TapCoord) y2WellCoord))
	 ;;; Calculate the x2Coord of the well, from the x2Coordinates 
	 ;;; of the diffLayerBbox and tapLayerBbox.
      (when isSingleStrapped
	(setq x2WellCoord  (plus x1Coord (difference sb (max x2DiffCoord x2TapCoord)) (max (plus wellEncDiffX x2DiffCoord) (plus wellEncTapX x2TapCoord))))
	)
      (unless isSingleStrapped
	(when  (or (and (greaterp sb 1e-6) (greaterp offset 1e-6) (greaterp sb (plus offset contactLLength))) 
		   (and (greaterp sb 1e-6) (equal offset 0.0) (geqp sb (plus offset contactLLength)))) 
	  (setq x2WellCoord (plus x1Coord (difference sb (max x2DiffCoord x2TapCoord)) (max (plus wellEncDiffX x2DiffCoord) (plus wellEncTapX x2TapCoord))))
	  )
	
	(when (or (and (greaterp offset 1e-6) (equal sb 0.0) (geqp (plus offset contactLLength) sb))  
		  (and (greaterp offset 1e-6) (greaterp sb 1e-6) (geqp (plus offset contactLLength) sb))) 
	  (setq x2WellCoord (plus x1Coord offset (max (plus wellEncDiffX x2DiffCoord) (plus wellEncTapX x2TapCoord))))
	  )
	)
      )
    
    (when idLayer
      (unless master~>diffLayerBbox (error (sprintf nil "Cannot find diffLayerBbox property for `%s'" lastContact)))
      (foreach layerInfo idLayersTable
	       (setq layerName  (car  layerInfo))
	       (setq layerEncs  (cadr layerInfo))
	       
	       (setq idEncXL  (nth 0 layerEncs))
	       (setq idEncXR  (nth 1 layerEncs))
	       (setq idEncY   (nth 2 layerEncs))
	       
	       ;;get the y1id & y2id coordinates to compare to the new computed one
	       ;;get the other coordinates to prevent overwriting them by a prior computation
	       (setq x1IdCoord (nth 0 (car  idLayersCoordTable[layerName])))
	       (setq y1IdCoord (nth 1 (car  idLayersCoordTable[layerName])))
	       (setq x2IdCoord (nth 0 (cadr idLayersCoordTable[layerName])))
	       (setq y2IdCoord (nth 1 (cadr idLayersCoordTable[layerName])))
	       
        	;;; Given the master of the contact just placed, recalculate the 
	        ;;; id overlaps in y direction. The maximum id overlaps should 
        	;;; be used.
	       (setq y1IdCoord   (min    (minus (max (plus idEncY y1DiffCoord) (plus idEncY y1TapCoord))) y1IdCoord))
	       (setq y2IdCoord   (max    (plus idEncY y2DiffCoord) (plus idEncY y2TapCoord) y2IdCoord))

	       (when isSingleStrapped
		   (setq x2IdCoord (plus x1Coord (plus (difference sb (max x2DiffCoord x2TapCoord)) (max (plus idEncXR x2DiffCoord) (plus idEncXR x2TapCoord)))))
		   )
	       (unless isSingleStrapped
		 (when (or (and (greaterp sb 1e-6) (greaterp offset 1e-6) (geqp sb (plus offset contactLLength))) 
			   (and (greaterp sb 1e-6) (geqp offset 0.0)(geqp sb (plus offset contactLLength)))) 
		   (setq x2IdCoord   (plus x1Coord (difference sb (max x2DiffCoord x2TapCoord))  (max (plus idEncXR x2DiffCoord) (plus idEncXR x2TapCoord))))
		   )
		 
		 (when  (or (and (greaterp offset 1e-6) (geqp sb 0.0) (geqp (plus offset contactLLength) sb)) 
			    (and (greaterp offset 1e-6) (greaterp sb 1e-6) (geqp (plus offset contactLLength) sb)))
		   (setq x2IdCoord   (plus  x1Coord offset  (max (plus idEncXR x2DiffCoord) (plus idEncXR x2TapCoord))))
		   )
		 )
	       (setq layerCoords (list x1IdCoord:y1IdCoord x2IdCoord:y2IdCoord))
	       idLayersCoordTable[layerName] = layerCoords
	       )
      )

    (when secIdLayer
      (unless master~>diffLayerBbox (error (sprintf nil "Cannot find diffLayerBbox property for `%s'" lastContact)))
      (foreach secLayerInfo secIdLayersTable
	       (setq secLayerName  (car  secLayerInfo))
	       (setq secLayerEncs  (cadr secLayerInfo))
	       
	       (setq secIdEncXL  (nth 0 secLayerEncs))
	       (setq secIdEncXR  (nth 1 secLayerEncs))
	       (setq secIdEncY   (nth 2 secLayerEncs))
	           
               ;;; Given the master of the contact just placed, recalculate the 
	       ;;; id overlaps in y direction. The maximum id overlaps should 
               ;;; be used.
	       (setq x1SecIdCoord   x1Coord)
	       (setq y1SecIdCoord   (minus (max (plus secIdEncY y1DiffCoord) (plus secIdEncY y1TapCoord))))
	       (setq y2SecIdCoord   (max    (plus secIdEncY y2DiffCoord) (plus secIdEncY y2TapCoord)))

	       (when isSingleStrapped
		   (setq x2SecIdCoord (plus x1Coord (plus (difference sb (max x2DiffCoord x2TapCoord)) (max (plus secIdEncXR x2DiffCoord) (plus secIdEncXR x2TapCoord)))))
		   )
	       (unless isSingleStrapped
		 (when (or (and (greaterp sb 1e-6) (greaterp offset 1e-6) (geqp sb (plus offset contactLLength))) 
			   (and (greaterp sb 1e-6) (geqp offset 0.0)(geqp sb (plus offset contactLLength)))) 
		   (setq x2SecIdCoord   (plus x1Coord (difference sb (max x2DiffCoord x2TapCoord))  (max (plus secIdEncXR x2DiffCoord) (plus secIdEncXR x2TapCoord))))
		   )
		 
		 (when  (or (and (greaterp offset 1e-6) (geqp sb 0.0) (geqp (plus offset contactLLength) sb)) 
			    (and (greaterp offset 1e-6) (greaterp sb 1e-6) (geqp (plus offset contactLLength) sb)))
		   (setq x2SecIdCoord   (plus  x1Coord offset  (max (plus secIdEncXR x2DiffCoord) (plus secIdEncXR x2TapCoord))))
		   )
		 )
	       (setq secLayerCoords (list x1SecIdCoord:y1SecIdCoord x2SecIdCoord:y2SecIdCoord))
	       secIdLayersCoordTable[secLayerName] = secLayerCoords
	       )
      )
    
    )

  (unless manualLOD
    ;; If wellLayer is defined, then calculate the upper coordinates 
    ;; of the well layer
    (when wellLayer
      (unless master~>diffLayerBbox 
        (error (sprintf nil "Cannot find diffLayerBbox property for `%s'" lastContact)))
      ;; Given the master of the contact just placed, recalculate the 
      ;; well overlaps in y direction. The maximum well overlaps 
      ;; should be used.
      ;; remember, (max (abs -1) (abs -2)) = (min -1 -2)
      (setq y1WellCoord (min (minus (max (plus wellEncDiffY y1DiffCoord) (plus wellEncTapY y1TapCoord))) y1WellCoord))
      (setq y2WellCoord (max (plus wellEncDiffY y2DiffCoord) (plus wellEncTapY y2TapCoord) y2WellCoord))
      ;; Calculate the x2Coord of the well, from the x2Coordinates 
      ;; of the diffLayerBbox and tapLayerBbox.
      (when isSingleStrapped
	(setq x2WellCoord (plus x1Coord extension  wellEncTapX))
	)
      (unless isSingleStrapped
	(setq x2WellCoord (plus x1Coord extension wellEncDiffX))
	)
      
      )
   
    (when idLayer
      (unless master~>diffLayerBbox (error (sprintf nil "Cannot find diffLayerBbox property for `%s'" lastContact)))
      (foreach layerInfo idLayersTable
               (setq layerName  (car  layerInfo))
               (setq layerEncs  (cadr layerInfo))
               
               (setq idEncXL  (nth 0 layerEncs))
               (setq idEncXR  (nth 1 layerEncs))
               (setq idEncY   (nth 2 layerEncs))
               
               ;;get the y1id & y2id coordinates to compare to the new computed one
               ;;get the other coordinates to prevent overwriting them by a prior computation
               (setq x1IdCoord (nth 0 (car  idLayersCoordTable[layerName])))
               (setq y1IdCoord (nth 1 (car  idLayersCoordTable[layerName])))
               (setq x2IdCoord (nth 0 (cadr idLayersCoordTable[layerName])))
               (setq y2IdCoord (nth 1 (cadr idLayersCoordTable[layerName])))
               
               ;; Given the master of the contact just placed, recalculate the 
               ;; id overlaps in y direction. The maximum id overlaps should 
               ;; be used.
               (setq y1IdCoord   (min    (minus (max (plus idEncY y1DiffCoord) (plus idEncY y1TapCoord))) y1IdCoord))
               (setq y2IdCoord   (max    (plus idEncY y2DiffCoord) (plus idEncY y2TapCoord) y2IdCoord))
	       (setq x2IdCoord  (plus x1Coord extension idEncXR))               
               (setq layerCoords (list x1IdCoord:y1IdCoord x2IdCoord:y2IdCoord))
               idLayersCoordTable[layerName] = layerCoords
               )
      )

    (when secIdLayer
      (unless master~>diffLayerBbox (error (sprintf nil "Cannot find diffLayerBbox property for `%s'" lastContact)))
      (foreach secLayerInfo secIdLayersTable
               (setq secLayerName  (car  secLayerInfo))
               (setq secLayerEncs  (cadr secLayerInfo))
               
               (setq secIdEncXL  (nth 0 secLayerEncs))
               (setq secIdEncXR  (nth 1 secLayerEncs))
               (setq secIdEncY   (nth 2 secLayerEncs))
                                             
               ;; Given the master of the contact just placed, recalculate the 
               ;; id overlaps in y direction. The maximum id overlaps should 
               ;; be used.
	       (setq x1SecIdCoord   x1Coord)
               (setq y1SecIdCoord   (minus (max (plus secIdEncY y1DiffCoord) (plus secIdEncY y1TapCoord))))
               (setq y2SecIdCoord   (max    (plus secIdEncY y2DiffCoord) (plus secIdEncY y2TapCoord)))
	       (setq x2SecIdCoord   (plus x1Coord extension secIdEncXR)) 
               (setq secLayerCoords (list x1SecIdCoord:y1SecIdCoord x2SecIdCoord:y2SecIdCoord))
               secIdLayersCoordTable[secLayerName] = secLayerCoords
               )
      )
    )
  )
  
  
  ;; Create the implant under this diffusion
  ;; This implant meets enclosure in the vertical direction.
  ;; when there is no contact on this end, we draw another
  ;; shape to meet horizontal enclosure
  (when (and diffImplant implant)
    (dbCreateRect tcCellView diffImplant
		  (list
		   (list x1Coord
			 (difference y1Coord diffImpEnc))
		   (list (plus x1Coord diffExt)
			 (plus (plus y1Coord w) diffImpEnc))
		   )
		  ))
  
  (when (and diffCoreImplant implant)
    (dbCreateRect tcCellView diffCoreImplant
		  (list
		   (list x1Coord
			 (difference y1Coord diffCoreImpEnc))
		   (list (plus x1Coord diffExt)
			 (plus (plus y1Coord w) diffCoreImpEnc))
		   )
		  ))
  
  
  ;; Close the opened cell view of the lastContact
  (dbClose contactId)
  ) ;; end lastContact

 ;;; Create a diffusion pin to allow transistors to be placed in parallel.
(setq dbid (dbCreateRect tcCellView diffLayer (list x1Coord:y1Coord
						    (plus x1Coord diffExt):(plus y1Coord w)))) 

(setq pinid (dbCreatePin cNet dbid))
pinid~>accessDir = (list "top" "bottom" "right")

;;Draw the secIdLayer
(when secIdLayer
  (foreach secLayerInfo secIdLayersTable
	   (setq secLayerName   (car  secLayerInfo))
           (setq secLayerCoords secIdLayersCoordTable[secLayerName])
	   (dbCreateRect tcCellView secLayerName secLayerCoords)
	   )
 )

;; draw the label and calculate the well coordinates.
(when (equal lastContact "")
;;; Create the implant under this diffusion
;;; This implant meets enclosure in the vertical direction.
;;; when there is no contact on this end, we draw another
;;; shape to meet horizontal enclosure
  (when (and diffImplant implant)
    (dbCreateRect tcCellView diffImplant
		  (list
		   (list x1Coord
			 (difference y1Coord diffImpEnc))
		   (list (plus x1Coord diffExt diffImpEnc)
			 (plus (plus y1Coord w) diffImpEnc))
		   )
		  ) 
    )
  
  (when (and diffCoreImplant implant)
    (dbCreateRect tcCellView diffCoreImplant
		  (list
		   (list x1Coord
			 (difference y1Coord diffCoreImpEnc))
		   (list (plus x1Coord diffExt diffCoreImpEnc)
			 (plus (plus y1Coord w) diffCoreImpEnc))
		   )
		  ) 
    )
  
  (when (and lodEnabled (not manualLOD) (geqp buttingGatesSB 1))
    
    ;;Even number of imaginary gates
    (when (equal (mod buttingGatesSB 2) 0)
      ;;Calculate extension
      (setq extension (plus contactLLength
        		    (times (quotient buttingGatesSB 2) curTermShConLength)
        		    (times buttingGatesSB curTermOffset)
        		    (times (quotient   buttingGatesSB 2) nextTermShConLength)
        		    (times buttingGatesSB nextTermOffset)
        		    (times buttingGatesSB l)
        		    ))
      )
    
    ;;Odd number of imaginary gates
    (unless (equal (mod buttingGatesSB 2) 0)
      ;;Calculate extension
      (setq extension (plus contactLLength
        		    (times (quotient (plus buttingGatesSB 1) 2) curTermShConLength)
        		    (times (plus buttingGatesSB 1) curTermOffset)
        		    (times (quotient (difference buttingGatesSB 1) 2) nextTermShConLength)
        		    (times (difference buttingGatesSB 1) nextTermOffset)
        		    (times buttingGatesSB l)
        		    ))
      )
    (dbCreateRect tcCellView diffLayer (list (plus x1Coord diffExt):y1Coord
        				     (plus x1Coord extension):(plus y1Coord w))) 
  
    (when (and diffImplant implant)
      (dbCreateRect tcCellView diffImplant
        	    (list
        	     (list (plus x1Coord diffExt)
        		   (difference y1Coord diffImpEnc))
        	     (list (plus x1Coord extension diffImpEnc)
        		   (plus (plus y1Coord w) diffImpEnc))
        	     )
        	    ) 
      )
    
    (when (and diffCoreImplant implant)
      (dbCreateRect tcCellView diffCoreImplant
        	    (list
        	     (list (plus x1Coord diffExt)
        		   (difference y1Coord diffCoreImpEnc))
        	     (list (plus x1Coord extension diffCoreImpEnc)
        		   (plus (plus y1Coord w) diffCoreImpEnc))
        	     )
        	    ) 
      )
    );when
  
  (when (and lodEnabled manualLOD (greaterp sb diffExt))
    (dbCreateRect tcCellView diffLayer 
        	  (list (plus x1Coord diffExt):y1Coord 
        		       (plus x1Coord sb):(plus y1Coord w)))
    
    (when (and diffImplant implant)
      ;; this shape only meets vertical enclosure to keep from overlapping the 
      ;; contact when there is no contact, we add the horizontal enclosure
      (dbCreateRect tcCellView diffImplant
        	    (list
        	     (list (plus x1Coord diffExt)
        		   (difference y1Coord diffImpEnc))
        	     (list (plus x1Coord sb diffImpEnc)
        		   (plus w       diffImpEnc) 
        		   )
        	     )
        	    )
      )
    
    (when (and diffCoreImplant implant)
      ;; this shape only meets vertical enclosure to keep from overlapping the 
      ;; contact when there is no contact, we add the horizontal enclosure
      (dbCreateRect tcCellView diffCoreImplant
        	    (list
        	     (list (plus x1Coord diffExt)
        		   (difference y1Coord diffCoreImpEnc))
        	     (list (plus x1Coord sb diffCoreImpEnc)
        		   (plus w       diffCoreImpEnc) 
        		   )
        	     )
        	    )
      )
    );when
  



     ;;; draw the label (at the center of the diff)
  (when labelLayer
    (dbCreateLabel tcCellView labelLayer
		   (list (plus x1Coord (quotient diffExt 2.0)) 
			 (plus y1Coord (quotient w 2.0)))
		   netL "centerCenter" "R0" "roman" labelWidth)
    )
  
     ;;; When lastContact is not defined, the upper coordinates of the well 
     ;;; are given by the diffExt.
  (when wellLayer
    (setq x2WellCoord (plus x1Coord diffExt wellEncDiffX))
    (when (and lodEnabled (not manualLOD) (geqp buttingGatesSB 1))
      (setq x2WellCoord (plus x1Coord extension wellEncDiffX))
      )
    (when (and lodEnabled manualLOD (greaterp sb diffExt))
      (setq x2WellCoord (plus x1Coord sb wellEncDiffX))
      )
    (setq y2WellCoord (max (plus y1Coord w wellEncDiffY) y2WellCoord))
    )
  
  (when idLayer
    (foreach layerInfo idLayersTable
	     (setq layerName  (car  layerInfo))
	     (setq layerEncs  (cadr layerInfo))
	     
	     (setq idEncXL  (nth 0 layerEncs))
	     (setq idEncXR  (nth 1 layerEncs))
	     (setq idEncY   (nth 2 layerEncs))
	     ;;get the y2id coordinate to compare to the new computed one
	     ;;get the other coordinates to prevent overwriting them by a prior computation
	     (setq x1IdCoord (nth 0 (car  idLayersCoordTable[layerName])))
	     (setq y1IdCoord (nth 1 (car  idLayersCoordTable[layerName])))
	     (setq x2IdCoord (nth 0 (cadr idLayersCoordTable[layerName])))
	     (setq y2IdCoord (nth 1 (cadr idLayersCoordTable[layerName])))
	     
             ;;; When lastContact is not defined, the upper coordinates of the idLayer
             ;;; are given by the diffExt.
	     (setq x2IdCoord (plus x1Coord diffExt idEncXR))
	     (when (and lodEnabled (not manualLOD) (geqp buttingGatesSB 1))
	       (setq x2IdCoord (plus x1Coord extension idEncXR))
	       )
	     (when (and lodEnabled manualLOD (greaterp sb diffExt))
	       (setq x2IdCoord (plus x1Coord sb idEncXR))
	       )
	     (setq y2IdCoord (max (plus y1Coord w idEncY) y2IdCoord))
	     
	     (setq layerCoords (list x1IdCoord:y1IdCoord x2IdCoord:y2IdCoord))
	     
	     idLayersCoordTable[layerName] = layerCoords
	     )
    )

  (when secIdLayer
    (foreach secLayerInfo secIdLayersTable
	     (setq secLayerName  (car  secLayerInfo))
	     (setq secLayerEncs  (cadr secLayerInfo))
	     
	     (setq secIdEncXL  (nth 0 secLayerEncs))
	     (setq secIdEncXR  (nth 1 secLayerEncs))
	     (setq secIdEncY   (nth 2 secLayerEncs))
	     	     
             ;;; When lastContact is not defined, the upper coordinates of the idLayer
             ;;; are given by the diffExt.
	     (setq x1SecIdCoord x1Coord)	     
	     (setq y1SecIdCoord (minus (max (plus secIdEncY y1DiffCoord) (plus secIdEncY y1TapCoord))))
	     (setq x2SecIdCoord (plus x1Coord diffExt secIdEncXR))
	     (when (and lodEnabled (not manualLOD) (geqp buttingGatesSB 1))
	       (setq x2SecIdCoord (plus x1Coord extension secIdEncXR))
	       )
	     (when (and lodEnabled manualLOD (greaterp sb diffExt))
	       (setq x2SecIdCoord (plus x1Coord sb secIdEncXR))
	       )
	     (setq y2SecIdCoord  (plus y1Coord w secIdEncY))
	     
	     (setq secLayerCoords (list x1SecIdCoord:y1SecIdCoord x2SecIdCoord:y2SecIdCoord))
	     
	     secIdLayersCoordTable[secLayerName] = secLayerCoords
	     )
	     (foreach secLayerInfo secIdLayersTable
		      (setq secLayerName   (car  secLayerInfo))
		      (setq secLayerCoords secIdLayersCoordTable[secLayerName])
		      (dbCreateRect tcCellView secLayerName secLayerCoords)
		      )
	     
    )
  )

 ;;; While we are at it, we could as well draw the tap contacts to satisfy 
 ;;; the new latchup rules. A tap contact (provided by the user) to left/right
 ;;; or both
 ;;; 1. get the id of the contact
 ;;; 2. place an instance at the offset given by a class property
 ;;; 3. get the master
 ;;; 4. get the topLayerBbox and place a pin with body net
 ;;; 5. get the botLayerBbox and recalculate x1WellCoord and x2WellCoord as 
 ;;;    required
 ;;; 6. close the opened contact cell
 
 ;;; Draw the well Layer if defined, all the coordinates have already
 ;;; been defined
 
(when  wellLayer
  wellLayer_Xorigin = x1WellCoord
  wellLayer_Yorigin = (plus y1WellCoord -wellEncYDiff)
  wellLayer_Xend = x2WellCoord
  wellLayer_Yend = (plus y2WellCoord  wellEncYDiff)
  
  (when (wellLayer_Xend-wellLayer_Xorigin)< wellminWidth
	Diff_well_width = wellminWidth - (wellLayer_Xend-wellLayer_Xorigin)
	x2WellCoord = x2WellCoord + (Diff_well_width/2)
	x1WellCoord = x1WellCoord - (Diff_well_width/2)
	)
  (when (wellLayer_Yend-wellLayer_Yorigin)< wellminWidth
	Diff_well_width = wellminWidth - (wellLayer_Yend-wellLayer_Yorigin)
	y1WellCoord = y1WellCoord - (Diff_well_width/2)
	y2WellCoord = y2WellCoord + (Diff_well_width/2)
	)
  
  (dbCreateRect tcCellView wellLayer (list x1WellCoord:(plus y1WellCoord -wellEncYDiff)
					   x2WellCoord:(plus y2WellCoord  wellEncYDiff)))
  )

(when idLayer
  (foreach layerInfo idLayersTable
	   (setq layerName   (car  layerInfo))
           (setq layerCoords idLayersCoordTable[layerName])
	   (dbCreateRect tcCellView layerName layerCoords)
	   )
 )
)

(tfcDefineDeviceClassProp
 ;;(viewName       devClassName      propName          propValue)
 ("symbolic"        "mModelFetClass"   "function"          "transistor")
 
)
;;; 
;;; $Id: antennaDiodeClass.il,v 1.3 2009/09/03 17:35:06 kuc Exp $
;;; 
;;; antennaDiodeClass.il
;;; 
;;; Copyright (c) 2006 by Cypress Semiconductor
;;; Cypress Kentucky CAD Center (KYCC)
;;; 
;;; Date  : Aug 09, 2006
;;; Author: Kungyen Chang (kuc) @ KYCC
;;; 
;;; Description:
;;;   Pcell code for the antenna diode.
;;; 
;;; Revision History:
;;;   kuc 08/18/06  initial version
;;;   kuc 09/03/09  added userDefTapDiffSpace
;;; 


(tcCreateDeviceClass
 "symbolic" "antennaDiodeClass"
 ;;; Class parameters
 (
  (diffLayer          "hilite")
  (diffImplant        "hilite")
  (diffImpEnc         0.0)
  
  (tapRingLayer       "hilite")
  (tapRingImplant     "hilite")
  (tapRingImpEnc      0.0)
  (tapWidth           0.0)
  
  (tapRingDiffSpacing 0.0)
  
  (via1Layer          nil)
  (via1Size           0.0)
  (via1Spacing        0.0)

  (via1ConLayer       nil)
  (via1ConWidth       0.0)
  (via1ConSpacing     0.0)

  (tapEncVia1X        0.0)
  (tapEncVia1Y        0.0)

  (diffEncVia1X       0.0)
  (diffEncVia1Y       0.0)

  (met1Layer          "hilite")
  (met1EncVia1X       0.0)
  (met1EncVia1Y       0.0)
  (met1EncVia2X       0.0)
  (met1EncVia2Y       0.0)

  (via2Layer          "hilite")
  (via2Size           0.0)
  (via2Spacing        0.0)

  (met2Layer          nil)
  (met2EncVia2X       0.0)
  (met2EncVia2Y       0.0)
  
  ;; parameters for R10/C10 only
  (usePcells          nil)
  (guardRingCell      nil)
  (diffCell           nil)
  (maxDdliWidth        0.0)
  (minDdliSpacing     0.0)
  (minLitrEndSpacing  0.0)
  (maxDdliExtension   0.0)
  (secondMetalCell    nil)
  (snapGrid           0.0)
  (minRemainderX      0.0)
  (minRemainderY      0.0)
  )
 ;;; Formal parameters
 (
  (length             1.0)
  (width              1.0)
  (secondMetalLength  1.0)
  (useSecondMetal     "FALSE")
  (met1OffsetY        0.0)
  (met1OffsetX        0.0)
  (userDefTapDiffSpace 0.0)
  )
 
 (if (or (equal useSecondMetal t) (equal useSecondMetal "TRUE")) then
   (setq useSecondMetal t)
   else
   (setq useSecondMetal nil)
   )

 ;; create diode - draw all in this pcell, do not instantiate other pcells
 (unless usePcells
   (setq diodeArea (rodCreateRect
		    ?layer diffLayer
		    ?width width
		    ?length length
		    ))
   (rodAlign
    ?alignObj diodeArea
    ?alignHandle "cC"
    ?refPoint (list 0 0)
    )
   (setq diodeImplant (rodCreateRect
		       ?layer diffImplant
		       ?fromObj diodeArea
		       ?size diffImpEnc
		       ))
   
   
   ;; recalculate tap width based on contact enclosures
   (setq tapWidth (max tapWidth (plus (times 2 tapEncVia1X) via1Size)))
   
   ;; calculate points for tap ring
   (setq ULring (list 
		 (minus (plus (quotient tapWidth 2) (quotient width 2) (max userDefTapDiffSpace tapRingDiffSpacing (plus diffImpEnc tapRingImpEnc)))) 
		 (plus (quotient tapWidth 2) (quotient length 2) (max userDefTapDiffSpace tapRingDiffSpacing (plus diffImpEnc tapRingImpEnc)))))
   (setq URring (list (minus (car ULring)) (cadr ULring)))
   (setq BLring (list (car ULring) (minus (cadr ULring))))
   (setq BRring (list (minus (car ULring)) (minus (cadr ULring))))
   (setq ringEnd_tapRing (list (car ULring) (plus (cadr ULring) (quotient tapWidth 2))))
   
   (setq ULring_tapRing (list (plus (quotient tapWidth 2) (car ULring)) (cadr ULring)))
   
   ;; create tap ring
   
   (setq tapRing (rodCreatePath
		  ?layer tapRingLayer
		  ?width tapWidth
		  ?justification "center"
		  ?pts (list ULring_tapRing URring BRring BLring ringEnd_tapRing)
		  ))
   
   ;; calculate points for tap implant
   (setq ULring_tapImpRing (list (plus (quotient (plus tapWidth (times 2 tapRingImpEnc)) 2) (car ULring)) (cadr ULring)))
   (setq ringEnd_tapImpRing (list (car ULring) (plus (cadr ULring) (quotient (plus tapWidth (times 2 tapRingImpEnc)) 2))))
   
   (setq tapImpRing (rodCreatePath
		     ?layer tapRingImplant
		     ?width (plus tapWidth (times 2 tapRingImpEnc))
		     ?justification "center"
		     ?pts (list ULring_tapImpRing URring BRring BLring ringEnd_tapImpRing)
		     ))

   ;; attach stretchable handles to pcell
   (rodAssignHandleToParameter
    ?parameter "length"
    ?rodObj tapImpRing
    ?handleName (list "lL" "cL" "uL" "lR" "cR" "uR" "uL" "uC" "uR" "lL" "lC" "lR")
    ?displayName "area"
    ?displayExpression "width * length"
    ?stretchDir "y"
    ?stretchType "relative"
    )
   (rodAssignHandleToParameter
    ?parameter "width"
    ?rodObj tapImpRing
    ?handleName (list "lL" "cL" "uL" "lR" "cR" "uR" "uL" "uC" "uR" "lL" "lC" "lR")
    ?stretchDir "x"
    ?stretchType "relative"
    )

   ;; draw first metal and contacts in ring
   
   (setq ULring_met1Ring (list (plus (quotient (plus (times 2 met1EncVia1X) via1Size) 2) (car ULring)) (cadr ULring)))
   (setq ringEnd_met1Ring (list (car ULring) (plus (cadr ULring) (quotient (plus (times 2 met1EncVia1X) via1Size) 2))))
   
   (setq tapRingMet1 (rodCreatePath
		      ?layer       met1Layer
		      ?width       (plus (times 2 met1EncVia1X) via1Size)
		      ?justification "center"
		      ?pts (list ULring_met1Ring URring BRring BLring ringEnd_met1Ring)
		      ?subRect   list(
				      list(
					   ?layer       via1Layer
							?width       via1Size
							?length      via1Size
							?beginOffset (minus via1Spacing)
							?endSegOffset via1Spacing
							?space       via1Spacing
							?gap         "minimum"
							)
					  )
		      ))
   
   ;; draw diff with metal contacts
   (setq met1ConColumns (floor (quotient (plus (difference width (times 2 diffEncVia1X)) via1Spacing) (plus via1Spacing via1Size))))
   (setq met1ConRows (floor (quotient (plus (difference length (times 2 diffEncVia1Y)) via1Spacing) (plus via1Spacing via1Size))))
   (setq met1Width (plus (times met1ConColumns via1Size) (times via1Spacing (difference met1ConColumns 1)) (times 2 met1EncVia1X)))
   (setq met1Length (plus (times met1ConRows via1Size) (times via1Spacing (difference met1ConRows 1)) (times 2 met1EncVia1Y)))
   
   (setq diffMet1 (rodCreateRect
		   ?layer met1Layer
		   ?width met1Width
		   ?length met1Length
		   ?subRectArray list(
				      list(
					   ?layer via1Layer
						  ?width via1Size
						  ?length via1Size
						  ?spaceX via1Spacing
						  ?spaceY via1Spacing
						  ?lowerLeftOffsetX met1EncVia1X
						  ?lowerLeftOffsetY met1EncVia1Y
						  ?gap "minimum"
						  )
					  )
		   ))
   (rodAlign
    ?alignObj diffMet1
    ?alignHandle "cC"
    ?refPoint (list 0 0)
    )

   (if useSecondMetal then
     (if (secondMetalLength < (plus (times 2 met2EncVia2Y) via2Size)) then
       (setq secondMetalLength (plus (times 2 met2EncVia2Y) via2Size))
       )
     ;; draw second metal layer according to specified length
     (setq met2ConLength (min (difference secondMetalLength (times 2 met2EncVia2Y)) (difference met1Length (times 2 met1EncVia2Y))))
     (setq met2ConRows (floor (quotient (plus met2ConLength via2Spacing) (plus via2Spacing via2Size))))
     (setq met2ConLengthDiff (quotient (difference secondMetalLength (plus (times met2ConRows via2Size) (times via2Spacing (difference met2ConRows 1)))) 2))
     (setq diffMet2Con (rodCreateRect
			?layer met2Layer
			?width (plus (times 2 met2EncVia2X) via2Size)
			?length secondMetalLength
			?subRectArray list(
					   list(
						?layer via2Layer
						       ?width via2Size
						       ?length via2Size
						       ?spaceX via2Spacing
						       ?spaceY via2Spacing
						       ?gap "minimum"
						       ?lowerLeftOffsetX met2EncVia2X
						       ?lowerLeftOffsetY met2ConLengthDiff
						       ?upperRightOffsetY (minus met2ConLengthDiff)
						       )
					       )
			))
     (rodAlign
      ?alignObj diffMet2Con
      ?refPoint (list 0 0)
      )
     )
   )
 
 ;; do this when usePcells is on
 ;; will use pcells to draw all parts, for now it only works with c10 pcells
 
 (when usePcells

   (setq diffCellId (dbOpenCellView tcCellView~>lib diffCell "symbolic" nil "rn"))

   ;; calculates width/2 and length/2 (with snapping) as well as difference between snapped vs actual
   (setq wOver2 (times (floor (quotient (quotient width 2) snapGrid)) snapGrid))
   (setq lOver2 (times (floor (quotient (quotient length 2) snapGrid)) snapGrid))
   (setq wAdjust (minus (difference (quotient width  2) wOver2)))
   (setq lAdjust (minus (difference (quotient length 2) lOver2)))
   
   (if (maxDdliWidth < (plus (times 2 maxDdliExtension) width)) then

     (setq bigSideY (min width (times (floor (quotient (sqrt maxDdliWidth) snapGrid)) snapGrid)))

     (setq numY (floor (quotient (plus minLitrEndSpacing width) (plus minLitrEndSpacing bigSideY))))
     
     (setq remainderY (difference width (times numY (plus bigSideY minLitrEndSpacing))))
     
     (setq shiftAdjustY 0)

     (if (remainderY <= minRemainderY) then
       (setq shiftAdjustY (quotient (plus minLitrEndSpacing remainderY) 2))
       (setq shiftAdjustY (times (floor (quotient shiftAdjustY snapGrid)) snapGrid))
       )

     (setq offsetX (minus (difference lOver2 (times 2 lAdjust))))
     (setq offsetY (minus (difference wOver2 shiftAdjustY (times 2 wAdjust))))

     (for yCount 1 numY
       (setq currentY (times (difference yCount 1) (plus minLitrEndSpacing bigSideY)))
	 
	 (if (and (equal yCount numY) (remainderY > minRemainderY)) then
	   (setq instName (sprintf nil "remainderFillY_%d" yCount))
	   (setq diffArea (dbCreateParamInst tcCellView diffCellId instName offsetX:(plus (plus currentY bigSideY minLitrEndSpacing) offsetY) "R0" 1 (list (list "wlDriven" "boolean" t) (list "W" "float" remainderY) (list "L" "float" length))))
	   )
	 
	 (setq instName (sprintf nil "diff_%d" yCount))
	 (setq diffArea (dbCreateParamInst tcCellView diffCellId instName offsetX:(plus currentY offsetY) "R0" 1 (list (list "wlDriven" "boolean" t) (list "W" "float" bigSideY) (list "L" "float" length))))
       )
     (setq fillArea (rodCreateRect
		     ?layer diffLayer
		     ?width length
		     ?length width
		     ))
    (rodAlign
      ?alignObj fillArea
      ?alignHandle "cC"
      ?refPoint (list lAdjust wAdjust)
      )
     (setq fillAreaImp (rodCreateRect
			?layer diffImplant
			?fromObj fillArea
			?size diffImpEnc
			))
     (rodAlign
      ?alignObj fillAreaImp
      ?alignHandle "cC"
      ?refPoint (list lAdjust wAdjust)
      )

     ;; for r10, draws litr across entire cell
     (when via1ConLayer
       (setq numVia1Con (floor (quotient (plus via1ConSpacing length) (plus via1ConWidth via1ConSpacing))))
       (setq via1ConArrayWidth (plus (times numVia1Con via1ConWidth) (times (difference numVia1Con 1) via1ConSpacing)))
       (setq via1ConArrayOffset (minus (difference (quotient via1ConArrayWidth 2) (times (floor (quotient (quotient via1ConArrayWidth 2) snapGrid)) snapGrid))))
       (setq via1ConArray (rodCreateRect
			   ?layer diffLayer
			   ?width via1ConArrayWidth
			   ?length width
			   ?subRectArray list(
					      list(
						   ?layer via1ConLayer
						   ?width via1ConWidth
						   ?length width
						   ?spaceX via1ConSpacing
						   ?spaceY via1ConSpacing
						   ?gap "minimum"
						   ))
			   ))
       (setq via1ConOffset (minus (quotient (difference via1ConArrayWidth length) 2)))
       (rodAlign
	?alignObj via1ConArray
	?alignHandle "cC"
	?refPoint (list (times 2 lAdjust) wAdjust)
	)
       )

     else
     
     ;; draws diff diode
     (setq diffArea (dbCreateParamInst tcCellView diffCellId "i0" 0:0 "R0" 1 (list (list "wlDriven" "boolean" t) (list "W" "float" width) (list "L" "float" length))))
     (setq diffAreaRod (rodGetObj diffArea))
     (rodAlign
      ?alignObj diffAreaRod
      ?refPoint (list lAdjust wAdjust)
      )
     )
   
   ;; draws guard ring
   (setq guardRingCellId (dbOpenCellView tcCellView~>lib guardRingCell "symbolic" nil "rn"))
   (setq guardRing (dbCreateParamInst tcCellView guardRingCellId "i1" 0:0 "R0" 1 (list (list "innerRing" "string" "pTap") (list "innerRingMet" "string" "DDLI") (list "W" "float" (plus (times 2 tapRingDiffSpacing) width)) (list "L" "float" (plus (times 2 tapRingDiffSpacing) length)))))
   (setq guardRingRod (rodGetObj guardRing))
   (rodAlign
    ?alignObj guardRingRod
    ?refPoint (list lAdjust wAdjust)
    )

   ;; draws second metal contact
   (if useSecondMetal then
     (setq metalRect (rodCreateRect
		      ?layer met1Layer
		      ?width  (max (plus via1Size (times 2 met1EncVia1Y)) secondMetalLength)
		      ?length (plus via1Size (times 2 met1EncVia1X))
		      ?subRectArray list(
					 list(
					      ?layer via1Layer
				              ?width via1Size
					      ?length via1Size
                                              ?spaceX via1Spacing
					      ?spaceY via1Spacing
					      ?gap "minimum"
					      ?lowerLeftOffsetX met1EncVia1Y
					      ?lowerLeftOffsetY met1EncVia1X
					      ?upperRightOffsetX (minus met1EncVia1Y)
					      ?upperRightOffsetY (minus met1EncVia1X)
					      ))
		      ))
     (rodAlign
      ?alignObj metalRect
      ?refPoint (list met1OffsetX met1OffsetY)
      )
     ;; stretch handles for moving the metal contact
     (rodAssignHandleToParameter
      ?parameter "met1OffsetY"
      ?rodObj metalRect
      ?handleName (list "lL" "cL" "uL" "lR" "cR" "uR" "uL" "uC" "uR" "lL" "lC" "lR")
      ?displayName "metal y-offset"
      ?displayExpression "met1OffsetY"
      ?stretchDir "y"
      ?stretchType "absolute"
      )
     (rodAssignHandleToParameter
      ?parameter "met1OffsetX"
      ?rodObj metalRect
      ?handleName (list "lL" "cL" "uL" "lR" "cR" "uR" "uL" "uC" "uR" "lL" "lC" "lR")
      ?displayName "metal x-offset"
      ?displayExpression "met1OffsetX"
      ?stretchDir "x"
      ?stretchType "absolute"
      )
     )

   ;; stretch handles for w and l
   (rodAssignHandleToParameter
    ?parameter "width"
    ?rodObj guardRingRod
    ?handleName (list "lL" "cL" "uL" "lR" "cR" "uR" "uL" "uC" "uR" "lL" "lC" "lR")
    ?displayName "area"
    ?displayExpression "width * length"
    ?stretchDir "y"
    ?stretchType "relative"
    )
   (rodAssignHandleToParameter
    ?parameter "length"
    ?rodObj guardRingRod
    ?handleName (list "lL" "cL" "uL" "lR" "cR" "uR" "uL" "uC" "uR" "lL" "lC" "lR")
    ?stretchDir "x"
    ?stretchType "relative"
    )
   )
 )

;;; 
;;; $Id: esdFetClass.il,v 1.6 2007/02/06 15:03:58 kuc Exp $
;;; 
;;; esdFetClass.il
;;; 
;;; Copyright (c) 2006 by Cypress Semiconductor
;;; Cypress Kentucky CAD Center (KYCC)
;;; 
;;; Date  : Nov 13, 2006
;;; Author: Kungyen Chang (kuc) @ KYCC
;;; 
;;; Description:
;;;   This is an ESD pcell class
;;; 
;;; Revision History:
;;;   kuc 11/13/06  updated version to have separate parameters for X
;;;                 and Y dimensions for inner tap ring, and separate
;;;                 parameters for source and drain contacts
;;;   kuc 12/12/06  added warning labels on inner guardring
;;;   kuc 01/05/07  moved warning labels to side of inner guardring
;;;   kuc 01/24/07  modified contact to gate spacing
;;;   kuc 02/05/07  updated to support CDF menus for drain to gate spacing
;;; 


(tcCreateDeviceClass
 "symbolic" "esdFetClass"
 ;; Class parameters
 ((diffLayer            "y0") ;; diffusion drawing layer
  (gateLayer            "y1") ;; poly drawing layer
  (pgateLayer           "y2") ;; poly gate layer
  (wellLayer             nil) ;; nwell drawing layer
  (diffImplant           nil) ;; implant required on the diffusion nsdm/psdm
  (diffImpEnc            0.0) ;; enclosure of diffimplant-diffusion
  (tapLayer             "y2") ;; tap drawing layer
  (tapImplant            nil) ;; implant required on the diffusion (psdm)
  (tapImpEnc             0.0) ;; enclosure of tap implant
  (idLayer               nil) ;; id layer required on device
  (hvLayer               nil) ;; high voltage id/mask layer
  (hvWellDiffTapEnc      0.0) ;; enclosure of hv difftap by hv nwell
  (hvLayerDiffTapEnc     0.0) ;; enclosure of hvDiffTap by hvLayer
  (flareInDiff           0.0) ;; flare amount of gate inside diffusion
  (flareOutDiff          0.0) ;; flare amount of gate outside diffusion
  (flareExt              0.0) ;; extention of poly beyond flaring
  (drnInterconnect       nil)
  (srcInterconnect       nil) ;; data structure of type list 
                              ;; i.e. '("contactLayerName" contactLayerWidth contactLayerSpace 
                              ;; contactColumnsNum "upperMetLayerName" metLayerWidth metLayerBevelEdge)
  (diffContact0Yenc      0.0) ;; enclosure of contact0 by src/drn diff in the y-direction
  (diffContact0Xenc      0.0) ;; enclosure of contact0 by src/drn diff in the x-direction
  (InnerRingInterconnectHoriz nil) ;; data structure of type list 
                                   ;;'("contactLayerName" contactLayerWidth contactLayerSpace 
			           ;; contactColumnsNum "upperMetLayerName" metContactEnc innerMetBevelEdge outerMetBevelEdge)
  (InnerRingInterconnectVert  nil) ;; data structure of type list 
                                   ;;'("contactLayerName" contactLayerWidth contactLayerSpace 
			           ;; contactColumnsNum "upperMetLayerName" metContactEnc innerMetBevelEdge outerMetBevelEdge)
  (OuterRingInterconnect nil) ;; data structure of type list 
			      ;;'("contactLayerName" contactLayerWidth contactLayerSpace 
  ;; contactColumnsNum "upperMetLayerName" metContactEnc innerMetBevelEdge outerMetBevelEdge)
  (buttingTapWidth       0.0) ;; size of width of the butting tap in the x-dimension 
  (buttingTapCont0Xenc   0.0) ;; x-dimension enclosure of contact0 (licon1) by butting tap
  (fetDiffInnerRingSpace 0.0) ;; minimun space between fet diffusion and the inner ring defined from tap to diff
  (OuterInnerRingSpace   0.0) ;; space between the inner and outer ring defined from tap to tap
  (mosType            "nmos") ;; determine whether its NMOS or PMOS since same class is used for both types
  (labelLayer  (list "text" "drawing")) ;; label layer used to identify Source/Drain
  (labelWidth            1.0) ;; height of labels on Source/Drain
  (evenOnly           "TRUE") ;; boolean that requires even m-factor fets only. Default is even only
  (singleFlare       "FALSE") ;; boolean, when true creates single-sided flares; Default is double flares
  (minInnerRingFetExtraRightSpace 0.0)
  (minInnerRingFetExtraLeftSpace  0.0)
  (minInnerRingFetExtraTopSpace   0.0)
  (minInnerRingFetExtraBotSpace   0.0)
;  (minimumTotalWidth              0.0)
  (minimumM                       0)
  (srcGateContactSpaceMin         0.0)
  (srcGateContactSpaceMax         0.0)
 )
 ;; Formal parameters
 (
  (buttingTap        "FALSE") ;; boolean, when true creates butting taps at the source terminals; Default is double flares
  (w                   0.0) ;; width of the fet
  (l                   0.0) ;; length of gate
  (m                     0) ;; mfactor of the fet
  (innerRingFetExtraRightSpace 0.0)  ;; additional space between right innerRing tap and src/drn diffusion
  (innerRingFetExtraLeftSpace  0.0)  ;; additional space between left  innerRing tap and src/drn diffusion
  (innerRingFetExtraTopSpace   0.0)  ;; additional space between top   innerRing tap and src/drn diffusion
  (innerRingFetExtraBotSpace   0.0)  ;; additional space between lower innerRing tap and src/drn diffusion
  (hvMode             nil)     ;; boolean that draws the hvLayer to the 
  (rings              "Both")  ;; cyclic to select the inner and/or outer rings
  (ringsMet1Off       nil)     ;; boolean that draws the metal1 on the rings
  (userOuterRingWidth 0.0)     ;; width of outerRing defined by the user. Cannot be less than default value
  (hspiceModel        nil)
  (hspiceModelChoices nil)
  (srcGateContactSpace 0.0) ;; space between gate and source contacts in X direction 
  (drnGateContactSpaceParams nil) ;; space between gate and drain contacts in X direction 
  (drnGateContactSpaceValue nil)
  (drnGateContactSpaceName nil)
 )

 (setq met1WidthD (nth 2 drnGateContactSpaceValue))
 (setq drnGateContactSpace (nth 0 drnGateContactSpaceValue))
 (setq minimumTotalWidth (float (nth 1 drnGateContactSpaceValue)))

 ;;do minimum dimension checks, error out if invalid
  (when (lessp innerRingFetExtraRightSpace minInnerRingFetExtraRightSpace)
   (error "%.3f is less than allowable minimum right side diff to tap ring spacing %.3f\n" 
	   innerRingFetExtraRightSpace minInnerRingFetExtraRightSpace)
   )
  (when (lessp innerRingFetExtraLeftSpace minInnerRingFetExtraLeftSpace)
   (error "%.3f is less than allowable minimum left side diff to tap ring spacing %.3f\n" 
	   innerRingFetExtraLeftSpace minInnerRingFetExtraLeftSpace)
   )
  (when (lessp innerRingFetExtraTopSpace minInnerRingFetExtraTopSpace)
   (error "%.3f is less than allowable minimum top side diff to tap ring spacing %.3f\n" 
	   innerRingFetExtraTopSpace minInnerRingFetExtraTopSpace)
   )
  (when (lessp innerRingFetExtraBotSpace minInnerRingFetExtraBotSpace)
   (error "%.3f is less than allowable minimum bottom side diff to tap ring spacing %.3f\n" 
	   innerRingFetExtraBotSpace minInnerRingFetExtraBotSpace)
   )
  (when (lessp (times w m) minimumTotalWidth)
   (error "%.3f is less than allowable minimum total width %.3f for %.3f drain to gate contact spacing\n" 
	   (times w m) minimumTotalWidth drnGateContactSpace)
   )
  (when (lessp m minimumM)
   (error "%d is less than allowable minimum m factor %d\n"
	   m minimumM)
   )
  (when (lessp srcGateContactSpace srcGateContactSpaceMin)
   (error "%.3f is less than allowable minimum source contact to gate spacing %.3f"
	  srcGateContactSpace srcGateContactSpaceMin)
   )
  (when (greaterp srcGateContactSpace srcGateContactSpaceMax)
   (error "%.3f is greater than allowable maximum source contact to gate spacing %.3f"
	  srcGateContactSpace srcGateContactSpaceMax)
   )
  
  
 ;;define the esdCell point of origin
 (setq esdCellOrigin (list 0 0))

 (cond
  ((equal mosType "nmos")
   (setq idLayerEndEnc  hvWellDiffTapEnc)
   (setq hvLayerEndEnc  hvLayerDiffTapEnc)
   )
  ((equal mosType "pmos")
   (setq idLayerEndEnc  hvLayerDiffTapEnc)
   (setq hvLayerEndEnc  hvWellDiffTapEnc)
   )
  (t
   )
  )

 ;;re-calculate the spacing of the inner ring to 
 ;(when buttingTap
 ;  (setq innerRingFetRightSpace innerRingFetExtraRightSpace)
 ;  (setq innerRingFetLeftSpace  innerRingFetExtraLeftSpace)
 ;  )
 ;(unless buttingTap
   (setq innerRingFetRightSpace (plus innerRingFetExtraRightSpace fetDiffInnerRingSpace))
   (setq innerRingFetLeftSpace (plus innerRingFetExtraLeftSpace fetDiffInnerRingSpace))
 ;  )

 ;(setq innerRingFetRightSpace innerRingFetExtraRightSpace fetDiffInnerRingSpace buttingTapWidth))
 ;(setq innerRingFetLeftSpace  innerRingFetExtraLeftSpace  fetDiffInnerRingSpace buttingTapWidth))
 (setq innerRingFetTopSpace   (plus innerRingFetExtraTopSpace   fetDiffInnerRingSpace))
 (setq innerRingFetBotSpace   (plus innerRingFetExtraBotSpace   fetDiffInnerRingSpace))

 (if (or (equal hvMode t) (equal hvMode "TRUE")) then
   (setq hvMode t)
   else
   (setq hvMode nil)
   )

 (if (or (equal ringsMet1Off t) (equal ringsMet1Off "TRUE")) then
   (setq ringsMet1Off t)
   else
   (setq ringsMet1Off nil)
   )

 (if (or (equal evenOnly t) (equal evenOnly "TRUE")) then
   (setq evenOnly t)
   else
   (setq evenOnly nil)
   )
 (if (or (equal singleFlare t) (equal singleFlare "TRUE")) then
   (setq singleFlare t)
   else
   (setq singleFlare nil)
   )
 (if (or (equal buttingTap t) (equal buttingTap "TRUE")) then
   (setq buttingTap t)
   else
   (setq buttingTap nil)
   )

 (when (and (oddp m) evenOnly)
   (error "Illegal m-factor: m-factor must be even number\n"))

 (setq contact0InfoS  (nth 0 srcInterconnect))
 (setq contact0LayerS (nth 0 contact0InfoS))
 (setq contact0WidthS (nth 1 contact0InfoS))
 (setq contact0SpaceS (nth 2 contact0InfoS))
 (setq contact0ColsS  (nth 3 contact0InfoS))
 (setq met0LayerS     (nth 4 contact0InfoS))
 (setq met0WidthS     (nth 5 contact0InfoS))
 (setq met0SpaceS     (nth 6 contact0InfoS))
 (setq met0BevelS     (nth 7 contact0InfoS)) ;;met0Bevel is not supported

 (setq contact1InfoS  (nth 1 srcInterconnect))
 (setq contact1LayerS (nth 0 contact1InfoS))
 (setq contact1WidthS (nth 1 contact1InfoS))
 (setq contact1SpaceS (nth 2 contact1InfoS))
 (setq contact1ColsS  (nth 3 contact1InfoS))
 (setq met1LayerS     (nth 4 contact1InfoS))
 (setq met1WidthS     (nth 5 contact1InfoS))
 (setq met1SpaceS     (nth 6 contact1InfoS))
 (setq met1BevelS     (nth 7 contact1InfoS))

 (setq contact0InfoD  (nth 0 drnInterconnect))
 (setq contact0LayerD (nth 0 contact0InfoD))
 (setq contact0WidthD (nth 1 contact0InfoD))
 (setq contact0SpaceD (nth 2 contact0InfoD))
 (setq contact0ColsD  (nth 3 contact0InfoD))
 (setq met0LayerD     (nth 4 contact0InfoD))
 (setq met0WidthD     (nth 5 contact0InfoD))
 (setq met0SpaceD     (nth 6 contact0InfoD))
 (setq met0BevelD     (nth 7 contact0InfoD)) ;;met0Bevel is not supported

 (setq contact1InfoD  (nth 1 drnInterconnect))
 (setq contact1LayerD (nth 0 contact1InfoD))
 (setq contact1WidthD (nth 1 contact1InfoD))
 (setq contact1SpaceD (nth 2 contact1InfoD))
 (setq contact1ColsD  (nth 3 contact1InfoD))
 (setq met1LayerD     (nth 4 contact1InfoD))
 ;(setq met1WidthD     (nth 5 contact1InfoD))
 (setq met1SpaceD     (nth 6 contact1InfoD))
 (setq met1BevelD     (nth 7 contact1InfoD))

 (setq srcPinWidth (plus (times contact0WidthS contact0ColsS) (times (plus contact0ColsS -1) contact0SpaceS)))
 (setq drnPinWidth (plus (times contact0WidthD contact0ColsD) (times (plus contact0ColsD -1) contact0SpaceD)))
 (setq mSourcePinOffset srcGateContactSpace)
 (setq mDrainPinOffset  drnGateContactSpace)
 (setq sharedSourceWidth (plus (times mSourcePinOffset 2.0) srcPinWidth))
 (setq sharedDrainWidth  (plus (times mDrainPinOffset  2.0) drnPinWidth))

 ;;This is used to resize the src/drn metal if the min metal space is violated
; (setq Metal0Space  (plus l srcPinWidth mSourcePinOffset mDrainPinOffset -met0Width))
; (when (lessp Metal0Space met0Space)
;   (setq met0Width     (plus met0Width (difference Metal0Space met0Space)))
;   (setq met0Width     (times (floor (times met0Width 100)) 0.01))
;   )
; (setq Metal1Space  (plus l srcdrnPinWidth mSourcePinOffset mDrainPinOffset -met1Width))
; (when (lessp Metal1Space met1Space)
;   (setq met1Width     (plus met1Width (difference Metal1Space met1Space) ))
;   (setq met1Width     (times (floor (times met1Width 100)) 0.01))
;   )

 (setq firstSourcePin
       (rodCreateRect
	?layer diffLayer
	?width srcPinWidth
	?length w
	?pin t
	?termName "S"
	?termIOType "inputOutput"
	?pinAccessDir (list "top" "bottom")
	?pinLabel t
	?pinLabelHeight labelWidth
	?pinLabelLayer labelLayer
	?pinLabelFont "roman"
	?subRectArray
	(list (list ?layer contact0LayerS
		    ?width  contact0WidthS
		    ?length contact0WidthS
		    ?spaceY contact0SpaceS
		    ?spaceX contact0SpaceS
		    ?lowerLeftOffsetY  diffContact0Yenc
		    ?upperRightOffsetY -diffContact0Yenc
		    ))
	))
 (rodAlign
  ?alignObj firstSourcePin
  ?alignHandle "lR"
  ?refPoint esdCellOrigin
  ?xSep -mSourcePinOffset
  )

;;Draw the met0Layer for the first source
 (setq contact1PitchS (plus contact1WidthS contact1SpaceS ))
 (setq contact1PitchD (plus contact1WidthD contact1SpaceD ))
 (setq met0PinWidthS (plus (times contact1WidthS contact1ColsS) (times (plus contact1ColsS -1) contact1SpaceS)))
 (setq met0PinWidthD (plus (times contact1WidthD contact1ColsD) (times (plus contact1ColsD -1) contact1SpaceD)))
 (setq firstMet0Pin
       (rodCreateRect
	?layer met0LayerS
	?width met0PinWidthS
	?length w
	?pin t
	?termName "S"
	?termIOType "inputOutput"
	?pinAccessDir (list "top" "bottom")
	?subRectArray
	(list (list ?layer contact1LayerS
		    ?width  contact1WidthS
		    ?length contact1WidthS
		    ?spaceY contact1SpaceS
		    ?spaceX contact1SpaceS
		    ?lowerLeftOffsetY  diffContact0Yenc
		    ?upperRightOffsetY -diffContact0Yenc
		    ))
	))

 (rodAlign
  ?alignObj firstMet0Pin
  ?alignHandle "lC"
  ?refObj firstSourcePin
  ?refHandle "lC"
  )

 (setq firstMet0Drawing
       (rodCreateRect
	?layer met0LayerS
	?width met0WidthS
	?length w
	))
 (rodAlign
  ?alignObj firstMet0Drawing
  ?alignHandle "lC"
  ?refObj  firstMet0Pin
  ?refHandle "lC"
  )

 ;;Define the points for the beveled met1Layer
 (declare met1DrawingPtsS[8])
 (declare met1DrawingPtsD[8])
;;     ______
;;    /2    3;;   /        ;;   |1      4|
;;   |        |
;;   |        |        
;;   |        |        
;;   |        |             
;;   |        | 
;;   |        |
;;   |0      5|
;;   \        /
;;    \______/
;;    7      6

 (setq x0Met1 0.0)
 (setq y0Met1 0.0)
 met1DrawingPtsS[0]  = x0Met1:(plus y0Met1 met1BevelS)
 met1DrawingPtsS[1]  = x0Met1:(difference w met1BevelS)
 met1DrawingPtsS[2]  = met1BevelS:w
 met1DrawingPtsS[3]  = (plus met1WidthS -met1BevelS):w
 met1DrawingPtsS[4]  = met1WidthS:(difference w met1BevelS)
 met1DrawingPtsS[5]  = met1WidthS:(plus y0Met1 met1BevelS)
 met1DrawingPtsS[6]  = (plus met1WidthS -met1BevelS):0
 met1DrawingPtsS[7]  = met1BevelS:0
 (setq firstMet1pointsS nil)
 (for i 1 8
      (setq firstMet1pointsS
	    (cons (car met1DrawingPtsS[8 - i]):(cadr met1DrawingPtsS[8 - i]) firstMet1pointsS))
      )

 (setq x0Met1 0.0)
 (setq y0Met1 0.0)
 met1DrawingPtsD[0]  = x0Met1:(plus y0Met1 met1BevelD)
 met1DrawingPtsD[1]  = x0Met1:(difference w met1BevelD)
 met1DrawingPtsD[2]  = met1BevelD:w
 met1DrawingPtsD[3]  = (plus met1WidthD -met1BevelD):w
 met1DrawingPtsD[4]  = met1WidthD:(difference w met1BevelD)
 met1DrawingPtsD[5]  = met1WidthD:(plus y0Met1 met1BevelD)
 met1DrawingPtsD[6]  = (plus met1WidthD -met1BevelD):0
 met1DrawingPtsD[7]  = met1BevelD:0
 (setq firstMet1pointsD nil)
 (for i 1 8
      (setq firstMet1pointsD
	    (cons (car met1DrawingPtsD[8 - i]):(cadr met1DrawingPtsD[8 - i]) firstMet1pointsD))
      )

 (setq firstMet1Drawing
       (rodCreatePolygon
	?layer met1LayerS
	?pts firstMet1pointsS
	?pin t
	?termName "S"
	?termIOType "inputOutput"
	?pinAccessDir (list "top" "bottom")
	))
 (rodAlign
  ?alignObj firstMet1Drawing
  ?alignHandle "cC"
  ?refObj  firstMet0Drawing
  ?refHandle "cC"
  )

(when (onep m)
 (setq firstDrainPin
       (rodCreateRect
	?layer diffLayer
	?width drnPinWidth
	?length w
	?pin t
	?termName "D"
	?termIOType "inputOutput"
	?pinAccessDir (list "top" "bottom")
	?pinLabel t
	?pinLabelHeight labelWidth
	?pinLabelLayer labelLayer
	?pinLabelFont "roman"
	?subRectArray
	(list (list ?layer  contact0LayerD
		    ?width  contact0WidthD
		    ?length contact0WidthD
		    ?spaceY contact0SpaceD
		    ?spaceX contact0SpaceD
		    ?lowerLeftOffsetY  diffContact0Yenc
		    ?upperRightOffsetY -diffContact0Yenc
		    ))
	))
 (rodAlign
  ?alignObj firstDrainPin
  ?alignHandle "lL"
  ?refPoint esdCellOrigin
  ?xSep (plus l mDrainPinOffset)
  )

;;Draw the drain met0Layer
 (setq oneDrainMet0Pin
       (rodCreateRect
	?layer met0LayerD
	?width met0PinWidthD
	?length w
	?pin t
	?termName "D"
	?termIOType "inputOutput"
	?pinAccessDir (list "top" "bottom")
	?subRectArray
	(list (list ?layer contact1LayerD
		    ?width  contact1WidthD
		    ?length contact1WidthD
		    ?spaceY contact1SpaceD
		    ?spaceX contact1SpaceD
		    ?lowerLeftOffsetY  diffContact0Yenc
		    ?upperRightOffsetY -diffContact0Yenc
		    ))
	))

 (rodAlign
  ?alignObj oneDrainMet0Pin
  ?alignHandle "lC"
  ?refObj firstDrainPin
  ?refHandle "lC"
  )

 (setq drainMet0Drawing
       (rodCreateRect
	?layer met0LayerD
	?width met0WidthD
	?length w
	))
 (rodAlign
  ?alignObj drainMet0Drawing
  ?alignHandle "lC"
  ?refObj  oneDrainMet0Pin
  ?refHandle "lC"
  )

 ;;Create beveled met1Layer on the drain
 (setq drainMet1Drawing
       (rodCreatePolygon
	?layer met1LayerD
	?pts firstMet1pointsD
	?pin t
	?termName "D"
	?termIOType "inputOutput"
	?pinAccessDir (list "top" "bottom")
	))
 (rodAlign
  ?alignObj drainMet1Drawing
  ?alignHandle "cC"
  ?refObj  drainMet0Drawing
  ?refHandle "cC"
  )
)

(setq sourcePinsNumber 1)
(setq drainPinsNumber  1)

(when (greaterp m 1)
  ;;Remember that a source terminal has already been created
  (setq sourcePinsNumber (quotient m 2))
  (setq sourcePinsSpace  (plus (times l 2) sharedDrainWidth (times mSourcePinOffset 2.0)))
  ;;Create the source terminals
  (setq sourcePinsOriginX (plus (car esdCellOrigin) (times l 2) sharedDrainWidth mSourcePinOffset))
  (setq sourcePinsOriginOffset  (plus sourcePinsSpace srcPinWidth))

  (for n 1 sourcePinsNumber

       ;;The origin of the remaining source terminals is after the first shared drain
       (setq sourcePinsOrigin (list (plus sourcePinsOriginX (times (difference n 1) sourcePinsOriginOffset)) 0.0))
       (setq sourcePins
	     (rodCreateRect
	      ?layer diffLayer
	      ?width srcPinWidth
	      ?length w
	      ?origin sourcePinsOrigin
	      ?pin t
	      ?termName "S"
	      ?termIOType "inputOutput"
	      ?pinAccessDir (list "top" "bottom")
	      ?pinLabel t
	      ?pinLabelHeight labelWidth
	      ?pinLabelLayer labelLayer
	      ?pinLabelFont "roman"
	      ?subRectArray
	      (list (list ?layer contact0LayerS
			  ?width  contact0WidthS
			  ?length contact0WidthS
			  ?spaceY contact0SpaceS
			  ?spaceX contact0SpaceS
			  ?lowerLeftOffsetY  diffContact0Yenc
			  ?upperRightOffsetY -diffContact0Yenc
			  ))
	      ))
  
       (setq sourceMet0Pins
	     (rodCreateRect
	      ?layer met0LayerS
	      ?width met0PinWidthS
	      ?length w
	      ?pin t
	      ?termName "S"
	      ?termIOType "inputOutput"
	      ?pinAccessDir (list "top" "bottom")
	      ?subRectArray
	      (list (list ?layer contact1LayerS
			  ?width  contact1WidthS
			  ?length contact1WidthS
			  ?spaceY contact1SpaceS
			  ?spaceX contact1SpaceS
			  ?lowerLeftOffsetY  diffContact0Yenc
			  ?upperRightOffsetY -diffContact0Yenc
			  ))
	      ))

  (rodAlign
   ?alignObj sourceMet0Pins
   ?alignHandle "lC"
   ?refObj sourcePins
   ?refHandle "lC"
   )
  (setq sourceMet0Drawing
	(rodCreateRect
	 ?layer met0LayerS
	 ?width met0WidthS
	 ?length w
	 ))
  (rodAlign
   ?alignObj sourceMet0Drawing
   ?alignHandle "lC"
   ?refObj  sourceMet0Pins
   ?refHandle "lC"
   )

 ;;Create beveled met1Layer on the source terminals
  (setq sourceMet1Drawing
	(rodCreatePolygon
	 ?layer met1LayerS
	 ?pts firstMet1pointsS
	 ?pin t
	 ?termName "S"
	 ?termIOType "inputOutput"
	 ?pinAccessDir (list "top" "bottom")
	 ))
  (rodAlign
   ?alignObj sourceMet1Drawing
   ?alignHandle "cC"
   ?refObj  sourceMet0Drawing
   ?refHandle "cC"
   )
 )

  (setq drainPinsNumber (ceiling (quotient m 2.0)))
  (setq drainPinsSpace  (plus (times l 2) sharedSourceWidth (times mDrainPinOffset 2.0)))
  ;;Create the drain terminals
  (setq drainPinsOriginX (plus (car esdCellOrigin) l mDrainPinOffset))
  (setq drainPinsOriginOffset  (plus drainPinsSpace drnPinWidth))
  (for n 1 drainPinsNumber

       ;;The origin of the remaining drain terminals is after the first single source
       (setq drainPinsOrigin (list (plus drainPinsOriginX (times (difference n 1) drainPinsOriginOffset)) 0.0))
       (setq drainPins
	     (rodCreateRect
	      ?layer diffLayer
	      ?width drnPinWidth
	      ?length w
	      ?origin drainPinsOrigin
	      ?pin t
	      ?termName "D"
	      ?termIOType "inputOutput"
	      ?pinAccessDir (list "top" "bottom")
	      ?pinLabel t
	      ?pinLabelHeight labelWidth
	      ?pinLabelLayer labelLayer
	      ?pinLabelFont "roman"
	      ?subRectArray
	      (list (list ?layer  contact0LayerD
			  ?width  contact0WidthD
			  ?length contact0WidthD
			  ?spaceY contact0SpaceD
			  ?spaceX contact0SpaceD
			  ?lowerLeftOffsetY  diffContact0Yenc
			  ?upperRightOffsetY -diffContact0Yenc
			  ))
	      ))
  
       (setq drainMet0Pins
	     (rodCreateRect
	      ?layer met0LayerD
	      ?width met0PinWidthD
	      ?length w
	      ?pin t
	      ?termName "D"
	      ?termIOType "inputOutput"
	      ?pinAccessDir (list "top" "bottom")
	      ?subRectArray
	      (list (list ?layer  contact1LayerD
			  ?width  contact1WidthD
			  ?length contact1WidthD
			  ?spaceY contact1SpaceD
			  ?spaceX contact1SpaceD
			  ?lowerLeftOffsetY  diffContact0Yenc
			  ?upperRightOffsetY -diffContact0Yenc
			  ))
	      ))

  (rodAlign
   ?alignObj drainMet0Pins
   ?alignHandle "lC"
   ?refObj drainPins
   ?refHandle "lC"
   )
  (setq drainMet0Drawing
	(rodCreateRect
	 ?layer met0LayerD
	 ?width met0WidthD
	 ?length w
	 ))
  (rodAlign
   ?alignObj drainMet0Drawing
   ?alignHandle "lC"
   ?refObj  drainMet0Pins
   ?refHandle "lC"
   )

 ;;Create beveled met1Layer on the drain terminals
  (setq drainMet1Drawing
	(rodCreatePolygon
	 ?layer met1LayerD
	 ?pts firstMet1pointsD
	 ?pin t
	 ?termName "D"
	 ?termIOType "inputOutput"
	 ?pinAccessDir (list "top" "bottom")
	 ))
  (rodAlign
   ?alignObj drainMet1Drawing
   ?alignHandle "cC"
   ?refObj  drainMet0Drawing
   ?refHandle "cC"
   )

  )

)

(setq flareY (plus flareOutDiff flareExt))
(cond 
 (singleFlare
  
  (declare oddflareGatePts[8])
;;  1 ____ 2
;;   |    |
;;   |    |
;;   |   / 3 
;;   |  /    
;;   | | 4  
;;   | |    
;;   | |    
;;   | |    
;;   | | 5  
;;   |  \   
;;   |   \ 6
;;   |    |
;;   |____|
;;  0      7
  (setq xo0 0.0)
  (setq xo2 (plus xo0 l flareInDiff flareOutDiff))
  (setq xo4 (plus xo0 l))
  oddflareGatePts[0]  = xo0:-flareY
  oddflareGatePts[1]  = xo0:(plus w flareY)
  oddflareGatePts[2]  = xo2:(plus w flareY)
  oddflareGatePts[3]  = xo2:(plus w flareOutDiff)
  oddflareGatePts[4]  = xo4:(plus w -flareInDiff)
  oddflareGatePts[5]  = xo4:flareInDiff
  oddflareGatePts[6]  = xo2:-flareOutDiff
  oddflareGatePts[7]  = xo2:-flareY

  (declare evenflareGatePts[8])
  ;;   5 ____ 6  
  ;;    |    |   
  ;;    |    |  
  ;;  4  \   | 
  ;;      \  |  
  ;;    3  | |
  ;;       | |  
  ;;       | |  
  ;;       | |
  ;;    2  | |
  ;;      /  |  
  ;;  1  /   |
  ;;    |    | 
  ;;    |____|
  ;;  0       7
  ;;
  (setq xe0 (plus xo0 -flareOutDiff -flareInDiff))
  (setq xe2 (plus xe0 flareInDiff flareOutDiff))
  (setq xe6 (plus xe2 l))
  evenflareGatePts[0]  = xe0:-flareY
  evenflareGatePts[1]  = xe0:-flareOutDiff
  evenflareGatePts[2]  = xe2:flareInDiff
  evenflareGatePts[3]  = xe2:(plus w -flareInDiff)
  evenflareGatePts[4]  = xe0:(plus w flareOutDiff)
  evenflareGatePts[5]  = xe0:(plus w flareY)
  evenflareGatePts[6]  = xe6:(plus w flareY)
  evenflareGatePts[7]  = xe6:-flareY

  (for i 1 8
       (setq pointList1 
	     (cons (car oddflareGatePts[8 - i]):(cadr oddflareGatePts[8 - i]) pointList1))
       )
  (setq firstGateDrawing
	(rodCreatePolygon
	 ?layer gateLayer
	 ?pts pointList1
	 ?pin t
	 ?termName "G"
	 ?termIOType "input"
	 ?pinAccessDir (list "top" "bottom")
	 ))

  )
 (t

  (declare flareGatePts[12])
  ;;   5 _______ 6  
  ;;    |       |   
  ;;    |       |  
  ;;  4  \     / 7
  ;;      \   /  
  ;;    3  | | 8
  ;;       | |  
  ;;       | |  
  ;;       | |
  ;;    2  | | 9
  ;;      /   \ 
  ;;  1  /     \ 10
  ;;    |       |
  ;;    |_______|
  ;;  0          11
  ;;
  (setq x0 (plus -flareOutDiff -flareInDiff))
  (setq x2 (plus x0 flareInDiff flareOutDiff))
  (setq x6 (plus x2 l -x0))
  (setq x8 (plus x2 l))
  flareGatePts[0]  = x0:-flareY
  flareGatePts[1]  = x0:-flareOutDiff
  flareGatePts[2]  = x2:flareInDiff
  flareGatePts[3]  = x2:(plus w -flareInDiff)
  flareGatePts[4]  = x0:(plus w flareOutDiff)
  flareGatePts[5]  = x0:(plus w flareY)
  flareGatePts[6]  = x6:(plus w flareY)
  flareGatePts[7]  = x6:(plus w flareOutDiff)
  flareGatePts[8]  = x8:(plus w -flareInDiff)
  flareGatePts[9]  = x8:flareInDiff
  flareGatePts[10]  = x6:-flareOutDiff
  flareGatePts[11]  = x6:-flareY

  (setq pointList1 nil)
  (for i 1 12
       (setq pointList1 
	     (cons (car flareGatePts[12 - i]):(cadr flareGatePts[12 - i]) pointList1))
       )
  (setq firstGateDrawing
	(rodCreatePolygon
	 ?layer gateLayer
	 ?pts pointList1
	 ?pin t
	 ?termName "G"
	 ?termIOType "input"
	 ?pinAccessDir (list "top" "bottom")
	 ))
  )
 )

(setq oddGateOffset  0.0)
(for n 2 m
     ;; Draw poly gate of fet
     (when (oddp n)
       (setq pointList1 nil)
       (setq oddGateOffset  (plus sharedDrainWidth l sharedSourceWidth l oddGateOffset))
       (cond
	(singleFlare
	 (for i 1 8
	      (setq pointList1 
		    (cons (plus (car oddflareGatePts[8 - i]) oddGateOffset):(cadr oddflareGatePts[8 - i]) pointList1))
	      )
	 )
	(t
	 (for i 1 12
	      (setq pointList1 
		    (cons (plus (car flareGatePts[12 - i]) oddGateOffset):(cadr flareGatePts[12 - i]) pointList1))
	      )
	 )
	)
       (setq oddGateDrawing
	     (rodCreatePolygon
	      ?layer gateLayer
	      ?pts pointList1
	      ?pin t
	      ?termName "G"
	      ?termIOType "input"
	      ?pinAccessDir (list "top" "bottom")
	      ))
       )

     (when (evenp n)
       (setq pointList2 nil)
       (if  (equal n 2) then
	 (setq evenGateOffset  (plus sharedDrainWidth l))
	 else
	 (setq evenGateOffset  (plus sharedDrainWidth l sharedSourceWidth l evenGateOffset))
	 )
       (cond
	(singleFlare
	 (for i 1 8
	      (setq pointList2 
		    (cons (plus (car evenflareGatePts[8 - i]) evenGateOffset):(cadr evenflareGatePts[8 - i]) pointList2))
	      )
	 )
	(t
	 (for i 1 12
	      (setq pointList2
		    (cons (plus (car flareGatePts[12 - i]) evenGateOffset):(cadr flareGatePts[12 - i]) pointList2))
	      )
	 )
	)
       (setq evenGateDrawing
	     (rodCreatePolygon
	      ?layer gateLayer
	      ?pts pointList2
	      ?pin t
	      ?termName "G"
	      ?termIOType "input"
	      ?pinAccessDir (list "top" "bottom")
	      ))
       )
     )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Draw poly gate of fet
(when pgateLayer
 (setq oddPGateDrawing 
       (rodCreateRect
	?layer pgateLayer
	?width l
	?length w
	?origin esdCellOrigin
	?elementsX (ceiling (quotient m 2.0))
	?spaceX (plus sharedDrainWidth l sharedSourceWidth)
	))

 (when (greaterp m 1)
   (setq evenPGateDrawing 
	 (rodCreateRect
	  ?layer pgateLayer
	  ?width l
	  ?length w
	  ?origin (list (plus sharedDrainWidth l) 0)
	  ?elementsX (quotient m 2)
	  ?spaceX (plus sharedDrainWidth l sharedSourceWidth)
	  ))
   )
 )

;; Draw diff under the gate
(cond
 ((onep m)
  (setq fetDiffusionXdim
	(plus (times l m) 
	       (plus drnPinWidth diffContact0Xenc mDrainPinOffset)
	       (plus srcPinWidth diffContact0Xenc mSourcePinOffset))
	      )
	)
  ((oddp m);;the last terminal is drain and not m=1
   (setq fetDiffusionXdim
	 (plus (times l m) 
	       (times sharedSourceWidth sourcePinsNumber)
	       (times sharedDrainWidth  (plus drainPinsNumber -1))
	       (plus drnPinWidth diffContact0Xenc mDrainPinOffset)
	       (plus srcPinWidth diffContact0Xenc mSourcePinOffset))
	 )
   )
  ((evenp m);;the last terminal is source
   (setq fetDiffusionXdim
	 (plus (times l m) 
	       (times sharedSourceWidth (plus sourcePinsNumber -1))
	       (times sharedDrainWidth  drainPinsNumber)
	       (times (plus srcPinWidth diffContact0Xenc mSourcePinOffset) 2.0)
	       )
	 )
   )
(t
 )
)

(setq fetDiffusion
      (rodCreateRect
       ?layer diffLayer
       ?width fetDiffusionXdim
       ?length w
       ))

 (rodAlign
  ?alignObj fetDiffusion
  ?alignHandle "lL"
  ?refObj firstSourcePin
  ?refHandle "lL"
  ?xSep -diffContact0Xenc
  )
(cond
 (buttingTap
  (setq firstSourceTap
	(rodCreateRect
	 ?layer  tapLayer
	 ?width  buttingTapWidth
	 ?length w
	 ?pin t
;	 ?subRectArray
;	 (list (list ?layer contact0LayerS
;		     ?width  contact0WidthS
;		     ?length contact0WidthS
;		     ?spaceY contact0SpaceS
;		     ?spaceX contact0SpaceS
;		     ?lowerLeftOffsetX  buttingTapCont0Xenc
;		     ?upperRightOffsetX -buttingTapCont0Xenc
;		     ?lowerLeftOffsetY  diffContact0Yenc
;		     ?upperRightOffsetY -diffContact0Yenc
;		     ))
	 ))
  (rodAlign
   ?alignObj firstSourceTap
   ?alignHandle "lR"
   ?refObj fetDiffusion
   ?refHandle "lL"
   )
  (setq firstSourceTapMet0
	(rodCreateRect
	 ?layer met0LayerS
	 ?width (plus buttingTapWidth diffContact0Xenc)
	 ?length w
	 ))
  (rodAlign
   ?alignObj firstSourceTapMet0
   ?alignHandle "cL"
   ?refObj firstSourceTap
   ?refHandle "cL"
   )
  (setq firstSourceTapMet1
	(rodCreateRect
	 ?layer met1LayerS
	 ?width (plus buttingTapWidth (times 2 diffContact0Xenc))
	 ?length w
	 ))
  (rodAlign
   ?alignObj firstSourceTapMet1
   ?alignHandle "cC"
   ?refObj firstSourceTap
   ?refHandle "cC"
   )
  (setq firstSourceTapImp
	(rodCreateRect
	 ?layer  tapImplant
	 ?width  (plus buttingTapWidth tapImpEnc)
	 ?length (plus w (times 2.0 tapImpEnc))
	 ))
  (rodAlign
   ?alignObj firstSourceTapImp
   ?alignHandle "lR"
   ?refObj firstSourceTap
   ?refHandle "lR"
   ?ySep -tapImpEnc
   )
  
  (setq lastSourceTap
	(rodCreateRect
	 ?layer  tapLayer
	 ?width  buttingTapWidth
	 ?length w
	 ?pin t
;	 ?subRectArray
;	 (list (list ?layer contact0LayerS
;		     ?width  contact0WidthS
;		     ?length contact0WidthS
;		     ?spaceY contact0SpaceS
	;	     ?spaceX contact0SpaceS
	;;	     ?lowerLeftOffsetX  buttingTapCont0Xenc
	;	     ?upperRightOffsetX -buttingTapCont0Xenc
	;	     ?lowerLeftOffsetY  diffContact0Yenc
	;	     ?upperRightOffsetY -diffContact0Yenc
	;	     ))
	 ))
  (rodAlign
   ?alignObj lastSourceTap
   ?alignHandle "lL"
   ?refObj fetDiffusion
   ?refHandle "lR"
   )
  (setq lastSourceTapMet0
	(rodCreateRect
	 ?layer met0LayerS
	 ?width (plus buttingTapWidth diffContact0Xenc)
	 ?length w
	 ))
  (rodAlign
   ?alignObj lastSourceTapMet0
   ?alignHandle "cR"
   ?refObj lastSourceTap
   ?refHandle "cR"
   )
  (setq lastSourceTapMet1
	(rodCreateRect
	 ?layer met1LayerS
	 ?width (plus buttingTapWidth (times 2 diffContact0Xenc))
	 ?length w
	 ))
  (rodAlign
   ?alignObj lastSourceTapMet1
   ?alignHandle "cC"
   ?refObj lastSourceTap
   ?refHandle "cC"
   )  
  (setq fetDiffImp
	(rodCreateRect
	 ?layer diffImplant
	 ?width  fetDiffusionXdim
	 ?length (plus w (times 2.0 diffImpEnc))
	 ))
  (rodAlign
   ?alignObj fetDiffImp
   ?alignHandle "lL"
   ?refObj fetDiffusion
   ?refHandle "lL"
   ?ySep -diffImpEnc
   )
  (setq lastSourceTapImp
	(rodCreateRect
	 ?layer  tapImplant
	 ?width  (plus buttingTapWidth tapImpEnc)
	 ?length (plus w (times 2.0 tapImpEnc))
	 ))
  (rodAlign
   ?alignObj lastSourceTapImp
   ?alignHandle "lL"
   ?refObj lastSourceTap
   ?refHandle "lL"
   ?ySep -tapImpEnc
   )
  
  (when (and (equal mosType "pmos") (equal rings "None"))
    (setq wellLayerDrawing
	  (rodCreateRect
	   ?layer wellLayer
	   ?width  (plus fetDiffusionXdim (times 2.0 buttingTapWidth) (times 2.0 hvWellDiffTapEnc))
	   ?length (plus w (times 2.0 hvWellDiffTapEnc))
	   ))
    (rodAlign
     ?alignObj wellLayerDrawing
     ?alignHandle "lL"
     ?refObj firstSourceTap
     ?refHandle "lL"
     ?xSep -hvWellDiffTapEnc
     ?ySep -hvWellDiffTapEnc
     )
    )
  )
 (t
  (setq fetDiffImp
	(rodCreateRect
	 ?layer diffImplant
	 ?fromObj fetDiffusion
	 ?size diffImpEnc
	 ))
  
  (when (and (equal mosType "pmos") (equal rings "None"))
    (setq wellLayerDrawing
	  (rodCreateRect
	   ?layer wellLayer
	   ?fromObj fetDiffusion
	   ?size hvWellDiffTapEnc
	   ))
    )
  )
 )

;;##################################InnerRing Generation##################################
;;(unless ringsOff
(when (or (equal rings "Inner") (equal rings "Both"))

  ;; parameters for top and bottom segments of inner ring
  (setq ringContact0InfoH  (nth 0 InnerRingInterconnectHoriz))
  (setq ringContact0LayerH (nth 0 ringContact0InfoH))
  (setq ringContact0WidthH (nth 1 ringContact0InfoH))
  (setq ringContact0SpaceH (nth 2 ringContact0InfoH))
  (setq ringContact0ColsH  (nth 3 ringContact0InfoH))
  (setq ringMet0LayerH     (nth 4 ringContact0InfoH))
  (setq ringMet0Cont0EncH  (nth 5 ringContact0InfoH))
  (setq ringMet0InBevelH   (nth 6 ringContact0InfoH))
  (setq ringMet0OutBevelH  (nth 7 ringContact0InfoH));;ringMet0OutBevel is not supported

  (setq ringContact1InfoH  (nth 1 InnerRingInterconnectHoriz))
  (setq ringContact1LayerH (nth 0 ringContact1InfoH))
  (setq ringContact1WidthH (nth 1 ringContact1InfoH))
  (setq ringContact1SpaceH (nth 2 ringContact1InfoH))
  (setq ringContact1ColsH  (nth 3 ringContact1InfoH))
  (setq ringMet1LayerH     (nth 4 ringContact1InfoH))
  (setq ringMet1Cont1EncH  (nth 5 ringContact1InfoH))
  (setq ringMet1InBevelH   (nth 6 ringContact1InfoH))
  (setq ringMet1OutBevelH  (nth 7 ringContact1InfoH))

  ;; parameters for left and right segments of inner ring
  (setq ringContact0InfoV  (nth 0 InnerRingInterconnectVert))
  (setq ringContact0LayerV (nth 0 ringContact0InfoV))
  (setq ringContact0WidthV (nth 1 ringContact0InfoV))
  (setq ringContact0SpaceV (nth 2 ringContact0InfoV))
  (setq ringContact0ColsV  (nth 3 ringContact0InfoV))
  (setq ringMet0LayerV     (nth 4 ringContact0InfoV))
  (setq ringMet0Cont0EncV  (nth 5 ringContact0InfoV))
  (setq ringMet0InBevelV   (nth 6 ringContact0InfoV))
  (setq ringMet0OutBevelV  (nth 7 ringContact0InfoV));;ringMet0OutBevel is not supported

  (setq ringContact1InfoV  (nth 1 InnerRingInterconnectVert))
  (setq ringContact1LayerV (nth 0 ringContact1InfoV))
  (setq ringContact1WidthV (nth 1 ringContact1InfoV))
  (setq ringContact1SpaceV (nth 2 ringContact1InfoV))
  (setq ringContact1ColsV  (nth 3 ringContact1InfoV))
  (setq ringMet1LayerV     (nth 4 ringContact1InfoV))
  (setq ringMet1Cont1EncV  (nth 5 ringContact1InfoV))
  (setq ringMet1InBevelV   (nth 6 ringContact1InfoV))
  (setq ringMet1OutBevelV  (nth 7 ringContact1InfoV))

  (setq ringContact0PitchH  (plus ringContact0WidthH ringContact0SpaceH ))
  (setq ringContact0PitchV  (plus ringContact0WidthV ringContact0SpaceV ))

  (setq innerRingWidthH     (plus (times ringContact0WidthH ringContact0ColsH)
				 (times (plus ringContact0ColsH -1) ringContact0SpaceH) (times 2.0 ringMet0Cont0EncH)))
  (setq innerRingWidthV     (plus (times ringContact0WidthV ringContact0ColsV)
				 (times (plus ringContact0ColsV -1) ringContact0SpaceV) (times 2.0 ringMet0Cont0EncV)))

  (setq innerRingLengthLR    (plus w innerRingFetTopSpace innerRingFetBotSpace (times 2.0 innerRingWidthH)))
  (setq innerRingLengthTB    (plus fetDiffusionXdim innerRingFetRightSpace innerRingFetLeftSpace (times 2.0 innerRingWidthV)))

  (setq ringContact1PitchH  (plus ringContact1WidthH ringContact1SpaceH ))
  (setq ringContact1PitchV  (plus ringContact1WidthV ringContact1SpaceV ))

  (setq innerMet1RingWidthH (plus (times ringContact1WidthH ringContact1ColsH)
				 (times (plus ringContact1ColsH -1) ringContact1SpaceH) (times 2.0 ringMet1Cont1EncH)))
  (setq innerMet1RingWidthV (plus (times ringContact1WidthV ringContact1ColsV)
				 (times (plus ringContact1ColsV -1) ringContact1SpaceV) (times 2.0 ringMet1Cont1EncV)))

;;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  (when (lessp innerMet1RingWidthH ringMet1OutBevelH)
    (setq ringMet1OutBevelH  innerMet1RingWidthH)
    )
  (when (lessp innerMet1RingWidthV ringMet1OutBevelV)
    (setq ringMet1OutBevelV  innerMet1RingWidthV)
    )
;;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

  ;;Create left side of the ring
  (setq leftInnerRing
	(rodCreateRect
	 ?layer tapLayer
	 ?width innerRingWidthV
	 ?length innerRingLengthLR
	 ?subRectArray
	 (list (list ?layer  ringContact0LayerV
		     ?width  ringContact0WidthV
		     ?length ringContact0WidthV
		     ?spaceY ringContact0SpaceV
		     ?spaceX ringContact0SpaceV
		     ?lowerLeftOffsetY  (plus innerRingWidthH ringContact0PitchH)
		     ?upperRightOffsetY (plus -innerRingWidthH -ringContact0PitchH)
		     ))
	 ))
  (rodAlign
   ?alignObj leftInnerRing
   ?alignHandle "lR"
   ?refObj fetDiffusion
   ?refHandle "lL"
   ?xSep -innerRingFetLeftSpace
   ?ySep (plus -innerRingFetBotSpace -innerRingWidthH)
   )
;  (cond
;   (buttingTap
    (setq leftInnerRingImp
	  (rodCreateRect
	   ?layer tapImplant
	   ?fromObj leftInnerRing
	   ?size tapImpEnc
	   ))
;    (setq leftInnerRingImpChunk
;	  (rodCreateRect
;	   ?layer tapImplant
;	   ?width tapImpEnc
;	   ?length (plus innerRingLengthLR (times 2.0 -innerMet1RingWidthH) -ringMet1OutBevelH)
;	   ))
;    )
;   (t
;    (setq leftInnerRingImp
;	  (rodCreateRect
;	   ?layer tapImplant
;	   ?fromObj leftInnerRing
;	   ?size tapImpEnc
;	   ))
;    )
;   )
;  (rodAlign
;   ?alignObj leftInnerRingImpChunk
;   ?alignHandle "cR"
;   ?refObj leftInnerRingImp
;   ?refHandle "cL"
;   )
  (setq leftInnerRingMet0
	(rodCreateRect
	 ?layer ringMet0LayerV
	 ?fromObj leftInnerRing
	 ))

;;Create right side of the ring
  (setq rightInnerRing
	(rodCreateRect
	 ?layer tapLayer
	 ?width innerRingWidthV
	 ?length innerRingLengthLR
	 ?subRectArray
	 (list (list ?layer  ringContact0LayerV
		     ?width  ringContact0WidthV
		     ?length ringContact0WidthV
		     ?spaceY ringContact0SpaceV
		     ?spaceX ringContact0SpaceV
		     ?lowerLeftOffsetY  (plus innerRingWidthH ringContact0PitchH)
		     ?upperRightOffsetY (plus -innerRingWidthH -ringContact0PitchH)
		     ))
	 ))
  (rodAlign
   ?alignObj rightInnerRing
   ?alignHandle "lL"
   ?refObj fetDiffusion
   ?refHandle "lR"
   ?xSep innerRingFetRightSpace
   ?ySep (plus -innerRingFetBotSpace -innerRingWidthH)
   )
;  (cond
;   (buttingTap
    (setq rightInnerRingImp
	  (rodCreateRect
	   ?layer tapImplant
	   ?fromObj rightInnerRing
	   ?size tapImpEnc
	   ))
;    (setq rightInnerRingImpChunk
;	  (rodCreateRect
;	   ?layer tapImplant
;	   ?width tapImpEnc
;	   ?length (plus innerRingLengthLR (times 2.0 -innerMet1RingWidthH) -ringMet1OutBevelH)
;	   ))
;    )
;   (t
;    (setq rightInnerRingImp
;	  (rodCreateRect
;	   ?layer tapImplant
;	   ?fromObj rightInnerRing
;	   ?size tapImpEnc
;	   ))
;    )
;   )
;  (rodAlign
;   ?alignObj rightInnerRingImpChunk
;   ?alignHandle "cL"
;   ?refObj rightInnerRingImp
;   ?refHandle "cR"
;   )
  (setq rightInnerRingMet0
	(rodCreateRect
	 ?layer ringMet0LayerV
	 ?fromObj rightInnerRing
	 ))

;;Create lower side of the ring
  (setq lowerInnerRing
	(rodCreateRect
	 ?layer tapLayer
	 ?width innerRingLengthTB
	 ?length innerRingWidthH
	 ?subRectArray
	 (list (list ?layer  ringContact0LayerH
		     ?width  ringContact0WidthH
		     ?length ringContact0WidthH
		     ?spaceY ringContact0SpaceH
		     ?spaceX ringContact0SpaceH
		     ?lowerLeftOffsetX   ringContact0PitchH
		     ?upperRightOffsetX -ringContact0PitchH
		     ))
	 ))
  (rodAlign
   ?alignObj lowerInnerRing
   ?alignHandle "uL"
   ?refObj fetDiffusion
   ?refHandle "lL"
   ?xSep (plus -innerRingFetLeftSpace -innerRingWidthV)
   ?ySep -innerRingFetBotSpace
   )
  (setq lowerInnerRingImp
	(rodCreateRect
	 ?layer tapImplant
	 ?fromObj lowerInnerRing
	 ?size tapImpEnc
	 ))
  (setq lowerInnerRingMet0
	(rodCreateRect
	 ?layer ringMet0LayerH
	 ?fromObj lowerInnerRing
	 ))

;;Create upper side of the ring
  (setq upperInnerRing
	(rodCreateRect
	 ?layer tapLayer
	 ?width innerRingLengthTB
	 ?length innerRingWidthH
	 ?subRectArray
	 (list (list ?layer  ringContact0LayerH
		     ?width  ringContact0WidthH
		     ?length ringContact0WidthH
		     ?spaceY ringContact0SpaceH
		     ?spaceX ringContact0SpaceH
		     ?lowerLeftOffsetX   ringContact0PitchH
		     ?upperRightOffsetX -ringContact0PitchH
		     ))
	 ))
  (rodAlign
   ?alignObj upperInnerRing
   ?alignHandle "uL"
   ?refObj fetDiffusion
   ?refHandle "uL"
   ?xSep (plus -innerRingFetLeftSpace -innerRingWidthV)
   ?ySep (plus innerRingFetTopSpace innerRingWidthH)
   )
  (setq upperInnerRingImp
	(rodCreateRect
	 ?layer tapImplant
	 ?fromObj upperInnerRing
	 ?size tapImpEnc
	 ))
  (setq upperInnerRingMet0
	(rodCreateRect
	 ?layer ringMet0LayerH
	 ?fromObj upperInnerRing
	 ))

  ;;Create the metal1 inner ring
  (unless ringsMet1Off
    (setq leftInnerRingMet1
	  (rodCreateRect
	   ?layer ringMet1LayerV
	   ?width innerMet1RingWidthV
	   ?length (plus innerRingLengthLR (times 2.0 -innerMet1RingWidthH) -ringMet1OutBevelH)
	   ?subRectArray
	   (list (list ?layer  ringContact1LayerV
		       ?width  ringContact1WidthV
		       ?length ringContact1WidthV
		       ?spaceY ringContact1SpaceV
		       ?spaceX ringContact1SpaceV
		       ?lowerLeftOffsetY  ringContact1PitchV
		       ?upperRightOffsetY -ringContact1PitchV
		       ?lowerLeftOffsetX ringMet1Cont1EncV
		       ?upperRightOffsetX -ringMet1Cont1EncV
		       ))
	   ))
    (rodAlign
     ?alignObj leftInnerRingMet1
     ?alignHandle "cC"
     ?refObj leftInnerRing
     ?refHandle "cC"
     )

    (setq rightInnerRingMet1
	  (rodCreateRect
	   ?layer ringMet1LayerV
	   ?width innerMet1RingWidthV
	   ?length (plus innerRingLengthLR (times 2.0 -innerMet1RingWidthH) -ringMet1OutBevelH)
	   ?subRectArray
	   (list (list ?layer  ringContact1LayerV
		       ?width  ringContact1WidthV
		       ?length ringContact1WidthV
		       ?spaceY ringContact1SpaceV
		       ?spaceX ringContact1SpaceV
		       ?lowerLeftOffsetY  ringContact1PitchV
		       ?upperRightOffsetY -ringContact1PitchV
		       ?lowerLeftOffsetX  ringMet1Cont1EncV
		       ?upperRightOffsetX -ringMet1Cont1EncV
		       ))
	   ))
    (rodAlign
     ?alignObj rightInnerRingMet1
     ?alignHandle "cC"
     ?refObj rightInnerRing
     ?refHandle "cC"
     )

    (setq lowerInnerRingMet1
	  (rodCreateRect
	   ?layer ringMet1LayerH
	   ?width (plus innerRingLengthTB (times 2.0 -ringMet1OutBevelV))
	   ?length innerMet1RingWidthH
	   ?subRectArray
	   (list (list ?layer  ringContact1LayerH
		       ?width  ringContact1WidthH
		       ?length ringContact1WidthH
		       ?spaceY ringContact1SpaceH
		       ?spaceX ringContact1SpaceH
		       ?lowerLeftOffsetX  ringContact1PitchH
		       ?upperRightOffsetX -ringContact1PitchH
		       ?lowerLeftOffsetY  ringMet1Cont1EncH
		       ?upperRightOffsetY -ringMet1Cont1EncH
		       ))
	   ))
    (rodAlign
     ?alignObj lowerInnerRingMet1
     ?alignHandle "cC"
     ?refObj lowerInnerRing
     ?refHandle "cC"
     )

    (setq upperInnerRingMet1
	  (rodCreateRect
	   ?layer ringMet1LayerH
	   ?width (plus innerRingLengthTB (times 2.0 -ringMet1OutBevelV))
	   ?length innerMet1RingWidthH
	   ?subRectArray
	   (list (list ?layer  ringContact1LayerH
		       ?width  ringContact1WidthH
		       ?length ringContact1WidthH
		       ?spaceY ringContact1SpaceH
		       ?spaceX ringContact1SpaceH
		       ?lowerLeftOffsetX  ringContact1PitchH
		       ?upperRightOffsetX -ringContact1PitchH
		       ?lowerLeftOffsetY  ringMet1Cont1EncH
		       ?upperRightOffsetY -ringMet1Cont1EncH
		       ))
	   ))
    (rodAlign
     ?alignObj upperInnerRingMet1
     ?alignHandle "cC"
     ?refObj upperInnerRing
     ?refHandle "cC"
     )

;;Define the points for the beveled innerRingMet1Layer
    (declare innerRingMet1Pts[18])
;;     ________________
;;   2/  ____________  \3
;;  1|  /14        13\  |4
;;   | /              \ |
;;   | |15          12| |
;;   | |              | |        
;;   | |              | |        
;;   | |              | |             
;;   | |              | | 
;;   | |8           11| |
;;   | \              / |
;;  0|  \9________10_/  |5
;;    \________________/
;;    7                6

;;Calculate the width difference between the inner tap and inner metal1 rings per side
    (setq innerRingWidthDiffH (difference innerMet1RingWidthH innerRingWidthH))
    (setq innerRingWidthDiffV (difference innerMet1RingWidthV innerRingWidthV))

    (setq x0Met1 0.0)
    (setq y0Met1 0.0)
;;distance between points 9&10
    (setq holeDimX (plus fetDiffusionXdim innerRingFetLeftSpace innerRingFetRightSpace
			 -innerRingWidthDiffV (times 2.0 -ringMet1InBevelV)))
;;distance between points 8&15
    (setq holeDimY (plus w innerRingFetTopSpace innerRingFetBotSpace 
			 -innerRingWidthDiffH (times 2.0 -ringMet1InBevelH)))

    (setq x0Met1  0.0)
    (setq x2Met1  ringMet1OutBevelV)
    (setq x3Met1  (difference (plus holeDimX (times 2.0 ringMet1InBevelV) (times 2.0 innerMet1RingWidthV)) ringMet1OutBevelV)) ;(plus holeDimX (times 2.0 innerMet1RingWidthV) (times 2.0 ringMet1InBevelV) ringMet1OutBevelV))
    (setq x4Met1  (plus x3Met1 ringMet1OutBevelV))
    (setq x9Met1  (plus innerMet1RingWidthV ringMet1InBevelV)) ;(plus innerMet1RingWidthV ringMet1OutBevelV ringMet1InBevelV))
    (setq x10Met1 (plus x9Met1 holeDimX))
    (setq x11Met1 (plus x10Met1 ringMet1InBevelV))
    (setq x15Met1 innerMet1RingWidthV)

    (setq y0Met1  -ringMet1InBevelH)
    (setq y1Met1  (plus holeDimY ringMet1InBevelH))
    (setq y2Met1  (plus y1Met1 ringMet1OutBevelH))
    (setq y6Met1  (plus -ringMet1InBevelH -ringMet1OutBevelH))
    (setq y8Met1  0.0)
    (setq y12Met1 holeDimY)

    innerRingMet1Pts[0]   = x0Met1:y0Met1
    innerRingMet1Pts[1]   = x0Met1:y1Met1
    innerRingMet1Pts[2]   = x2Met1:y2Met1
    innerRingMet1Pts[3]   = x3Met1:y2Met1
    innerRingMet1Pts[4]   = x4Met1:y1Met1
    innerRingMet1Pts[5]   = x4Met1:y0Met1
    innerRingMet1Pts[6]   = x3Met1:y6Met1
    innerRingMet1Pts[7]   = x2Met1:y6Met1
    innerRingMet1Pts[8]   = x15Met1:y8Met1
    innerRingMet1Pts[9]   = x9Met1:y0Met1
    innerRingMet1Pts[10]  = x10Met1:y0Met1
    innerRingMet1Pts[11]  = x11Met1:y8Met1
    innerRingMet1Pts[12]  = x11Met1:y12Met1
    innerRingMet1Pts[13]  = x10Met1:y1Met1
    innerRingMet1Pts[14]  = x9Met1:y1Met1
    innerRingMet1Pts[15]  = x15Met1:y12Met1

    (setq innerRingMet1Points (list innerRingMet1Pts[0] innerRingMet1Pts[1] innerRingMet1Pts[2] innerRingMet1Pts[3] 
				    innerRingMet1Pts[4] innerRingMet1Pts[5] innerRingMet1Pts[6] innerRingMet1Pts[7] 
				    innerRingMet1Pts[9] innerRingMet1Pts[10] innerRingMet1Pts[11] innerRingMet1Pts[12] 
				    innerRingMet1Pts[13] innerRingMet1Pts[14] innerRingMet1Pts[15] innerRingMet1Pts[8] 
				    innerRingMet1Pts[9] innerRingMet1Pts[7]))
    (setq innerRingMet1Layer
	  (rodCreatePolygon
	   ?layer ringMet1LayerH
	   ?pts innerRingMet1Points
	   ))

    (rodAlign
     ?alignObj innerRingMet1Layer
     ?alignHandle "cL"
     ?refObj  leftInnerRingMet1
     ?refHandle "cL"
;     ?xSep (times (difference innerMet1RingWidthV ringMet1OutBevelV) 0.5)
     )
    );;// unless ringsMet1Off

  ;;Draw the hvLayer
  (when hvMode
    (setq hvLayerDrawing
	  (rodCreateRect
	   ?layer hvLayer
	   ?width (plus innerRingLengthTB (times 2.0 hvLayerDiffTapEnc))
	   ?length (plus innerRingLengthLR (times 2.0 hvLayerDiffTapEnc))
	   ))
    (rodAlign
     ?alignObj hvLayerDrawing
     ?alignHandle "lL"
     ?refObj lowerInnerRing
     ?refHandle "lL"
     ?xSep -hvLayerDiffTapEnc
     ?ySep -hvLayerDiffTapEnc
     )
    )

  (when (equal mosType "pmos")
    (setq wellLayerWidth  (plus innerRingLengthTB (times 2.0 hvWellDiffTapEnc)))
    (setq wellLayerLength (plus innerRingLengthLR (times 2.0 hvWellDiffTapEnc)))
    
    (setq wellLayerDrawing
	  (rodCreateRect
	   ?layer wellLayer
	   ?width wellLayerWidth
	   ?length wellLayerLength
	   ))
    (rodAlign
     ?alignObj wellLayerDrawing
     ?alignHandle "lL"
     ?refObj lowerInnerRing
     ?refHandle "lL"
     ?xSep -hvWellDiffTapEnc
     ?ySep -hvWellDiffTapEnc
     )

    (when hvMode
      (setq hvLayerDrawing
	    (rodCreateRect
	     ?layer hvLayer
	     ?fromObj wellLayerDrawing
	     ?size 0.0
	     ))
      )

  )

 );;(when (or (equal rings "Inner") (equal rings "Both"))

(when (equal rings "Both")

;;##################################OuterRing Generation##################################
  (setq ringContact0Info  (nth 0 OuterRingInterconnect))
  (setq ringContact0Layer (nth 0 ringContact0Info))
  (setq ringContact0Width (nth 1 ringContact0Info))
  (setq ringContact0Space (nth 2 ringContact0Info))
  (setq ringContact0Cols  (nth 3 ringContact0Info))
  (setq ringMet0Layer     (nth 4 ringContact0Info))
  (setq ringMet0Cont0Enc  (nth 5 ringContact0Info))
  (setq ringMet0InBevel   (nth 6 ringContact0Info))
  (setq ringMet0OutBevel  (nth 7 ringContact0Info))

  (setq ringContact1Info  (nth 1 OuterRingInterconnect))
  (setq ringContact1Layer (nth 0 ringContact1Info))
  (setq ringContact1Width (nth 1 ringContact1Info))
  (setq ringContact1Space (nth 2 ringContact1Info))
  (setq ringContact1Cols  (nth 3 ringContact1Info))
  (setq ringMet1Layer     (nth 4 ringContact1Info))
  (setq ringMet1Cont1Enc  (nth 5 ringContact1Info))
  (setq ringMet1InBevel   (nth 6 ringContact1Info))
  (setq ringMet1OutBevel  (nth 7 ringContact1Info))

  (setq ringContact0Pitch  (plus ringContact0Width ringContact0Space))
  (setq outerRingWidth     (plus (times ringContact0Width ringContact0Cols)
				 (times (plus ringContact0Cols -1) ringContact0Space) (times 2.0 ringMet0Cont0Enc)))
  (setq outerRingWidth     (max  outerRingWidth userOuterRingWidth))
  (setq outerRingLengthLR (plus innerRingLengthLR (times 2.0 OuterInnerRingSpace) (times 2.0 outerRingWidth)))
  (setq outerRingLengthTB (plus innerRingLengthTB (times 2.0 OuterInnerRingSpace) (times 2.0 outerRingWidth)))
  (setq ringContact1Pitch  (plus ringContact1Width ringContact1Space))
  (setq outerMet1RingWidth (plus (times ringContact1Width ringContact1Cols)
				 (times (plus ringContact1Cols -1) ringContact1Space) (times 2.0 ringMet1Cont1Enc)))

;;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  (when (lessp outerMet1RingWidth ringMet1OutBevel)
    (setq ringMet1OutBevel  outerMet1RingWidth)
    )
;;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

;;Create left side of the ring
  (setq leftOuterRing
	(rodCreateRect
	 ?layer tapLayer
	 ?width outerRingWidth
	 ?length outerRingLengthLR
	 ?subRectArray
	 (list (list ?layer  ringContact0Layer
		     ?width  ringContact0Width
		     ?length ringContact0Width
		     ?spaceY ringContact0Space
		     ?spaceX ringContact0Space
		     ?lowerLeftOffsetY  (plus  outerRingWidth  ringContact0Pitch)
		     ?upperRightOffsetY (plus -outerRingWidth -ringContact0Pitch)
		     ))
	 ))
  (rodAlign
   ?alignObj leftOuterRing
   ?alignHandle "lR"
   ?refObj leftInnerRing
   ?refHandle "lL"
   ?xSep -OuterInnerRingSpace
   ?ySep (plus -OuterInnerRingSpace -outerRingWidth)
   )
  (setq leftOuterRingImp
	(rodCreateRect
	 ?layer diffImplant
	 ?fromObj leftOuterRing
	 ?size diffImpEnc
	 ))
  (when (equal mosType "nmos")
    (setq leftOuterRingWell
	  (rodCreateRect
	   ?layer wellLayer
	   ?fromObj leftOuterRing
	   ?size  hvWellDiffTapEnc
	   ))
    )
  (setq leftOuterRingMet0
	(rodCreateRect
	 ?layer ringMet0Layer
	 ?fromObj leftOuterRing
	 ))

;;Create right side of the ring
  (setq rightOuterRing
	(rodCreateRect
	 ?layer tapLayer
	 ?width outerRingWidth
	 ?length outerRingLengthLR
	 ?subRectArray
	 (list (list ?layer  ringContact0Layer
		     ?width  ringContact0Width
		     ?length ringContact0Width
		     ?spaceY ringContact0Space
		     ?spaceX ringContact0Space
		     ?lowerLeftOffsetY  (plus  outerRingWidth  ringContact0Pitch)
		     ?upperRightOffsetY (plus -outerRingWidth -ringContact0Pitch)
		     ))
	 ))
  (rodAlign
   ?alignObj rightOuterRing
   ?alignHandle "lL"
   ?refObj rightInnerRing
   ?refHandle "lR"
   ?xSep OuterInnerRingSpace
   ?ySep (plus -OuterInnerRingSpace -outerRingWidth)
   )
  (setq rightOuterRingImp
	(rodCreateRect
	 ?layer diffImplant
	 ?fromObj rightOuterRing
	 ?size diffImpEnc
	 ))
  (when (equal mosType "nmos")
    (setq rightOuterRingWell
	  (rodCreateRect
	   ?layer wellLayer
	   ?fromObj rightOuterRing
	   ?size  hvWellDiffTapEnc
	   ))
    )
  (setq rightOuterRingMet0
	(rodCreateRect
	 ?layer ringMet0Layer
	 ?fromObj rightOuterRing
	 ))

;;Create lower side of the ring
  (setq lowerOuterRing
	(rodCreateRect
	 ?layer tapLayer
	 ?width outerRingLengthTB
	 ?length outerRingWidth
	 ?subRectArray
	 (list (list ?layer  ringContact0Layer
		     ?width  ringContact0Width
		     ?length ringContact0Width
		     ?spaceY ringContact0Space
		     ?spaceX ringContact0Space
		     ?lowerLeftOffsetX   ringContact0Pitch
		     ?upperRightOffsetX -ringContact0Pitch
		     ))
	 ))
  (rodAlign
   ?alignObj lowerOuterRing
   ?alignHandle "uC"
   ?refObj lowerInnerRing
   ?refHandle "lC"
   ?ySep -OuterInnerRingSpace
   )
  (setq lowerOuterRingImp
	(rodCreateRect
	 ?layer diffImplant
	 ?fromObj lowerOuterRing
	 ?size diffImpEnc
	 ))
  (when (equal mosType "nmos")
    (setq lowerOuterRingWell
	  (rodCreateRect
	   ?layer wellLayer
	   ?fromObj lowerOuterRing
	   ?size  hvWellDiffTapEnc
	   ))
    )
  (setq lowerOuterRingMet0
	(rodCreateRect
	 ?layer ringMet0Layer
	 ?fromObj lowerOuterRing
	 ))

;;Create upper side of the ring
  (setq upperOuterRing 
	(rodCreateRect
	 ?layer tapLayer
	 ?width outerRingLengthTB
	 ?length outerRingWidth
	 ?subRectArray
	 (list (list ?layer  ringContact0Layer
		     ?width  ringContact0Width
		     ?length ringContact0Width
		     ?spaceY ringContact0Space
		     ?spaceX ringContact0Space
		     ?lowerLeftOffsetX   ringContact0Pitch
		     ?upperRightOffsetX -ringContact0Pitch
		     ))
	 ))
  (rodAlign
   ?alignObj upperOuterRing
   ?alignHandle "lC"
   ?refObj upperInnerRing
   ?refHandle "uC"
   ?ySep OuterInnerRingSpace
   )
  (setq upperOuterRingImp
	(rodCreateRect
	 ?layer diffImplant
	 ?fromObj upperOuterRing
	 ?size diffImpEnc
	 ))
  (when (equal mosType "nmos")
    (setq upperOuterRingWell
	  (rodCreateRect
	   ?layer wellLayer
	   ?fromObj upperOuterRing
	   ?size  hvWellDiffTapEnc
	   ))
    )
  (setq upperOuterRingMet0
	(rodCreateRect
	 ?layer ringMet0Layer
	 ?fromObj upperOuterRing
	 ))

  (unless ringsMet1Off
    ;;Create the metal1 on the outer ring
    (setq leftOuterRingMet1
	  (rodCreateRect
	   ?layer ringMet1Layer
	   ?width outerMet1RingWidth
	   ?length (plus outerRingLengthLR (times 2.0 -outerMet1RingWidth) -ringMet1OutBevel)
	   ?subRectArray
	   (list (list ?layer  ringContact1Layer
		       ?width  ringContact1Width
		       ?length ringContact1Width
		       ?spaceY ringContact1Space
		       ?spaceX ringContact1Space
		       ?lowerLeftOffsetY  ringContact1Pitch
		       ?upperRightOffsetY -ringContact1Pitch
		       ?lowerLeftOffsetX  ringMet1Cont1Enc
		       ?upperRightOffsetX -ringMet1Cont1Enc
		       ))
	   ))
    (rodAlign
     ?alignObj leftOuterRingMet1
     ?alignHandle "cC"
     ?refObj leftOuterRing
     ?refHandle "cC"
     )

    (setq rightOuterRingMet1
	  (rodCreateRect
	   ?layer ringMet1Layer
	   ?width outerMet1RingWidth
	   ?length (plus outerRingLengthLR (times 2.0 -outerMet1RingWidth) -ringMet1OutBevel)
	   ?subRectArray
	   (list (list ?layer  ringContact1Layer
		       ?width  ringContact1Width
		       ?length ringContact1Width
		       ?spaceY ringContact1Space
		       ?spaceX ringContact1Space
		       ?lowerLeftOffsetY  ringContact1Pitch
		       ?upperRightOffsetY -ringContact1Pitch
		       ?lowerLeftOffsetX  ringMet1Cont1Enc
		       ?upperRightOffsetX -ringMet1Cont1Enc
		       ))
	   ))
    (rodAlign
     ?alignObj rightOuterRingMet1
     ?alignHandle "cC"
     ?refObj rightOuterRing
     ?refHandle "cC"
     )

    (setq lowerOuterRingMet1
	  (rodCreateRect
	   ?layer ringMet1Layer
	   ?width (plus outerRingLengthTB -outerMet1RingWidth (times 2.0 -ringMet1OutBevel))
	   ?length outerMet1RingWidth
	   ?subRectArray
	   (list (list ?layer  ringContact1Layer
		       ?width  ringContact1Width
		       ?length ringContact1Width
		       ?spaceY ringContact1Space
		       ?spaceX ringContact1Space
		       ?lowerLeftOffsetX  ringContact1Pitch
		       ?upperRightOffsetX -ringContact1Pitch
		       ?lowerLeftOffsetY  ringMet1Cont1Enc
		       ?upperRightOffsetY -ringMet1Cont1Enc
		       ))
	   ))
    (rodAlign
     ?alignObj lowerOuterRingMet1
     ?alignHandle "cC"
     ?refObj lowerOuterRing
     ?refHandle "cC"
     )

    (setq upperOuterRingMet1
	  (rodCreateRect
	   ?layer ringMet1Layer
	   ?width (plus outerRingLengthTB -outerMet1RingWidth (times 2.0 -ringMet1OutBevel))
	   ?length outerMet1RingWidth
	   ?subRectArray
	   (list (list ?layer  ringContact1Layer
		       ?width  ringContact1Width
		       ?length ringContact1Width
		       ?spaceY ringContact1Space
		       ?spaceX ringContact1Space
		       ?lowerLeftOffsetX  ringContact1Pitch
		       ?upperRightOffsetX -ringContact1Pitch
		       ?lowerLeftOffsetY  ringMet1Cont1Enc
		       ?upperRightOffsetY -ringMet1Cont1Enc
		       ))
	   ))
    (rodAlign
     ?alignObj upperOuterRingMet1
     ?alignHandle "cC"
     ?refObj upperOuterRing
     ?refHandle "cC"
     )

    ;;Define the points for the beveled outerRingMet1Layer
    (declare outerRingMet1Pts[18])
;;     ________________
;;   2/  ____________  \3
;;  1|  /14        13\  |4
;;   | /              \ |
;;   | |15          12| |
;;   | |              | |        
;;   | |              | |        
;;   | |              | |             
;;   | |              | | 
;;   | |8           11| |
;;   | \              / |
;;  0|  \9________10_/  |5
;;    \________________/
;;    7                6

    ;;Calculate the width difference between the inner tap and inner metal1 rings per side
    (setq outerRingWidthDiff (difference outerMet1RingWidth outerRingWidth))
    
    (setq x0Met1 0.0)
    (setq y0Met1 0.0)
    ;;distance between points 9&10
    (setq holeDimX (plus fetDiffusionXdim innerRingFetLeftSpace innerRingFetRightSpace -outerRingWidthDiff 
			 (times 2.0 OuterInnerRingSpace) (times 2.0 innerRingWidthV) (times 2.0 -ringMet1InBevel)))
    ;;distance between points 8&15
    (setq holeDimY (plus w innerRingFetTopSpace innerRingFetBotSpace -outerRingWidthDiff
			 (times 2.0 OuterInnerRingSpace) (times 2.0 innerRingWidthH) (times 2.0 -ringMet1InBevel)))
    
    (setq x0Met1  0.0)
    (setq x2Met1  ringMet1OutBevel)
    (setq x3Met1  (plus holeDimX (times 2.0 ringMet1InBevel) ringMet1OutBevel))
    (setq x4Met1  (plus x3Met1 ringMet1OutBevel))
    (setq x9Met1  (plus ringMet1OutBevel ringMet1InBevel))
    (setq x10Met1 (plus x9Met1 holeDimX))

    (setq y0Met1  -ringMet1InBevel)
    (setq y1Met1  (plus holeDimY ringMet1InBevel))
    (setq y2Met1  (plus y1Met1 ringMet1OutBevel))
    (setq y6Met1  (plus -ringMet1InBevel -ringMet1OutBevel))
    (setq y8Met1  0.0)
    (setq y12Met1 holeDimY)

    outerRingMet1Pts[0]   = x0Met1:y0Met1
    outerRingMet1Pts[1]   = x0Met1:y1Met1
    outerRingMet1Pts[2]   = x2Met1:y2Met1
    outerRingMet1Pts[3]   = x3Met1:y2Met1
    outerRingMet1Pts[4]   = x4Met1:y1Met1
    outerRingMet1Pts[5]   = x4Met1:y0Met1
    outerRingMet1Pts[6]   = x3Met1:y6Met1
    outerRingMet1Pts[7]   = x2Met1:y6Met1
    outerRingMet1Pts[8]   = x2Met1:y8Met1
    outerRingMet1Pts[9]   = x9Met1:y0Met1
    outerRingMet1Pts[10]  = x10Met1:y0Met1
    outerRingMet1Pts[11]  = x3Met1:y8Met1
    outerRingMet1Pts[12]  = x3Met1:y12Met1
    outerRingMet1Pts[13]  = x10Met1:y1Met1
    outerRingMet1Pts[14]  = x9Met1:y1Met1
    outerRingMet1Pts[15]  = x2Met1:y12Met1

    (setq outerRingMet1Points (list outerRingMet1Pts[0] outerRingMet1Pts[1]  outerRingMet1Pts[2]  outerRingMet1Pts[3] 
				    outerRingMet1Pts[4] outerRingMet1Pts[5]  outerRingMet1Pts[6]  outerRingMet1Pts[7] 
				    outerRingMet1Pts[9] outerRingMet1Pts[10] outerRingMet1Pts[11] outerRingMet1Pts[12] 
				    outerRingMet1Pts[13] outerRingMet1Pts[14] outerRingMet1Pts[15] outerRingMet1Pts[8] 
				    outerRingMet1Pts[9] outerRingMet1Pts[7]))
    (setq outerRingMet1Layer
	  (rodCreatePolygon
	   ?layer ringMet1Layer
	   ?pts outerRingMet1Points
	   ))

    (rodAlign
     ?alignObj outerRingMet1Layer
     ?alignHandle "cL"
     ?refObj  leftOuterRingMet1
     ?refHandle "cL"
     ?xSep (times (difference outerMet1RingWidth ringMet1OutBevel) 0.5)
     )

    );;//(unless ringsMet1Off

 (cond
  ((equal mosType "nmos")
   (setq idLayerWidth  (plus outerRingLengthTB (times 2.0 hvWellDiffTapEnc)))
   (setq idLayerLength (plus outerRingLengthLR (times 2.0 hvWellDiffTapEnc)))

  ;;Draw the hvLayer
  (when hvMode
      (setq hvLayerDrawing
	    (rodCreateRect
	     ?layer hvLayer
	     ?width idLayerWidth
	     ?length idLayerLength
	     ))
      (rodAlign
       ?alignObj hvLayerDrawing
       ?alignHandle "lL"
       ?refObj lowerOuterRingWell
       ?refHandle "lL"
       )
      )
   )
  ((equal mosType "pmos")
   (setq idLayerWidth  (plus outerRingLengthTB (times 2.0 hvLayerDiffTapEnc)))
   (setq idLayerLength (plus outerRingLengthLR (times 2.0 hvLayerDiffTapEnc)))

   ;;Draw the hvLayer
   (when hvMode
     (setq hvLayerDrawing
	   (rodCreateRect
	    ?layer hvLayer
	    ?width idLayerWidth
	    ?length idLayerLength
	    ))
     (rodAlign
      ?alignObj hvLayerDrawing
      ?alignHandle "lL"
      ?refObj lowerOuterRing
      ?refHandle "lL"
      ?xSep -hvLayerDiffTapEnc
      ?ySep -hvLayerDiffTapEnc
      )
     )
   )
  (t
   )
  )

  ;;The idLayer should be drawn only when the rings exist.
  ;;When the ring is does not exist then the device should be used to be 
  ;;placed in another bigger ring that has the id layer
  ;;Draw the idLayer
  (setq idLayerDrawing
	(rodCreateRect
	 ?layer idLayer
	 ;;?width (plus outerRingLengthTB (times 2.0 hvWellDiffTapEnc))
	 ;;?length (plus outerRingLengthLR (times 2.0 hvWellDiffTapEnc))
	 ?width idLayerWidth
	 ?length idLayerLength
	 ))
  (rodAlign
   ?alignObj idLayerDrawing
   ?alignHandle "lL"
   ;;the reference is in the priority hvLayer, wellLayer, implant
   ?refObj (or hvLayerDrawing lowerOuterRingWell lowerOuterRingImp)
   ?refHandle "lL"
   )

 );;(when (equal rings "Both") )

;;Draw the hvLayer over the diffusion when the rings are off and operating in hvMode
(when (and hvMode (equal rings "None"))
  (setq hvLayerDrawing
	(rodCreateRect
	 ?layer hvLayer
	 ?width (plus fetDiffusionXdim 
		      (max innerRingFetRightSpace hvLayerDiffTapEnc) 
		      (max innerRingFetLeftSpace hvLayerDiffTapEnc))
	 ?length (plus w (max innerRingFetBotSpace hvLayerDiffTapEnc)
		       (max innerRingFetTopSpace hvLayerDiffTapEnc))
	 ))
  (rodAlign
   ?alignObj hvLayerDrawing
   ?alignHandle "lL"
   ?refObj fetDiffusion
   ?refHandle "lL"
   ?xSep (min -innerRingFetLeftSpace -hvLayerDiffTapEnc)
   ?ySep (min -innerRingFetBotSpace -hvLayerDiffTapEnc)
   )
 )

;; Draw warning labels on cell
(unless (equal rings "None")
  (setq leftXCoord (difference (car esdCellOrigin) (plus innerRingFetLeftSpace (quotient innerRingWidthV 2) diffContact0Xenc mSourcePinOffset srcPinWidth)))
  (setq rightXCoord (plus (car esdCellOrigin) innerRingFetRightSpace (quotient innerRingWidthV 2) (difference fetDiffusionXdim diffContact0Xenc mSourcePinOffset srcPinWidth)))
  
  (setq labelYCoord (difference (quotient innerRingLengthLR 2) innerRingFetBotSpace))
  
  (dbCreateLabel tcCellView labelLayer (list leftXCoord (plus 0.9 labelYCoord)) "CRITICAL TO" "centerCenter" "R0" "roman" 0.4)
  (dbCreateLabel tcCellView labelLayer (list leftXCoord (plus 0.3 labelYCoord)) "CONNECT WIDE" "centerCenter" "R0" "roman" 0.4)
  (dbCreateLabel tcCellView labelLayer (list leftXCoord (difference labelYCoord 0.3)) "SIDES OF" "centerCenter" "R0" "roman" 0.4)
  (dbCreateLabel tcCellView labelLayer (list leftXCoord (difference labelYCoord 0.9)) "GUARDRING" "centerCenter" "R0" "roman" 0.4)
  
  (dbCreateLabel tcCellView labelLayer (list rightXCoord (plus 0.9 labelYCoord)) "CRITICAL TO" "centerCenter" "R0" "roman" 0.4)
  (dbCreateLabel tcCellView labelLayer (list rightXCoord (plus 0.3 labelYCoord)) "CONNECT WIDE" "centerCenter" "R0" "roman" 0.4)
  (dbCreateLabel tcCellView labelLayer (list rightXCoord (difference labelYCoord 0.3)) "SIDES OF" "centerCenter" "R0" "roman" 0.4)
  (dbCreateLabel tcCellView labelLayer (list rightXCoord (difference labelYCoord 0.9)) "GUARDRING" "centerCenter" "R0" "roman" 0.4)
  )

)


(tfcDefineDeviceClassProp
;;(viewName       devClassName        propName          propValue)
 (symbolic        esdFetClass         function         "transistor")
)

;;; 
;;; $Id: esdCascodeFetClass.il,v 1.5 2007/02/06 15:03:58 kuc Exp $
;;; 
;;; esdCascodeFetClass.il
;;; 
;;; Copyright (c) 2006 by Cypress Semiconductor
;;; Cypress Kentucky CAD Center (KYCC)
;;; 
;;; Date  : Dec 11, 2006
;;; Author: Kungyen Chang (kuc) @ KYCC
;;; 
;;; Description:
;;;   This is a cascode ESD pcell class
;;; 
;;; Revision History:
;;;   kuc 12/11/06  updated version to have separate parameters for X
;;;                 and Y dimensions for inner tap ring, and separate
;;;                 parameters for source and drain contacts
;;;                 added warning labels on inner guardring
;;;   kuc 01/05/07  moved warning labels to side of inner guardring, changed
;;;                 how m factor is handled by doubling inside code
;;;   kuc 01/24/07  added flexibility in drain to gate contact spacing
;;;   kuc 02/05/07  updated to support CDF menus for drain to gate spacing
;;; 

(tcCreateDeviceClass
 "symbolic" "esdCascodeFetClass"
 ;; Class parameters
 ((diffLayer            "y0") ;; diffusion drawing layer
  (gateLayer            "y1") ;; poly drawing layer
  (pgateLayer           "y2") ;; poly gate layer
  (wellLayer             nil) ;; nwell drawing layer
  (diffImplant           nil) ;; implant required on the diffusion nsdm/psdm
  (diffImpEnc            0.0) ;; enclosure of diffimplant-diffusion
  (tapLayer             "y2") ;; tap drawing layer
  (tapImplant            nil) ;; implant required on the diffusion (psdm)
  (tapImpEnc             0.0) ;; enclosure of tap implant
  (idLayer               nil) ;; id layer required on device
  (hvLayer               nil) ;; high voltage id/mask layer
  (hvWellDiffTapEnc      0.0) ;; enclosure of hv difftap by hv nwell
  (hvLayerDiffTapEnc     0.0) ;; enclosure of hvDiffTap by hvLayer
  (flareInDiff           0.0) ;; flare amount of gate inside diffusion
  (flareOutDiff          0.0) ;; flare amount of gate outside diffusion
  (flareExt              0.0) ;; extention of poly beyond flaring
  (drnInterconnect       nil)
  (srcInterconnect       nil) ;; data structure of type list 
                              ;; i.e. '("contactLayerName" contactLayerWidth contactLayerSpace 
                              ;; contactColumnsNum "upperMetLayerName" metLayerWidth metLayerBevelEdge)
  (diffContact0Yenc      0.0) ;; enclosure of contact0 by src/drn diff in the y-direction
  (diffContact0Xenc      0.0) ;; enclosure of contact0 by src/drn diff in the x-direction
  (InnerRingInterconnectHoriz nil) ;; data structure of type list 
                              ;;'("contactLayerName" contactLayerWidth contactLayerSpace 
			      ;; contactColumnsNum "upperMetLayerName" metContactEnc innerMetBevelEdge outerMetBevelEdge)
  (InnerRingInterconnectVert  nil)
  (OuterRingInterconnect nil) ;; data structure of type list 
			      ;;'("contactLayerName" contactLayerWidth contactLayerSpace 
			      ;; contactColumnsNum "upperMetLayerName" metContactEnc innerMetBevelEdge outerMetBevelEdge)
  (buttingTapWidth       0.0) ;; size of width of the butting tap in the x-dimension 
  (buttingTapCont0Xenc   0.0) ;; x-dimension enclosure of contact0 (licon1) by butting tap
  (fetDiffInnerRingSpace 0.0) ;; minimun space between fet diffusion and the inner ring defined from tap to diff
  (OuterInnerRingSpace   0.0) ;; space between the inner and outer ring defined from tap to tap
  (mosType            "nmos") ;; determine whether its NMOS or PMOS since same class is used for both types
  (labelLayer  (list "text" "drawing")) ;; label layer used to identify Source/Drain
  (labelWidth            1.0) ;; height of labels on Source/Drain
  (singleFlare       "FALSE") ;; boolean, when true creates single-sided flares; Default is double flares
  (sharedCascodeDiffWidth       0.0) ;; spacing between cascode gate pairs
  (minInnerRingFetExtraRightSpace 0.0)
  (minInnerRingFetExtraLeftSpace  0.0)
  (minInnerRingFetExtraTopSpace   0.0)
  (minInnerRingFetExtraBotSpace   0.0)
;  (minimumTotalWidth              0.0)
  (minimumM                       0)
  (srcGateContactSpace 0.0) ;; space between gate and source contacts in X direction
 )
 ;; Formal parameters
 (
  (buttingTap        "FALSE") ;; boolean, when true creates butting taps at the source terminals; Default is double flares
  (w                   0.0) ;; width of the fet
  (l                   0.0) ;; length of gate
  (m                     0) ;; mfactor of the fet
  (innerRingFetExtraRightSpace 0.0)  ;; additional space between right innerRing tap and src/drn diffusion
  (innerRingFetExtraLeftSpace  0.0)  ;; additional space between left  innerRing tap and src/drn diffusion
  (innerRingFetExtraTopSpace   0.0)  ;; additional space between top   innerRing tap and src/drn diffusion
  (innerRingFetExtraBotSpace   0.0)  ;; additional space between lower innerRing tap and src/drn diffusion
  (hvMode             nil)     ;; boolean that draws the hvLayer to the 
  (rings              "Both")  ;; cyclic to select the inner and/or outer rings
  (ringsMet1Off       nil)     ;; boolean that draws the metal1 on the rings
  (userOuterRingWidth 0.0)     ;; width of outerRing defined by the user. Cannot be less than default value
  (hspiceModel        nil)
  (hspiceModelChoices nil)
  (drnGateContactSpaceParams nil) ;; space between gate and drain contacts in X direction 
  (drnGateContactSpaceValue nil)
  (drnGateContactSpaceName nil)
 )

 (setq met1WidthD (nth 2 drnGateContactSpaceValue))
 (setq drnGateContactSpace (nth 0 drnGateContactSpaceValue))
 (setq minimumTotalWidth (float (nth 1 drnGateContactSpaceValue)))

 ;; since each gate is actually a pair of gates
 (setq origm m)
 (setq m (times 2 m))
 
 ;;do minimum dimension checks, error out if invalid
  (when (lessp innerRingFetExtraRightSpace minInnerRingFetExtraRightSpace)
   (error "%.3f is less than allowable minimum right side diff to tap ring spacing %.3f\n" 
	   innerRingFetExtraRightSpace minInnerRingFetExtraRightSpace)
   )
  (when (lessp innerRingFetExtraLeftSpace minInnerRingFetExtraLeftSpace)
   (error "%.3f is less than allowable minimum left side diff to tap ring spacing %.3f\n" 
	   innerRingFetExtraLeftSpace minInnerRingFetExtraLeftSpace)
   )
  (when (lessp innerRingFetExtraTopSpace minInnerRingFetExtraTopSpace)
   (error "%.3f is less than allowable minimum top side diff to tap ring spacing %.3f\n" 
	   innerRingFetExtraTopSpace minInnerRingFetExtraTopSpace)
   )
  (when (lessp innerRingFetExtraBotSpace minInnerRingFetExtraBotSpace)
   (error "%.3f is less than allowable minimum bottom side diff to tap ring spacing %.3f\n" 
	   innerRingFetExtraBotSpace minInnerRingFetExtraBotSpace)
   )
  (when (lessp (times w origm) minimumTotalWidth)
    (error "%.3f is less than allowable minimum total width %.3f for %.3f drain to gate contact spacing\n" 
	   (times w origm) minimumTotalWidth drnGateContactSpace)
    )
  (when (lessp origm minimumM)
   (error "%d is less than allowable minimum m factor %d\n"
	   origm minimumM)
   )

 ;;define the esdCell point of origin
 (setq esdCellOrigin (list 0 0))

 (cond
  ((equal mosType "nmos")
   (setq idLayerEndEnc  hvWellDiffTapEnc)
   (setq hvLayerEndEnc  hvLayerDiffTapEnc)
   )
  ((equal mosType "pmos")
   (setq idLayerEndEnc  hvLayerDiffTapEnc)
   (setq hvLayerEndEnc  hvWellDiffTapEnc)
   )
  (t
   )
  )

 ;;re-calculate the spacing of the inner ring to 
 ;(when buttingTap
 ;  (setq innerRingFetRightSpace innerRingFetExtraRightSpace)
 ;  (setq innerRingFetLeftSpace  innerRingFetExtraLeftSpace)
 ;  )
 ;(unless buttingTap
   (setq innerRingFetRightSpace (plus innerRingFetExtraRightSpace fetDiffInnerRingSpace))
   (setq innerRingFetLeftSpace (plus innerRingFetExtraLeftSpace fetDiffInnerRingSpace))
 ;  )

 ;(setq innerRingFetRightSpace (plus innerRingFetExtraRightSpace fetDiffInnerRingSpace buttingTapWidth))
 ;(setq innerRingFetLeftSpace  (plus innerRingFetExtraLeftSpace  fetDiffInnerRingSpace buttingTapWidth))
 (setq innerRingFetTopSpace   (plus innerRingFetExtraTopSpace   fetDiffInnerRingSpace))
 (setq innerRingFetBotSpace   (plus innerRingFetExtraBotSpace   fetDiffInnerRingSpace))

 (if (or (equal hvMode t) (equal hvMode "TRUE")) then
   (setq hvMode t)
   else
   (setq hvMode nil)
   )

 (if (or (equal ringsMet1Off t) (equal ringsMet1Off "TRUE")) then
   (setq ringsMet1Off t)
   else
   (setq ringsMet1Off nil)
   )

 (if (or (equal singleFlare t) (equal singleFlare "TRUE")) then
   (setq singleFlare t)
   else
   (setq singleFlare nil)
   )
 (if (or (equal buttingTap t) (equal buttingTap "TRUE")) then
   (setq buttingTap t)
   else
   (setq buttingTap nil)
   )

 (when (oddp origm)
   (error "Illegal m-factor: m-factor must be even number\n"))

 (setq contact0InfoS  (nth 0 srcInterconnect))
 (setq contact0LayerS (nth 0 contact0InfoS))
 (setq contact0WidthS (nth 1 contact0InfoS))
 (setq contact0SpaceS (nth 2 contact0InfoS))
 (setq contact0ColsS  (nth 3 contact0InfoS))
 (setq met0LayerS     (nth 4 contact0InfoS))
 (setq met0WidthS     (nth 5 contact0InfoS))
 (setq met0SpaceS     (nth 6 contact0InfoS))
 (setq met0BevelS     (nth 7 contact0InfoS)) ;;met0Bevel is not supported

 (setq contact1InfoS  (nth 1 srcInterconnect))
 (setq contact1LayerS (nth 0 contact1InfoS))
 (setq contact1WidthS (nth 1 contact1InfoS))
 (setq contact1SpaceS (nth 2 contact1InfoS))
 (setq contact1ColsS  (nth 3 contact1InfoS))
 (setq met1LayerS     (nth 4 contact1InfoS))
 (setq met1WidthS     (nth 5 contact1InfoS))
 (setq met1SpaceS     (nth 6 contact1InfoS))
 (setq met1BevelS     (nth 7 contact1InfoS))

 (setq contact0InfoD  (nth 0 drnInterconnect))
 (setq contact0LayerD (nth 0 contact0InfoD))
 (setq contact0WidthD (nth 1 contact0InfoD))
 (setq contact0SpaceD (nth 2 contact0InfoD))
 (setq contact0ColsD  (nth 3 contact0InfoD))
 (setq met0LayerD     (nth 4 contact0InfoD))
 (setq met0WidthD     (nth 5 contact0InfoD))
 (setq met0SpaceD     (nth 6 contact0InfoD))
 (setq met0BevelD     (nth 7 contact0InfoD)) ;;met0Bevel is not supported

 (setq contact1InfoD  (nth 1 drnInterconnect))
 (setq contact1LayerD (nth 0 contact1InfoD))
 (setq contact1WidthD (nth 1 contact1InfoD))
 (setq contact1SpaceD (nth 2 contact1InfoD))
 (setq contact1ColsD  (nth 3 contact1InfoD))
 (setq met1LayerD     (nth 4 contact1InfoD))
; (setq met1WidthD     (nth 5 contact1InfoD))
 (setq met1SpaceD     (nth 6 contact1InfoD))
 (setq met1BevelD     (nth 7 contact1InfoD))

 (setq srcPinWidth (plus (times contact0WidthS contact0ColsS) (times (plus contact0ColsS -1) contact0SpaceS)))
 (setq mSourcePinOffset srcGateContactSpace)
 (setq sharedSourceWidth (plus (times mSourcePinOffset 2.0) srcPinWidth))
 (setq drnPinWidth (plus (times contact0WidthD contact0ColsD) (times (plus contact0ColsD -1) contact0SpaceD)))
 (setq mDrainPinOffset drnGateContactSpace)
 (setq sharedDrainWidth (plus (times mDrainPinOffset 2.0) drnPinWidth))

 ;;This is used to resize the src/drn metal if the min metal space is violated
; (setq Metal0Space  (plus srcdrnPinWidth (times 2.0 (plus l mSourcePinOffset)) sharedCascodeDiffWidth -met0Width))
; (when (lessp Metal0Space met0Space)
;   (setq met0Width     (plus met0Width (difference Metal0Space met0Space)))
;   (setq met0Width     (times (floor (times met0Width 100)) 0.01))
;   )
; (setq Metal1Space  (plus srcdrnPinWidth (times 2.0 (plus l mSourcePinOffset)) sharedCascodeDiffWidth -met1Width))
; (when (lessp Metal1Space met1Space)
;   (setq met1Width     (plus met1Width (difference Metal1Space met1Space) ))
;   (setq met1Width     (times (floor (times met1Width 100)) 0.01))
;   )

 (setq firstSourcePin
       (rodCreateRect
	?layer diffLayer
	?width srcPinWidth
	?length w
	?pin t
	?termName "S"
	?termIOType "inputOutput"
	?pinAccessDir (list "top" "bottom")
	?pinLabel t
	?pinLabelHeight labelWidth
	?pinLabelLayer labelLayer
	?pinLabelFont "roman"
	?subRectArray
	(list (list ?layer contact0LayerS
		    ?width  contact0WidthS
		    ?length contact0WidthS
		    ?spaceY contact0SpaceS
		    ?spaceX contact0SpaceS
		    ?lowerLeftOffsetY  diffContact0Yenc
		    ?upperRightOffsetY -diffContact0Yenc
		    ))
	))
 (rodAlign
  ?alignObj firstSourcePin
  ?alignHandle "lR"
  ?refPoint esdCellOrigin
  ?xSep -mSourcePinOffset
  )

;;Draw the met0Layer for the first source
 (setq contact1PitchS (plus contact1WidthS contact1SpaceS ))
 (setq contact1PitchD (plus contact1WidthD contact1SpaceD ))
 (setq met0PinWidthS (plus (times contact1WidthS contact1ColsS) (times (plus contact1ColsS -1) contact1SpaceS)))
 (setq met0PinWidthD (plus (times contact1WidthD contact1ColsD) (times (plus contact1ColsD -1) contact1SpaceD)))
 (setq firstMet0Pin
       (rodCreateRect
	?layer met0LayerS
	?width met0PinWidthS
	?length w
	?pin t
	?termName "S"
	?termIOType "inputOutput"
	?pinAccessDir (list "top" "bottom")
	?subRectArray
	(list (list ?layer contact1LayerS
		    ?width  contact1WidthS
		    ?length contact1WidthS
		    ?spaceY contact1SpaceS
		    ?spaceX contact1SpaceS
		    ?lowerLeftOffsetY  diffContact0Yenc
		    ?upperRightOffsetY -diffContact0Yenc
		    ))
	))

 (rodAlign
  ?alignObj firstMet0Pin
  ?alignHandle "lC"
  ?refObj firstSourcePin
  ?refHandle "lC"
  )

 (setq firstMet0Drawing
       (rodCreateRect
	?layer met0LayerS
	?width met0WidthS
	?length w
	))
 (rodAlign
  ?alignObj firstMet0Drawing
  ?alignHandle "lC"
  ?refObj  firstMet0Pin
  ?refHandle "lC"
  )

 ;;Define the points for the beveled met1Layer
 (declare met1DrawingPtsS[8])
 (declare met1DrawingPtsD[8])
;;     ______
;;    /2    3;;   /        ;;   |1      4|
;;   |        |
;;   |        |        
;;   |        |        
;;   |        |             
;;   |        | 
;;   |        |
;;   |0      5|
;;   \        /
;;    \______/
;;    7      6

 (setq x0Met1 0.0)
 (setq y0Met1 0.0)
 met1DrawingPtsS[0]  = x0Met1:(plus y0Met1 met1BevelS)
 met1DrawingPtsS[1]  = x0Met1:(difference w met1BevelS)
 met1DrawingPtsS[2]  = met1BevelS:w
 met1DrawingPtsS[3]  = (plus met1WidthS -met1BevelS):w
 met1DrawingPtsS[4]  = met1WidthS:(difference w met1BevelS)
 met1DrawingPtsS[5]  = met1WidthS:(plus y0Met1 met1BevelS)
 met1DrawingPtsS[6]  = (plus met1WidthS -met1BevelS):0
 met1DrawingPtsS[7]  = met1BevelS:0
 (setq firstMet1pointsS nil)
 met1DrawingPtsD[0]  = x0Met1:(plus y0Met1 met1BevelD)
 met1DrawingPtsD[1]  = x0Met1:(difference w met1BevelD)
 met1DrawingPtsD[2]  = met1BevelD:w
 met1DrawingPtsD[3]  = (plus met1WidthD -met1BevelD):w
 met1DrawingPtsD[4]  = met1WidthD:(difference w met1BevelD)
 met1DrawingPtsD[5]  = met1WidthD:(plus y0Met1 met1BevelD)
 met1DrawingPtsD[6]  = (plus met1WidthD -met1BevelD):0
 met1DrawingPtsD[7]  = met1BevelD:0
 (setq firstMet1pointsD nil)
 (for i 1 8
      (setq firstMet1pointsS
	    (cons (car met1DrawingPtsS[8 - i]):(cadr met1DrawingPtsS[8 - i]) firstMet1pointsS))
      (setq firstMet1pointsD
	    (cons (car met1DrawingPtsD[8 - i]):(cadr met1DrawingPtsD[8 - i]) firstMet1pointsD))
      )
 (setq firstMet1Drawing
       (rodCreatePolygon
	?layer met1LayerS
	?pts firstMet1pointsS
	?pin t
	?termName "S"
	?termIOType "inputOutput"
	?pinAccessDir (list "top" "bottom")
	))
 (rodAlign
  ?alignObj firstMet1Drawing
  ?alignHandle "cC"
  ?refObj  firstMet0Drawing
  ?refHandle "cC"
  )

(setq sourcePinsNumber 1)
(setq drainPinsNumber  1)

;;Remember that a source terminal has already been created
(setq sourcePinsNumber (quotient m 4))
(setq drainPinsNumber sourcePinsNumber)
(setq sourcePinsSpace  (plus sharedDrainWidth (times l 4) (times 2 sharedCascodeDiffWidth) (times mSourcePinOffset 2.0)))
(setq drainPinsSpace (plus sharedSourceWidth (times l 4) (times 2 sharedCascodeDiffWidth) (times mDrainPinOffset 2.0)))

;;Create the source terminals
(setq sourcePinsOriginOffset  (plus sourcePinsSpace srcPinWidth))
(setq sourcePinsOriginX (plus (car esdCellOrigin) (times l 4) (times 2 sharedCascodeDiffWidth) sharedDrainWidth mSourcePinOffset))

(for n 1 sourcePinsNumber

     ;;The origin of the remaining source terminals is after the first shared drain
     (setq sourcePinsOrigin (list (plus sourcePinsOriginX (times (difference n 1) sourcePinsOriginOffset)) 0.0))
     (setq sourcePins
	   (rodCreateRect
	    ?layer diffLayer
	    ?width srcPinWidth
	    ?length w
	    ?origin sourcePinsOrigin
	    ?pin t
	    ?termName "S"
	    ?termIOType "inputOutput"
	    ?pinAccessDir (list "top" "bottom")
	    ?pinLabel t
	    ?pinLabelHeight labelWidth
	    ?pinLabelLayer labelLayer
	    ?pinLabelFont "roman"
	    ?subRectArray
	    (list (list ?layer contact0LayerS
			?width  contact0WidthS
			?length contact0WidthS
			?spaceY contact0SpaceS
			?spaceX contact0SpaceS
			?lowerLeftOffsetY  diffContact0Yenc
			?upperRightOffsetY -diffContact0Yenc
			))
	    ))
  
     (setq sourceMet0Pins
	   (rodCreateRect
	    ?layer met0LayerS
	    ?width met0PinWidthS
	    ?length w
	    ?pin t
	    ?termName "S"
	    ?termIOType "inputOutput"
	    ?pinAccessDir (list "top" "bottom")
	    ?subRectArray
	    (list (list ?layer contact1LayerS
			?width  contact1WidthS
			?length contact1WidthS
			?spaceY contact1SpaceS
			?spaceX contact1SpaceS
			?lowerLeftOffsetY  diffContact0Yenc
			?upperRightOffsetY -diffContact0Yenc
			))
	    ))

  (rodAlign
   ?alignObj sourceMet0Pins
   ?alignHandle "lC"
   ?refObj sourcePins
   ?refHandle "lC"
   )
  (setq sourceMet0Drawing
	(rodCreateRect
	 ?layer met0LayerS
	 ?width met0WidthS
	 ?length w
	 ))
  (rodAlign
   ?alignObj sourceMet0Drawing
   ?alignHandle "lC"
   ?refObj  sourceMet0Pins
   ?refHandle "lC"
   )

  ;;Create beveled met1Layer on the source terminals
  (setq sourceMet1Drawing
	(rodCreatePolygon
	 ?layer met1LayerS
	 ?pts firstMet1pointsS
	 ?pin t
	 ?termName "S"
	 ?termIOType "inputOutput"
	 ?pinAccessDir (list "top" "bottom")
	 ))
  (rodAlign
   ?alignObj sourceMet1Drawing
   ?alignHandle "cC"
   ?refObj  sourceMet0Drawing
   ?refHandle "cC"
   )
 )

;;Create the drain terminals
(setq drainPinsOriginOffset  (plus drainPinsSpace drnPinWidth))
(setq drainPinsOriginX (plus (car esdCellOrigin) (times l 2) sharedCascodeDiffWidth mDrainPinOffset))

(for n 1 drainPinsNumber

     ;;The origin of the remaining drain terminals is after the first gate
     (setq drainPinsOrigin (list (plus drainPinsOriginX (times (difference n 1) drainPinsOriginOffset)) 0.0))
     (setq drainPins
	   (rodCreateRect
	    ?layer diffLayer
	    ?width drnPinWidth
	    ?length w
	    ?origin drainPinsOrigin
	    ?pin t
	    ?termName "D"
	    ?termIOType "inputOutput"
	    ?pinAccessDir (list "top" "bottom")
	    ?pinLabel t
	    ?pinLabelHeight labelWidth
	    ?pinLabelLayer labelLayer
	    ?pinLabelFont "roman"
	    ?subRectArray
	    (list (list ?layer contact0LayerD
			?width  contact0WidthD
			?length contact0WidthD
			?spaceY contact0SpaceD
			?spaceX contact0SpaceD
			?lowerLeftOffsetY  diffContact0Yenc
			?upperRightOffsetY -diffContact0Yenc
			))
	    ))
  
     (setq drainMet0Pins
	   (rodCreateRect
	    ?layer met0LayerD
	    ?width met0PinWidthD
	    ?length w
	    ?pin t
	    ?termName "D"
	    ?termIOType "inputOutput"
	    ?pinAccessDir (list "top" "bottom")
	    ?subRectArray
	    (list (list ?layer contact1LayerD
			?width  contact1WidthD
			?length contact1WidthD
			?spaceY contact1SpaceD
			?spaceX contact1SpaceD
			?lowerLeftOffsetY  diffContact0Yenc
			?upperRightOffsetY -diffContact0Yenc
			))
	    ))

  (rodAlign
   ?alignObj drainMet0Pins
   ?alignHandle "lC"
   ?refObj drainPins
   ?refHandle "lC"
   )
  (setq drainMet0Drawing
	(rodCreateRect
	 ?layer met0LayerD
	 ?width met0WidthD
	 ?length w
	 ))
  (rodAlign
   ?alignObj drainMet0Drawing
   ?alignHandle "lC"
   ?refObj  drainMet0Pins
   ?refHandle "lC"
   )

  ;;Create beveled met1Layer on the drain terminals
  (setq drainMet1Drawing
	(rodCreatePolygon
	 ?layer met1LayerD
	 ?pts firstMet1pointsD
	 ?pin t
	 ?termName "D"
	 ?termIOType "inputOutput"
	 ?pinAccessDir (list "top" "bottom")
	 ))
  (rodAlign
   ?alignObj drainMet1Drawing
   ?alignHandle "cC"
   ?refObj  drainMet0Drawing
   ?refHandle "cC"
   )
 )

  (setq sharedCascodeDiffNumber (ceiling (quotient m 4.0)))
  (setq sharedCascodeDiffSpace  (plus (times l 4) sharedSourceWidth (times 2 sharedCascodeDiffWidth) sharedDrainWidth))
  ;;Create the drain terminals
  (setq sharedCascodeDiffOriginX_1 (plus (car esdCellOrigin) l))
  (setq sharedCascodeDiffOriginX_2 (plus (car esdCellOrigin) (times 3 l) sharedCascodeDiffWidth sharedDrainWidth))
  (setq sharedCascodeDiffOriginOffset  sharedCascodeDiffSpace)
  (for n 1 sharedCascodeDiffNumber

       ;;The origin of the remaining drain terminals is after the first single source
       (setq sharedCascodeDiffOrigin_1 (list (plus sharedCascodeDiffOriginX_1 (times (difference n 1) sharedCascodeDiffOriginOffset)) 0.0))
       (setq sharedCascodeDiff_1
	     (rodCreateRect
	      ?layer diffLayer
	      ?width sharedCascodeDiffWidth
	      ?length w
	      ?origin sharedCascodeDiffOrigin_1
	      ))
       (setq sharedCascodeDiffOrigin_2 (list (plus sharedCascodeDiffOriginX_2 (times (difference n 1) sharedCascodeDiffOriginOffset)) 0.0))
       (setq sharedCascodeDiff_2
	     (rodCreateRect
	      ?layer diffLayer
	      ?width sharedCascodeDiffWidth
	      ?length w
	      ?origin sharedCascodeDiffOrigin_2
	      ))
  )
 
(setq flareY (plus flareOutDiff flareExt))
(cond 
 (singleFlare
  
  (declare oddflareGatePts[8])
  ;;   5 ____ 6  
  ;;    |    |   
  ;;    |    |  
  ;;  4  \   | 
  ;;      \  |  
  ;;    3  | |
  ;;       | |  
  ;;       | |  
  ;;       | |
  ;;    2  | |
  ;;      /  |  
  ;;  1  /   |
  ;;    |    | 
  ;;    |____|
  ;;  0       7
  ;;

  (setq xo0 (plus -flareOutDiff -flareInDiff))
  (setq xo2 (plus xo0 flareInDiff flareOutDiff))
  (setq xo6 (plus xo2 l))
  oddflareGatePts[0]  = xo0:-flareY
  oddflareGatePts[1]  = xo0:-flareOutDiff
  oddflareGatePts[2]  = xo2:flareInDiff
  oddflareGatePts[3]  = xo2:(plus w -flareInDiff)
  oddflareGatePts[4]  = xo0:(plus w flareOutDiff)
  oddflareGatePts[5]  = xo0:(plus w flareY)
  oddflareGatePts[6]  = xo6:(plus w flareY)
  oddflareGatePts[7]  = xo6:-flareY

  (declare evenflareGatePts[8])
  ;;  1 ____ 2
  ;;   |    |
  ;;   |    |
  ;;   |   / 3 
  ;;   |  /    
  ;;   | | 4  
  ;;   | |    
  ;;   | |    
  ;;   | |    
  ;;   | | 5  
  ;;   |  \   
  ;;   |   \ 6
  ;;   |    |
  ;;   |____|
  ;;  0      7
  (setq xe0 0.0)
  (setq xe2 (plus xe0 l flareInDiff flareOutDiff))
  (setq xe4 (plus xe0 l))
  evenflareGatePts[0]  = xe0:-flareY
  evenflareGatePts[1]  = xe0:(plus w flareY)
  evenflareGatePts[2]  = xe2:(plus w flareY)
  evenflareGatePts[3]  = xe2:(plus w flareOutDiff)
  evenflareGatePts[4]  = xe4:(plus w -flareInDiff)
  evenflareGatePts[5]  = xe4:flareInDiff
  evenflareGatePts[6]  = xe2:-flareOutDiff
  evenflareGatePts[7]  = xe2:-flareY

  (for i 1 8
       (setq pointList1 
	     (cons (car oddflareGatePts[8 - i]):(cadr oddflareGatePts[8 - i]) pointList1))
       )
  (setq firstGateDrawing
	(rodCreatePolygon
	 ?layer gateLayer
	 ?pts pointList1
	 ?pin t
	 ?termName "G"
	 ?termIOType "input"
	 ?pinAccessDir (list "top" "bottom")
	 ))

  )
 (t

  (declare flareGatePts[12])
  ;;   5 _______ 6  
  ;;    |       |   
  ;;    |       |  
  ;;  4  \     / 7
  ;;      \   /  
  ;;    3  | | 8
  ;;       | |  
  ;;       | |  
  ;;       | |
  ;;    2  | | 9
  ;;      /   \ 
  ;;  1  /     \ 10
  ;;    |       |
  ;;    |_______|
  ;;  0          11
  ;;
  (setq x0 (plus -flareOutDiff -flareInDiff))
  (setq x2 (plus x0 flareInDiff flareOutDiff))
  (setq x6 (plus x2 l -x0))
  (setq x8 (plus x2 l))
  flareGatePts[0]  = x0:-flareY
  flareGatePts[1]  = x0:-flareOutDiff
  flareGatePts[2]  = x2:flareInDiff
  flareGatePts[3]  = x2:(plus w -flareInDiff)
  flareGatePts[4]  = x0:(plus w flareOutDiff)
  flareGatePts[5]  = x0:(plus w flareY)
  flareGatePts[6]  = x6:(plus w flareY)
  flareGatePts[7]  = x6:(plus w flareOutDiff)
  flareGatePts[8]  = x8:(plus w -flareInDiff)
  flareGatePts[9]  = x8:flareInDiff
  flareGatePts[10]  = x6:-flareOutDiff
  flareGatePts[11]  = x6:-flareY

  (setq pointList1 nil)
  (for i 1 12
       (setq pointList1 
	     (cons (car flareGatePts[12 - i]):(cadr flareGatePts[12 - i]) pointList1))
       )
  (setq firstGateDrawing
	(rodCreatePolygon
	 ?layer gateLayer
	 ?pts pointList1
	 ?pin t
	 ?termName "G"
	 ?termIOType "input"
	 ?pinAccessDir (list "top" "bottom")
	 ))
  )
 )

(setq oddGateOffset  0.0)
(for n 2 m
     ;; Draw poly gate of fet
     (when (oddp n)
       (setq pointList1 nil)
       (setq oddGateOffset  (plus sharedCascodeDiffWidth l ,(if (oddp (floor (quotient n 2))) sharedDrainWidth sharedSourceWidth) l oddGateOffset))
       (cond
	(singleFlare
	 (for i 1 8
	      (setq pointList1 
		    (cons (plus (car oddflareGatePts[8 - i]) oddGateOffset):(cadr oddflareGatePts[8 - i]) pointList1))
	      )
	 )
	(t
	 (for i 1 12
	      (setq pointList1 
		    (cons (plus (car flareGatePts[12 - i]) oddGateOffset):(cadr flareGatePts[12 - i]) pointList1))
	      )
	 )
	)
       (setq oddGateDrawing
	     (rodCreatePolygon
	      ?layer gateLayer
	      ?pts pointList1
	      ?pin t
	      ?termName "G"
	      ?termIOType "input"
	      ?pinAccessDir (list "top" "bottom")
	      ))
       )

     (when (evenp n)
       (setq pointList2 nil)
       (if  (equal n 2) then
	 (setq evenGateOffset  (plus sharedCascodeDiffWidth l))
	 else
	 (setq evenGateOffset  (plus sharedCascodeDiffWidth l ,(if (evenp (floor (quotient n 2))) sharedDrainWidth sharedSourceWidth) l evenGateOffset))
	 )
       (cond
	(singleFlare
	 (for i 1 8
	      (setq pointList2 
		    (cons (plus (car evenflareGatePts[8 - i]) evenGateOffset):(cadr evenflareGatePts[8 - i]) pointList2))
	      )
	 )
	(t
	 (for i 1 12
	      (setq pointList2
		    (cons (plus (car flareGatePts[12 - i]) evenGateOffset):(cadr flareGatePts[12 - i]) pointList2))
	      )
	 )
	)
       (setq evenGateDrawing
	     (rodCreatePolygon
	      ?layer gateLayer
	      ?pts pointList2
	      ?pin t
	      ?termName "G"
	      ?termIOType "input"
	      ?pinAccessDir (list "top" "bottom")
	      ))
       )
     )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Draw poly gate of fet
(when pgateLayer
 (setq odd1PGateDrawing
       (rodCreateRect
	?layer pgateLayer
	?width l
	?length w
	?origin esdCellOrigin
	?elementsX (ceiling (quotient m 4.0))
	?spaceX (plus (times 2 sharedCascodeDiffWidth) (times 3 l) sharedDrainWidth sharedSourceWidth)
	))
 (setq odd2PGateDrawing
       (rodCreateRect
	?layer pgateLayer
	?width l
	?length w
	?origin (list (plus (car esdCellOrigin) (times 2 l) sharedCascodeDiffWidth sharedDrainWidth) 0)
	?elementsX (ceiling (quotient m 4.0))
	?spaceX (plus (times 2 sharedCascodeDiffWidth) (times 3 l) sharedDrainWidth sharedSourceWidth)
	))
 
 (setq even1PGateDrawing 
       (rodCreateRect
	?layer pgateLayer
	?width l
	?length w
	?origin (list (plus sharedCascodeDiffWidth l) 0)
	?elementsX (quotient m 4)
	?spaceX (plus (times 2 sharedCascodeDiffWidth) (times 3 l) sharedDrainWidth sharedSourceWidth)
	))
 (setq even1PGateDrawing 
       (rodCreateRect
	?layer pgateLayer
	?width l
	?length w
	?origin (list (plus (car esdCellOrigin) (times 3 l) (times 2 sharedCascodeDiffWidth) sharedDrainWidth) 0)
	?elementsX (quotient m 4)
	?spaceX (plus (times 2 sharedCascodeDiffWidth) (times 3 l) sharedDrainWidth sharedSourceWidth)
	))
 )

(setq fetDiffusionXdim
      (plus (times l m)
	    (times sharedSourceWidth (plus sourcePinsNumber -1))
	    (times sharedDrainWidth drainPinsNumber)
	    (times sharedCascodeDiffWidth (times 2 sharedCascodeDiffNumber))
	    (times (plus srcPinWidth diffContact0Xenc mSourcePinOffset) 2.0)
	    )
      )

(setq fetDiffusion
      (rodCreateRect
       ?layer diffLayer
       ?width fetDiffusionXdim
       ?length w
       ))

 (rodAlign
  ?alignObj fetDiffusion
  ?alignHandle "lL"
  ?refObj firstSourcePin
  ?refHandle "lL"
  ?xSep -diffContact0Xenc
  )


(cond 
 (buttingTap
  (setq firstSourceTap
	(rodCreateRect
	 ?layer  tapLayer
	 ?width  buttingTapWidth
	 ?length w
	 ?pin t
;	  ?subRectArray
;	  (list (list ?layer contact0LayerS
;		      ?width  contact0WidthS
;		      ?length contact0WidthS
;		      ?spaceY contact0SpaceS
;		      ?spaceX contact0SpaceS
;		      ?lowerLeftOffsetX  buttingTapCont0Xenc
;		      ?upperRightOffsetX -buttingTapCont0Xenc
;		      ?lowerLeftOffsetY  diffContact0Yenc
;		      ?upperRightOffsetY -diffContact0Yenc
;		      ))
	 ))
  (rodAlign
   ?alignObj firstSourceTap
   ?alignHandle "lR"
   ?refObj fetDiffusion
   ?refHandle "lL"
   )
  (setq firstSourceTapMet0
	(rodCreateRect
	 ?layer met0LayerS
	 ?width (plus buttingTapWidth diffContact0Xenc)
	 ?length w
	 ))
  (rodAlign
   ?alignObj firstSourceTapMet0
   ?alignHandle "cL"
   ?refObj firstSourceTap
   ?refHandle "cL"
   )
  (setq firstSourceTapMet1
	(rodCreateRect
	 ?layer met1LayerS
	 ?width (plus buttingTapWidth (times 2 diffContact0Xenc))
	 ?length w
	 ))
  (rodAlign
   ?alignObj firstSourceTapMet1
   ?alignHandle "cC"
   ?refObj firstSourceTap
   ?refHandle "cC"
   )
  (setq firstSourceTapImp
	(rodCreateRect
	 ?layer  tapImplant
	 ?width  (plus tapImpEnc buttingTapWidth)
	 ?length (plus w (times 2.0 tapImpEnc))
	 ))
  (rodAlign
   ?alignObj firstSourceTapImp
   ?alignHandle "lR"
   ?refObj firstSourceTap
   ?refHandle "lR"
   ?ySep -tapImpEnc
   )
  
  (setq lastSourceTap
	(rodCreateRect
	 ?layer  tapLayer
	 ?width  buttingTapWidth
	 ?length w
	 ?pin t
;	  ?subRectArray
;	  (list (list ?layer contact0LayerS
;		      ?width  contact0WidthS
;		      ?length contact0WidthS
;		      ?spaceY contact0SpaceS
;		      ?spaceX contact0SpaceS
	;	      ?lowerLeftOffsetX  buttingTapCont0Xenc
;		      ?upperRightOffsetX -buttingTapCont0Xenc
;		      ?lowerLeftOffsetY  diffContact0Yenc
;		      ?upperRightOffsetY -diffContact0Yenc
;		      ))
	  ))
  (rodAlign
   ?alignObj lastSourceTap
   ?alignHandle "lL"
   ?refObj fetDiffusion
   ?refHandle "lR"
   )
  (setq lastSourceTapMet0
	(rodCreateRect
	 ?layer met0LayerS
	 ?width (plus buttingTapWidth diffContact0Xenc)
	 ?length w
	 ))
  (rodAlign
   ?alignObj lastSourceTapMet0
   ?alignHandle "cR"
   ?refObj lastSourceTap
   ?refHandle "cR"
   )
  (setq lastSourceTapMet1
	(rodCreateRect
	 ?layer met1LayerS
	 ?width (plus buttingTapWidth (times 2 diffContact0Xenc))
	 ?length w
	 ))
  (rodAlign
   ?alignObj lastSourceTapMet1
   ?alignHandle "cC"
   ?refObj lastSourceTap
   ?refHandle "cC"
   )
  (setq fetDiffImp
	(rodCreateRect
	 ?layer diffImplant
	 ?width  fetDiffusionXdim
	 ?length (plus w (times 2.0 diffImpEnc))
	 ))
  (rodAlign
   ?alignObj fetDiffImp
   ?alignHandle "lL"
   ?refObj fetDiffusion
   ?refHandle "lL"
   ?ySep -diffImpEnc
   )
  (setq lastSourceTapImp
	(rodCreateRect
	 ?layer  tapImplant
	 ?width  (plus tapImpEnc buttingTapWidth)
	 ?length (plus w (times 2.0 tapImpEnc))
	 ))
  (rodAlign
   ?alignObj lastSourceTapImp
   ?alignHandle "lL"
   ?refObj lastSourceTap
   ?refHandle "lL"
   ?ySep -tapImpEnc
   )
  
  (when (and (equal mosType "pmos") (equal rings "None"))
    (setq wellLayerDrawing
	  (rodCreateRect
	   ?layer wellLayer
	   ?width  (plus fetDiffusionXdim (times 2.0 buttingTapWidth) (times 2.0 hvWellDiffTapEnc))
	   ?length (plus w (times 2.0 hvWellDiffTapEnc))
	   ))
    (rodAlign
     ?alignObj wellLayerDrawing
     ?alignHandle "lL"
     ?refObj firstSourceTap
     ?refHandle "lL"
     ?xSep -hvWellDiffTapEnc
     ?ySep -hvWellDiffTapEnc
     )
     )
  )
 (t
  (setq fetDiffImp
	(rodCreateRect
	 ?layer diffImplant
	 ?fromObj fetDiffusion
	 ?size diffImpEnc
	 ))
  
  (when (and (equal mosType "pmos") (equal rings "None"))
    (setq wellLayerDrawing
	  (rodCreateRect
	   ?layer wellLayer
	   ?fromObj fetDiffusion
	   ?size hvWellDiffTapEnc
	   ))
    )
  )
 )

;;##################################InnerRing Generation##################################
;;(unless ringsOff
(when (or (equal rings "Inner") (equal rings "Both"))

  ;; parameters for top and bottom segments of inner ring
  (setq ringContact0InfoH  (nth 0 InnerRingInterconnectHoriz))
  (setq ringContact0LayerH (nth 0 ringContact0InfoH))
  (setq ringContact0WidthH (nth 1 ringContact0InfoH))
  (setq ringContact0SpaceH (nth 2 ringContact0InfoH))
  (setq ringContact0ColsH  (nth 3 ringContact0InfoH))
  (setq ringMet0LayerH     (nth 4 ringContact0InfoH))
  (setq ringMet0Cont0EncH  (nth 5 ringContact0InfoH))
  (setq ringMet0InBevelH   (nth 6 ringContact0InfoH))
  (setq ringMet0OutBevelH  (nth 7 ringContact0InfoH));;ringMet0OutBevel is not supported

  (setq ringContact1InfoH  (nth 1 InnerRingInterconnectHoriz))
  (setq ringContact1LayerH (nth 0 ringContact1InfoH))
  (setq ringContact1WidthH (nth 1 ringContact1InfoH))
  (setq ringContact1SpaceH (nth 2 ringContact1InfoH))
  (setq ringContact1ColsH  (nth 3 ringContact1InfoH))
  (setq ringMet1LayerH     (nth 4 ringContact1InfoH))
  (setq ringMet1Cont1EncH  (nth 5 ringContact1InfoH))
  (setq ringMet1InBevelH   (nth 6 ringContact1InfoH))
  (setq ringMet1OutBevelH  (nth 7 ringContact1InfoH))

  ;; parameters for left and right segments of inner ring
  (setq ringContact0InfoV  (nth 0 InnerRingInterconnectVert))
  (setq ringContact0LayerV (nth 0 ringContact0InfoV))
  (setq ringContact0WidthV (nth 1 ringContact0InfoV))
  (setq ringContact0SpaceV (nth 2 ringContact0InfoV))
  (setq ringContact0ColsV  (nth 3 ringContact0InfoV))
  (setq ringMet0LayerV     (nth 4 ringContact0InfoV))
  (setq ringMet0Cont0EncV  (nth 5 ringContact0InfoV))
  (setq ringMet0InBevelV   (nth 6 ringContact0InfoV))
  (setq ringMet0OutBevelV  (nth 7 ringContact0InfoV));;ringMet0OutBevel is not supported

  (setq ringContact1InfoV  (nth 1 InnerRingInterconnectVert))
  (setq ringContact1LayerV (nth 0 ringContact1InfoV))
  (setq ringContact1WidthV (nth 1 ringContact1InfoV))
  (setq ringContact1SpaceV (nth 2 ringContact1InfoV))
  (setq ringContact1ColsV  (nth 3 ringContact1InfoV))
  (setq ringMet1LayerV     (nth 4 ringContact1InfoV))
  (setq ringMet1Cont1EncV  (nth 5 ringContact1InfoV))
  (setq ringMet1InBevelV   (nth 6 ringContact1InfoV))
  (setq ringMet1OutBevelV  (nth 7 ringContact1InfoV))

  (setq ringContact0PitchH  (plus ringContact0WidthH ringContact0SpaceH ))
  (setq ringContact0PitchV  (plus ringContact0WidthV ringContact0SpaceV ))

  (setq innerRingWidthH     (plus (times ringContact0WidthH ringContact0ColsH)
				 (times (plus ringContact0ColsH -1) ringContact0SpaceH) (times 2.0 ringMet0Cont0EncH)))
  (setq innerRingWidthV     (plus (times ringContact0WidthV ringContact0ColsV)
				 (times (plus ringContact0ColsV -1) ringContact0SpaceV) (times 2.0 ringMet0Cont0EncV)))

  (setq innerRingLengthLR    (plus w innerRingFetTopSpace innerRingFetBotSpace (times 2.0 innerRingWidthH)))
  (setq innerRingLengthTB    (plus fetDiffusionXdim innerRingFetRightSpace innerRingFetLeftSpace (times 2.0 innerRingWidthV)))

  (setq ringContact1PitchH  (plus ringContact1WidthH ringContact1SpaceH ))
  (setq ringContact1PitchV  (plus ringContact1WidthV ringContact1SpaceV ))

  (setq innerMet1RingWidthH (plus (times ringContact1WidthH ringContact1ColsH)
				 (times (plus ringContact1ColsH -1) ringContact1SpaceH) (times 2.0 ringMet1Cont1EncH)))
  (setq innerMet1RingWidthV (plus (times ringContact1WidthV ringContact1ColsV)
				 (times (plus ringContact1ColsV -1) ringContact1SpaceV) (times 2.0 ringMet1Cont1EncV)))

;;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  (when (lessp innerMet1RingWidthH ringMet1OutBevelH)
    (setq ringMet1OutBevelH  innerMet1RingWidthH)
    )
  (when (lessp innerMet1RingWidthV ringMet1OutBevelV)
    (setq ringMet1OutBevelV  innerMet1RingWidthV)
    )
;;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

  ;;Create left side of the ring
  (setq leftInnerRing
	(rodCreateRect
	 ?layer tapLayer
	 ?width innerRingWidthV
	 ?length innerRingLengthLR
	 ?subRectArray
	 (list (list ?layer  ringContact0LayerV
		     ?width  ringContact0WidthV
		     ?length ringContact0WidthV
		     ?spaceY ringContact0SpaceV
		     ?spaceX ringContact0SpaceV
		     ?lowerLeftOffsetY  (plus innerRingWidthH ringContact0PitchH)
		     ?upperRightOffsetY (plus -innerRingWidthH -ringContact0PitchH)
		     ))
	 ))
  (rodAlign
   ?alignObj leftInnerRing
   ?alignHandle "lR"
   ?refObj fetDiffusion
   ?refHandle "lL"
   ?xSep -innerRingFetLeftSpace
   ?ySep (plus -innerRingFetBotSpace -innerRingWidthH)
   )

  (setq leftInnerRingImp
	(rodCreateRect
	 ?layer tapImplant
	 ?fromObj leftInnerRing
	 ?size tapImpEnc
	 ))
  (setq leftInnerRingMet0
	(rodCreateRect
	 ?layer ringMet0LayerV
	 ?fromObj leftInnerRing
	 ))

;;Create right side of the ring
  (setq rightInnerRing
	(rodCreateRect
	 ?layer tapLayer
	 ?width innerRingWidthV
	 ?length innerRingLengthLR
	 ?subRectArray
	 (list (list ?layer  ringContact0LayerV
		     ?width  ringContact0WidthV
		     ?length ringContact0WidthV
		     ?spaceY ringContact0SpaceV
		     ?spaceX ringContact0SpaceV
		     ?lowerLeftOffsetY  (plus innerRingWidthH ringContact0PitchH)
		     ?upperRightOffsetY (plus -innerRingWidthH -ringContact0PitchH)
		     ))
	 ))
  (rodAlign
   ?alignObj rightInnerRing
   ?alignHandle "lL"
   ?refObj fetDiffusion
   ?refHandle "lR"
   ?xSep innerRingFetRightSpace
   ?ySep (plus -innerRingFetBotSpace -innerRingWidthH)
   )
  (setq rightInnerRingImp
	(rodCreateRect
	 ?layer tapImplant
	 ?fromObj rightInnerRing
	 ?size tapImpEnc
	 ))
  (setq rightInnerRingMet0
	(rodCreateRect
	 ?layer ringMet0LayerV
	 ?fromObj rightInnerRing
	 ))

;;Create lower side of the ring
  (setq lowerInnerRing
	(rodCreateRect
	 ?layer tapLayer
	 ?width innerRingLengthTB
	 ?length innerRingWidthH
	 ?subRectArray
	 (list (list ?layer  ringContact0LayerH
		     ?width  ringContact0WidthH
		     ?length ringContact0WidthH
		     ?spaceY ringContact0SpaceH
		     ?spaceX ringContact0SpaceH
		     ?lowerLeftOffsetX   ringContact0PitchH
		     ?upperRightOffsetX -ringContact0PitchH
		     ))
	 ))
  (rodAlign
   ?alignObj lowerInnerRing
   ?alignHandle "uL"
   ?refObj fetDiffusion
   ?refHandle "lL"
   ?xSep (plus -innerRingFetLeftSpace -innerRingWidthV)
   ?ySep -innerRingFetBotSpace
   )
  (setq lowerInnerRingImp
	(rodCreateRect
	 ?layer tapImplant
	 ?fromObj lowerInnerRing
	 ?size tapImpEnc
	 ))
  (setq lowerInnerRingMet0
	(rodCreateRect
	 ?layer ringMet0LayerH
	 ?fromObj lowerInnerRing
	 ))

;;Create upper side of the ring
  (setq upperInnerRing
	(rodCreateRect
	 ?layer tapLayer
	 ?width innerRingLengthTB
	 ?length innerRingWidthH
	 ?subRectArray
	 (list (list ?layer  ringContact0LayerH
		     ?width  ringContact0WidthH
		     ?length ringContact0WidthH
		     ?spaceY ringContact0SpaceH
		     ?spaceX ringContact0SpaceH
		     ?lowerLeftOffsetX   ringContact0PitchH
		     ?upperRightOffsetX -ringContact0PitchH
		     ))
	 ))
  (rodAlign
   ?alignObj upperInnerRing
   ?alignHandle "uL"
   ?refObj fetDiffusion
   ?refHandle "uL"
   ?xSep (plus -innerRingFetLeftSpace -innerRingWidthV)
   ?ySep (plus innerRingFetTopSpace innerRingWidthH)
   )
  (setq upperInnerRingImp
	(rodCreateRect
	 ?layer tapImplant
	 ?fromObj upperInnerRing
	 ?size tapImpEnc
	 ))
  (setq upperInnerRingMet0
	(rodCreateRect
	 ?layer ringMet0LayerH
	 ?fromObj upperInnerRing
	 ))

  ;;Create the metal1 inner ring
  (unless ringsMet1Off
    (setq leftInnerRingMet1
	  (rodCreateRect
	   ?layer ringMet1LayerV
	   ?width innerMet1RingWidthV
	   ?length (plus innerRingLengthLR (times 2.0 -innerMet1RingWidthH) -ringMet1OutBevelH)
	   ?subRectArray
	   (list (list ?layer  ringContact1LayerV
		       ?width  ringContact1WidthV
		       ?length ringContact1WidthV
		       ?spaceY ringContact1SpaceV
		       ?spaceX ringContact1SpaceV
		       ?lowerLeftOffsetY  ringContact1PitchV
		       ?upperRightOffsetY -ringContact1PitchV
		       ?lowerLeftOffsetX ringMet1Cont1EncV
		       ?upperRightOffsetX -ringMet1Cont1EncV
		       ))
	   ))
    (rodAlign
     ?alignObj leftInnerRingMet1
     ?alignHandle "cC"
     ?refObj leftInnerRing
     ?refHandle "cC"
     )

    (setq rightInnerRingMet1
	  (rodCreateRect
	   ?layer ringMet1LayerV
	   ?width innerMet1RingWidthV
	   ?length (plus innerRingLengthLR (times 2.0 -innerMet1RingWidthH) -ringMet1OutBevelH)
	   ?subRectArray
	   (list (list ?layer  ringContact1LayerV
		       ?width  ringContact1WidthV
		       ?length ringContact1WidthV
		       ?spaceY ringContact1SpaceV
		       ?spaceX ringContact1SpaceV
		       ?lowerLeftOffsetY  ringContact1PitchV
		       ?upperRightOffsetY -ringContact1PitchV
		       ?lowerLeftOffsetX  ringMet1Cont1EncV
		       ?upperRightOffsetX -ringMet1Cont1EncV
		       ))
	   ))
    (rodAlign
     ?alignObj rightInnerRingMet1
     ?alignHandle "cC"
     ?refObj rightInnerRing
     ?refHandle "cC"
     )

    (setq lowerInnerRingMet1
	  (rodCreateRect
	   ?layer ringMet1LayerH
	   ?width (plus innerRingLengthTB (times 2.0 -ringMet1OutBevelV))
	   ?length innerMet1RingWidthH
	   ?subRectArray
	   (list (list ?layer  ringContact1LayerH
		       ?width  ringContact1WidthH
		       ?length ringContact1WidthH
		       ?spaceY ringContact1SpaceH
		       ?spaceX ringContact1SpaceH
		       ?lowerLeftOffsetX  ringContact1PitchH
		       ?upperRightOffsetX -ringContact1PitchH
		       ?lowerLeftOffsetY  ringMet1Cont1EncH
		       ?upperRightOffsetY -ringMet1Cont1EncH
		       ))
	   ))
    (rodAlign
     ?alignObj lowerInnerRingMet1
     ?alignHandle "cC"
     ?refObj lowerInnerRing
     ?refHandle "cC"
     )

    (setq upperInnerRingMet1
	  (rodCreateRect
	   ?layer ringMet1LayerH
	   ?width (plus innerRingLengthTB (times 2.0 -ringMet1OutBevelV))
	   ?length innerMet1RingWidthH
	   ?subRectArray
	   (list (list ?layer  ringContact1LayerH
		       ?width  ringContact1WidthH
		       ?length ringContact1WidthH
		       ?spaceY ringContact1SpaceH
		       ?spaceX ringContact1SpaceH
		       ?lowerLeftOffsetX  ringContact1PitchH
		       ?upperRightOffsetX -ringContact1PitchH
		       ?lowerLeftOffsetY  ringMet1Cont1EncH
		       ?upperRightOffsetY -ringMet1Cont1EncH
		       ))
	   ))
    (rodAlign
     ?alignObj upperInnerRingMet1
     ?alignHandle "cC"
     ?refObj upperInnerRing
     ?refHandle "cC"
     )

;;Define the points for the beveled innerRingMet1Layer
    (declare innerRingMet1Pts[18])
;;     ________________
;;   2/  ____________  \3
;;  1|  /14        13\  |4
;;   | /              \ |
;;   | |15          12| |
;;   | |              | |        
;;   | |              | |        
;;   | |              | |             
;;   | |              | | 
;;   | |8           11| |
;;   | \              / |
;;  0|  \9________10_/  |5
;;    \________________/
;;    7                6

;;Calculate the width difference between the inner tap and inner metal1 rings per side
    (setq innerRingWidthDiffH (difference innerMet1RingWidthH innerRingWidthH))
    (setq innerRingWidthDiffV (difference innerMet1RingWidthV innerRingWidthV))

    (setq x0Met1 0.0)
    (setq y0Met1 0.0)
;;distance between points 9&10
    (setq holeDimX (plus fetDiffusionXdim innerRingFetLeftSpace innerRingFetRightSpace
			 -innerRingWidthDiffV (times 2.0 -ringMet1InBevelV)))
;;distance between points 8&15
    (setq holeDimY (plus w innerRingFetTopSpace innerRingFetBotSpace 
			 -innerRingWidthDiffH (times 2.0 -ringMet1InBevelH)))

    (setq x0Met1  0.0)
    (setq x2Met1  ringMet1OutBevelV)
    (setq x3Met1  (difference (plus holeDimX (times 2.0 ringMet1InBevelV) (times 2.0 innerMet1RingWidthV)) ringMet1OutBevelV)) ;(plus holeDimX (times 2.0 innerMet1RingWidthV) (times 2.0 ringMet1InBevelV) ringMet1OutBevelV))
    (setq x4Met1  (plus x3Met1 ringMet1OutBevelV))
    (setq x9Met1  (plus innerMet1RingWidthV ringMet1InBevelV)) ;(plus innerMet1RingWidthV ringMet1OutBevelV ringMet1InBevelV))
    (setq x10Met1 (plus x9Met1 holeDimX))
    (setq x11Met1 (plus x10Met1 ringMet1InBevelV))
    (setq x15Met1 innerMet1RingWidthV)

    (setq y0Met1  -ringMet1InBevelH)
    (setq y1Met1  (plus holeDimY ringMet1InBevelH))
    (setq y2Met1  (plus y1Met1 ringMet1OutBevelH))
    (setq y6Met1  (plus -ringMet1InBevelH -ringMet1OutBevelH))
    (setq y8Met1  0.0)
    (setq y12Met1 holeDimY)

    innerRingMet1Pts[0]   = x0Met1:y0Met1
    innerRingMet1Pts[1]   = x0Met1:y1Met1
    innerRingMet1Pts[2]   = x2Met1:y2Met1
    innerRingMet1Pts[3]   = x3Met1:y2Met1
    innerRingMet1Pts[4]   = x4Met1:y1Met1
    innerRingMet1Pts[5]   = x4Met1:y0Met1
    innerRingMet1Pts[6]   = x3Met1:y6Met1
    innerRingMet1Pts[7]   = x2Met1:y6Met1
    innerRingMet1Pts[8]   = x15Met1:y8Met1
    innerRingMet1Pts[9]   = x9Met1:y0Met1
    innerRingMet1Pts[10]  = x10Met1:y0Met1
    innerRingMet1Pts[11]  = x11Met1:y8Met1
    innerRingMet1Pts[12]  = x11Met1:y12Met1
    innerRingMet1Pts[13]  = x10Met1:y1Met1
    innerRingMet1Pts[14]  = x9Met1:y1Met1
    innerRingMet1Pts[15]  = x15Met1:y12Met1

    (setq innerRingMet1Points (list innerRingMet1Pts[0] innerRingMet1Pts[1] innerRingMet1Pts[2] innerRingMet1Pts[3] 
				    innerRingMet1Pts[4] innerRingMet1Pts[5] innerRingMet1Pts[6] innerRingMet1Pts[7] 
				    innerRingMet1Pts[9] innerRingMet1Pts[10] innerRingMet1Pts[11] innerRingMet1Pts[12] 
				    innerRingMet1Pts[13] innerRingMet1Pts[14] innerRingMet1Pts[15] innerRingMet1Pts[8] 
				    innerRingMet1Pts[9] innerRingMet1Pts[7]))
    (setq innerRingMet1Layer
	  (rodCreatePolygon
	   ?layer ringMet1LayerH
	   ?pts innerRingMet1Points
	   ))

    (rodAlign
     ?alignObj innerRingMet1Layer
     ?alignHandle "cL"
     ?refObj  leftInnerRingMet1
     ?refHandle "cL"
;     ?xSep (times (difference innerMet1RingWidthV ringMet1OutBevelV) 0.5)
     )
    );;// unless ringsMet1Off

  ;;Draw the hvLayer
  (when hvMode
    (setq hvLayerDrawing
	  (rodCreateRect
	   ?layer hvLayer
	   ?width (plus innerRingLengthTB (times 2.0 hvLayerDiffTapEnc))
	   ?length (plus innerRingLengthLR (times 2.0 hvLayerDiffTapEnc))
	   ))
    (rodAlign
     ?alignObj hvLayerDrawing
     ?alignHandle "lL"
     ?refObj lowerInnerRing
     ?refHandle "lL"
     ?xSep -hvLayerDiffTapEnc
     ?ySep -hvLayerDiffTapEnc
     )
    )

  (when (equal mosType "pmos")
    (setq wellLayerWidth  (plus innerRingLengthTB (times 2.0 hvWellDiffTapEnc)))
    (setq wellLayerLength (plus innerRingLengthLR (times 2.0 hvWellDiffTapEnc)))
    
    (setq wellLayerDrawing
	  (rodCreateRect
	   ?layer wellLayer
	   ?width wellLayerWidth
	   ?length wellLayerLength
	   ))
    (rodAlign
     ?alignObj wellLayerDrawing
     ?alignHandle "lL"
     ?refObj lowerInnerRing
     ?refHandle "lL"
     ?xSep -hvWellDiffTapEnc
     ?ySep -hvWellDiffTapEnc
     )

    (when hvMode
      (setq hvLayerDrawing
	    (rodCreateRect
	     ?layer hvLayer
	     ?fromObj wellLayerDrawing
	     ?size 0.0
	     ))
      )

  )

 );;(when (or (equal rings "Inner") (equal rings "Both"))

(when (equal rings "Both")

;;##################################OuterRing Generation##################################
  (setq ringContact0Info  (nth 0 OuterRingInterconnect))
  (setq ringContact0Layer (nth 0 ringContact0Info))
  (setq ringContact0Width (nth 1 ringContact0Info))
  (setq ringContact0Space (nth 2 ringContact0Info))
  (setq ringContact0Cols  (nth 3 ringContact0Info))
  (setq ringMet0Layer     (nth 4 ringContact0Info))
  (setq ringMet0Cont0Enc  (nth 5 ringContact0Info))
  (setq ringMet0InBevel   (nth 6 ringContact0Info))
  (setq ringMet0OutBevel  (nth 7 ringContact0Info))

  (setq ringContact1Info  (nth 1 OuterRingInterconnect))
  (setq ringContact1Layer (nth 0 ringContact1Info))
  (setq ringContact1Width (nth 1 ringContact1Info))
  (setq ringContact1Space (nth 2 ringContact1Info))
  (setq ringContact1Cols  (nth 3 ringContact1Info))
  (setq ringMet1Layer     (nth 4 ringContact1Info))
  (setq ringMet1Cont1Enc  (nth 5 ringContact1Info))
  (setq ringMet1InBevel   (nth 6 ringContact1Info))
  (setq ringMet1OutBevel  (nth 7 ringContact1Info))

  (setq ringContact0Pitch  (plus ringContact0Width ringContact0Space))
  (setq outerRingWidth     (plus (times ringContact0Width ringContact0Cols)
				 (times (plus ringContact0Cols -1) ringContact0Space) (times 2.0 ringMet0Cont0Enc)))
  (setq outerRingWidth     (max  outerRingWidth userOuterRingWidth))
  (setq outerRingLengthLR (plus innerRingLengthLR (times 2.0 OuterInnerRingSpace) (times 2.0 outerRingWidth)))
  (setq outerRingLengthTB (plus innerRingLengthTB (times 2.0 OuterInnerRingSpace) (times 2.0 outerRingWidth)))
  (setq ringContact1Pitch  (plus ringContact1Width ringContact1Space))
  (setq outerMet1RingWidth (plus (times ringContact1Width ringContact1Cols)
				 (times (plus ringContact1Cols -1) ringContact1Space) (times 2.0 ringMet1Cont1Enc)))

;;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
  (when (lessp outerMet1RingWidth ringMet1OutBevel)
    (setq ringMet1OutBevel  outerMet1RingWidth)
    )
;;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

;;Create left side of the ring
  (setq leftOuterRing
	(rodCreateRect
	 ?layer tapLayer
	 ?width outerRingWidth
	 ?length outerRingLengthLR
	 ?subRectArray
	 (list (list ?layer  ringContact0Layer
		     ?width  ringContact0Width
		     ?length ringContact0Width
		     ?spaceY ringContact0Space
		     ?spaceX ringContact0Space
		     ?lowerLeftOffsetY  (plus  outerRingWidth  ringContact0Pitch)
		     ?upperRightOffsetY (plus -outerRingWidth -ringContact0Pitch)
		     ))
	 ))
  (rodAlign
   ?alignObj leftOuterRing
   ?alignHandle "lR"
   ?refObj leftInnerRing
   ?refHandle "lL"
   ?xSep -OuterInnerRingSpace
   ?ySep (plus -OuterInnerRingSpace -outerRingWidth)
   )
  (setq leftOuterRingImp
	(rodCreateRect
	 ?layer diffImplant
	 ?fromObj leftOuterRing
	 ?size diffImpEnc
	 ))
  (when (equal mosType "nmos")
    (setq leftOuterRingWell
	  (rodCreateRect
	   ?layer wellLayer
	   ?fromObj leftOuterRing
	   ?size  hvWellDiffTapEnc
	   ))
    )
  (setq leftOuterRingMet0
	(rodCreateRect
	 ?layer ringMet0Layer
	 ?fromObj leftOuterRing
	 ))

;;Create right side of the ring
  (setq rightOuterRing
	(rodCreateRect
	 ?layer tapLayer
	 ?width outerRingWidth
	 ?length outerRingLengthLR
	 ?subRectArray
	 (list (list ?layer  ringContact0Layer
		     ?width  ringContact0Width
		     ?length ringContact0Width
		     ?spaceY ringContact0Space
		     ?spaceX ringContact0Space
		     ?lowerLeftOffsetY  (plus  outerRingWidth  ringContact0Pitch)
		     ?upperRightOffsetY (plus -outerRingWidth -ringContact0Pitch)
		     ))
	 ))
  (rodAlign
   ?alignObj rightOuterRing
   ?alignHandle "lL"
   ?refObj rightInnerRing
   ?refHandle "lR"
   ?xSep OuterInnerRingSpace
   ?ySep (plus -OuterInnerRingSpace -outerRingWidth)
   )
  (setq rightOuterRingImp
	(rodCreateRect
	 ?layer diffImplant
	 ?fromObj rightOuterRing
	 ?size diffImpEnc
	 ))
  (when (equal mosType "nmos")
    (setq rightOuterRingWell
	  (rodCreateRect
	   ?layer wellLayer
	   ?fromObj rightOuterRing
	   ?size  hvWellDiffTapEnc
	   ))
    )
  (setq rightOuterRingMet0
	(rodCreateRect
	 ?layer ringMet0Layer
	 ?fromObj rightOuterRing
	 ))

;;Create lower side of the ring
  (setq lowerOuterRing
	(rodCreateRect
	 ?layer tapLayer
	 ?width outerRingLengthTB
	 ?length outerRingWidth
	 ?subRectArray
	 (list (list ?layer  ringContact0Layer
		     ?width  ringContact0Width
		     ?length ringContact0Width
		     ?spaceY ringContact0Space
		     ?spaceX ringContact0Space
		     ?lowerLeftOffsetX   ringContact0Pitch
		     ?upperRightOffsetX -ringContact0Pitch
		     ))
	 ))
  (rodAlign
   ?alignObj lowerOuterRing
   ?alignHandle "uC"
   ?refObj lowerInnerRing
   ?refHandle "lC"
   ?ySep -OuterInnerRingSpace
   )
  (setq lowerOuterRingImp
	(rodCreateRect
	 ?layer diffImplant
	 ?fromObj lowerOuterRing
	 ?size diffImpEnc
	 ))
  (when (equal mosType "nmos")
    (setq lowerOuterRingWell
	  (rodCreateRect
	   ?layer wellLayer
	   ?fromObj lowerOuterRing
	   ?size  hvWellDiffTapEnc
	   ))
    )
  (setq lowerOuterRingMet0
	(rodCreateRect
	 ?layer ringMet0Layer
	 ?fromObj lowerOuterRing
	 ))

;;Create upper side of the ring
  (setq upperOuterRing 
	(rodCreateRect
	 ?layer tapLayer
	 ?width outerRingLengthTB
	 ?length outerRingWidth
	 ?subRectArray
	 (list (list ?layer  ringContact0Layer
		     ?width  ringContact0Width
		     ?length ringContact0Width
		     ?spaceY ringContact0Space
		     ?spaceX ringContact0Space
		     ?lowerLeftOffsetX   ringContact0Pitch
		     ?upperRightOffsetX -ringContact0Pitch
		     ))
	 ))
  (rodAlign
   ?alignObj upperOuterRing
   ?alignHandle "lC"
   ?refObj upperInnerRing
   ?refHandle "uC"
   ?ySep OuterInnerRingSpace
   )
  (setq upperOuterRingImp
	(rodCreateRect
	 ?layer diffImplant
	 ?fromObj upperOuterRing
	 ?size diffImpEnc
	 ))
  (when (equal mosType "nmos")
    (setq upperOuterRingWell
	  (rodCreateRect
	   ?layer wellLayer
	   ?fromObj upperOuterRing
	   ?size  hvWellDiffTapEnc
	   ))
    )
  (setq upperOuterRingMet0
	(rodCreateRect
	 ?layer ringMet0Layer
	 ?fromObj upperOuterRing
	 ))

  (unless ringsMet1Off
    ;;Create the metal1 on the outer ring
    (setq leftOuterRingMet1
	  (rodCreateRect
	   ?layer ringMet1Layer
	   ?width outerMet1RingWidth
	   ?length (plus outerRingLengthLR (times 2.0 -outerMet1RingWidth) -ringMet1OutBevel)
	   ?subRectArray
	   (list (list ?layer  ringContact1Layer
		       ?width  ringContact1Width
		       ?length ringContact1Width
		       ?spaceY ringContact1Space
		       ?spaceX ringContact1Space
		       ?lowerLeftOffsetY  ringContact1Pitch
		       ?upperRightOffsetY -ringContact1Pitch
		       ?lowerLeftOffsetX  ringMet1Cont1Enc
		       ?upperRightOffsetX -ringMet1Cont1Enc
		       ))
	   ))
    (rodAlign
     ?alignObj leftOuterRingMet1
     ?alignHandle "cC"
     ?refObj leftOuterRing
     ?refHandle "cC"
     )

    (setq rightOuterRingMet1
	  (rodCreateRect
	   ?layer ringMet1Layer
	   ?width outerMet1RingWidth
	   ?length (plus outerRingLengthLR (times 2.0 -outerMet1RingWidth) -ringMet1OutBevel)
	   ?subRectArray
	   (list (list ?layer  ringContact1Layer
		       ?width  ringContact1Width
		       ?length ringContact1Width
		       ?spaceY ringContact1Space
		       ?spaceX ringContact1Space
		       ?lowerLeftOffsetY  ringContact1Pitch
		       ?upperRightOffsetY -ringContact1Pitch
		       ?lowerLeftOffsetX  ringMet1Cont1Enc
		       ?upperRightOffsetX -ringMet1Cont1Enc
		       ))
	   ))
    (rodAlign
     ?alignObj rightOuterRingMet1
     ?alignHandle "cC"
     ?refObj rightOuterRing
     ?refHandle "cC"
     )

    (setq lowerOuterRingMet1
	  (rodCreateRect
	   ?layer ringMet1Layer
	   ?width (plus outerRingLengthTB -outerMet1RingWidth (times 2.0 -ringMet1OutBevel))
	   ?length outerMet1RingWidth
	   ?subRectArray
	   (list (list ?layer  ringContact1Layer
		       ?width  ringContact1Width
		       ?length ringContact1Width
		       ?spaceY ringContact1Space
		       ?spaceX ringContact1Space
		       ?lowerLeftOffsetX  ringContact1Pitch
		       ?upperRightOffsetX -ringContact1Pitch
		       ?lowerLeftOffsetY  ringMet1Cont1Enc
		       ?upperRightOffsetY -ringMet1Cont1Enc
		       ))
	   ))
    (rodAlign
     ?alignObj lowerOuterRingMet1
     ?alignHandle "cC"
     ?refObj lowerOuterRing
     ?refHandle "cC"
     )

    (setq upperOuterRingMet1
	  (rodCreateRect
	   ?layer ringMet1Layer
	   ?width (plus outerRingLengthTB -outerMet1RingWidth (times 2.0 -ringMet1OutBevel))
	   ?length outerMet1RingWidth
	   ?subRectArray
	   (list (list ?layer  ringContact1Layer
		       ?width  ringContact1Width
		       ?length ringContact1Width
		       ?spaceY ringContact1Space
		       ?spaceX ringContact1Space
		       ?lowerLeftOffsetX  ringContact1Pitch
		       ?upperRightOffsetX -ringContact1Pitch
		       ?lowerLeftOffsetY  ringMet1Cont1Enc
		       ?upperRightOffsetY -ringMet1Cont1Enc
		       ))
	   ))
    (rodAlign
     ?alignObj upperOuterRingMet1
     ?alignHandle "cC"
     ?refObj upperOuterRing
     ?refHandle "cC"
     )

    ;;Define the points for the beveled outerRingMet1Layer
    (declare outerRingMet1Pts[18])
;;     ________________
;;   2/  ____________  \3
;;  1|  /14        13\  |4
;;   | /              \ |
;;   | |15          12| |
;;   | |              | |        
;;   | |              | |        
;;   | |              | |             
;;   | |              | | 
;;   | |8           11| |
;;   | \              / |
;;  0|  \9________10_/  |5
;;    \________________/
;;    7                6

    ;;Calculate the width difference between the inner tap and inner metal1 rings per side
    (setq outerRingWidthDiff (difference outerMet1RingWidth outerRingWidth))
    
    (setq x0Met1 0.0)
    (setq y0Met1 0.0)
    ;;distance between points 9&10
    (setq holeDimX (plus fetDiffusionXdim innerRingFetLeftSpace innerRingFetRightSpace -outerRingWidthDiff 
			 (times 2.0 OuterInnerRingSpace) (times 2.0 innerRingWidthV) (times 2.0 -ringMet1InBevel)))
    ;;distance between points 8&15
    (setq holeDimY (plus w innerRingFetTopSpace innerRingFetBotSpace -outerRingWidthDiff
			 (times 2.0 OuterInnerRingSpace) (times 2.0 innerRingWidthH) (times 2.0 -ringMet1InBevel)))
    
    (setq x0Met1  0.0)
    (setq x2Met1  ringMet1OutBevel)
    (setq x3Met1  (plus holeDimX (times 2.0 ringMet1InBevel) ringMet1OutBevel))
    (setq x4Met1  (plus x3Met1 ringMet1OutBevel))
    (setq x9Met1  (plus ringMet1OutBevel ringMet1InBevel))
    (setq x10Met1 (plus x9Met1 holeDimX))

    (setq y0Met1  -ringMet1InBevel)
    (setq y1Met1  (plus holeDimY ringMet1InBevel))
    (setq y2Met1  (plus y1Met1 ringMet1OutBevel))
    (setq y6Met1  (plus -ringMet1InBevel -ringMet1OutBevel))
    (setq y8Met1  0.0)
    (setq y12Met1 holeDimY)

    outerRingMet1Pts[0]   = x0Met1:y0Met1
    outerRingMet1Pts[1]   = x0Met1:y1Met1
    outerRingMet1Pts[2]   = x2Met1:y2Met1
    outerRingMet1Pts[3]   = x3Met1:y2Met1
    outerRingMet1Pts[4]   = x4Met1:y1Met1
    outerRingMet1Pts[5]   = x4Met1:y0Met1
    outerRingMet1Pts[6]   = x3Met1:y6Met1
    outerRingMet1Pts[7]   = x2Met1:y6Met1
    outerRingMet1Pts[8]   = x2Met1:y8Met1
    outerRingMet1Pts[9]   = x9Met1:y0Met1
    outerRingMet1Pts[10]  = x10Met1:y0Met1
    outerRingMet1Pts[11]  = x3Met1:y8Met1
    outerRingMet1Pts[12]  = x3Met1:y12Met1
    outerRingMet1Pts[13]  = x10Met1:y1Met1
    outerRingMet1Pts[14]  = x9Met1:y1Met1
    outerRingMet1Pts[15]  = x2Met1:y12Met1

    (setq outerRingMet1Points (list outerRingMet1Pts[0] outerRingMet1Pts[1]  outerRingMet1Pts[2]  outerRingMet1Pts[3] 
				    outerRingMet1Pts[4] outerRingMet1Pts[5]  outerRingMet1Pts[6]  outerRingMet1Pts[7] 
				    outerRingMet1Pts[9] outerRingMet1Pts[10] outerRingMet1Pts[11] outerRingMet1Pts[12] 
				    outerRingMet1Pts[13] outerRingMet1Pts[14] outerRingMet1Pts[15] outerRingMet1Pts[8] 
				    outerRingMet1Pts[9] outerRingMet1Pts[7]))
    (setq outerRingMet1Layer
	  (rodCreatePolygon
	   ?layer ringMet1Layer
	   ?pts outerRingMet1Points
	   ))

    (rodAlign
     ?alignObj outerRingMet1Layer
     ?alignHandle "cL"
     ?refObj  leftOuterRingMet1
     ?refHandle "cL"
     ?xSep (times (difference outerMet1RingWidth ringMet1OutBevel) 0.5)
     )

    );;//(unless ringsMet1Off

 (cond
  ((equal mosType "nmos")
   (setq idLayerWidth  (plus outerRingLengthTB (times 2.0 hvWellDiffTapEnc)))
   (setq idLayerLength (plus outerRingLengthLR (times 2.0 hvWellDiffTapEnc)))

  ;;Draw the hvLayer
  (when hvMode
      (setq hvLayerDrawing
	    (rodCreateRect
	     ?layer hvLayer
	     ?width idLayerWidth
	     ?length idLayerLength
	     ))
      (rodAlign
       ?alignObj hvLayerDrawing
       ?alignHandle "lL"
       ?refObj lowerOuterRingWell
       ?refHandle "lL"
       )
      )
   )
  ((equal mosType "pmos")
   (setq idLayerWidth  (plus outerRingLengthTB (times 2.0 hvLayerDiffTapEnc)))
   (setq idLayerLength (plus outerRingLengthLR (times 2.0 hvLayerDiffTapEnc)))

   ;;Draw the hvLayer
   (when hvMode
     (setq hvLayerDrawing
	   (rodCreateRect
	    ?layer hvLayer
	    ?width idLayerWidth
	    ?length idLayerLength
	    ))
     (rodAlign
      ?alignObj hvLayerDrawing
      ?alignHandle "lL"
      ?refObj lowerOuterRing
      ?refHandle "lL"
      ?xSep -hvLayerDiffTapEnc
      ?ySep -hvLayerDiffTapEnc
      )
     )
   )
  (t
   )
  )

  ;;The idLayer should be drawn only when the rings exist.
  ;;When the ring is does not exist then the device should be used to be 
  ;;placed in another bigger ring that has the id layer
  ;;Draw the idLayer
  (setq idLayerDrawing
	(rodCreateRect
	 ?layer idLayer
	 ;;?width (plus outerRingLengthTB (times 2.0 hvWellDiffTapEnc))
	 ;;?length (plus outerRingLengthLR (times 2.0 hvWellDiffTapEnc))
	 ?width idLayerWidth
	 ?length idLayerLength
	 ))
  (rodAlign
   ?alignObj idLayerDrawing
   ?alignHandle "lL"
   ;;the reference is in the priority hvLayer, wellLayer, implant
   ?refObj (or hvLayerDrawing lowerOuterRingWell lowerOuterRingImp)
   ?refHandle "lL"
   )

 );;(when (equal rings "Both") )

;;Draw the hvLayer over the diffusion when the rings are off and operating in hvMode
(when (and hvMode (equal rings "None"))
  (setq hvLayerDrawing
	(rodCreateRect
	 ?layer hvLayer
	 ?width (plus fetDiffusionXdim 
		      (max innerRingFetRightSpace hvLayerDiffTapEnc) 
		      (max innerRingFetLeftSpace hvLayerDiffTapEnc))
	 ?length (plus w (max innerRingFetBotSpace hvLayerDiffTapEnc)
		       (max innerRingFetTopSpace hvLayerDiffTapEnc))
	 ))
  (rodAlign
   ?alignObj hvLayerDrawing
   ?alignHandle "lL"
   ?refObj fetDiffusion
   ?refHandle "lL"
   ?xSep (min -innerRingFetLeftSpace -hvLayerDiffTapEnc)
   ?ySep (min -innerRingFetBotSpace -hvLayerDiffTapEnc)
   )
 )

;; Draw warning labels on cell
(unless (equal rings "None")
  (setq leftXCoord (difference (car esdCellOrigin) (plus innerRingFetLeftSpace (quotient innerRingWidthV 2) diffContact0Xenc mSourcePinOffset srcPinWidth)))
  (setq rightXCoord (plus (car esdCellOrigin) innerRingFetRightSpace (quotient innerRingWidthV 2) (difference fetDiffusionXdim diffContact0Xenc mSourcePinOffset srcPinWidth)))
  
  (setq labelYCoord (difference (quotient innerRingLengthLR 2) innerRingFetBotSpace))
  
  (dbCreateLabel tcCellView labelLayer (list leftXCoord (plus 0.9 labelYCoord)) "CRITICAL TO" "centerCenter" "R0" "roman" 0.4)
  (dbCreateLabel tcCellView labelLayer (list leftXCoord (plus 0.3 labelYCoord)) "CONNECT WIDE" "centerCenter" "R0" "roman" 0.4)
  (dbCreateLabel tcCellView labelLayer (list leftXCoord (difference labelYCoord 0.3)) "SIDES OF" "centerCenter" "R0" "roman" 0.4)
  (dbCreateLabel tcCellView labelLayer (list leftXCoord (difference labelYCoord 0.9)) "GUARDRING" "centerCenter" "R0" "roman" 0.4)
  
  (dbCreateLabel tcCellView labelLayer (list rightXCoord (plus 0.9 labelYCoord)) "CRITICAL TO" "centerCenter" "R0" "roman" 0.4)
  (dbCreateLabel tcCellView labelLayer (list rightXCoord (plus 0.3 labelYCoord)) "CONNECT WIDE" "centerCenter" "R0" "roman" 0.4)
  (dbCreateLabel tcCellView labelLayer (list rightXCoord (difference labelYCoord 0.3)) "SIDES OF" "centerCenter" "R0" "roman" 0.4)
  (dbCreateLabel tcCellView labelLayer (list rightXCoord (difference labelYCoord 0.9)) "GUARDRING" "centerCenter" "R0" "roman" 0.4)
  )

)

(tfcDefineDeviceClassProp
;;(viewName       devClassName        propName          propValue)
 (symbolic        esdCascodeFetClass  function         "transistor")
)
;;; 
;;; $Id: rodIsoResClass.il,v 1.8 2005/12/05 13:49:31 kuc Exp $ %T%
;;; 
;;; rodIsoResClass.il
;;; 
;;; Copyright (c) 2005 by Cypress Semiconductor
;;; Cypress INDIA Cad Center (INDC)
;;; 
;;; Date  : NOV 11, 2005
;;; Author: Ranjit M (rnh) @ INDC
;;; 
;;; Description:
;;;  Skill code for isolated Pwell resistor. Here the width is fixed
;;;  and the length is variable.
;;;
;;; Revision History:
;;;  rnh 11/15/05  Initial Version.
;;;  kuc 11/18/05  Updated class to meet requirements
;;;  kuc 11/18/05  removed HARDCODED implant layer, added class parameter for it
;;;  kuc 11/21/05  removed yet another hardcoded implant layer, added pins
;;;  kuc 11/21/05  Modified mcon placement so they fall right on top of licon
;;;  kuc 11/22/05  Added b terminal to nwell ring
;;; 

(tcCreateDeviceClass "symbolic" "rodIsoResClass"
  ;; Class parameters
  (
   (tapLayer        nil)
   (tapWidth        0.0)
   (tapImpEnc       0.0)
   (tapRingImplant    nil)
   (resContactImplant nil)
   (innerRingImplant     nil)
   (implantSpc      0.0)
   (resIdLayer      "hilite")
   (resCutLayer     "marker")
   (resCutWidth     0.0)
   (resWidth        0.0)
   (minResL         0.0)
   (maxResL         0.0)
   (wellLayer       nil)
   (nwellWidth      0.0)
   (tapWellSpc      nil)
   (dnwellLayer     nil)
   (dnwellWidth     0.0)
   (dnwWellEnc      0.0)
   (conLayer        nil)
   (conWidth        0.0)
   (conLength       0.0)
   (conSpacing      0.0)
   (tapConEncX      0.0)
   (tapConEncY      0.0)
   (M0Layer         nil)
   (M0conEncY       0.0)
   (viaLayer        nil)
   (viaWidth        0.0)
   (viaLength       0.0)
   (viaSpacing      0.0)
   (M0viaEncX       0.0)
   (M1Layer         nil)
   (M1viaEncX       0.0)
   (M1viaEncY       0.0)
;   (L1contact       "TPL1")
;   (M1contact       "TPM1")
  )
  ;; Formal parameters
  (
   (resLength       0.0)
   (contactToMetal  "FALSE")
  )

  (setq nwellWidth (plus nwellWidth dnwWellEnc))
  (setq res (rodCreateRect
	     ?cvId   tcCellView
	     ?layer  resIdLayer
	     ?width  (max (min resLength maxResL) minResL)
	     ?length resWidth
	    )
  )
  (setq cut (rodCreateRect
	     ?cvId   tcCellView
	     ?layer  resCutLayer
	     ?width  resCutWidth
	     ?length resWidth
	    )
  )
  (setq tap_W  (plus (times tapConEncX 2)
		     conSpacing (times conWidth 2)))
  (setq tap_L  (plus (times tapConEncY 2)
		     (times conSpacing 5) (times conLength 6)))
  (setq tapLHS (rodCreateRect
		?cvId   tcCellView
		?layer  tapLayer
		?width  tap_W
		?length tap_L
		?subRectArray list(
				   list(
					?layer              ,conLayer
			                ?width              ,conWidth
					?length             ,conLength
					?lowerLeftOffsetX   ,tapConEncX
					?lowerLeftOffsetY   ,tapConEncY
					?upperRightOffsetX  -,tapConEncX
					?upperRightOffsetY  -,tapConEncY
					?spaceX             ,conSpacing
					?spaceY             ,conSpacing
				       )
				  )
	       )
  )
  (setq impLHS (rodCreateRect
		?cvId   tcCellView
		?layer  resContactImplant
		?width  (plus tap_W (times tapImpEnc 2))
		?length (plus tap_L (times tapImpEnc 2))
	       )
  )
  (setq tapRHS (rodCreateRect
		?cvId   tcCellView
		?layer  tapLayer
		?width  tap_W
		?length tap_L
		?subRectArray list(
				   list(
					?layer              ,conLayer
			                ?width              ,conWidth
					?length             ,conLength
					?lowerLeftOffsetX   ,tapConEncX
					?lowerLeftOffsetY   ,tapConEncY
					?upperRightOffsetX  -,tapConEncX
					?upperRightOffsetY  -,tapConEncY
					?spaceX             ,conSpacing
					?spaceY             ,conSpacing
				       )
				  )
	       )
  )
  (setq impRHS (rodCreateRect
		?cvId   tcCellView
		?layer  resContactImplant
		?width  (plus tap_W (times tapImpEnc 2))
		?length (plus tap_L (times tapImpEnc 2))
	       )
  )
  (if (equal contactToMetal nil)  then
      (setq M0LHS  (rodCreateRect
		    ?cvId   tcCellView
		    ?layer  M0Layer
		    ?width  tap_W
		    ?length tap_L
		    ?termName "r0"
		    ?pin t
		    )
	    )
      (setq M0RHS  (rodCreateRect
		    ?cvId   tcCellView
		    ?layer  M0Layer
		    ?width  tap_W
		    ?length tap_L
		    ?termName "r1"
		    ?pin t
		    )
	    )
      else
      (setq M0LayerWithM1_W (plus (plus (times 2 viaWidth) viaSpacing) (times 2 M0viaEncX)))
      (setq M0LHS  (rodCreateRect
		    ?cvId   tcCellView
		    ?layer  M0Layer
		    ?width  M0LayerWithM1_W
		    ?length tap_L
		    )
	    )
      (setq M0RHS  (rodCreateRect
		    ?cvId   tcCellView
		    ?layer  M0Layer
		    ?width  M0LayerWithM1_W
		    ?length tap_L
		    )
	    )
      )
  (setq DNW    (rodCreateRect
		?cvId   tcCellView
		?layer  dnwellLayer
		?width  (plus (max (min resLength maxResL) minResL)
			      (times tapWellSpc 2)
			      (times tap_W 2)
			      (times (difference nwellWidth dnwWellEnc) 2)
			)
		?length (plus resWidth
			      (times (difference nwellWidth dnwWellEnc) 2)
			)
	       )
  )
  (setq NWRingL (rodCreatePath
		 ?cvId   tcCellView
		 ?layer  wellLayer
		 ?width  nwellWidth
		 ?pts    list(-(plus tap_W tapWellSpc nwellWidth/2):0
			      -(plus tap_W tapWellSpc nwellWidth/2):resWidth
			     )
		 ?encSubPath list(
				  list(
				       ?layer ,tapLayer
					      ?enclosure   (difference nwellWidth/2
								       (plus ,conWidth/2 ,tapConEncX))
					      ?beginOffset (difference nwellWidth/2
								       (plus ,conWidth/2 ,tapConEncX))
					      ?endOffset   (difference nwellWidth/2
								       (plus ,conWidth/2 ,tapConEncX))
				      )
				  list(
				       ?layer innerRingImplant
					      ?enclosure   (difference nwellWidth/2
								       (plus ,conWidth/2 ,tapConEncX tapImpEnc))
					      ?beginOffset (difference nwellWidth/2
								       (plus ,conWidth/2 ,tapConEncX tapImpEnc))
					      ?endOffset   (difference nwellWidth/2
								       (plus ,conWidth/2 ,tapConEncX tapImpEnc))
				      )
				 )
		)
  )
  (setq NWRingT (rodCreatePath
		 ?cvId   tcCellView
		 ?layer  wellLayer
		 ?width  nwellWidth
		 ?pts    list(-(plus tap_W tapWellSpc nwellWidth):
			       (plus resWidth nwellWidth/2)
			       (plus (max (min resLength maxResL) minResL)
				     tapWellSpc tap_W nwellWidth):
			       (plus resWidth nwellWidth/2)
			     )
		 ?encSubPath list(
				  list(
				       ?layer       ,tapLayer
				       ?enclosure   (difference nwellWidth/2
								(plus ,conWidth/2 ,tapConEncX))
				       ?beginOffset -(difference nwellWidth/2
								 (plus ,conWidth/2 ,tapConEncX))
				       ?endOffset   -(difference nwellWidth/2
								 (plus ,conWidth/2 ,tapConEncX))
				      )
				  list(
				       ?layer       innerRingImplant
				       ?enclosure   (difference nwellWidth/2
								(plus ,conWidth/2 ,tapConEncX tapImpEnc))
				       ?beginOffset -(difference nwellWidth/2
								 (plus ,conWidth/2 ,tapConEncX tapImpEnc))
				       ?endOffset   -(difference nwellWidth/2
								 (plus ,conWidth/2 ,tapConEncX tapImpEnc))
				      )
				  list(
				       ?layer       M0Layer
				       ?enclosure   (difference nwellWidth/2
								(plus ,conWidth/2 ,tapConEncX))
				       ?beginOffset -(difference nwellWidth/2
								 (plus ,conWidth/2 ,tapConEncX))
				       ?endOffset   -(difference nwellWidth/2
								 (plus ,conWidth/2 ,tapConEncX))
				      )
				  list(
				       ?layer       M1Layer
				       ?termName    "b"
				       ?pin         t
				       ?termIOType "input"
				       ?enclosure   (difference nwellWidth/2
								(plus ,viaWidth/2 ,M1viaEncX))
				       ?beginOffset -(difference nwellWidth/2
								 (plus ,viaWidth/2 ,tapConEncX))
				       ?endOffset   -(difference nwellWidth/2
								 (plus ,viaWidth/2 ,tapConEncX))
				      )
				 )
		 ?subRect   list(
				 list(
				      ?layer       ,conLayer
				      ?width       ,conWidth
				      ?length      ,conLength
				      ?beginOffset -(plus (difference nwellWidth/2
								      (plus ,conWidth/2 ,tapConEncX))
							  tapConEncY)
				      ?endOffset   -(plus (difference nwellWidth/2
								      (plus ,conWidth/2 ,tapConEncX))
							  tapConEncY)
				      ?space       ,conSpacing
				     )
				 list(
				      ?layer       ,viaLayer
				      ?width       ,viaWidth
				      ?length      ,viaLength
				      ?beginOffset -(plus (difference nwellWidth/2
								      (plus ,viaWidth/2 ,tapConEncX))
							  tapConEncY)
				      ?endOffset   -(plus (difference nwellWidth/2
								      (plus ,viaWidth/2 ,tapConEncX))
							  tapConEncY)
				      ?space       ,viaSpacing
				     )
				)
		)
  )
  (setq NWRingR (rodCreatePath
		 ?cvId   tcCellView
		 ?layer  wellLayer
		 ?width  nwellWidth
		 ?pts    list((plus (max (min resLength maxResL) minResL)
				    tapWellSpc tap_W nwellWidth/2):resWidth
			      (plus (max (min resLength maxResL) minResL)
				    tapWellSpc tap_W nwellWidth/2):0
			     )
		 ?encSubPath list(
				  list(
				       ?layer ,tapLayer
					      ?enclosure   (difference nwellWidth/2
								       (plus ,conWidth/2 ,tapConEncX))
					      ?beginOffset (difference nwellWidth/2
								       (plus ,conWidth/2 ,tapConEncX))
					      ?endOffset   (difference nwellWidth/2
								       (plus ,conWidth/2 ,tapConEncX))
				      )
				  list(
				       ?layer innerRingImplant
					      ?enclosure   (difference nwellWidth/2
								       (plus ,conWidth/2 ,tapConEncX tapImpEnc))
					      ?beginOffset (difference nwellWidth/2
								       (plus ,conWidth/2 ,tapConEncX tapImpEnc))
					      ?endOffset   (difference nwellWidth/2
								       (plus ,conWidth/2 ,tapConEncX tapImpEnc))
				      )
				 )
		)
  )
  (setq NWRingB (rodCreatePath
		 ?cvId   tcCellView
		 ?layer  wellLayer
		 ?width  nwellWidth
		 ?pts    list((plus (max (min resLength maxResL) minResL)
				    tapWellSpc tap_W nwellWidth):-nwellWidth/2
			      -(plus tap_W tapWellSpc nwellWidth):-nwellWidth/2
			     )
		 ?encSubPath list(
				  list(
				       ?layer       ,tapLayer
				       ?enclosure   (difference nwellWidth/2
								(plus ,conWidth/2 ,tapConEncX))
				       ?beginOffset -(difference nwellWidth/2
								 (plus ,conWidth/2 ,tapConEncX))
				       ?endOffset   -(difference nwellWidth/2
								 (plus ,conWidth/2 ,tapConEncX))
				      )
				  list(
				       ?layer       innerRingImplant
				       ?enclosure   (difference nwellWidth/2
								(plus ,conWidth/2 ,tapConEncX tapImpEnc))
				       ?beginOffset -(difference nwellWidth/2
								 (plus ,conWidth/2 ,tapConEncX tapImpEnc))
				       ?endOffset   -(difference nwellWidth/2
								 (plus ,conWidth/2 ,tapConEncX tapImpEnc))
				      )
				  list(
				       ?layer       M0Layer
				       ?enclosure   (difference nwellWidth/2
								(plus ,conWidth/2 ,tapConEncX))
				       ?beginOffset -(difference nwellWidth/2
								 (plus ,conWidth/2 ,tapConEncX))
				       ?endOffset   -(difference nwellWidth/2
								 (plus ,conWidth/2 ,tapConEncX))
				      )
				  list(
				       ?layer       M1Layer
				       ?termName    "b"
				       ?pin         t
				       ?termIOType  "input"
				       ?enclosure   (difference nwellWidth/2
								(plus ,viaWidth/2 ,M1viaEncX))
				       ?beginOffset -(difference nwellWidth/2
								 (plus ,viaWidth/2 ,tapConEncX))
				       ?endOffset   -(difference nwellWidth/2
								 (plus ,viaWidth/2 ,tapConEncX))
				      )
				 )
		 ?subRect   list(
				 list(
				      ?layer       ,conLayer
				      ?width       ,conWidth
				      ?length      ,conLength
				      ?beginOffset -(plus (difference nwellWidth/2
								      (plus ,conWidth/2 ,tapConEncX))
							  tapConEncY)
				      ?endOffset   -(plus (difference nwellWidth/2
								      (plus ,conWidth/2 ,tapConEncX))
							  tapConEncY)
				      ?space       ,conSpacing
				     )
				 list(
				      ?layer       ,viaLayer
				      ?width       ,viaWidth
				      ?length      ,viaLength
				      ?beginOffset -(plus (difference nwellWidth/2
								      (plus ,viaWidth/2 ,tapConEncX))
							  tapConEncY)
				      ?endOffset   -(plus (difference nwellWidth/2
								      (plus ,viaWidth/2 ,tapConEncX))
							  tapConEncY)
				      ?space       ,viaSpacing
				     )
				)
		)
  )
  (setq ImpWby2 (plus ,conWidth/2 ,tapConEncX tapImpEnc))
  (setq TAPRingL (rodCreatePath
		 ?cvId   tcCellView
		 ?layer  tapRingImplant
		 ?width  (times ImpWby2 2)
		 ?pts    list(-(plus tap_W (times tapWellSpc 2) conWidth/2 tapConEncX nwellWidth):
			      -(plus nwellWidth conWidth/2 tapConEncX tapWellSpc)
			      -(plus tap_W (times tapWellSpc 2) conWidth/2 tapConEncX nwellWidth):
			      (plus  resWidth nwellWidth conWidth/2 tapConEncX tapWellSpc)
			     )
		 ?encSubPath list(
				  list(
				       ?layer ,tapLayer
					      ?enclosure   tapImpEnc
					      ?beginOffset 0.0
					      ?endOffset   0.0
				      )
				 )
		 )
  )
  (setq TAPRingT (rodCreatePath
		 ?cvId   tcCellView
		 ?layer  tapRingImplant
		 ?width  (times ImpWby2 2)
		 ?pts    list(-(plus tap_W (times tapWellSpc 2) ImpWby2 conWidth/2 tapConEncX nwellWidth):
			       (plus  resWidth nwellWidth conWidth/2 tapConEncX tapWellSpc)
			       (plus (max (min resLength maxResL) minResL) tap_W nwellWidth (times tapWellSpc 2) (times ImpWby2 2)):
			       (plus  resWidth nwellWidth conWidth/2 tapConEncX tapWellSpc)
			     )
		 ?encSubPath list(
				  list(
				       ?layer       ,tapLayer
				       ?enclosure   tapImpEnc
				       ?beginOffset -tapImpEnc
				       ?endOffset   -tapImpEnc
				      )
				  list(
				       ?layer       ,M0Layer
				       ?enclosure   tapImpEnc
				       ?beginOffset -tapImpEnc
				       ?endOffset   -tapImpEnc
				      )
				 )
		 ?subRect   list(
				 list(
				      ?layer       ,conLayer
				      ?width       ,conWidth
				      ?length      ,conLength
				      ?beginOffset -(plus tapConEncY tapImpEnc)
				      ?endOffset   -(plus tapConEncY tapImpEnc)
				      ?space       ,conSpacing
				     )
				)
		)
  )
  (setq TAPRingR (rodCreatePath
		  ?cvId   tcCellView
		  ?layer  tapRingImplant
		  ?width  (times ImpWby2 2)
		  ?pts    list((plus (max (min resLength maxResL) minResL) tap_W nwellWidth (times tapWellSpc 2) ImpWby2):
			       (plus  resWidth nwellWidth conWidth/2 tapConEncX tapWellSpc)
			       (plus (max (min resLength maxResL) minResL) tap_W nwellWidth (times tapWellSpc 2) ImpWby2):
			       -(plus nwellWidth conWidth/2 tapConEncX tapWellSpc)
			      )
		  ?encSubPath list(
				   list(
					?layer ,tapLayer
					       ?enclosure   tapImpEnc
					       ?beginOffset 0.0 
					       ?endOffset   0.0
				       )
				  )
		 )
  )
  (setq TAPRingB (rodCreatePath
		 ?cvId   tcCellView
		 ?layer  tapRingImplant
		 ?width  (times ImpWby2 2)
		 ?pts    list((plus (max (min resLength maxResL) minResL) tap_W nwellWidth (times tapWellSpc 2) (times ImpWby2 2)):
			       -(plus nwellWidth conWidth/2 tapConEncX tapWellSpc)
			       -(plus tap_W (times tapWellSpc 2) conWidth/2 tapConEncX nwellWidth ImpWby2):
			       -(plus nwellWidth conWidth/2 tapConEncX tapWellSpc)
			     )
		 ?encSubPath list(
				  list(
				       ?layer       ,tapLayer
				       ?enclosure   tapImpEnc
				       ?beginOffset -tapImpEnc
				       ?endOffset   -tapImpEnc
				      )
				  list(
				       ?layer       ,M0Layer
				       ?enclosure   tapImpEnc
				       ?beginOffset -tapImpEnc
				       ?endOffset   -tapImpEnc
				      )
				 )
		 ?subRect   list(
				 list(
				      ?layer       ,conLayer
				      ?width       ,conWidth
				      ?length      ,conLength
				      ?beginOffset -(plus tapConEncY tapImpEnc)
				      ?endOffset   -(plus tapConEncY tapImpEnc)
				      ?space       ,conSpacing
				     )
				)
		)
  )
  (rodAlign
   ?alignObj    cut
   ?alignHandle "cC"
   ?refObj      res
   ?refHandle   "cC"
  )
  (rodAlign
   ?alignObj    impLHS
   ?alignHandle "cC"
   ?refObj      tapLHS
   ?refHandle   "cC"
  )
  (rodAlign
   ?alignObj    impRHS
   ?alignHandle "cC"
   ?refObj      tapRHS
   ?refHandle   "cC"
  )
  (rodAlign
   ?alignObj    tapLHS
   ?alignHandle "cR"
   ?refObj      res
   ?refHandle   "cL"
  )
  (rodAlign
   ?alignObj   tapRHS
   ?alignHandle "cL"
   ?refObj      res
   ?refHandle   "cR"
  )
  (rodAlign
   ?alignObj    M0LHS
   ?alignHandle "cC"
   ?refObj      tapLHS
   ?refHandle   "cC"
  )
  (rodAlign
   ?alignObj    M0RHS
   ?alignHandle "cC"
   ?refObj      tapRHS
   ?refHandle   "cC"
  )
  (rodAlign
   ?alignObj    DNW
   ?alignHandle "cC"
   ?refObj      res
   ?refHandle   "cC"
  )
  (setq M1_W (plus (times 2 (plus M1viaEncX viaWidth)) viaSpacing))
  (if (nequal contactToMetal  nil) then
      (setq M1LHS (rodCreateRect
		   ?cvId   tcCellView
		   ?layer  M1Layer
		   ?width  M1_W
		   ?length (plus (times 5 viaSpacing) (times 6 viaWidth) (times 2 M1viaEncY))
		   ?termName "r0"
		   ?pin t
		   ?subRectArray list(
				      list(
					   ?layer              ,viaLayer
                                           ?width              ,viaWidth
					   ?length             ,viaLength
					   ?lowerLeftOffsetX   ,M1viaEncX
					   ?lowerLeftOffsetY   ,M1viaEncY
					   ?upperRightOffsetX  -,M1viaEncX
					   ?upperRightOffsetY  -,M1viaEncY
					   ?spaceX             ,viaSpacing
					   ?spaceY             ,viaSpacing
					  )
				     )
		  )
      )
      (rodAlign
       ?alignObj    M1LHS
       ?alignHandle "cC"
       ?refObj      M0LHS
       ?refHandle   "cC"
      )
      (setq M1RHS (rodCreateRect
		    ?cvId   tcCellView
		    ?layer  M1Layer
		    ?width  M1_W
		    ?length (plus (times 5 viaSpacing) (times 6 viaWidth) (times 2 M1viaEncY))
		    ?termName "r1"
		    ?pin t
		    ?subRectArray list(
				       list(
					   ?layer              ,viaLayer
                                           ?width              ,viaWidth
					   ?length             ,viaLength
					   ?lowerLeftOffsetX   ,M1viaEncX
					   ?lowerLeftOffsetY   ,M1viaEncY
					   ?upperRightOffsetX  -,M1viaEncX
					   ?upperRightOffsetY  -,M1viaEncY
					   ?spaceX             ,viaSpacing
					   ?spaceY             ,viaSpacing
					   )
				      )
		  )
      )
      (rodAlign
       ?alignObj    M1RHS
       ?alignHandle "cC"
       ?refObj      M0RHS
       ?refHandle   "cC"
      )
  )
)

;;; Define the function of the class.

(tfcDefineDeviceClassProp
 ;;(viewName       devClassName      propName        propValue)
 (symbolic        rodIsoResClass     function       "transistor")
)


;; taking out per BOU request - not quite ready yet
;;#include "xframeClass.il"

;; (tcDeclareDevice
;;  "symbolic" "xframeClass" "xframe"
;;  (
;;   )
;;  (
;;   )
;;  )

 ;; poly to li1 (rcInterConImp)
 ;; implant can be toggled on/off, has no polarity
 (tcDeclareDevice
  "symbolic" "rcInterConImpClass" "PYL1"
  ;; Class Parameters
  ( 
   (layer1 	    "poly")
   (layer2 	    "li1")
   (viaLayer  	    "licon1")
   (encByLayer1     (TECHgetRuleWith "minEnclosure" "poly" "licon1"))
   (layer2XEnc      0.0)
   (layer2YEnc      (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (viaLayerImplant   "npc")
   (viaLayerImpEnc    (TECHgetRule  "licon_15"))
  )
  ;; Formal Parameters
  ( 
   (row 	    1)
   (column 	    1)
   (w   	    (TECHgetRuleWith "minWidth" "licon1"))
   (l   	    (TECHgetRuleWith "minWidth" "licon1"))
   (xPitch 	    (plus (TECHgetRuleWith "minSpacing" "licon1")
			  (TECHgetRuleWith "minWidth"   "licon1")))
   (yPitch 	    (plus (TECHgetRuleWith "minSpacing" "licon1")
			  (TECHgetRuleWith "minWidth"   "licon1")))
   (implant         t)
  )
 )
 ;; we need to tell placeBus that this isn't the right contact to use
 (tfcDefineDeviceProp
  ;;(viewName  deviceName   propName      propValue)
  ("symbolic" "PYL1"   "PBUSignore"     t)
 )

 
 ;; poly to li1, square (rcInterConImp)
 ;; implant can be toggled on/off, has no polarity
 (tcDeclareDevice
  "symbolic" "rcInterConImpClass" "PYL1sq"
  ;; Class Parameters
  ( 
   (layer1 	    "poly")
   (layer2 	    "li1")
   (viaLayer  	    "licon1")
   (encByLayer1     (TECHgetRuleWith "minEnclosure" "poly" "licon1"))
   (layer2XEnc      (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer2YEnc      (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (viaLayerImplant   "npc")
   (viaLayerImpEnc    (TECHgetRule  "licon_15"))
  )
  ;; Formal Parameters
  ( 
   (row 	    1)
   (column 	    1)
   (w   	    (TECHgetRuleWith "minWidth" "licon1"))
   (l   	    (TECHgetRuleWith "minWidth" "licon1"))
   (xPitch 	    (plus (TECHgetRuleWith "minSpacing" "licon1")
			  (TECHgetRuleWith "minWidth"   "licon1")))
   (yPitch 	    (plus (TECHgetRuleWith "minSpacing" "licon1")
			  (TECHgetRuleWith "minWidth"   "licon1")))
   (implant         t)
  )
 )

 ;; tap to li1 (rcInterConPolImp)
 ;; implant can be toggled on/off, has polarity
 (tcDeclareDevice
  "symbolic" "rcInterConPolImpClass" "TPL1"
  ;; Class Parameters
  ( 
   (layer1 	    "tap")
   (layer2 	    "li1")
   (viaLayer  	    "licon1")
   (wellLayer       "nwell")
   (wellLayerEnc    (TECHgetRuleWith "minEnclosure" "nwell" "tap"))
   (encByLayer1     (TECHgetRuleWith "minEnclosure" "tap" "licon1"))
   (layer2XEnc      0.0)
   (layer2YEnc      (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer1Implant   (list "psdm" "nsdm"))
   (layer1ImpEnc    (list (TECHgetRule "psd_5b") (TECHgetRule "nsd_5b")))
  )
  ;; Formal Parameters
  ( 
   (row 	    1)
   (column 	    1)
   (w   	    (TECHgetRuleWith "minWidth" "licon1"))
   (l   	    (TECHgetRuleWith "minWidth" "licon1"))
   (xPitch 	    (plus (TECHgetRuleWith "minSpacing" "licon1")
			  (TECHgetRuleWith "minWidth"   "licon1")))
   (yPitch 	    (plus (TECHgetRuleWith "minSpacing" "licon1")
			  (TECHgetRuleWith "minWidth"   "licon1")))
   (implant         t)
   (inWell         "FALSE")
  )
 )
 ;; we need to tell placeBus that this isn't the right contact to use
 (tfcDefineDeviceProp
  ;;(viewName  deviceName   propName      propValue)
  ("symbolic" "TPL1"   "PBUSignore"     t)
 )
 
 ;; tap to li1 (rcInterConPolImp)
 ;; implant can be toggled on/off, has polarity
 (tcDeclareDevice
  "symbolic" "rcInterConPolImpClass" "TPL1sq"
  ;; Class Parameters
  ( 
   (layer1 	    "tap")
   (layer2 	    "li1")
   (viaLayer  	    "licon1")
   (wellLayer       "nwell")
   (wellLayerEnc    (TECHgetRuleWith "minEnclosure" "nwell" "tap"))
   (encByLayer1     (TECHgetRuleWith "minEnclosure" "tap" "licon1"))
   (layer2XEnc      (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer2YEnc      (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer1Implant   (list "psdm" "nsdm"))
   (layer1ImpEnc    (list (TECHgetRule "psd_5b") (TECHgetRule "nsd_5b")))
  )
  ;; Formal Parameters
  ( 
   (row 	    1)
   (column 	    1)
   (w   	    (TECHgetRuleWith "minWidth" "licon1"))
   (l   	    (TECHgetRuleWith "minWidth" "licon1"))
   (xPitch 	    (plus (TECHgetRuleWith "minSpacing" "licon1")
			  (TECHgetRuleWith "minWidth"   "licon1")))
   (yPitch 	    (plus (TECHgetRuleWith "minSpacing" "licon1")
			  (TECHgetRuleWith "minWidth"   "licon1")))
   (implant         t)
   (inWell         "FALSE")
  )
 )
 ;; tap to li1 (rcInterConPolImp)
 ;; implant can be toggled on/off, has polarity
 (tcDeclareDevice
  "symbolic" "rcInterConPolImpClass" "TPL1_fence"
  ;; Class Parameters
  ( 
   (layer1 	    "tap")
   (layer2 	    "li1")
   (viaLayer  	    "licon1")
   (wellLayer       "nwell")
   (wellLayerEnc    (TECHgetRuleWith "minEnclosure" "nwell" "tap"))
   (encByLayer1     (TECHgetRuleWith "minEnclosure" "tap" "licon1"))
   (layer2XEnc      (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer2YEnc      (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer1Implant   (list "psdm" "nsdm"))
   (layer1ImpEnc    (list (TECHgetRule "psd_5b") (TECHgetRule "nsd_5b")))
  )
  ;; Formal Parameters
  ( 
   (row 	    1)
   (column 	    1)
   (w   	    (TECHgetRuleWith "minWidth" "licon1"))
   (l   	    (TECHgetRuleWith "minWidth" "licon1"))
   (xPitch 	    (plus (TECHgetRuleWith "minSpacing" "licon1")
			  (TECHgetRuleWith "minWidth"   "licon1")))
   (yPitch 	    (plus (TECHgetRuleWith "minSpacing" "licon1")
			  (TECHgetRuleWith "minWidth"   "licon1")))
   (implant         t)
   (inWell         "FALSE")
  )
 )
;;; centered contact class. has lots of nice features
;;; requested by design
 (tcDeclareDevice
  "symbolic" "rc3InterConCenPolImpClass" "TPL1cen"
  ;; Class Parameters
  ( 
   (wellLayer        "nwell")
   (layer1           "tap")
   (layer2           "li1")
   (layer3           "met1")
   (via1Layer        "licon1")
   (via2Layer        "mcon")
   (layer1XEncVia1   0.0)
   (layer1YEncVia1   (TECHgetRuleWith "minEnclosure" "tap" "licon1"))
   (layer1Implant    (list "psdm" "nsdm"))
   (layer1ImpEnc     (list (TECHgetRule "psd_5b") (TECHgetRule "nsd_5b")))
   (layer2XEncVia1   0.0)
   (layer2YEncVia1   (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer2XEncVia2   (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (layer2YEncVia2   (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (layer3XEncVia2   (TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
   (layer3YEncVia2   (TECHgetRuleWith "minEnclosure" "met1" "mcon"))
   (wellLayerEnc     (TECHgetRuleWith "minEnclosure" "nwell" "tap"))
   (via1Width        (TECHgetRuleWith "minWidth" "licon1"))
   (via1Length       (TECHgetRuleWith "minWidth" "licon1"))
   (via1Spacing      (TECHgetRuleWith "minSpacing" "licon1"))
   (via2Width        (TECHgetRuleWith "minWidth" "mcon"))
   (via2Length       (TECHgetRuleWith "minWidth" "mcon"))
   (via2Spacing      (TECHgetRuleWith "minSpacing" "mcon")) 
   (layer1Width      (TECHgetRuleWith "minWidth" "tap"))
   )
  ;; Formal Parameters
  ( 
   (layer1W         (TECHgetRuleWith "minWidth" "licon1"))
   (layer1L         (plus (TECHgetRuleWith "minWidth" "licon1")
			  (times 2 (TECHgetRuleWith "minEnclosure" "tap" "licon1"))))
   (inWell          "FALSE")
   )
  )
 ;; we need to tell placeBus that this isn't the right contact to use
 (tfcDefineDeviceProp
  ;;(viewName  deviceName   propName      propValue)
  ("symbolic" "TPL1cen"   "PBUSignore"     t)
 )

 ;; tap to li1 (rcInterConSPolImp)
 ;; implant can be toggled on/off, has polarity
 ;; has added control of layer2
 (tcDeclareDevice
  "symbolic" "rcInterConSPolImpClass" "TPL1a"
  ;; Class Parameters
  ( 
   (layer1 	    "tap")
   (layer2 	    "li1")
   (viaLayer  	    "licon1")
   (wellLayer       "nwell")
   (wellLayerEnc    (TECHgetRuleWith "minEnclosure" "nwell" "tap"))
   (encByLayer1     0.0)
   (layer1XEnc      0.0)
   (layer1YEnc      (TECHgetRuleWith "minEnclosure" "tap" "licon1"))
   (layer2AdjEnc    (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (viaLayerX       (TECHgetRuleWith "minWidth" "licon1"))
   (viaLayerY       (TECHgetRuleWith "minWidth" "licon1"))
   (layer1Implant   (list "psdm" "nsdm"))
   (layer1ImpEnc    (list (TECHgetRule "psd_5b") (TECHgetRule "nsd_5b")))
  )
  ;; Formal Parameters
  ( 
   (deltaw          0.0)
   (deltal          0.0)
   (rotate         "FALSE")
   (implant         t)
   (inWell         "FALSE")
  )
 )
 ;; we need to tell placeBus that this isn't the right contact to use
 (tfcDefineDeviceProp
  ;;(viewName  deviceName   propName      propValue)
  ("symbolic" "TPL1a"   "PBUSignore"     t)
 )
 
 (tcDeclareDevice
  "symbolic" "rcInterConPolImpClass" "DFL1"
  ;; Class Parameters
  ( 
   (layer1 	    "diff")
   (layer2 	    "li1")
   (viaLayer  	    "licon1")
   (wellLayer       "nwell")
   (wellLayerEnc    (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
   (layer1XEnc      (TECHgetRuleWith "minEnclosure" "diff" "licon1"))
   (layer1YEnc      (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
   (layer2XEnc      0.0)
   (layer2YEnc      (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer1Implant   (list "nsdm" "psdm"))
   (layer1ImpEnc    (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
  )
  ;; Formal Parameters
  ( 
   (row 	    1)
   (column 	    1)
   (w   	    (TECHgetRuleWith "minWidth" "licon1"))
   (l   	    (TECHgetRuleWith "minWidth" "licon1"))
   (xPitch 	    (plus (TECHgetRuleWith "minSpacing" "licon1")
			  (TECHgetRuleWith "minWidth"   "licon1")))
   (yPitch 	    (plus (TECHgetRuleWith "minSpacing" "licon1")
			  (TECHgetRuleWith "minWidth"   "licon1")))
   (implant         t)
   (inWell          "FALSE")
  )
 )
 
 ;; we need to tell placeBus that this isn't the right contact to use
 (tfcDefineDeviceProp
  ;;(viewName  deviceName   propName      propValue)
  ("symbolic" "DFL1"   "PBUSignore"     t)
 )
 ;; diff to li1 (rcInterConPolImp)
 ;; implant can be toggled on/off, has polarity
 (tcDeclareDevice
  "symbolic" "rcInterConPolImpClass" "DFL1sq"
  ;; Class Parameters
  ( 
   (layer1 	    "diff")
   (layer2 	    "li1")
   (viaLayer  	    "licon1")
   (wellLayer       "nwell")
   (wellLayerEnc    (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
   (encByLayer1     (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
   (layer2XEnc      (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer2YEnc      (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer1Implant   (list "nsdm" "psdm"))
   (layer1ImpEnc    (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
  )
  ;; Formal Parameters
  ( 
   (row 	    1)
   (column 	    1)
   (w   	    (TECHgetRuleWith "minWidth" "licon1"))
   (l   	    (TECHgetRuleWith "minWidth" "licon1"))
   (xPitch 	    (plus (TECHgetRuleWith "minSpacing" "licon1")
			  (TECHgetRuleWith "minWidth"   "licon1")))
   (yPitch 	    (plus (TECHgetRuleWith "minSpacing" "licon1")
			  (TECHgetRuleWith "minWidth"   "licon1")))
   (implant         t)
   (inWell          "FALSE")
  )
 )
 ;; li1 to met1 (rcInterCon)
 (tcDeclareDevice
  "symbolic" "rcInterConClass" "L1M1"
  ;; Class Parameters
  ( 
   (layer1 	    "li1")
   (layer2 	    "met1")
   (viaLayer  	    "mcon")
   (layer1XEnc      (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (layer1YEnc      (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (layer2XEnc      (TECHgetRuleWith "minEnclosure" "met1" "mcon"))
   (layer2YEnc      (TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
  )
  ;; Formal Parameters
  ( 
   (row 	    1)
   (column 	    1)
   (w   	    (TECHgetRuleWith "minWidth" "mcon"))
   (l   	    (TECHgetRuleWith "minWidth" "mcon"))
   (xPitch 	    (plus (TECHgetRuleWith "minSpacing" "mcon")
			  (TECHgetRuleWith "minWidth"   "mcon")))
   (yPitch 	    (plus (TECHgetRuleWith "minSpacing" "mcon")
			  (TECHgetRuleWith "minWidth"   "mcon")))
  )
 )

 ;; we need to tell placeBus that this isn't the right contact to use
 (tfcDefineDeviceProp
  ;;(viewName  deviceName   propName      propValue)
  ("symbolic" "L1M1"   "PBUSignore"     t)
 )

 ;; li1 to met1 square (rcInterCon)
 (tcDeclareDevice
  "symbolic" "rcInterConClass" "L1M1sq"
  ;; Class Parameters
  ( 
   (layer1 	    "li1")
   (layer2 	    "met1")
   (viaLayer  	    "mcon")
   (encByLayer1     (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (layer2XEnc      (TECHgetRuleWith "minEnclosure" "met1" "mcon"))
   (layer2YEnc      (TECHgetRuleWith "minEnclosure" "met1" "mcon"))
  )
  ;; Formal Parameters
  ( 
   (row 	    1)
   (column 	    1)
   (w   	    (TECHgetRuleWith "minWidth" "mcon"))
   (l   	    (TECHgetRuleWith "minWidth" "mcon"))
   (xPitch 	    (plus (TECHgetRuleWith "minSpacing" "mcon")
			  (TECHgetRuleWith "minWidth"   "mcon")))
   (yPitch 	    (plus (TECHgetRuleWith "minSpacing" "mcon")
			  (TECHgetRuleWith "minWidth"   "mcon")))
  )
 )
 ;; met1 to met2 (rcInterCon)
 (tcDeclareDevice
  "symbolic" "rcInterConClass" "M1M2"
  ;; Class Parameters
  ( 
   (layer1 	    "met1")
   (layer2 	    "met2")
   (viaLayer  	    "via")
   (layer1XEnc      (TECHgetRuleWith "minEnclosure"    "met1" "via"))
   (layer1YEnc      (TECHgetRuleWith "minEnclosureAny" "met1" "via")) 
   (layer2XEnc      (TECHgetRuleWith "minEnclosure"    "met2" "via"))
   (layer2YEnc      (TECHgetRuleWith "minEnclosureAny" "met2" "via"))
  )
  ;; Formal Parameters
  ( 
   (row 	    1)
   (column 	    1)
   (w   	    (TECHgetRuleWith "minWidth" "via"))
   (l   	    (TECHgetRuleWith "minWidth" "via"))
   (xPitch 	    (plus (TECHgetRuleWith "minSpacing" "via")
			  (TECHgetRuleWith "minWidth"   "via")))
   (yPitch 	    (plus (TECHgetRuleWith "minSpacing" "via")
			  (TECHgetRuleWith "minWidth"   "via")))
  )
 )
 ;; we need to tell placeBus that this isn't the right contact to use
 (tfcDefineDeviceProp
  ;;(viewName  deviceName   propName      propValue)
  ("symbolic" "M1M2"   "PBUSignore"     t)
 )
 
 ;; met1 to met2 sqare (rcInterCon)
 (tcDeclareDevice
  "symbolic" "rcInterConClass" "M1M2sq"
  ;; Class Parameters
  ( 
   (layer1 	    "met1")
   (layer2 	    "met2")
   (viaLayer  	    "via")
   (encByLayer1     (TECHgetRuleWith "minEnclosure" "met1" "via"))
   (layer2XEnc      (TECHgetRuleWith "minEnclosure" "met2" "via"))
   (layer2YEnc      (TECHgetRuleWith "minEnclosure" "met2" "via"))
  )
  ;; Formal Parameters
  ( 
   (row 	    1)
   (column 	    1)
   (w   	    (TECHgetRuleWith "minWidth" "via"))
   (l   	    (TECHgetRuleWith "minWidth" "via"))
   (xPitch 	    (plus (TECHgetRuleWith "minSpacing" "via")
			  (TECHgetRuleWith "minWidth"   "via")))
   (yPitch 	    (plus (TECHgetRuleWith "minSpacing" "via")
			  (TECHgetRuleWith "minWidth"   "via")))
  )
 )
 ;; diff to met1 (rcInterConEnhClass)
 (tcDeclareDevice
  "symbolic" "rcInterConEnhClass" "DFM1"
  ;; Class Parameters
  (
   (layer1         "diff")
   (layer2         "li1")
   (layer3         "met1")
   (via1Layer      "licon1")
   (via2Layer      "mcon")
   (wellLayer      "nwell")
   (wellLayerEnc    (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
   (via1Lay1XEnc    (TECHgetRuleWith "minEnclosure" "diff" "licon1"))
   (via1Lay1YEnc    (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
   (via1Lay2XEnc    0.0)
   (via1Lay2YEnc    (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (via2Lay2XEnc    (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (via2Lay2YEnc    (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (via2Lay3XEnc    (TECHgetRuleWith "minEnclosure" "met1" "mcon"))
   (via2Lay3YEnc    (TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
   (via1Width       (TECHgetRuleWith "minWidth" "licon1"))
   (via1Length      (TECHgetRuleWith "minWidth" "licon1"))
   (via2Width       (TECHgetRuleWith "minWidth" "mcon"))
   (via2Length      (TECHgetRuleWith "minWidth" "mcon"))
   (layer1Implant   (list "nsdm" "psdm"))
   (layer1ImpEnc    (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
  )

;; Formal Parameters
  (
   (via1SpaceX      (TECHgetRuleWith "minSpacing" "licon1"))
   (via1SpaceY      (TECHgetRuleWith "minSpacing" "licon1"))
   (via2SpaceX      (TECHgetRuleWith "minSpacing" "mcon"))
   (via2SpaceY      (TECHgetRuleWith "minSpacing" "mcon"))
   (row              1)
   (column           1)
   (rotateTop        t)
   (rotateMiddle     t)
   (eqEnc      "FALSE")
   (center      t)
   (inWell      "FALSE")
   (implant          t)
   (W                (plus (times 2 (TECHgetRuleWith "minEnclosure" "diff" "licon1")) 
                           (TECHgetRuleWith "minWidth" "licon1")))
   (L                (plus (times 2 (TECHgetRuleWith "minEnclosure" "diff" "licon1")) (TECHgetRuleWith "minWidth" "licon1")))
  
  )
  )
;; we need to tell placeBus that this isn't the right contact to use
(tfcDefineDeviceProp
 ;;(viewName  deviceName   propName      propValue)
 ("symbolic" "DFM1"   "PBUSignore"     t)
)

;; Declare the triple guard ring.
(tcDeclareDevice
 "symbolic" "rodTripleGuardRing" "guardRingEnh"
 ;; class parameters
 (
  (tapLayer        (list "tap" "drawing"))
  (tapWidth        (TECHgetRuleWith "minWidth" "tap"))
  (tapImpEnc       (TECHgetRule "psd_5a"))
  (nImplant        (list "nsdm" "drawing"))
  (pImplant        (list "psdm" "drawing"))
  (implantSpc      (TECHgetRuleWith "minSpacing" "nsdm"))
  (wellLayer       (list "nwell" "drawing"))
  (nwellWidth      (TECHgetRule "nwell_6"))
  (ptapWellSpc     (TECHgetRule "denmos_11"))
  (ntapWellSpc     (TECHgetRule "depmos_11"))
  (dnwellLayer     (list "dnwell" "drawing"))
  (dnwellWidth     (TECHgetRuleWith "minWidth" "dnwell"))
  (dnwWellEnc      (TECHgetRuleWith "minOverlap" "nwell" "dnwell"))
  (conLayer        (list "licon1" "drawing"))
  (conWidth        (TECHgetRuleWith "minWidth" "licon1"))
  (conLength       (TECHgetRuleWith "minWidth" "licon1"))
  (conSpacing      (TECHgetRuleWith "minSpacing" "licon1"))
  (tapConEncX      (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
  (tapConEncY      (TECHgetRuleWith "minEnclosure" "tap" "licon1"))
  (M0Layer         (list "li1" "drawing"))
  (M0conEncY       (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
  (viaLayer        (list "mcon" "drawing"))
  (viaWidth        (TECHgetRuleWith "minWidth" "mcon"))
  (viaLength       (TECHgetRuleWith "minWidth" "mcon"))
  (viaSpacing      (TECHgetRuleWith "minSpacing" "mcon"))
  (M1Layer         (list "met1" "drawing"))
  (M1viaEncY       (TECHgetRuleWith "minEnclosure" "met1" "mcon"))
  (M1viaEncX       (TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
 )
 ;; Formal parameters
 (
  (FullWell        t)
  (DeepNwell       t)
  (ORingWidth      (plus (TECHgetRuleWith "minWidth" "licon1") (times (TECHgetRuleWith "minEnclosureAny" "tap" "licon1") 2)))
  (MRingWidth      (plus (TECHgetRuleWith "minWidth" "licon1") (times (TECHgetRuleWith "minEnclosureAny" "tap" "licon1") 2)))
  (IRingWidth      (plus (TECHgetRuleWith "minWidth" "licon1") (times (TECHgetRuleWith "minEnclosureAny" "tap" "licon1") 2)))
  (Space23         (TECHgetRule "psd_5a"))
  (Space12         (TECHgetRule "psd_5a"))
  (InnerRing       "nTap")
  (RingNum         1)
  (W               5)
  (L               5)
 )
)

 ;; tap to met1 (rcInterConEnhClass)
 (tcDeclareDevice
  "symbolic" "rcInterConEnhClass" "TPM1"
  ;; Class Parameters
  (
(layer1         "tap")
   (layer2         "li1")
   (layer3         "met1")
   (via1Layer      "licon1")
   (via2Layer      "mcon")
   (wellLayer      "nwell")
   (wellLayerEnc    (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
   (via1Lay1XEnc    (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (via1Lay1YEnc    (TECHgetRuleWith "minEnclosure" "tap" "licon1"))
   (via1Lay2XEnc    0.0)
   (via1Lay2YEnc    (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (via2Lay2XEnc    (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (via2Lay2YEnc    (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (via2Lay3XEnc    (TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
   (via2Lay3YEnc    (TECHgetRuleWith "minEnclosure" "met1" "mcon"))
   (via1Width       (TECHgetRuleWith "minWidth" "licon1"))
   (via1Length      (TECHgetRuleWith "minWidth" "licon1"))
   (via2Width       (TECHgetRuleWith "minWidth" "mcon"))
   (via2Length      (TECHgetRuleWith "minWidth" "mcon"))
   (layer1Implant   (list "psdm" "nsdm"))
   (layer1ImpEnc    (list (TECHgetRule "psd_5b") (TECHgetRule "nsd_5b")))

     )
  ;; formal parameters
  (
   (via1SpaceX      (TECHgetRuleWith "minSpacing" "licon1"))
   (via1SpaceY      (TECHgetRuleWith "minSpacing" "licon1"))
   (via2SpaceX      (TECHgetRuleWith "minSpacing" "mcon"))
   (via2SpaceY      (TECHgetRuleWith "minSpacing" "mcon"))
   (row              1)
   (column           1)
   (rotateTop        t)
   (rotateMiddle     t)
   (eqEnc      "FALSE")
   (center      t)
   (inWell      "FALSE")
   (implant          t)
   (W                (plus (times 2 (TECHgetRuleWith "minEnclosure" "diff" "licon1")) 
                           (TECHgetRuleWith "minWidth" "licon1")))
   (L                (plus (times 2 (TECHgetRuleWith "minEnclosure" "diff" "licon1")) (TECHgetRuleWith "minWidth" "licon1")))

   )
 ) 

;; we need to tell placeBus that this isn't the right contact to use
(tfcDefineDeviceProp
 ;;(viewName  deviceName   propName      propValue)
 ("symbolic" "TPM1"   "PBUSignore"     t)
)


 ;; poly to met1 (rc3InterConImp)
 (tcDeclareDevice
  "symbolic" "rc3InterConImpClass" "PYM1"
  ;; Class Parameters
  (
   (layer1         "poly")
   (layer2         "li1")
   (layer3         "met1")
   (via1Layer      "licon1")
   (via2Layer      "mcon")
   (via1Implant    "npc")
   (layer1Width    (TECHgetRuleWith "minWidth"        "poly"))
   (layer2Width    (TECHgetRuleWith "minWidth"        "li1"))
   (layer3Width    (TECHgetRuleWith "minWidth"        "met1"))
   (via1Width      (TECHgetRuleWith "minWidth"        "licon1"))
   (via1Space      (TECHgetRuleWith "minSpacing"      "licon1"))
   (via2Width      (TECHgetRuleWith "minWidth"        "mcon"))
   (via2Space      (TECHgetRuleWith "minSpacing"      "mcon"))
   (layer1EncVia1  (TECHgetRuleWith "minEnclosure"    "poly" "licon1"))
   (layer2XEncVia1 (TECHgetRuleWith "minEnclosure"    "li1"  "licon1"))
   (layer2YEncVia1 (TECHgetRuleWith "minEnclosure"    "li1"  "licon1"))
   (layer2EncVia2  (TECHgetRuleWith "minEnclosure"    "li1"  "mcon"))
   (layer3XEncVia2 (TECHgetRuleWith "minEnclosure"    "met1" "mcon"))
   (layer3YEncVia2 (TECHgetRuleWith "minEnclosure"    "met1" "mcon"))
   (via1ImpEnc     (TECHgetRuleWith "minEnclosure"    "npc"  "licon1"))
  )
  ;; formal parameters
  (
   (row            1)
   (column         1)
   (implant        t)
  )
 )
 ;; poly to met1 (rc3InterCon)
 (tcDeclareDevice
  "symbolic" "rc3InterConClass" "L1M2"
  ;; Class Parameters
  (
   (layer1         "li1")
   (layer2         "met1")
   (layer3         "met2")
   (via1Layer      "mcon")
   (via2Layer      "via")
   (layer1Width    (TECHgetRuleWith "minWidth"        "li1"))
   (layer2Width    (TECHgetRuleWith "minWidth"        "met1"))
   (layer3Width    (TECHgetRuleWith "minWidth"        "met2"))
   (via1Width      (TECHgetRuleWith "minWidth"        "mcon"))
   (via1Space      (TECHgetRuleWith "minSpacing"      "mcon"))
   (via2Width      (TECHgetRuleWith "minWidth"        "via"))
   (via2Space      (TECHgetRuleWith "minSpacing"      "via"))
   (layer1EncVia1  (TECHgetRuleWith "minEnclosure"    "li1"  "mcon"))
   (layer2XEncVia1 (TECHgetRuleWith "minEnclosure"    "met1" "mcon"))
   (layer2YEncVia1 (TECHgetRuleWith "minEnclosure"    "met1" "mcon"))
   (layer2EncVia2  (TECHgetRuleWith "minEnclosure"    "met1" "via"))
   (layer3XEncVia2 (TECHgetRuleWith "minEnclosure"    "met2" "via"))
   (layer3YEncVia2 (TECHgetRuleWith "minEnclosure"    "met2" "via"))
  )
  ;; formal parameters
  (
   (row            1)
   (column         1)
  )
 )

 ;; PR poly to li1 contact
 (tcDeclareDevice 
  "symbolic" "syEnhContact" "PYL1_PR"
  ;; Class Parameters
  ( 
   (layer1 	    "poly")
   (layer2 	    "li1")
   (viaLayer 	    "licon1")
   (via1Implant     "npc")
   (via1ImpEnc      (TECHgetRuleWith "minEnclosure" "npc" "licon1"))
   (via1Width 	    (TECHgetRuleWith "minWidth" "licon1"))
   (via1Space 	    (TECHgetRuleWith "minSpacing" "licon1"))
   (layer1EncVia1   (TECHgetRuleWith "minEnclosure" "poly" "licon1"))
   (layer2XEncVia1  (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer2YEncVia1  (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (halfgrid 	    (quotient (TECHgetLayerProp "li1" 'snapGrid) 2.0))
  )
  ;; Formal Parameters
  ( 
   (row 	    1)
   (column 	    1)
   (xPitch 	    (plus (TECHgetRuleWith "minWidth" "licon1")
			  (TECHgetRuleWith "minSpacing" "licon1")))
   (yPitch 	    (plus (TECHgetRuleWith "minWidth" "licon1")
			  (TECHgetRuleWith "minSpacing" "licon1")))
   (w 		    (TECHgetRuleWith "minWidth" "licon1"))
   (l 		    (TECHgetRuleWith "minWidth" "licon1"))
  )
 )
 (tcSetDeviceProp "symbolic" "PYL1_PR" 
		  list("res" (TECHgetRule "rcl1gp") ))

 ;; PR ntap to li1 contact
 (tcDeclareDevice 
  "symbolic" "syEnhContact" "nTPL1_PR"
  ;; Class Parameters
  ( 
   (layer1 	    "tap")
   (layer2 	    "li1")
   (viaLayer 	    "licon1")
   (layer1Implant   "nsdm")
   (layer1ImpEnc    (TECHgetRule "nsd_5b"))
   (via1Width 	    (TECHgetRuleWith "minWidth" "licon1"))
   (via1Space 	    (TECHgetRuleWith "minSpacing" "licon1"))
   (layer1EncVia1   (TECHgetRuleWith "minEnclosure" "tap" "licon1"))
   (layer2XEncVia1  (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer2YEncVia1  (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (halfgrid 	    (quotient (TECHgetLayerProp "li1" 'snapGrid) 2.0))
  )
  ;; Formal Parameters
  ( 
   (row 	    1)
   (column 	    1)
   (xPitch 	    (plus (TECHgetRuleWith "minWidth" "licon1")
			  (TECHgetRuleWith "minSpacing" "licon1")))
   (yPitch 	    (plus (TECHgetRuleWith "minWidth" "licon1")
			  (TECHgetRuleWith "minSpacing" "licon1")))
   (w 		    (TECHgetRuleWith "minWidth" "licon1"))
   (l 		    (TECHgetRuleWith "minWidth" "licon1"))
  )
 )
 (tcSetDeviceProp "symbolic" "nTPL1_PR" 
		  list("res" (TECHgetRule "rcl1n") ))

 ;; PR ptap to li1 contact
 (tcDeclareDevice 
  "symbolic" "syEnhContact" "pTPL1_PR"
  ;; Class Parameters
  ( 
   (layer1 	    "tap")
   (layer2 	    "li1")
   (viaLayer 	    "licon1")
   (layer1Implant   "psdm")
   (layer1ImpEnc    (TECHgetRule "psd_5b"))
   (via1Width 	    (TECHgetRuleWith "minWidth" "licon1"))
   (via1Space 	    (TECHgetRuleWith "minSpacing" "licon1"))
   (layer1EncVia1   (TECHgetRuleWith "minEnclosure" "tap" "licon1"))
   (layer2XEncVia1  (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer2YEncVia1  (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (halfgrid 	    (quotient (TECHgetLayerProp "li1" 'snapGrid) 2.0))
  )
  ;; Formal Parameters
  ( 
   (row 	    1)
   (column 	    1)
   (xPitch 	    (plus (TECHgetRuleWith "minWidth" "licon1")
			  (TECHgetRuleWith "minSpacing" "licon1")))
   (yPitch 	    (plus (TECHgetRuleWith "minWidth" "licon1")
			  (TECHgetRuleWith "minSpacing" "licon1")))
   (w 		    (TECHgetRuleWith "minWidth" "licon1"))
   (l 		    (TECHgetRuleWith "minWidth" "licon1"))
  )
 )
 (tcSetDeviceProp "symbolic" "pTPL1_PR" 
		  list("res" (TECHgetRule "rcl1p") ))

 ;; PR ndiff to li1 contact
 (tcDeclareDevice 
  "symbolic" "syEnhContact" "nDFL1_PR"
  ;; Class Parameters
  ( 
   (layer1 	    "diff")
   (layer2 	    "li1")
   (viaLayer 	    "licon1")
   (layer1Implant   "nsdm")
   (layer1ImpEnc    (TECHgetRule "nsd_5a"))
   (via1Width 	    (TECHgetRuleWith "minWidth" "licon1"))
   (via1Space 	    (TECHgetRuleWith "minSpacing" "licon1"))
   (layer1EncVia1   (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
   (layer2XEncVia1  (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer2YEncVia1  (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (halfgrid 	    (quotient (TECHgetLayerProp "li1" 'snapGrid) 2.0))
  )
  ;; Formal Parameters
  ( 
   (row 	    1)
   (column 	    1)
   (xPitch 	    (plus (TECHgetRuleWith "minWidth" "licon1")
			  (TECHgetRuleWith "minSpacing" "licon1")))
   (yPitch 	    (plus (TECHgetRuleWith "minWidth" "licon1")
			  (TECHgetRuleWith "minSpacing" "licon1")))
   (w 		    (TECHgetRuleWith "minWidth" "licon1"))
   (l 		    (TECHgetRuleWith "minWidth" "licon1"))
  )
 )
 (tcSetDeviceProp "symbolic" "nDFL1_PR" 
		  list("res" (TECHgetRule "rcl1n") ))

 ;; PR pdiff to li1 contact
 (tcDeclareDevice 
  "symbolic" "syEnhContact" "pDFL1_PR"
  ;; Class Parameters
  ( 
   (layer1 	    "diff")
   (layer2 	    "li1")
    (viaLayer 	    "licon1")
   (layer1Implant   "psdm")
   (layer1ImpEnc    (TECHgetRule "psd_5a"))
   (via1Width 	    (TECHgetRuleWith "minWidth" "licon1"))
   (via1Space 	    (TECHgetRuleWith "minSpacing" "licon1"))
   (layer1EncVia1   (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
   (layer2XEncVia1  (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer2YEncVia1  (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (halfgrid 	    (quotient (TECHgetLayerProp "li1" 'snapGrid) 2.0))
  )
  ;; Formal Parameters
  ( 
   (row 	    1)
   (column 	    1)
   (xPitch 	    (plus (TECHgetRuleWith "minWidth" "licon1")
			  (TECHgetRuleWith "minSpacing" "licon1")))
   (yPitch 	    (plus (TECHgetRuleWith "minWidth" "licon1")
			  (TECHgetRuleWith "minSpacing" "licon1")))
   (w 		    (TECHgetRuleWith "minWidth" "licon1"))
   (l 		    (TECHgetRuleWith "minWidth" "licon1"))
  )
 )
 (tcSetDeviceProp "symbolic" "pDFL1_PR" 
		  list("res" (TECHgetRule "rcl1p") ))

 ;; PR li1 to met1 contact
 (tcDeclareDevice 
  "symbolic" "syEnhContact" "L1M1_PR"
  ;; Class Parameters
  ( 
   (layer1 	    "li1")
   (layer2 	    "met1")
   (viaLayer 	    "mcon")
   (via1Width 	    (TECHgetRuleWith "minWidth" "mcon"))
   (via1Space 	    (TECHgetRuleWith "minSpacing" "mcon"))
   (layer1EncVia1   (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (layer2XEncVia1  (TECHgetRuleWith "minEnclosure" "met1" "mcon"))
   (layer2YEncVia1  (TECHgetRuleWith "minEnclosure" "met1" "mcon"))
   (halfgrid 	    (quotient (TECHgetLayerProp "li1" 'snapGrid) 2.0))
  )
  ;; Formal Parameters
  ( 
   (row 	    1)
   (column 	    1)
   (xPitch 	    (plus (TECHgetRuleWith "minWidth" "mcon")
			  (TECHgetRuleWith "minSpacing" "mcon")))
   (yPitch 	    (plus (TECHgetRuleWith "minWidth" "mcon")
			  (TECHgetRuleWith "minSpacing" "mcon")))
   (w 		    (TECHgetRuleWith "minWidth" "mcon"))
   (l 		    (TECHgetRuleWith "minWidth" "mcon"))
  )
 )
 (tcSetDeviceProp "symbolic" "L1M1_PR" 
		  list("res" (TECHgetRule "rcm1l1") ))

 ;; PR met1 to met2 contact
 (tcDeclareDevice 
  "symbolic" "syEnhContact" "M1M2_PR"
  ;; Class Parameters
  ( 
   (layer1 	    "met1")
   (layer2 	    "met2")
   (viaLayer 	    "via")
   (via1Width 	    (TECHgetRuleWith "minWidth"        "via"))
   (via1Space 	    (TECHgetRuleWith "minSpacing"      "via"))
   (layer1EncVia1   (TECHgetRuleWith "minEnclosure"    "met1" "via"))
   (layer2XEncVia1  (TECHgetRuleWith "minEnclosure"    "met2" "via"))
   (layer2YEncVia1  (TECHgetRuleWith "minEnclosure"    "met2" "via"))
   (halfgrid 	    (quotient (TECHgetLayerProp "met1" 'snapGrid) 2.0))
  )
  ;; Formal Parameters
  ( 
   (row 	    1)
   (column 	    1)
   (xPitch 	    (plus (TECHgetRuleWith "minWidth" "via")
			  (TECHgetRuleWith "minSpacing" "via")))
   (yPitch 	    (plus (TECHgetRuleWith "minWidth" "via")
			  (TECHgetRuleWith "minSpacing" "via")))
   (w 		    (TECHgetRuleWith "minWidth" "via"))
   (l 		    (TECHgetRuleWith "minWidth" "via"))
  )
 )
 (tcSetDeviceProp "symbolic" "M1M2_PR" 
		  list("res" (TECHgetRule "rcvia") ))

 ;; Diffusion and tap contact to li1 for single source.
 (tcDeclareDevice
  "symbolic" "enSstrap3PolImpClass" "DFTPL1s"
  (
   ;; Class Parameters
   (diff 	        "diff")
   (tap 	        "tap")
   (layer2 	        "li1")
   (via1Layer 	        "licon1")
   (wellLayer           "nwell")
   (diffWidth 	        (TECHgetRuleWith "minWidth" "diff"))
   (tapWidth 	        (TECHgetRuleWith "minWidth" "tap"))
   (tapWidthButtingDiff (TECHgetRuleWith "minWidthButting" "tap" "diff"))
   (minSrc		(TECHgetRuleWith "minGateSpacing" "poly" "tap"))
   (layer2Width         (TECHgetRuleWith "minWidth" "li1"))
   (via1Width 	        (TECHgetRuleWith "minWidth" "licon1"))
   (via1Space 	        (TECHgetRuleWith "minSpacing" "licon1"))
   (diffYEncVia         (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
   (diffLEncVia         (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
   (diffREncVia         0.0)
   (sideTapXInEncVia    (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (sideTapXOutEncVia   (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (sideTapYEncVia      (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (layer2XEncVia       0.0)
   (layer2YEncVia       (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (halfDiffusionGrid   (quotient (TECHgetLayerProp "diff" 'snapGrid) 2.0))
   (diffImplant         (list "nsdm" "psdm") )
   (diffImpEnc          (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
;;   (diffImpEnc          (list 
;;			 (plus (TECHgetRule "nsd_5a") (TECHgetLayerProp "nsdm" 'snapGrid))
;;			 (plus (TECHgetRule "psd_5a") (TECHgetLayerProp "psdm" 'snapGrid))))
   (tapImplant          (list "psdm" "nsdm"))
   (tapImpEnc           (list (TECHgetRule "psd_5b") (TECHgetRule "nsd_5b")))
;;   (tapImpEnc           (list 
;;			 (plus (TECHgetRule "psd_5a") (TECHgetLayerProp "psdm" 'snapGrid))
;;			 (plus (TECHgetRule "nsd_5a") (TECHgetLayerProp "nsdm" 'snapGrid))))
   (wellLayerDiffEnc    (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
   (wellLayerTapEnc     (TECHgetRuleWith "minEnclosure" "nwell" "tap"))
  )
  ;; Formal Parameters
  (
   (w 		    (plus (times 2.0 (TECHgetRuleWith "minEnclosureAdj" 
						      "diff" "licon1"))
			  (TECHgetRuleWith "minWidth" "licon1")))
   (topEndTap 	    "FALSE")
   (bottomEndTap    "FALSE")
   (tryToStagger    "FALSE")
   (implant         t)
   (inWell          "FALSE")
  )
 )
 (tcSetDeviceProp "symbolic" "DFTPL1s" 
		  list("res" (TECHgetRule "rcl1p") ))

 ;; Diffusion and tap contact to li1 for single source,wide (diffusion).
 (tcDeclareDevice
  "symbolic" "enSstrap3PolImpClass" "DFTPL1sw"
  (
   ;; Class Parameters
   (diff 	        "diff")
   (tap 	        "tap")
   (layer2 	        "li1")
   (via1Layer 	        "licon1")
   (wellLayer           "nwell")
   (diffWidth 	        (TECHgetRuleWith "minWidth" "diff"))
   (tapWidth 	        (TECHgetRuleWith "minWidth" "tap"))
   (tapWidthButtingDiff (TECHgetRuleWith "minWidthButting" "tap" "diff"))
   (minSrc		(TECHgetRuleWith "minGateSpacing" "poly" "tap"))
   (layer2Width         (TECHgetRuleWith "minWidth" "li1"))
   (via1Width 	        (TECHgetRuleWith "minWidth" "licon1"))
   (via1Space 	        (TECHgetRuleWith "minSpacing" "licon1"))
   (diffYEncVia         (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
   (diffLEncVia         (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
   (diffREncVia         (plus (TECHgetRuleWith "minSpacing" "licon1")
			      (minus (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
			      ))
   (sideTapXInEncVia    (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (sideTapXOutEncVia   (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (sideTapYEncVia      (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (layer2XEncVia       0.0)
   (layer2YEncVia       (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (halfDiffusionGrid   (quotient (TECHgetLayerProp "diff" 'snapGrid) 2.0))
   (diffImplant         (list "nsdm" "psdm") )
   (diffImpEnc          (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
;;   (diffImpEnc          (list 
;;			 (plus (TECHgetRule "nsd_5a") (TECHgetLayerProp "nsdm" 'snapGrid))
;;			 (plus (TECHgetRule "psd_5a") (TECHgetLayerProp "psdm" 'snapGrid))))
   (tapImplant          (list "psdm" "nsdm"))
   (tapImpEnc           (list (TECHgetRule "psd_5a") (TECHgetRule "nsd_5a")))
;;   (tapImpEnc           (list 
;;			 (plus (TECHgetRule "psd_5a") (TECHgetLayerProp "psdm" 'snapGrid))
;;			 (plus (TECHgetRule "nsd_5a") (TECHgetLayerProp "nsdm" 'snapGrid))))
   (wellLayerDiffEnc    (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
   (wellLayerTapEnc     (TECHgetRuleWith "minEnclosure" "nwell" "tap"))
  )
  ;; Formal Parameters
  (
   (w 		    (plus (times 2.0 (TECHgetRuleWith "minEnclosureAdj" 
						      "diff" "licon1"))
			  (TECHgetRuleWith "minWidth" "licon1")))
   (topEndTap 	    "FALSE")
   (bottomEndTap    "FALSE")
   (tryToStagger    "FALSE")
   (implant         t)
   (inWell          "FALSE")
  )
 )
 (tcSetDeviceProp "symbolic" "DFTPL1sw" 
		  list("res" (TECHgetRule "rcl1p") ))


 ;; Diffusion and tap contact to met1 for single source.
 (tcDeclareDevice
  "symbolic" "enSstrap3PolImpClass" "DFTPM1s"
  (
   ;; Class Parameters
   (diff        	"diff")
   (tap         	"tap")
   (layer2      	"li1")
   (layer3      	"met1")
   (via1Layer   	"licon1")
   (via2Layer   	"mcon")
   (wellLayer           "nwell")
   (diffWidth   	(TECHgetRuleWith "minWidth" "diff"))
   (tapWidth    	(TECHgetRuleWith "minWidth" "tap"))
   (tapWidthButtingDiff (TECHgetRuleWith "minWidthButting" "tap" "diff"))
   (minSrc		(TECHgetRuleWith "minGateSpacing" "poly" "tap"))
   (layer2Width 	(TECHgetRuleWith "minWidth" "li1"))
   (layer3Width 	(TECHgetRuleWith "minWidth" "met1"))
   (via1Width   	(TECHgetRuleWith "minWidth" "licon1"))
   (via2Width   	(TECHgetRuleWith "minWidth" "mcon"))
   (via1Space   	(TECHgetRuleWith "minSpacing" "licon1"))
   (via2Space   	(TECHgetRuleWith "minSpacing" "mcon"))
   (diffYEncVia 	(TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
   (diffLEncVia 	(TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
   (diffREncVia         0.0)
   (sideTapXInEncVia    (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (sideTapXOutEncVia   (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (sideTapYEncVia      (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (layer2XEncVia       0.0)
   (layer2YEncVia       (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer2XEncVia2 	(TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (layer2YEncVia2 	(TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (layer3XEncVia2 	(TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
   (layer3YEncVia2 	(TECHgetRuleWith "minEnclosure" "met1" "mcon"))
   (halfDiffusionGrid   (quotient (TECHgetLayerProp "diff" 'snapGrid) 2.0))
   (diffImplant         (list "nsdm" "psdm") )
   (diffImpEnc          (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (tapImplant          (list "psdm" "nsdm"))
   (tapImpEnc           (list (TECHgetRule "psd_5a") (TECHgetRule "nsd_5a")))
   (wellLayerDiffEnc    (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
   (wellLayerTapEnc     (TECHgetRuleWith "minEnclosure" "nwell" "tap"))
  )
  ;; Formal Parameters
  (
   (w 		    (plus (times 2.0 (TECHgetRuleWith "minEnclosureAdj" 
						      "diff" "licon1"))
			  (TECHgetRuleWith "minWidth" "licon1")))
   (topEndTap 	    "FALSE")
   (bottomEndTap    "FALSE")
   (tryToStagger    "FALSE")
   (implant         t)
   (inWell          "FALSE")
  )
 )
 (tcSetDeviceProp "symbolic" "DFTPM1s" 
		  list("res" (TECHgetRule "rcp") ))

 ;; Diffusion and tap contact to met1 for single source for wide transistors.
 (tcDeclareDevice
  "symbolic" "enSstrap3PolImpClass" "DFTPM1sw"
  (
   ;; Class Parameters
   (diff        	"diff")
   (tap         	"tap")
   (layer2      	"li1")
   (layer3      	"met1")
   (via1Layer   	"licon1")
   (via2Layer   	"mcon")
   (wellLayer           "nwell")
   (diffWidth   	(TECHgetRuleWith "minWidth" "diff"))
   (tapWidth    	(TECHgetRuleWith "minWidth" "tap"))
   (tapWidthButtingDiff (TECHgetRuleWith "minWidthButting" "tap" "diff"))
   (minSrc		(TECHgetRuleWith "minGateSpacing" "poly" "tap"))
   (layer2Width 	(TECHgetRuleWith "minWidth" "li1"))
   (layer3Width 	(TECHgetRuleWith "minWidth" "met1"))
   (via1Width   	(TECHgetRuleWith "minWidth" "licon1"))
   (via2Width   	(TECHgetRuleWith "minWidth" "mcon"))
   (via1Space   	(TECHgetRuleWith "minSpacing" "licon1"))
   (via2Space   	(TECHgetRuleWith "minSpacing" "mcon"))
   (diffYEncVia 	(TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
   (diffLEncVia 	(TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
   (diffREncVia         (plus (TECHgetRuleWith "minSpacing" "licon1")
			      (minus (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
			      ))
   (sideTapXInEncVia    (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (sideTapXOutEncVia   (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (sideTapYEncVia      (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (layer2XEncVia       0.0)
   (layer2YEncVia       (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer2XEncVia2 	(TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (layer2YEncVia2 	(TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (layer3XEncVia2 	(TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
   (layer3YEncVia2 	(TECHgetRuleWith "minEnclosure" "met1" "mcon"))
   (tapSpacePoly        (TECHgetRuleWith "minSpacing" "poly" "tap"))
   (halfDiffusionGrid   (quotient (TECHgetLayerProp "diff" 'snapGrid) 2.0))
   (diffImplant         (list "nsdm" "psdm") )
   (diffImpEnc          (list  (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (tapImplant          (list "psdm" "nsdm"))
   (tapImpEnc           (list (TECHgetRule "psd_5a") (TECHgetRule "nsd_5a")))
   (wellLayerDiffEnc    (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
   (wellLayerTapEnc     (TECHgetRuleWith "minEnclosure" "nwell" "tap"))
  )
  ;; Formal Parameters
  (
   (w 		    (plus (times 2.0 (TECHgetRuleWith "minEnclosure" 
						      "tap" "licon1"))
			  (TECHgetRuleWith "minWidth" "licon1")))
   (topEndTap 	    "FALSE")
   (bottomEndTap    "FALSE")
   (tryToStagger    "FALSE")
   (implant         t)
   (inWell          "FALSE")
  )
 )
 (tcSetDeviceProp "symbolic" "DFTPM1sw" 
		  list("res" (TECHgetRule "rcp") ))


 (tcDeclareDevice
  "symbolic" "enhStrap3PolImpClass" "DFTPM1s2enh"
  ;; Class Parameters
  ( 
   (wellLayer        "nwell")
   (diffLayer        "diff")
   (tapLayer         "tap")
   (via1Layer        "licon1")
   (layer2 	     "li1")
   (via2Layer        "mcon")
   (layer3           "met1")
   (tapImplant       (list "psdm" "nsdm"))
   (tapImpEnc        (list (TECHgetRule "psd_5b") (TECHgetRule "nsd_5b")))
   (diffImplant      (list "nsdm" "psdm"))
   (diffImpEnc       (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (diffXEncVia1In   (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
   (diffXEncVia1Out  (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
   (diffYEncVia1     (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
   (tapXEncVia1      (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (tapYEncVia1      (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (tapMinNarExt     (TECHgetRule "difftap_7"))
   (layer2XEncVia1   0.0)
   (layer2YEncVia1   (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer2XEncVia2   (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (layer2YEncVia2   (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (layer3XEncVia2   (TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
   (layer3YEncVia2   (TECHgetRuleWith "minEnclosure" "met1" "mcon"))
   (wellLayerDiffEnc (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
   (wellLayerTapEnc  (TECHgetRuleWith "minEnclosure" "nwell" "tap"))
   (diffSourceWidth  (TECHgetRuleWith "minGateSpacing" "poly" "tap"))
   (tapWidthBetween  (TECHgetRuleWith "minWidthBetween" "tap" "diff"))
   (wellWidth        (TECHgetRuleWith "minWidth"     "nwell"))
   (via1Width        (TECHgetRuleWith "minWidth"     "licon1"))
   (via1Length       (TECHgetRuleWith "minWidth"     "licon1"))
   (via1Space        (TECHgetRuleWith "minSpacing"   "licon1"))
   (via2Width        (TECHgetRuleWith "minWidth"     "mcon"))
   (via2Length       (TECHgetRuleWith "minWidth"     "mcon"))
   (via2Space        (TECHgetRuleWith "minSpacing"   "mcon"))
   )
  ;; Formal Parameters
  ( 
   (tranWidthL      (max (plus (times 2 (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
			       (TECHgetRuleWith "minWidth" "licon1"))
			 (TECHgetRuleWith "minGateWidth" "diff")
			 ))
   (tranWidthR      (max (plus (times 2 (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
			       (TECHgetRuleWith "minWidth" "licon1"))
			 (TECHgetRuleWith "minGateWidth" "diff")
			 ))
   (extraDiffL       (max 0.0
			  (difference (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1")
				      (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))))
   (extraDiffR       (max 0.0
			  (difference (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1")
				      (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))))
   (extraTapL        0.0)
   (extraTapR        0.0)
   (implant          t)
   (inWell           "FALSE")
   (noLayer3         "FALSE")
   )
  )
 (tcSetDeviceProp "symbolic" "DFTPM1s2enh" 
		  list("res" (TECHgetRule "rcp") ))

 ;; Diffusion and tap contact to li1 for single source.
 (tcDeclareDevice
  "symbolic" "enDstrap3PolImpClass" "DFTPL1s2"
  (
   ;; Class Parameters
   (diff        	"diff")
   (tap         	"tap")
   (layer2      	"li1")
   (via1Layer   	"licon1")
   (diffWidth   	(TECHgetRuleWith "minWidth" "diff"))
   (tapWidth    	(TECHgetRuleWith "minWidth" "tap"))
   (tapWidthButtingDiff (TECHgetRuleWith "minWidthButting" "tap" "diff"))
   (tapWidthBetweenDiff (TECHgetRuleWith "minWidthBetween" "tap" "diff"))
   (layer2Width 	(TECHgetRuleWith "minWidth" "li1"))
   (via1Width   	(TECHgetRuleWith "minWidth" "licon1"))
   (via1Space   	(TECHgetRuleWith "minSpacing" "licon1"))
   (diffYEncVia 	(TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
   (diffXEncVia 	(TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
   (diffXOutEncVia      (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
   (centerTapXEncVia    (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (centerTapYEncVia    (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (layer2XEncVia       0.0)
   (layer2YEncVia       (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (tapSpaceGate 	(TECHgetRuleWith "minGateSpacing" "poly" "tap"))
   (tapSpacePoly 	(TECHgetRuleWith "minSpacing" "poly" "tap"))
   (halfDiffusionGrid   (quotient (TECHgetLayerProp "diff" 'snapGrid) 2.0))
   (diffImplant         (list "nsdm" "psdm"))
   (tapImplant          (list "psdm" "nsdm"))
   (diffImpEnc          (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (tapImpEnc           (list (TECHgetRule "psd_5b") (TECHgetRule "nsd_5b")))
  )
  ;; Formal Parameters
  (
   (w 		    (plus (times 2.0 (TECHgetRuleWith "minEnclosureAdj"
						      "diff" "licon1"))
			  (TECHgetRuleWith "minWidth" "licon1")))
   (topEndTap       "FALSE")
   (bottomEndTap    "FALSE")
   (centerTap       t)
  )
 )
 (tcSetDeviceProp "symbolic" "DFTPL1s2" 
		  list("res" (TECHgetRule "rcl1p") ))


 ;; Diffusion and tap contact to met1 for single source.
 (tcDeclareDevice
  "symbolic" "enDstrap3PolImpClass" "DFTPM1s2"
  (
   ;; Class Parameters
   (diff        	"diff")
   (tap         	"tap")
   (layer2      	"li1")
   (layer3              "met1")
   (via1Layer   	"licon1")
   (via2Layer           "mcon")
   (diffWidth   	(TECHgetRuleWith "minWidth" "diff"))
   (tapWidth    	(TECHgetRuleWith "minWidth" "tap"))
   (tapWidthButtingDiff (TECHgetRuleWith "minWidthButting" "tap" "diff"))
   (tapWidthBetweenDiff (TECHgetRuleWith "minWidthBetween" "tap" "diff"))
   (layer2Width 	(TECHgetRuleWith "minWidth" "li1"))
   (layer3Width 	(TECHgetRuleWith "minWidth" "met1"))
   (via1Width   	(TECHgetRuleWith "minWidth" "licon1"))
   (via1Space   	(TECHgetRuleWith "minSpacing" "licon1"))
   (via2Width   	(TECHgetRuleWith "minWidth" "mcon"))
   (via2Space   	(TECHgetRuleWith "minSpacing" "mcon"))
   (diffYEncVia 	(TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
   (diffXEncVia 	(TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
   (diffXOutEncVia      (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
   (centerTapXEncVia    (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (centerTapYEncVia    (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (layer2XEncVia       0.0)
   (layer2YEncVia       (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer2XEncVia2      (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (layer2YEncVia2      (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (layer3XEncVia2      (TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
   (layer3YEncVia2      (TECHgetRuleWith "minEnclosure" "met1" "mcon"))
   (tapSpaceGate 	(TECHgetRuleWith "minGateSpacing" "poly" "tap"))
   (tapSpacePoly 	(TECHgetRuleWith "minSpacing" "poly" "tap"))
   (halfDiffusionGrid   (quotient (TECHgetLayerProp "diff" 'snapGrid) 2.0))
   (diffImplant         (list "nsdm" "psdm"))
   (tapImplant          (list "psdm" "nsdm"))
   (diffImpEnc          (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (tapImplant          (list "psdm" "nsdm"))
   (tapImpEnc           (list (TECHgetRule "psd_5a") (TECHgetRule "nsd_5a")))
  )
  ;; Formal Parameters
  (
   (w 		    (plus (times 2.0 (TECHgetRuleWith "minEnclosureAdj"
						      "diff" "licon1"))
			  (TECHgetRuleWith "minWidth" "licon1")))
   (topEndTap       "FALSE")
   (bottomEndTap    "FALSE")
   (centerTap       t)
  )
 )
 (tcSetDeviceProp "symbolic" "DFTPM1s2" 
		  list("res" (TECHgetRule "rcl1p") ))

 
 (tcDeclareDevice
  "symbolic" "drainContactPolImpClass" "DFL1sd"
  ;; Class Parameters
  (
   (diffLayer 	    (list "diff" "drawing"))
   (layer2 	    (list "li1" "drawing"))
   (viaLayer 	    (list "licon1" "drawing"))
   (wellLayer       "nwell")
   (viaWidth 	    (TECHgetRuleWith "minWidth" "licon1"))
   (viaSpace 	    (TECHgetRuleWith "minSpacing" "licon1"))
   (diffREnc 	    (TECHgetRuleWith "minEnclosure" "diff" "licon1"))
   (diffLEnc 	    (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
   (diffYEnc 	    (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
   (layer2REnc 	    0.0)
   (layer2LEnc 	    0.0)
   (layer2YEnc 	    (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer2Width     (TECHgetRuleWith "minWidth" "li1"))
   (diffImplant     (list "nsdm" "psdm"))
   (diffImpXLEnc    (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (diffImpXREnc    (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (diffImpYEnc     (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (wellLayerEnc    (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
  )
  ;; Formal Parameters
  (
   (w 		    (plus (times 2.0 (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
			  (TECHgetRuleWith "minWidth" "licon1")))
   (implant         t)
   (inWell          "FALSE")
  )
 )
 (tcSetDeviceProp "symbolic" "DFL1sd" 
		  list("res" (TECHgetRule "rcl1p") ))


 (tcDeclareDevice
  "symbolic" "drainContact3PolImpClass" "hvDFM1sd"
  ;; Class Parameters
  (
   (diffLayer 	    (list "diff" "drawing"))
   (layer2 	    (list "li1" "drawing"))
   (layer3 	    (list "met1" "drawing"))
   (via1Layer 	    (list "licon1" "drawing"))
   (wellLayer       "nwell")
   (via1Width 	    (TECHgetRuleWith "minWidth" "licon1"))
   (via1Space 	    (TECHgetRuleWith "minSpacing" "licon1"))
   (via2Layer 	    (list "mcon" "drawing"))
   (via2Width 	    (TECHgetRuleWith "minWidth" "mcon"))
   (via2Space 	    (TECHgetRuleWith "minSpacing" "mcon"))
   (diffREncVia1    (TECHgetRuleWith "minEnclosure" "diff" "licon1"))
   (diffLEncVia1    (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
   (diffYEncVia1    (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
   (layer2XEncVia1  0.0)
   (layer2YEncVia1  (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer2XEncVia2  (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (layer2YEncVia2  (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (layer3LEncVia2  (TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
   (layer3REncVia2  (TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
   (layer3YEncVia2  (TECHgetRuleWith "minEnclosure" "met1" "mcon"))
   (layer2Width     (TECHgetRuleWith "minWidth" "li1"))
   (layer3Width     (TECHgetRuleWith "minWidth" "met1"))
   (centerVia2 	    "TRUE")
   (via2Grid 	    (TECHgetLayerProp "mcon" 'snapGrid))
   (diffImplant     (list "nsdm" "psdm") )
   (diffImpXLEnc    (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (diffImpXREnc    (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (diffImpYEnc     (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (wellLayerEnc    (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
  )
  ;; Formal Parameters
  (
   (w 		    (plus (times 2.0 (TECHgetRuleWith "minEnclosureAdj" 
						      "diff" "licon1"))
			  (TECHgetRuleWith "minWidth" "licon1")))
   (implant         t)
   (inWell          "FALSE")
  )
 ) 
(tcSetDeviceProp "symbolic" "hvDFM1sd"
		  list("res" (TECHgetRule "rcp") ))


 (tcDeclareDevice
  "symbolic" "drainContactPolImpClass" "DFL1sdf"
  ;; Class Parameters
  (
   (diffLayer 	    (list "diff" "drawing"))
   (layer2 	    (list "li1" "drawing"))
   (viaLayer 	    (list "licon1" "drawing"))
   (wellLayer       "nwell")
   (viaWidth 	    (TECHgetRuleWith "minWidth" "licon1"))
   (viaSpace 	    (TECHgetRuleWith "minSpacing" "licon1"))
   (diffREnc 	    (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
   (diffLEnc 	    (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
   (diffYEnc 	    (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
   (layer2REnc 	    0.0)
   (layer2LEnc 	    0.0)
   (layer2YEnc 	    (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer2Width     (TECHgetRuleWith "minWidth" "li1"))
   (diffImplant     (list "nsdm" "psdm") )
   (diffImpXLEnc    (list 0.0 0.0))
   (diffImpXREnc    (list 0.0 0.0))
   (diffImpYEnc     (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (wellLayerEnc    (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
  )
  ;; Formal Parameters
  (
   (w 		    (plus (times 2.0 (TECHgetRuleWith "minEnclosureAdj" 
						      "diff" "licon1"))
			  (TECHgetRuleWith "minWidth" "licon1")))
   (implant         t)
   (inWell          "FALSE")
  )
 )
 (tcSetDeviceProp "symbolic" "DFL1sdf" 
		  list("res" (TECHgetRule "rcl1p") ))


 (tcDeclareDevice
  "symbolic" "drainContactPolImpClass" "DFL1sd2"
  ;; Class Parameters
  (
   (diffLayer 	    (list "diff" "drawing"))
   (layer2 	    (list "li1" "drawing"))
   (viaLayer 	    (list "licon1" "drawing"))
   (wellLayer       (list "nwell" "drawing"))
   (viaWidth 	    (TECHgetRuleWith "minWidth" "licon1"))
   (viaSpace 	    (TECHgetRuleWith "minSpacing" "licon1"))
   (diffREnc 	    (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
   (diffLEnc 	    (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
   (diffYEnc 	    (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
   (layer2REnc 	    0.0)
   (layer2LEnc 	    0.0)
   (layer2YEnc 	    (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer2Width     (TECHgetRuleWith "minWidth" "li1"))
   (diffImplant     (list "nsdm" "psdm"))
   (diffImpXLEnc    (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (diffImpXREnc    (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (diffImpYEnc     (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (wellLayerEnc    (TECHgetRuleWith "minEnclosure" "nwell" "diff"))	
  )
  ;; Formal Parameters
  (
   (w 		    (plus (times 2.0 (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
			  (TECHgetRuleWith "minWidth" "licon1")))
   (implant         t)
   (inWell          "FALSE")
  )
 )
 (tcSetDeviceProp "symbolic" "DFL1sd2" 
		  list("res" (TECHgetRule "rcl1p") ))



 (tcDeclareDevice
  "symbolic" "drainContactPolImpClass" "TPL1s"
  ;; Class Parameters
  (
   (diffLayer 	    (list "tap" "drawing"))
   (layer2 	    (list "li1" "drawing"))
   (viaLayer 	    (list "licon1" "drawing"))
   (wellLayer       "nwell")
   (viaWidth 	    (TECHgetRuleWith "minWidth" "licon1"))
   (viaSpace 	    (TECHgetRuleWith "minSpacing" "licon1"))
;   (diffREnc 	    0.0)
   (diffREnc        (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (diffLEnc 	    (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
   (diffYEnc 	    (TECHgetRuleWith "minEnclosure" "tap" "licon1"))
;   (diffYEnc        0.0)
   (layer2REnc 	    0.0)
   (layer2LEnc 	    0.0)
   (layer2YEnc 	    (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer2Width     (TECHgetRuleWith "minWidth" "li1"))
   (diffImplant     (list "psdm" "nsdm") )
   (diffImpXLEnc    (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (diffImpXREnc    (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (diffImpYEnc     (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (wellLayerEnc    (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
  )
  ;; Formal Parameters
  (
   (w 		    (plus (times 2.0 (TECHgetRuleWith "minEnclosure"
						      "tap" "licon1"))
			  (TECHgetRuleWith "minWidth" "licon1")))
   (implant         t)
   (inWell          "FALSE")
  )
 )
 (tcSetDeviceProp "symbolic" "TPL1s" 
		  list("res" (TECHgetRule "rcl1p") ))

 (tcDeclareDevice
  "symbolic" "drainContact3PolImpClass" "TPM1s"
  ;; Class Parameters
  (
   (diffLayer 	    (list "tap" "drawing"))
   (layer2 	    (list "li1" "drawing"))
   (layer3 	    (list "met1" "drawing"))
   (wellLayer       "nwell")
   (via1Layer 	    (list "licon1" "drawing"))
   (via1Width 	    (TECHgetRuleWith "minWidth" "licon1"))
   (via1Space 	    (TECHgetRuleWith "minSpacing" "licon1"))
   (via2Layer 	    (list "mcon" "drawing"))
   (via2Width 	    (TECHgetRuleWith "minWidth" "mcon"))
   (via2Space 	    (TECHgetRuleWith "minSpacing" "mcon"))
   (diffREncVia1    (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (diffLEncVia1    (max (TECHgetRuleWith "minGateSpacing" "poly" "licon1")
			 (TECHgetRuleWith "minEnclosureAny" "tap" "licon1")))
   (diffYEncVia1    (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1")) ; really used for tap
   (layer2XEncVia1  0.0)
   (layer2YEncVia1  (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer2XEncVia2  (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (layer2YEncVia2  (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (layer3LEncVia2  (TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
   (layer3REncVia2  (TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
   (layer3YEncVia2  (TECHgetRuleWith "minEnclosure" "met1" "mcon"))
   (layer2Width     (TECHgetRuleWith "minWidth" "li1"))
   (layer3Width     (TECHgetRuleWith "minWidth" "met1"))
   (diffImplant     (list "psdm" "nsdm") )
   (diffImpXLEnc    (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (diffImpXREnc    (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (diffImpYEnc     (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (wellLayerEnc    (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
  )
  ;; Formal Parameters
  (
   (w 		    (plus (times 2.0 (TECHgetRuleWith "minEnclosureAdj" 
						      "diff" "licon1")) ; really used for tap
			  (TECHgetRuleWith "minWidth" "licon1")))
   (implant         t)
   (inWell          "FALSE")
  )
 )
 (tcSetDeviceProp "symbolic" "TPM1s" 
		  list("res" (TECHgetRule "rcp") ))

 (tcDeclareDevice
  "symbolic" "drainContact3PolImpClass" "DFM1sd"
  ;; Class Parameters
  (
   (diffLayer 	    (list "diff" "drawing"))
   (layer2 	    (list "li1" "drawing"))
   (layer3 	    (list "met1" "drawing"))
   (via1Layer 	    (list "licon1" "drawing"))
   (wellLayer       "nwell")
   (via1Width 	    (TECHgetRuleWith "minWidth" "licon1"))
   (via1Space 	    (TECHgetRuleWith "minSpacing" "licon1"))
   (via2Layer 	    (list "mcon" "drawing"))
   (via2Width 	    (TECHgetRuleWith "minWidth" "mcon"))
   (via2Space 	    (TECHgetRuleWith "minSpacing" "mcon"))
   (diffREncVia1    (TECHgetRuleWith "minEnclosure" "diff" "licon1"))
   (diffLEncVia1    (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
   (diffYEncVia1    (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
   (layer2XEncVia1  0.0)
   (layer2YEncVia1  (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer2XEncVia2  (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (layer2YEncVia2  (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (layer3LEncVia2  (TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
   (layer3REncVia2  (TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
   (layer3YEncVia2  (TECHgetRuleWith "minEnclosure" "met1" "mcon"))
   (layer2Width     (TECHgetRuleWith "minWidth" "li1"))
   (layer3Width     (TECHgetRuleWith "minWidth" "met1"))
   (centerVia2 	    "TRUE")
   (via2Grid 	    (TECHgetLayerProp "mcon" 'snapGrid))
   (diffImplant     (list "nsdm" "psdm") )
   (diffImpXLEnc    (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (diffImpXREnc    (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (diffImpYEnc     (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (wellLayerEnc    (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
  )
  ;; Formal Parameters
  (
   (w 		    (plus (times 2.0 (TECHgetRuleWith "minEnclosureAdj" 
						      "diff" "licon1"))
			  (TECHgetRuleWith "minWidth" "licon1")))
   (implant         t)
   (inWell          "FALSE")
  )
 ) 
(tcSetDeviceProp "symbolic" "DFM1sd" 
		  list("res" (TECHgetRule "rcp") ))


(tcDeclareDevice
 "symbolic" "drainContact3PolImpClass" "DFM1sd2"
 ;; Class Parameters
 (
  (diffLayer 	    (list "diff" "drawing"))
  (layer2 	    (list "li1" "drawing"))
  (layer3 	    (list "met1" "drawing"))
  (via1Layer 	    (list "licon1" "drawing"))
  (wellLayer       "nwell")
  (via1Width 	    (TECHgetRuleWith "minWidth" "licon1"))
  (via1Space 	    (TECHgetRuleWith "minSpacing" "licon1"))
  (via2Layer 	    (list "mcon" "drawing"))
  (via2Width 	    (TECHgetRuleWith "minWidth" "mcon"))
  (via2Space 	    (TECHgetRuleWith "minSpacing" "mcon"))
  (diffREncVia1    (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
  (diffLEncVia1    (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
  (diffYEncVia1    (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
  (layer2XEncVia1  0.0)
  (layer2YEncVia1  (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
  (layer2XEncVia2  (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
  (layer2YEncVia2  (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
  (layer3LEncVia2  (TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
  (layer3REncVia2  (TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
  (layer3YEncVia2  (TECHgetRuleWith "minEnclosure" "met1" "mcon"))
  (layer2Width     (TECHgetRuleWith "minWidth" "li1"))
  (layer3Width     (TECHgetRuleWith "minWidth" "met1"))
  (centerVia2 	    "TRUE")
  (via2Grid 	    (TECHgetLayerProp "mcon" 'snapGrid))
  (diffImplant     (list "nsdm" "psdm") )
  (diffImpXLEnc    (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
  (diffImpXREnc    (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
  (diffImpYEnc     (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
  (wellLayerEnc    (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
  )
  ;; Formal Parameters
 (
  (w 		  (plus (times 2.0 (TECHgetRuleWith "minEnclosureAdj" 
						    "diff" "licon1"))
			(TECHgetRuleWith "minWidth" "licon1")))
  (implant        t)
  (inWell         "FALSE")
  )
 )
(tcSetDeviceProp "symbolic" "DFM1sd2" 
		 list("res" (TECHgetRule "rcp") ))

;;;met1-li contact for drain/source
(tcDeclareDevice
 "symbolic" "drainContact3PolImpClass" "hvDFM1sd2"
 ;; Class Parameters
 (
  (diffLayer       (list "diff" "drawing"))
  (layer2          (list "li1" "drawing"))
  (layer3          (list "met1" "drawing"))
  (via1Layer       (list "licon1" "drawing"))
  (wellLayer       "nwell")
  (via1Width       (TECHgetRuleWith "minWidth" "licon1"))
  (via1Space       (TECHgetRuleWith "minSpacing" "licon1"))
  (via2Layer       (list "mcon" "drawing"))
  (via2Width       (TECHgetRuleWith "minWidth" "mcon"))
  (via2Space       (TECHgetRuleWith "minSpacing" "mcon"))
  ;in c8q-3r we have an explicit rule for enclosure of licon1 by diff (licon.5a). Using that 
  ;for diffREncVia1 & diffLEncVia1.
  (diffREncVia1    (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
  (diffLEncVia1    (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
  (diffYEncVia1    (TECHgetRuleWith "minEnclosureAdj"  "diff" "licon1"))
  (layer2XEncVia1  0.0)
  (layer2YEncVia1  (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
  (layer2XEncVia2  (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
  (layer2YEncVia2  (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
  (layer3LEncVia2  (TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
  (layer3REncVia2  (TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
  (layer3YEncVia2  (TECHgetRuleWith "minEnclosure" "met1" "mcon"))
  (layer2Width     (TECHgetRuleWith "minWidth" "li1"))
  (layer3Width     (TECHgetRuleWith "minWidth" "met1"))
  (centerVia2      "TRUE")
  (via2Grid        (TECHgetLayerProp "mcon" 'snapGrid))
  (diffImplant     (list "nsdm" "psdm") )
  (diffImpXLEnc    (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
  (diffImpXREnc    (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
  (diffImpYEnc     (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
  (wellLayerEnc    (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
 )
 ;; Formal Parameters
 (
  (w                (max (TECHgetRuleWith "minWidthDiff" "hvi")
                         (plus (times 2.0 (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
                          (TECHgetRuleWith "minWidth" "licon1"))))
  (implant         t)
  (inWell          "FALSE")
 )
)


;;;hv contact double (for shared src) strap
(tcDeclareDevice
  "symbolic" "enDstrap3PolImpClass" "hvDFTPL1s2"
  (
   ;; Class Parameters
   (diff        	"diff")
   (tap         	"tap")
   (layer2      	"li1")
   (via1Layer   	"licon1")
   (diffWidth   	(TECHgetRuleWith "minWidthDiff" "hvi"))
   (tapWidth    	(TECHgetRuleWith "minWidthInside" "tap" "hvi"))
   (tapWidthButtingDiff (TECHgetRuleWith "minWidthInside" "tap" "hvi"))
   (tapWidthBetweenDiff (TECHgetRuleWith "minWidthInside" "tap" "hvi"))
   (layer2Width 	(TECHgetRuleWith "minWidth" "li1"))
   (via1Width   	(TECHgetRuleWith "minWidth" "licon1"))
   (via1Space   	(TECHgetRuleWith "minSpacing" "licon1"))
   (diffYEncVia 	(TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
   (diffXEncVia 	(TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
   (diffXOutEncVia      (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
   (centerTapXEncVia    (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (centerTapYEncVia    (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (layer2XEncVia       0.0)
   (layer2YEncVia       (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (tapSpaceGate 	(TECHgetRuleWith "minGateSpacing" "poly" "tap"))
   (tapSpacePoly 	(TECHgetRuleWith "minSpacing" "poly" "tap"))
   (halfDiffusionGrid   (quotient (TECHgetLayerProp "diff" 'snapGrid) 2.0))
   (diffImplant         (list "nsdm" "psdm"))
   (tapImplant          (list "psdm" "nsdm"))
   (diffImpEnc          (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (tapImpEnc           (list (TECHgetRule "psd_5a") (TECHgetRule "nsd_5a")))
  )
  ;; Formal Parameters
  (
   (w 		    (max (TECHgetRuleWith "minWidthDiff" "hvi")
                         (plus (times 2.0 (TECHgetRuleWith "minEnclosure" "tap" "licon1"))
                          (TECHgetRuleWith "minWidth" "licon1"))))
   (topEndTap       "FALSE")
   (bottomEndTap    "FALSE")
   (centerTap       t)
  )
 )
 (tcSetDeviceProp "symbolic" "hvDFTPL1s2" 
		  list("res" (TECHgetRule "rcl1p") ))


(tcDeclareDevice
  "symbolic" "enDstrap3PolImpClass" "hvDFTPM1s2"
  (
   ;; Class Parameters
   (diff        	"diff")
   (tap         	"tap")
   (layer2      	"li1")
   (layer3              "met1")
   (via1Layer   	"licon1")
   (via2Layer           "mcon")
   (diffWidth   	(TECHgetRuleWith "minWidthDiff" "hvi"))
   (tapWidth    	(TECHgetRuleWith "minWidthInside" "tap" "hvi"))
   (tapWidthButtingDiff (TECHgetRuleWith "minWidthInside" "tap" "hvi"))
   (tapWidthBetweenDiff (TECHgetRuleWith "minWidthInside" "tap" "hvi"))
   (layer2Width 	(TECHgetRuleWith "minWidth" "li1"))
   (layer3Width         (TECHgetRuleWith "minWidth" "met1"))
   (via1Width   	(TECHgetRuleWith "minWidth" "licon1"))
   (via1Space   	(TECHgetRuleWith "minSpacing" "licon1"))
   (via2Width           (TECHgetRuleWith "minWidth" "mcon"))
   (via2Space           (TECHgetRuleWith "minSpacing" "mcon"))
   (diffYEncVia 	(TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
   (diffXEncVia 	(TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
   (diffXOutEncVia      (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
   (centerTapXEncVia    (TECHgetRuleWith "minEnclosure"    "tap" "licon1"))
   (centerTapYEncVia    (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (layer2XEncVia       0.0)
   (layer2YEncVia       (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer2XEncVia2      (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (layer2YEncVia2      (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (layer3XEncVia2      (TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
   (layer3YEncVia2      (TECHgetRuleWith "minEnclosure" "met1" "mcon"))
   (tapSpaceGate 	(TECHgetRuleWith "minGateSpacing" "poly" "tap"))
   (tapSpacePoly 	(TECHgetRuleWith "minSpacing" "poly" "tap"))
   (halfDiffusionGrid   (quotient (TECHgetLayerProp "diff" 'snapGrid) 2.0))
   (diffImplant         (list "nsdm" "psdm"))
   (tapImplant          (list "psdm" "nsdm"))
   (diffImpEnc          (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (tapImpEnc           (list (TECHgetRule "psd_5a") (TECHgetRule "nsd_5a")))
  )
  ;; Formal Parameters
  (
   (w 		    (max (TECHgetRuleWith "minWidthDiff" "hvi")
                         (plus (times 2.0 (TECHgetRuleWith "minEnclosure" "tap" "licon1"))
                          (TECHgetRuleWith "minWidth" "licon1"))))
   (topEndTap       "FALSE")
   (bottomEndTap    "FALSE")
   (centerTap       t)
  )
 )
 (tcSetDeviceProp "symbolic" "hvDFTPM1s2" 
		  list("res" (TECHgetRule "rcl1p") ))


(tcDeclareDevice
 "symbolic" "enSstrap3PolImpClass" "hvDFTPM1s"
 (
  ;; Class Parameters
  (centerVia1           t)
  (centerVia2           t)
  (diff         "diff")
  (tap          "tap")
  (layer2       "li1")
  (layer3       "met1")
  (via1Layer    "licon1")
  (via2Layer    "mcon")
  (wellLayer    "nwell")
  (diffWidth           (TECHgetRuleWith "minWidthDiff" "hvi"))
  (tapWidth            (TECHgetRuleWith "minWidth" "tap"))
  (tapWidthButtingDiff (TECHgetRuleWith "minWidthInside" "tap"       "hvi"))
  (minSrc              (TECHgetRuleWith "minGateSpacing" "poly" "tap"))
  (layer2Width         (TECHgetRuleWith "minWidth" "li1"))
  (layer3Width         (TECHgetRuleWith "minWidth" "met1"))
  (via1Width           (TECHgetRuleWith "minWidth" "licon1"))
  (via2Width           (TECHgetRuleWith "minWidth" "mcon"))
  (via1Space           (TECHgetRuleWith "minSpacing" "licon1"))
  (via2Space           (TECHgetRuleWith "minSpacing" "mcon"))
  (diffYEncVia         (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
  (diffLEncVia         (TECHgetRuleWith "minGateSpacing"  "poly" "licon1")) 
  (diffREncVia         (TECHgetRuleWith "minEnclosure"    "diff" "licon1"))

  ; preserve monSpace tapLicon-diffLicon
  (sideTapXInEncVia    (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
  (minSpaceDiffTapVia1 (TECHgetRuleWith "minSpacing"     "licon1"))
  (sideTapXOutEncVia   0.0)
  (sideTapYEncVia      (TECHgetRuleWith "minEnclosure" "tap" "licon1"))
  (layer2XEncVia       0.0)
  (layer2YEncVia       (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
  (layer2XEncVia2      (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
  (layer2YEncVia2      (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
  (layer3XEncVia2      (TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
  (layer3YEncVia2      (TECHgetRuleWith "minEnclosure" "met1" "mcon"))
  (halfDiffusionGrid   (quotient (TECHgetLayerProp "diff" 'snapGrid) 2.0))
  (diffImplant         (list "nsdm" "psdm") )
  (tapImplant          (list "psdm" "nsdm"))
  (diffImpEnc          (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
  (tapImpEnc           (list (TECHgetRule "psd_5a") (TECHgetRule "nsd_5a")))
  (wellLayerDiffEnc    (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
  (wellLayerTapEnc     (TECHgetRuleWith "minEnclosure" "nwell" "tap"))
 )
 ;; Formal Parameters
 (
  (w                (max (TECHgetRuleWith "minWidthDiff" "hvi")
                         (plus (times 2.0 (TECHgetRuleWith "minEnclosure" "tap" "licon1"))
                          (TECHgetRuleWith "minWidth" "licon1"))))
  (topEndTap        "FALSE")
  (bottomEndTap    "FALSE")
  (tryToStagger    "FALSE")
  (implant         t)
  (inWell          "FALSE")
 )
)


(tcDeclareDevice
 "symbolic" "drainContactPolImpClass" "hvDFL1sd"
 ;; Class Parameters
 (
  (diffLayer        (list "diff" "drawing"))
  (layer2           (list "li1" "drawing"))
  (viaLayer         (list "licon1" "drawing"))
  (wellLayer       "nwell")
  (viaWidth         (TECHgetRuleWith "minWidth" "licon1"))
  (viaSpace         (TECHgetRuleWith "minSpacing" "licon1"))
  (diffREnc         (TECHgetRuleWith "minEnclosure" "diff" "licon1"))
  (diffLEnc         (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
  (diffYEnc         (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
  ;; center li1 over licon
  (layer2REnc       (quotient (difference (TECHgetRuleWith "minWidth" "li1") 
                                          (TECHgetRuleWith "minWidth" "licon1")) 2))

  (layer2LEnc       (quotient (difference (TECHgetRuleWith "minWidth" "li1")
                                          (TECHgetRuleWith "minWidth" "licon1")) 2))
  (layer2YEnc       (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
  (layer2Width      (TECHgetRuleWith "minWidth" "li1"))
  (diffImplant      (list "nsdm" "psdm"))
  (diffImpXLEnc    (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
  (diffImpXREnc    (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
  (diffImpYEnc     (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
  (wellLayerEnc    (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
 )
 ;; Formal Parameters
 (
  (w                (max (TECHgetRuleWith "minWidthDiff" "hvi")
                         (plus (times 2.0 (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
                          (TECHgetRuleWith "minWidth" "licon1"))))
  (implant         t)
  (inWell          "FALSE")
 )
)


(tcDeclareDevice
 "symbolic" "drainContactPolImpClass" "hvDFL1sd2"
 ;; Class Parameters
 (
  (diffLayer        (list "diff" "drawing"))
  (layer2           (list "li1" "drawing"))
  (viaLayer         (list "licon1" "drawing"))
  (wellLayer       "nwell")
  (viaWidth         (TECHgetRuleWith "minWidth" "licon1"))
  (viaSpace         (TECHgetRuleWith "minSpacing" "licon1"))
  (diffREnc         (TECHgetRuleWith "minGateSpacing" "poly" "licon1")) 
  (diffLEnc         (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
  (diffYEnc         (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
  ;; center li1 over licon
  (layer2REnc       (quotient (difference (TECHgetRuleWith "minWidth" "li1") 
                                          (TECHgetRuleWith "minWidth" "licon1")) 2))

  (layer2LEnc       (quotient (difference (TECHgetRuleWith "minWidth" "li1")
                                          (TECHgetRuleWith "minWidth" "licon1")) 2))
  (layer2YEnc       (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
  (layer2Width      (TECHgetRuleWith "minWidth" "li1"))
  (diffImplant      (list "nsdm" "psdm") )
  (diffImpXLEnc    (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
  (diffImpXREnc    (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
  (diffImpYEnc     (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
  (wellLayerEnc    (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
 )
 ;; Formal Parameters
 (
  (w                (max (TECHgetRuleWith "minWidthDiff" "hvi")
                         (plus (times 2.0 (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
                          (TECHgetRuleWith "minWidth" "licon1"))))
  (implant         t)
  (inWell          "FALSE")
 )
)



(tcDeclareDevice
 "symbolic" "enSstrap3PolImpClass" "hvDFTPL1s"
 (
  ;; Class Parameters
  (diff                 "diff")
  (tap                  "tap")
  (layer2               "li1")
  (via1Layer            "licon1")
  (wellLayer            "nwell")
  (diffWidth            (TECHgetRuleWith "minWidthDiff" "hvi"))
  (tapWidth             (TECHgetRuleWith "minWidth" "tap"))
  (tapWidthButtingDiff  (TECHgetRuleWith "minWidthInside" "tap"       "hvi"))
  (minSrc               (TECHgetRuleWith "minGateSpacing" "poly" "tap"))
  (layer2Width          (TECHgetRuleWith "minWidth" "li1"))
  (via1Width            (TECHgetRuleWith "minWidth" "licon1"))
  (via1Space            (TECHgetRuleWith "minSpacing" "licon1"))
  (diffYEncVia          (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
  ;;(diffLEncVia          (TECHgetRuleWith "minEnclosure" "diff" "licon1"))
  ;;(diffREncVia          (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
  (diffLEncVia          (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
  (diffREncVia          (TECHgetRuleWith "minEnclosure" "diff" "licon1"))
  ; preserve monSpace tapLicon-diffLicon
  (sideTapXInEncVia     (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
  (minSpaceDiffTapVia1  (TECHgetRuleWith "minSpacing"     "licon1"))                   
  (sideTapXOutEncVia    0.0)
  (sideTapYEncVia       (TECHgetRuleWith "minEnclosure" "tap" "licon1"))
  (layer2XEncVia        0.0)
  (layer2YEncVia        (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
  (halfDiffusionGrid    (quotient (TECHgetLayerProp "diff" 'snapGrid) 2.0))
  (diffImplant          (list "nsdm" "psdm"))
  (tapImplant           (list "psdm" "nsdm"))
  (diffImpEnc          (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
  (tapImpEnc           (list (TECHgetRule "psd_5a") (TECHgetRule "nsd_5a")))
  (wellLayerDiffEnc     (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
  (wellLayerTapEnc      (TECHgetRuleWith "minEnclosure" "nwell" "tap"))
 )
 ;; Formal Parameters
 (
  (w                (max (TECHgetRuleWith "minWidthDiff" "hvi")
                         (plus (times 2.0 (TECHgetRuleWith "minEnclosure" "tap" "licon1"))
                          (TECHgetRuleWith "minWidth" "licon1"))))
  (topEndTap        "FALSE")
  (bottomEndTap    "FALSE")
  (tryToStagger    "FALSE")
  (implant         t)
  (inWell          "FALSE")
 )
)


;; ;; n-drain transistor
 (tcDeclareDevice
  "symbolic" "drainOnlyClass" "nDrainOnly"
  ;; Class parameters
  (
   (diffLayer 	    "diff")
   (gateLayer 	    "poly")
   (tapLayer 	    "tap")
   (diffExt 	    (TECHgetRuleWith "minExtension" "diff" "poly"))
   (tapExt 	    (TECHgetRuleWith "minWidthButting" "tap" "diff"))
  )
  ;; Formal parameters
  (
   (drainContact    "DFM1sd")
   (sourceContact   "TPM1s")
   (polyExt 	    (TECHgetRuleWith "minExtension" "poly" "diff"))
   (srcOffset 	    0.0)
   (drnOffset 	    0.0)
   (w 		    (max (TECHgetRuleWith "minGateWidth" "diff")
			 (plus (times 2.0 (TECHgetRuleWith "minEnclosure" 
						      "diff" "licon1"))
				(TECHgetRuleWith "minWidth" "licon1"))))
   (l 		    (TECHgetRuleWith "minWidth" "poly"))
   (tapSource 	    t)
  )
 )

;; ;; p-drain transistor
 (tcDeclareDevice
  "symbolic" "drainOnlyClass" "pDrainOnly"
  ;; Class parameters
  (	
   (diffLayer 	    "diff")
   (gateLayer 	    "poly")
   (tapLayer 	    "tap")
   (wellLayer 	    "nwell")
   (diffExt 	    (TECHgetRuleWith "minExtension" "diff" "poly"))
   (tapExt 	    (TECHgetRuleWith "minWidthButting" "tap" "diff"))
   (wellEncDiff     (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
   (wellEncTap 	    (TECHgetRuleWith "minEnclosure" "nwell" "tap"))
  )
  ;; Formal parameters
  (
   (drainContact    "DFM1sd")
   (sourceContact   "TPM1s")
   (srcOffset 	    0.0)
   (drnOffset 	    0.0)
   (polyExt 	    (TECHgetRuleWith "minExtension" "poly" "diff"))
   (w 		    (max (TECHgetRuleWith "minGateWidth" "diff")
			 (plus (times 2.0 (TECHgetRuleWith "minEnclosure" 
						      "diff" "licon1"))
			  	(TECHgetRuleWith "minWidth" "licon1"))))
   (l 		    (TECHgetRuleWith "minWidth" "poly"))
   (tapSource 	    t)
  )
 )


;;;;;;;;;;;;;;;;;
;; Transistors ;;
;;;;;;;;;;;;;;;;;

;; Declare the n-Transistor (nmos 1.8V)
(tcDeclareDevice "symbolic" "mNormTranImpClass" "nTran"
  ;; Class parameters
  ((diffLayer       (list "diff" "drawing"))
   (gateLayer       (list "poly" "drawing"))
   (diffExt         (TECHgetRuleWith "minExtension" "diff" "poly"))
   (labelWidth      0.15)
   (diffImplant     (list "nsdm" "drawing"))
   (diffImpEnc      (TECHgetRule "nsd_5a"))
;;   (diffImpEnc      (plus (TECHgetRule "nsd_5a") (TECHgetLayerProp "nsdm" 'snapGrid)))
   (via1MinSpace    (TECHgetRuleWith "minSpacing" "licon1"))
   (via2MinSpace    (TECHgetRuleWith "minSpacing" "mcon"))
   (layer2MinSpace  (TECHgetRuleWith "minSpacing" "li1"))
   (layer3MinSpace  (TECHgetRuleWith "minSpacing" "met1"))
   (bckCompatibleOffSet t)
  )
  ;; Formal parameters
  ((sourceFirst     t)
   (sharedDrain     "DFL1sd2")
   (sharedSource    "DFL1sd2")
   (lastContact     "DFL1sd")
   (firstContact    "DFL1sd")
   (gateExt         (TECHgetRuleWith "minExtension" "poly" "diff"))
   (srcOffset       0.0)
   (drnOffset       0.0)
   (m               1)
   (l               (TECHgetRuleWith "minWidth" "poly"))
   (w               (TECHgetRuleWith "minGateWidth" "diff"))
   (implant         t)
   (idLayerChoices  (list "none" "lvtn"))  ;;; idlayerChoices should have "none"
   (idLayer         "none")               ;;; idLayer should default to "none"
   (idEncDiff       "FALSE")
   (idEncXL         (TECHgetRule "lvtn_4b"))
   (idEncXR         (TECHgetRule "lvtn_4b"))
   (idEncY          (TECHgetRule "lvtn_4b"))
  )
)
;;The following defines a set of device (nTran/pTran) properties to map the 
;;idLayerChoice to its corresponding model. This will be used by the DL* functions 
;;to generate the required discrete W/L CDFs
(tfcDefineDeviceProp
 ;;(viewName  deviceName   propName      propValue)
 ("symbolic" "nTran" "discreteWLs" t)  ;;Declares that the nTran is a discrete device
 ("symbolic" "nTran" "noneModels" "nshort")  ;;Maps an nTran without masks to the nshort discreteWLs in TECHrep.
 ("symbolic" "nTran" "lvtnModels" "nlowvt")  ;;Maps an nTran with lvtn mask to the nlowvt discreteWLs in TECHrep.
)

;; Declare the p-Transistor (pmos 1.8V)
(tcDeclareDevice "symbolic" "mNormTranImpClass" "pTran"
  ;; Class parameters
  ((diffLayer        (list "diff" "drawing"))
   (gateLayer        (list "poly" "drawing"))
   (wellLayer        (list "nwell" "drawing"))
   (diffExt          (TECHgetRuleWith "minExtension" "diff" "poly"))
   (wellEncDiff      (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
   (labelWidth       0.15)
   (diffImplant      (list "psdm" "drawing"))
;;   (diffImpEnc       (plus (TECHgetRule "psd_5a") (TECHgetLayerProp "psdm" 'snapGrid)))
   (diffImpEnc       (TECHgetRule "psd_5a"))
   (via1MinSpace     (TECHgetRuleWith "minSpacing" "licon1"))
   (via2MinSpace     (TECHgetRuleWith "minSpacing" "mcon"))
   (layer2MinSpace   (TECHgetRuleWith "minSpacing" "li1"))
   (layer3MinSpace   (TECHgetRuleWith "minSpacing" "met1"))
   (bckCompatibleOffSet t)
  )
  ;; Formal parameters
  ((sourceFirst     t)
   (sharedDrain     "DFL1sd2")
   (sharedSource    "DFL1sd2")
   (lastContact     "DFL1sd")
   (firstContact    "DFL1sd")
   (gateExt         (TECHgetRuleWith "minExtension" "poly" "diff"))
   (srcOffset       0.0)
   (drnOffset       0.0)
   (m               1)
   (l               (TECHgetRuleWith "minWidth" "poly"))
   (w               (TECHgetRuleWith "minGateWidth" "diff"))
   (implant         t)
   (idLayerChoices  (list "none" "hvtp" "lvtn")) ;;; idlayerChoices should have "none"
   (idLayer         "none")               ;;; idLayer should default to "none"
   (idEncDiff       "FALSE")
   (idEncXL         (TECHgetRule "hvtp_3"))
   (idEncXR         (TECHgetRule "hvtp_3"))
   (idEncY          (TECHgetRule "hvtp_3"))
  )
)
;;The following defines a set of device (nTran/pTran) properties to map the 
;;idLayerChoice to its corresponding model. This will be used by the DL* functions 
;;to generate the required discrete W/L CDFs
(tfcDefineDeviceProp
 ;;(viewName  deviceName   propName      propValue)
 ("symbolic" "pTran" "discreteWLs" t)  ;;Declares that the pTran is a discrete device
 ("symbolic" "pTran" "noneModels" "pshort")  ;;Maps a pTran without masks to the pshort discreteWLs in TECHrep.
 ("symbolic" "pTran" "hvtpModels" "phighvt") ;;Maps a pTran with hvtp mask to the phighvt discreteWLs in TECHrep.
 ("symbolic" "pTran" "lvtnModels" "plowvt")  ;;Maps a pTran with lvtn mask to the nlowvt discreteWLs in TECHrep.
)

;;;; Declare the nHV-Transistor (hvnmos 5/10.5V)
(tcDeclareDevice "symbolic" "mNormTranImpClass" "hvnTran"
  ;; Class parameters
  ((diffLayer       (list "diff" "drawing"))
   (gateLayer       (list "poly" "drawing"))
   (diffExt         (TECHgetRuleWith "minExtension" "diff" "poly"))
   (labelWidth      0.15)
   (hvLayer         (list "hvi" "drawing"))
   (hvEnclosure     (TECHgetRuleWith "minEnclosureHV" "diff" "tap"))
   (diffImplant     (list "nsdm" "drawing"))
   (diffImpEnc      (TECHgetRule "nsd_5a"))
;;   (diffImpEnc      (plus (TECHgetRule "nsd_5a") (TECHgetLayerProp "nsdm" 'snapGrid)))
   (via1MinSpace    (TECHgetRuleWith "minSpacing" "licon1"))
   (via2MinSpace    (TECHgetRuleWith "minSpacing" "mcon"))
   (layer2MinSpace  (TECHgetRuleWith "minSpacing" "li1"))
   (layer3MinSpace  (TECHgetRuleWith "minSpacing" "met1"))
   (bckCompatibleOffSet nil)
  )
  ;; Formal parameters
  (
   (sourceFirst     t)
   (sharedDrain     "hvDFL1sd2")
   (sharedSource    "hvDFL1sd2")
   (lastContact     "hvDFTPL1s")
   (firstContact    "hvDFTPL1s")
   (gateExt         (TECHgetRuleWith "minExtension" "poly" "diff"))
   (srcOffset       0.0)
   (drnOffset       0.0)
   (m                1)
   (l               (TECHgetRuleWith "minWidthPolyP" "hvi"))
   (w               (TECHgetRuleWith "minGateWidth" "diff"))
   (implant         t)
   (idLayerChoices  (list "none" "lvtn"))  ;;; idlayerChoices should have "none"
   (idLayer         "none")               ;;; idLayer should default to "none"
   (idEncDiff       "FALSE")
   (idEncXL         (TECHgetRule "lvtn_4b"))
   (idEncXR         (TECHgetRule "lvtn_4b"))
   (idEncY          (TECHgetRule "lvtn_4b"))
  )
)
(tfcDefineDeviceProp
 ;;(viewName  deviceName   propName      propValue)
 ("symbolic" "hvnTran" "discreteWLs"    t)  ;;Declares that the hvnTran is a discrete device
 ("symbolic" "hvnTran" "noneModels" "nhv")  ;;Maps an hvnTran without masks to the nhv discreteWLs in TECHrep.
 ("symbolic" "hvnTran" "lvtnModels" "nhvnative ntvnative")  ;;This defines the models that use the same mask.
)

;; Declare the pHV-Transistor (hvpmos 5/10.5V)
(tcDeclareDevice "symbolic" "mNormTranImpClass" "hvpTran"
  ;; Class parameters
  ((diffLayer        (list "diff" "drawing"))
   (gateLayer        (list "poly" "drawing"))
   (wellLayer        (list "nwell" "drawing"))
   (diffExt          (TECHgetRuleWith "minExtension" "diff" "poly"))
   (hvLayer          (list "hvi" "drawing"))
   (wellEncDiff      (TECHgetRuleWith "minEnclosureHV" "diff" "nwell"))  
   (wellEncTap       (TECHgetRuleWith "minEnclosureHV" "tap" "nwell"))
   (hvEnclosure      0.0)
   (labelWidth       0.15)
   (diffImplant      (list "psdm" "drawing"))
   (diffImpEnc       (TECHgetRule     "psd_5a"))
;;   (diffImpEnc       (plus (TECHgetRule "psd_5a") (TECHgetLayerProp "psdm" 'snapGrid)))
   (via1MinSpace     (TECHgetRuleWith "minSpacing" "licon1"))
   (via2MinSpace     (TECHgetRuleWith "minSpacing" "mcon"))
   (layer2MinSpace   (TECHgetRuleWith "minSpacing" "li1"))
   (layer3MinSpace   (TECHgetRuleWith "minSpacing" "met1"))
  (bckCompatibleOffSet nil)
  )
  ;; Formal parameters
  ((sourceFirst     t)
   (sharedDrain     "hvDFL1sd2")
   (sharedSource    "hvDFL1sd2")
   (lastContact     "hvDFTPL1s")
   (firstContact    "hvDFTPL1s")
   (gateExt         (TECHgetRuleWith "minExtension" "poly" "diff"))
   (srcOffset       0.0)
   (drnOffset       0.0)
   (m               1)
   (l               (TECHgetRuleWith "minWidthPolyP" "hvi"))
   (w               (TECHgetRuleWith "minGateWidth" "diff"))
   (implant         t)
   (idLayerChoices  (list "none")) ;;; idlayerChoices should have "none"
   (idLayer         "none")        ;;; idLayer should default to "none"
   (idEncDiff       "FALSE")
  )
)
(tfcDefineDeviceProp
 ;;(viewName  deviceName   propName      propValue)
 ("symbolic" "hvpTran" "discreteWLs"    t) ;;Declares that the hvpTran is a discrete device
 ("symbolic" "hvpTran" "noneModels" "phv")
)

;; Declare the nfet (nmos)
(tcDeclareDevice "symbolic" "mModelFetClass" "nfet"
  ;; Class parameters
  ((diffLayer       (list "diff" "drawing"))
   (gateLayer       (list "poly" "drawing"))
   (diffExt         (TECHgetRuleWith "minExtension" "diff" "poly"))
   (labelWidth      0.15)
   (diffImplant     (list "nsdm" "drawing"))
   (diffImpEnc      (TECHgetRule "nsd_5a"))
   (via1MinSpace    (TECHgetRuleWith "minSpacing" "licon1"))
   (via2MinSpace    (TECHgetRuleWith "minSpacing" "mcon"))
   (layer2MinSpace  (TECHgetRuleWith "minSpacing" "li1"))
   (layer3MinSpace  (TECHgetRuleWith "minSpacing" "met1"))
   (implant         t) 
   (tapLayer        (list "tap" "drawing"))    
   (tapImplant      (list "psdm" "drawing"))  
   (tapImpEnc       (TECHgetRule  "psd_5b"))  
   (lodEnabled      t)
   )
  ;; Formal parameters
  ((sourceFirst     t)
   (sharedDrain     "DFL1sd2")
   (sharedSource    "DFL1sd2")
   (lastContact     "DFL1sd")
   (firstContact    "DFL1sd")
   (gateExt         (TECHgetRuleWith "minExtension" "poly" "diff"))
   (srcOffset       0.0)
   (drnOffset       0.0)
   (m               1)
   (l               (TECHgetRuleWith "minWidth" "poly"))
   (w               (TECHgetRuleWith "minGateWidth" "diff"))
   (hspiceModel     "nshort")
   (gatetogateSpacing (TECHgetRuleWith "minSpacing" "poly"))
   (LODContactMapSStrapped   (list         (list  "DFTPL1s"   "DFL1sd2")
					   (list  "DFTPM1s"   "DFM1sd2")
					   (list  "hvDFTPL1s" "hvDFL1sd2")
					   (list  "hvDFTPM1s" "hvDFM1sd2")
					   (list  "DFTPL1sw"  "DFL1sd2")
					   (list  "DFTPM1sw"  "DFM1sd2")
					   ))
   (LODContactMapNDStrapped  (list         (list  "DFL1sd"     "DFL1sd2")
					   (list  "DFL1sdf"    "DFL1sd2")
					   (list  "DFL1sd2"    "DFL1sd2")
					   (list  "DFM1sd"     "DFM1sd2")
					   (list  "DFM1sd2"    "DFM1sd2")
					   (list  "hvDFL1sd"   "hvDFL1sd2")
					   (list  "hvDFM1sd"   "hvDFM1sd2")  
					   (list  "hvDFM1sd2"  "hvDFM1sd2")
					   (list  "hvDFL1sd2"  "hvDFL1sd2")   
					   
					   (list  "DFTPM1s2"   "DFM1sd")
					   (list  "DFTPL1s2"   "DFL1sd")
					   (list  "hvDFTPL1s2" "hvDFL1sd")
					   (list  "hvDFTPM1s2" "hvDFM1sd")
					   ))
   (noContactLOD      (TECHgetRuleWith "minExtension" "diff" "poly"))
   )
  )
(tfcDefineDeviceProp
 ;;(viewName  deviceName   propName      propValue)
 ("symbolic" "nfet" "discreteWLs" t)  ;;Declares that the nfet is a discrete device
 ("symbolic" "nfet" "enableLOD"   t)  ;;Enables LOD parameters on nfet
 )

; Declare the p-Transistor (pmos 1.8V)
(tcDeclareDevice "symbolic" "mModelFetClass" "pfet"
;; Class parameters
  ((diffLayer        (list "diff" "drawing"))
   (gateLayer        (list "poly" "drawing"))
   (wellLayer        (list "nwell" "drawing"))
   (diffExt          (TECHgetRuleWith "minExtension" "diff" "poly"))
   (wellEncDiff      (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
   (wellEncTap       (TECHgetRuleWith "minEnclosure" "nwell" "tap"))
   (labelWidth       0.15)
   (diffImplant      (list "psdm" "drawing"))
   (diffImpEnc       (TECHgetRule "psd_5a"))
   (via1MinSpace     (TECHgetRuleWith "minSpacing" "licon1"))
   (via2MinSpace     (TECHgetRuleWith "minSpacing" "mcon"))
   (layer2MinSpace   (TECHgetRuleWith "minSpacing" "li1"))
   (layer3MinSpace   (TECHgetRuleWith "minSpacing" "met1"))
   (implant          t)
   (tapLayer         (list "tap" "drawing"))    
   (tapImplant       (list "nsdm" "drawing"))  
   (tapImpEnc        (TECHgetRule  "nsd_5b"))  
   (lodEnabled       t)
   )
  ;; Formal parameters
  ((sourceFirst     t)
   (sharedDrain     "DFL1sd2")
   (sharedSource    "DFL1sd2")
   (lastContact     "DFL1sd")
   (firstContact    "DFL1sd")
   (gateExt         (TECHgetRuleWith "minExtension" "poly" "diff"))
   (srcOffset       0.0)
   (drnOffset       0.0)
   (m               1)
   (l               (TECHgetRuleWith "minWidth" "poly"))
   (w               (TECHgetRuleWith "minGateWidth" "diff"))
   (hspiceModel     "pshort")
   (gatetogateSpacing (TECHgetRuleWith "minSpacing" "poly"))
   (LODContactMapSStrapped   (list (list "DFTPL1s"   "DFL1sd2")
				   (list "DFTPM1s"   "DFM1sd2")
				   (list "hvDFTPL1s" "hvDFL1sd2")
				   (list "hvDFTPM1s" "hvDFM1sd2")
				   (list "DFTPL1sw"  "DFL1sd2")
				   (list "DFTPM1sw"  "DFM1sd2")
				   ))
   (LODContactMapNDStrapped  (list (list  "DFL1sd"     "DFL1sd2")
				   (list  "DFL1sdf"    "DFL1sd2")
				   (list  "DFM1sd"     "DFM1sd2")
				   (list  "hvDFL1sd"   "hvDFL1sd2")
				   (list  "hvDFM1sd"   "hvDFM1sd2")      
				   (list  "hvDFM1sd2"  "hvDFM1sd2")
				   (list  "hvDFL1sd2"  "hvDFL1sd2")
				   (list  "DFL1sd2"    "DFL1sd2")
				   (list  "DFM1sd2"    "DFM1sd2")
				   (list  "DFTPM1s2"   "DFM1sd")
				   (list  "DFTPL1s2"   "DFL1sd")
				   (list  "hvDFTPL1s2" "hvDFL1sd")
				   (list  "hvDFTPM1s2" "hvDFM1sd")
				   ))
   (noContactLOD      (TECHgetRuleWith "minExtension" "diff" "poly"))
   )
)
(tfcDefineDeviceProp
 ;;(viewName  deviceName   propName      propValue)
 ("symbolic" "pfet" "discreteWLs" t)  ;;Declares that the pfet is a discrete device
 ("symbolic" "pfet" "enableLOD"   t)  ;;Enables LOD on pfet
 )

;;;moved the extended drain fets from the s8d* flows to the common file
(tcDeclareDevice "symbolic" "mExtDrainTranClass" "extDpTran"
  ;; class parameters
  (
   (srcLayer   (list "diff" "drawing"))
   (srcImplant (list "psdm" "drawing"))
   (srcImplantEnc (TECHgetRule "psd_5a"))
   (drnLayer   (list "tap" "drawing"))
   (drnImplant (list "psdm" "drawing"))
   (drnImplantEnc (TECHgetRule "psd_5b"))
   (idLayer    (list "areaid" "extendedDrain"))
   (gateLayer  (list "poly" "drawing"))
   (drainWell  (list "nwell" "drawing"))
   (dnWell     (list "dnwell" "drawing"))
   (nwellEncDnwell (TECHgetRuleWith "minEnclosure" "dnwell" "nwell"))
   (dnwellEncNwell (TECHgetRuleWith "minOverlap" "nwell" "dnwell"))
   (wellEncSrc (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
   (wellEncDrn (TECHgetRuleWith "minEnclosure" "nwell" "tap"))
   (via0Layer  (list "licon1" "drawing"))
   (via0Width  (TECHgetRuleWith "minWidth" "licon1"))
   (met0Layer  (list "li1" "drawing"))
   (via1Layer  (list "mcon" "drawing"))
   (via1Width  (TECHgetRuleWith "minWidth" "mcon"))
   (met1Layer  (list "met1" "drawing"))
   (hviLayer   (list "hvi" "drawing"))

   (minEncVia0SrcX (TECHgetRuleWith "minEnclosure" "diff" "licon1"))
   (minEncVia0SrcY (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))   

   (minEncVia0DrnX 0.00)
   (minEncVia0DrnY (TECHgetRuleWith "minEnclosure" "tap" "licon1"))
   (via0MinSpace (TECHgetRuleWith "minSpacing" "licon1"))
   (met0EncVia0X 0.00)
   (met0EncVia0Y (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (met0EncVia1X 0.00)
   (met0EncVia1Y (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (via1MinSpace (TECHgetRuleWith "minSpacing" "mcon"))
   (met1EncVia1X (TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
   (met1EncVia1Y (TECHgetRuleWith "minEnclosure" "met1" "mcon"))

   (wellEncDiffTap (max (TECHgetRuleWith "minEnclosure" "nwell" "diff")
			(TECHgetRuleWith "minEnclosure" "nwell" "tap")))
   (wellEncDrain  (TECHgetRule "depmos_10"))
   (wellExtHole  (TECHgetRule "depmos_11"))
   (minSpaceSrcDrn (TECHgetRule "depmos_6"))
   (minDrnWidth (plus (times 2 (TECHgetRule "depmos_9b")) (TECHgetRule "depmos_4")))
   (wellBevel (TECHgetRule "depmos_9a")) ;; Used to calculate bevels
   (drnBevel (TECHgetRule "depmos_9b"))
   (srcExtFromPoly (TECHgetRule "depmos_2")) ;; Extension of source diff out from poly gate
   (polyExtSource   (difference (TECHgetRule "depmos_1") (TECHgetRule "depmos_3")))
   (minSpaceSrcOverWell (TECHgetRule "depmos_5"))
   (minSpaceEndTapDrain (plus (TECHgetRule "depmos_10") (TECHgetRule "depmos_11")))
   (minSpaceEndTapSource (max (plus (TECHgetRule "nsd_5b") (TECHgetRule "nsd_5a"))
			      (TECHgetRuleWith "minSpacing" "diff" "tap")))
   (endTapLayer (list "tap" "drawing"))
   (endTapWidth (TECHgetRuleWith "minWidth" "tap"))
   (endTapImplant (list "nsdm" "drawing"))
   (endTapImpEnc (TECHgetRule "nsd_5b"))
   (wellEncTap (TECHgetRuleWith "minEnclosure" "nwell" "tap"))
   (pFet       t)
   (sharedSrcWidth (plus (times 2 (TECHgetRuleWith "minWidth" "licon1")) (TECHgetRuleWith "minSpacing" "licon1")
			      (times 2 (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))))
   (snapGrid (TECHgetProp snapGrid))
  )
  ;; Formal parameters
  (
   (w   (TECHgetRule "depmos_7"))
   (l   (difference (TECHgetRule "depmos_3") (TECHgetRule "depmos_5")))
   (m   1)
   (gateExt (TECHgetRuleWith "minExtension" "poly" "diff"))
   (contacts "no contacts")
   (endTaps t)
  )
)
(tcDeclareDevice "symbolic" "mExtDrainTranClass" "extDnTran"
  ;; class parameters
  (
   (srcLayer   (list "diff" "drawing"))
   (srcImplant (list "nsdm" "drawing"))
   (srcImplantEnc (TECHgetRule "nsd_5a"))
   (drnLayer   (list "tap" "drawing"))
   (drnImplant (list "nsdm" "drawing"))
   (drnImplantEnc (TECHgetRule "nsd_5b"))
   (idLayer    (list "areaid" "extendedDrain"))
   (gateLayer  (list "poly" "drawing"))
   (drainWell  (list "nwell" "drawing"))
   (wellEncSrc (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
   (wellEncDrn (TECHgetRuleWith "minEnclosure" "nwell" "tap"))
   (via0Layer  (list "licon1" "drawing"))
   (via0Width  (TECHgetRuleWith "minWidth" "licon1"))
   (met0Layer  (list "li1" "drawing"))
   (via1Layer  (list "mcon" "drawing"))
   (via1Width  (TECHgetRuleWith "minWidth" "mcon"))
   (met1Layer  (list "met1" "drawing"))
   (hviLayer   (list "hvi" "drawing"))
   (hviEnc     (TECHgetRuleWith "minEnclosureHV" "diff" "tap"))

   (minEncVia0SrcX (TECHgetRuleWith "minEnclosure" "diff" "licon1"))
   (minEncVia0SrcY (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))   

   (minEncVia0DrnX 0.00)
   (minEncVia0DrnY (TECHgetRuleWith "minEnclosure" "tap" "licon1"))
   (via0MinSpace (TECHgetRuleWith "minSpacing" "licon1"))
   (met0EncVia0X 0.00)
   (met0EncVia0Y (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (met0EncVia1X 0.00)
   (met0EncVia1Y (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (via1MinSpace (TECHgetRuleWith "minSpacing" "mcon"))
   (met1EncVia1X (TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
   (met1EncVia1Y (TECHgetRuleWith "minEnclosure" "met1" "mcon"))

   (wellEncDiffTap (max (TECHgetRuleWith "minEnclosure" "nwell" "diff")
			(TECHgetRuleWith "minEnclosure" "nwell" "tap")))
   (wellEncDrain  (TECHgetRule "denmos_10"))
   (wellExtHole  (TECHgetRule "denmos_11"))
   (minSpaceSrcDrn (TECHgetRule "denmos_6"))
   (minDrnWidth (plus (times 2 (TECHgetRule "denmos_9b")) (TECHgetRule "denmos_4")))
   (wellBevel (TECHgetRule "denmos_9a")) ;; Used to calculate bevels
   (drnBevel (TECHgetRule "denmos_9b"))
   (srcExtFromPoly (TECHgetRule "denmos_2")) ;; Extension of source diff out from poly gate
   (polyExtSource (difference (TECHgetRule "denmos_1") (TECHgetRule "denmos_3")))
   (minSpaceSrcOverWell (TECHgetRule "denmos_5"))
   (minSpaceEndTapDrain (plus (TECHgetRule "denmos_10") (TECHgetRule "denmos_11")))
   (minSpaceEndTapSource (max (plus (TECHgetRule "psd_5b") (TECHgetRule "psd_5a"))
			      (TECHgetRuleWith "minSpacing" "diff" "tap") (TECHgetRule "difftap_15b")))
   (endTapLayer (list "tap" "drawing"))
   (endTapWidth (TECHgetRuleWith "minWidth" "tap"))
   (endTapImplant (list "psdm" "drawing"))
   (endTapImpEnc (TECHgetRule "psd_5b"))
   (wellEncTap (TECHgetRuleWith "minEnclosure" "nwell" "tap"))
   (sharedSrcWidth (max (plus (times 2 (TECHgetRuleWith "minWidth" "licon1")) (TECHgetRuleWith "minSpacing" "licon1")
			      (times 2 (TECHgetRuleWith "minGateSpacing" "poly" "licon1")))
			(difference (TECHgetRule "nwell_8") (times 2 (difference (TECHgetRule "denmos_3") (TECHgetRule "denmos_5"))))))
   (snapGrid (TECHgetProp snapGrid))
  )
  ;; Formal parameters
  (
   (w   (TECHgetRule "denmos_7"))
   (l   (difference (TECHgetRule "denmos_3") (TECHgetRule "denmos_5")))
   (m   1)
   (gateExt (TECHgetRuleWith "minExtension" "poly" "diff"))
   (contacts "no contacts")
   (endTaps t)
  )
);;end extended drain fets
 ;; ndiff resistor
 (tcDeclareDevice
  "symbolic" "wlResImpClass" "nDFres"
  ;; Class parameters
  (
   (resistorLayer      (list "diff" "drawing"))
   (resIdLayer 	       (list "diff" "res"))
   (resCutLayer        (list "diff" "cut"))
   (resCutWidth        (TECHgetLayerProp "diff" 'snapGrid))
   (resistorLayerGrid  (TECHgetLayerProp "diff" 'snapGrid))
   (fullImplantLayer   (list "nsdm" "drawing"))
   (fullImpEnc         (TECHgetRule "nsd_5a"))
  )
  ;; Formal parameters
  (
   (rw 		       (TECHgetRuleWith "minWidth" "diff"))
   (rl 		       (TECHgetRuleWith "minSpacing" "diff"))
   (percentVariability 0)
   (deltaLength        0.0)
   (contactName        "DFL1")
   (implant            t)
  )
 )

 ;; pdiff resistor
 (tcDeclareDevice
  "symbolic" "wlResImpClass" "pDFres"
  ;; Class parameters
  (
   (resistorLayer     (list "diff" "drawing"))
   (wellLayer 	      (list "nwell" "drawing"))
   (resIdLayer 	      (list "diff" "res"))
   (wellEnc 	      (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
   (wellWidth 	      (TECHgetRuleWith "minWidth" "nwell"))
   (resCutLayer       (list "diff" "cut"))
   (resCutWidth       (TECHgetLayerProp "diff" 'snapGrid))
   (resistorLayerGrid (TECHgetLayerProp "diff" 'snapGrid))
   (fullImplantLayer  (list "psdm" "drawing"))
   (fullImpEnc        (TECHgetRule "psd_5a"))
  )
  ;; Formal parameters
  (
   (rw 		       (TECHgetRuleWith "minWidth" "diff"))
   (rl 		       (TECHgetRuleWith "minSpacing" "diff"))
   (percentVariability 0)
   (deltaLength        0.0)
   (contactName        "DFL1")
   (implant            t)
  )
 )

 ;; poly resistor
 (tcDeclareDevice
  "symbolic" "wlResImpClass" "PYres"
  ;; Class parameters
  (
   (resistorLayer     (list "poly" "drawing"))
   (resIdLayer 	      (list "poly" "res"))
   (resCutLayer       (list "poly" "cut"))
   (resCutWidth       (TECHgetLayerProp "poly" 'snapGrid))
   (resistorLayerGrid (TECHgetLayerProp "poly" 'snapGrid))
  )
  ;; Formal parameters
  (
   (rw 		       (TECHgetRuleWith "minResWidth" "poly"))
   (rl 		       (TECHgetRuleWith "minResWidth" "poly"))
   (percentVariability 0)
   (deltaLength        0.0)
   (contactName        "PYL1")
   (implant            t)
  )
 )
 ;; li1 resistor
 (tcDeclareDevice
  "symbolic" "wlResImpClass" "LIres"
  ;; Class parameters
  (
   (resistorLayer     (list "li1" "drawing"))
   (resIdLayer 	      (list "li1" "res"))
   (resCutLayer       (list "li1" "cut"))
   (resCutWidth       (TECHgetLayerProp "li1" 'snapGrid))
   (resistorLayerGrid (TECHgetLayerProp "li1" 'snapGrid))
  )
  ;; Formal parameters
  (
   (rw 		       (TECHgetRuleWith  "minResWidth" "li1"))
   (rl 		       (plus (TECHgetRuleWith  "minWidth" "li1")
                             (TECHgetRuleWith  "minSpacing" "li1")))
   (percentVariability 0)
   (deltaLength        0.0)
   (contactName        "L1M1")
   (implant            t)
  )
 )

 ;; Poly bent resistor
 (tcDeclareDevice
  "symbolic" "bentResImpClass" "PYbentRes"
  ;; Class Parameters
  (
   (resistorLayer     (list "poly" "drawing"))
   (resIdLayer        (list "poly" "res"))
   (minResSpace       (TECHgetRuleWith "minSpacing" "poly"))
   (resCutLayer       (list "poly" "cut"))
   (resCutWidth       (times 2.0 (TECHgetLayerProp "poly" 'snapGrid)))
   (resistorLayerGrid (TECHgetLayerProp "poly" 'snapGrid))
  )
  ;; Formal Parameters
  (
   (rw               (TECHgetRuleWith "minResWidth" "poly"))
   (rl               (TECHgetRuleWith "minResWidth" "poly"))
   (spaceBetweenRuns (max (TECHgetRuleWith "minSpacing"  "poly")
			  (TECHgetRule     "poly_9")))
   (maxRunLength     10.0)
   (variability      "FALSE")
   (contactName      "PYL1")
   (implant          t)
  )
 )

;; debug the bentResClass could really use the wellWidth parameter as well
 ;; ndiff bent resistor
 (tcDeclareDevice
  "symbolic" "bentResImpClass" "nDFbentRes"
  ;; Class Parameters
  (
   (resistorLayer     (list "diff" "drawing"))
   (resIdLayer        (list "diff" "res"))
   (minResSpace       (TECHgetRuleWith "minSpacing" "diff"))
   (resCutLayer       (list "diff" "cut"))
   (resCutWidth       (times 2.0 (TECHgetLayerProp "diff" 'snapGrid)))
   (resistorLayerGrid (TECHgetLayerProp "diff" 'snapGrid))
   (fullImplantLayer  (list "nsdm" "drawing"))
   (fullImpEnc        (TECHgetRule "nsd_5a"))
  )
  ;; Formal Parameters
  (
   (rw               (TECHgetRuleWith "minWidth"   "diff"))
   (rl               (TECHgetRuleWith "minSpacing" "diff"))
   (spaceBetweenRuns (TECHgetRuleWith "minSpacing" "diff"))
   (maxRunLength     10.0)
   (variability      "FALSE")
   (contactName      "DFL1")
   (implant          t)
  )
 )

 ;; pdiff bent resistor
 (tcDeclareDevice
  "symbolic" "bentResImpClass" "pDFbentRes"
  ;; Class Parameters
  (
   (resistorLayer     (list "diff" "drawing"))
   (resIdLayer        (list "diff" "res"))
   (wellLayer         (list "nwell" "drawing"))
   (wellminWidth 	TECHgetRuleWith("minWidth" "nwell"))
   (wellEnc           (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
   (minResSpace       (TECHgetRuleWith "minSpacing" "diff"))
   (resCutLayer       (list "diff" "cut"))
   (resCutWidth       (times 2.0 (TECHgetLayerProp "diff" 'snapGrid)))
   (resistorLayerGrid (TECHgetLayerProp "diff" 'snapGrid))
   (fullImplantLayer  (list "psdm" "drawing"))
   (fullImpEnc        (TECHgetRule "psd_5a"))
  )
  ;; Formal Parameters
  (
   (rw               (TECHgetRuleWith "minWidth"   "diff"))
   (rl               (TECHgetRuleWith "minSpacing" "diff"))
   (spaceBetweenRuns (TECHgetRuleWith "minSpacing" "diff"))
   (maxRunLength     10.0)
   (variability      "FALSE")
   (contactName      "DFL1")
   (implant          t)
  )
 )
;;moved isopwellres to common file
(tcDeclareDevice "symbolic" "rodIsoResClass" "isoPwellRES"
  ;; class parameters
  (
   (tapLayer        (list "tap" "drawing"))
   (tapWidth        (TECHgetRuleWith "minWidth" "tap"))
   (tapImpEnc       (TECHgetRule "psd_5a"))
   (tapRingImplant  (list "psdm" "drawing"))
   (resContactImplant (list "psdm" "drawing"))
   (implantSpc      (TECHgetRuleWith "minSpacing" "nsdm"))
   (innerRingImplant     (list "nsdm" "drawing"))
   (resIdLayer      (list "pwell" "res"))
   (resCutLayer     (list "pwell" "cut"))
   (resCutWidth     (TECHgetLayerProp "diff" 'snapGrid))
   (resWidth        (TECHgetRule "pwres_2"))
   (minResL         (TECHgetRule "pwres_3"))
   (maxResL         (TECHgetRule "pwres_4"))
   (wellLayer       (list "nwell" "drawing"))
   (nwellWidth      (TECHgetRule "nwell_6"))
   (tapWellSpc      (TECHgetRule "pwres_5"))
   (dnwellLayer     (list "dnwell" "drawing"))
   (dnwellWidth     (TECHgetRuleWith "minWidth" "dnwell"))
   (dnwWellEnc      (TECHgetRuleWith "minEnclosure" "dnwell" "nwell"))
   (conLayer        (list "licon1" "drawing"))
   (conWidth        (TECHgetRuleWith "minWidth" "licon1"))
   (conLength       (TECHgetRuleWith "minWidth" "licon1"))
   (conSpacing      (TECHgetRuleWith "minSpacing" "mcon")) ;; Changing this to mcon spacing so the contacts are aligned NOT MIN SPACE
   (tapConEncX      0)
   (tapConEncY      (TECHgetRuleWith "minEnclosure" "tap" "licon1"))
   (M0Layer         (list "li1" "drawing"))
   (M0conEncY       (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (viaLayer        (list "mcon" "drawing"))
   (viaWidth        (TECHgetRuleWith "minWidth" "mcon"))
   (viaLength       (TECHgetRuleWith "minWidth" "mcon"))
   (viaSpacing      (TECHgetRuleWith "minSpacing" "mcon"))
   (M0viaEncX       (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (M1Layer         (list "met1" "drawing"))
   (M1viaEncY       (TECHgetRuleWith "minEnclosure" "met1" "mcon"))
   (M1viaEncX       (TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
  )
  ;; Formal parameters
  (
   (resLength       (TECHgetRule "pwres_3"))
   (contactToMetal  t)
  )
)

;; polyShort element
(tcDeclareDevice
 "symbolic" "shortClass" "plyshort"
 ;; Class Parameters
 (
  (shortOnLayer    (list "poly" "drawing"))
  (shortLayer 	    (list "poly" "short"))
  (minPinWidth     (TECHgetRuleWith "minWidth" "poly"))
  (minShortWidth   (times 2.0 (TECHgetLayerProp "poly" 'snapGrid)))
  )
 ;; Formal Parameters
 (
  (w 		    (TECHgetRuleWith "minWidth" "poly"))
  (l 		    (TECHgetRuleWith "minSpacing" "poly"))
	    )
 ) ; end plyshort

;; li1Short element
(tcDeclareDevice
 "symbolic" "shortClass" "li1short"
 ;; Class Parameters
 (
  (shortOnLayer    (list "li1" "drawing"))
  (shortLayer 	    (list "li1" "short"))
  (minPinWidth     (TECHgetRuleWith "minWidth" "li1"))
  (minShortWidth   (times 2.0 (TECHgetLayerProp "li1" 'snapGrid)))
  )
 ;; Formal Parameters
 (
  (w 		    (TECHgetRuleWith "minWidth" "li1"))
  (l 		    (TECHgetRuleWith "minSpacing" "li1"))
  )
 ) ; end li1short

 ;; met1Short element
 (tcDeclareDevice
  "symbolic" "shortClass" "M1short"
  ;; Class Parameters
  (
   (shortOnLayer    (list "met1" "drawing"))
   (shortLayer 	    (list "met1" "short"))
   (minPinWidth     (TECHgetRuleWith "minWidth" "met1"))
   (minShortWidth   (times 2.0 (TECHgetLayerProp "met1" 'snapGrid)))
  )
  ;; Formal Parameters
  (
   (w	            (TECHgetRuleWith "minWidth" "met1"))
   (l 		    (TECHgetRuleWith "minSpacing" "met1"))
  )
 )

 ;; met2Short element
 (tcDeclareDevice
  "symbolic" "shortClass" "M2short"
  ;; Class Parameters
  (
   (shortOnLayer    (list "met2" "drawing"))
   (shortLayer 	    (list "met2" "short"))
   (minPinWidth     (TECHgetRuleWith "minWidth" "met2"))
   (minShortWidth   (times 2.0 (TECHgetLayerProp "met2" 'snapGrid)))
  )
  ;; Formal Parameters
  (
   (w 		    (TECHgetRuleWith "minWidth" "met2"))
   (l 		    (TECHgetRuleWith "minSpacing" "met2"))
  )
 )

;; met3Short element
(tcDeclareDevice
 "symbolic" "shortClass" "M3short"
 ;; Class Parameters
 (
  (shortOnLayer    (list "met3" "drawing"))
  (shortLayer 	    (list "met3" "short"))
  (minPinWidth     (TECHgetRuleWith "minWidth" "met3"))
  (minShortWidth   (times 2.0 (TECHgetLayerProp "met3" 'snapGrid)))
  )
 ;; Formal Parameters
 (
  (w 		    (TECHgetRuleWith "minWidth" "met3"))
  (l 		    (TECHgetRuleWith "minSpacing" "met3"))
  )
 ) ; end met3short


 ;; Declare the generic ring.  This device will be placed by other devices.
 ;; All of the parameters are user parameters.
 (tcDeclareDevice
  "symbolic" "ringClass" "genDLring"
  ;; Class Parameters
  (
  )	
  ;; User Parameters
  (
  )
 )

 ;; Declare the generic integer based ring.  This device will be placed
 ;; by other devices.  All of the parameters are user parameters.
 (tcDeclareDevice
  "symbolic" "intRingClass" "genIntDLring"
  ;; Class Parameters
  (
  )
  ;; Formal Parameters
  (
  )
 )

 ;; Declare the generic riveted ring.  This device will be placed by other
 ;; devices in the device library.  All of the parameters are user params.
 (tcDeclareDevice
  "symbolic" "rivetRingClass" "genRivetDLring"
  ;; Class Parameters
  (
  )
  ;; User Parameters
  (
  )
 )

 ;; Declare the generic riveted ring that is mirrored correctly for sharing.
 ;; This device will be placed by other devices in the device library.  All
 ;; of the parameters are user params.
 (tcDeclareDevice
  "symbolic" "rivetRingMirrorClass" "genRivetMirrorDLring"
  ;; Class Parameters
  (
  )
  ;; Formal Parameters
  (
  )
 )

(tcDeclareDevice
 "symbolic" "antennaDiodeClass" "antenna_diode"
 ;; Class Parameters
 ( 
  (diffLayer       (list "diff" "drawing"))
  (diffImplant     (list "nsdm" "drawing"))
  (diffImpEnc      (TECHgetRule "nsd_5a"))
  
  (tapRingLayer    (list "tap" "drawing"))
  (tapRingImplant  (list "psdm" "drawing"))
  (tapRingImpEnc   (TECHgetRule "psd_5b"))
  (tapWidth        (TECHgetRuleWith "minWidth" "tap"))
  
  (tapRingDiffSpacing (TECHgetRuleWith "minSpacing" "diff" "tap"))
  
  (via1Layer       (list "licon1" "drawing"))
  (via1Size        (TECHgetRuleWith "minWidth" "licon1"))
  (via1Spacing     (TECHgetRuleWith "minSpacing" "licon1"))
  (tapEncVia1Y     (TECHgetRuleWith "minEnclosure" "tap" "licon1"))
  (tapEncVia1X     (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
  (diffEncVia1Y    (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
  (diffEncVia1X    (TECHgetRuleWith "minEnclosure" "diff" "licon1"))
  
  (met1Layer       (list "li1" "drawing"))
  (met1EncVia1Y    (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
  (met1EncVia1X    0.0)
  (met1EncVia2Y    (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
  (met1EncVia2X    (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
  (met2Layer       (list "met1" "drawing"))
  (via2Layer       (list "mcon" "drawing"))
  (via2Size        (TECHgetRuleWith "minWidth" "mcon"))
  (via2Spacing     (TECHgetRuleWith "minSpacing" "mcon"))
  (met2EncVia2Y    (TECHgetRuleWith "minEnclosure" "met1" "mcon"))
  (met2EncVia2X    (TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
  
  )
 ;; Formal Parameters
 ( 
  (length     1.0)
  (width      1.0)
  (secondMetalLength 1.0)
  )
 )

;; The following section defines varactor contacts

(setq TPM1params (list (list (list "tap" "drawing")
			     0.0
			     0.0
			     0.0
			     0.0
			     0.0
			     ,(TECHgetRuleWith "minEnclosure" "tap" "licon1")
			     (list (list 
				    (list (list "psdm" "drawing")
					  ,(TECHgetRule "psd_5a")
					  ))
				   (list 
				    (list (list "nsdm" "drawing")
					  ,(TECHgetRule "nsd_5a")
					  )
				    (list (list "nwell" "drawing")
					  ,(TECHgetRuleWith "minEnclosure" "nwell" "tap")
					  ))
				   )
			     )			   
		       (list (list "licon1" "drawing")
			     ,(TECHgetRuleWith "minWidth" "licon1")
			     ,(TECHgetRuleWith "minSpacing" "licon1")
			     )
		       (list (list "li1" "drawing")
			     0.0
			     0.0
			     ,(TECHgetRuleWith "minEnclosure" "li1" "licon1")
			     0.0
			     0.0
			     ,(TECHgetRuleWith "minEnclosure" "li1" "mcon")
			     )
		       (list (list "mcon" "drawing")
			     ,(TECHgetRuleWith "minWidth" "mcon")
			     ,(TECHgetRuleWith "minSpacing" "mcon")
			     )
		       (list (list "met1" "drawing")
			     ,(TECHgetRuleWith "minEnclosureAny" "met1" "mcon")
			     ,(TECHgetRuleWith "minEnclosureAny" "met1" "mcon")
			     ,(TECHgetRuleWith "minEnclosure" "met1" "mcon")
			     0.0
			     0.0
			     0.0
			     )
		       ))
(setq TPM2params (list (list (list "tap" "drawing")
			     0.0
			     0.0
			     0.0 
			     0.0
			     0.0
			     ,(TECHgetRuleWith "minEnclosure" "tap" "licon1")
			     (list (list 
				    (list (list "psdm" "drawing")
					  ,(TECHgetRule "psd_5a")
					  ))
				   (list 
				    (list (list "nsdm" "drawing")
					  ,(TECHgetRule "nsd_5a")
					  )
				    (list (list "nwell" "drawing")
					  ,(TECHgetRuleWith "minEnclosure" "nwell" "tap")
					  ))
				   )
			     )			   
		       (list (list "licon1" "drawing")
			     ,(TECHgetRuleWith "minWidth" "licon1")
			     ,(TECHgetRuleWith "minSpacing" "licon1")
			     )
		       (list (list "li1" "drawing")
			     0.0
			     0.0
			     ,(TECHgetRuleWith "minEnclosure" "li1" "licon1")
			     0.0
			     0.0
			     ,(TECHgetRuleWith "minEnclosure" "li1" "mcon")
			     )
		       (list (list "mcon" "drawing")
			     ,(TECHgetRuleWith "minWidth" "mcon")
			     ,(TECHgetRuleWith "minSpacing" "mcon")
			     )
		       (list (list "met1" "drawing")
			     ,(TECHgetRuleWith "minEnclosureAny" "met1" "mcon")
			     ,(TECHgetRuleWith "minEnclosureAny" "met1" "mcon")
			     ,(TECHgetRuleWith "minEnclosure" "met1" "mcon")
			     ,(TECHgetRuleWith "minEnclosureAny" "met1" "via")
			     ,(TECHgetRuleWith "minEnclosureAny" "met1" "via")
			     ,(TECHgetRuleWith "minEnclosure" "met1" "via")
			     )
		       (list (list "via" "drawing")
			     ,(TECHgetRuleWith "minWidth" "via")
			     ,(TECHgetRuleWith "minSpacing" "via")
			     )
		       (list (list "met2" "drawing")
			     ,(TECHgetRuleWith "minEnclosureAny" "met2" "via")
			     ,(TECHgetRuleWith "minEnclosureAny" "met2" "via")
			     ,(TECHgetRuleWith "minEnclosure" "met2" "via")
			     0.0
			     0.0
			     0.0
			     )
		       ))
(setq PYM1params (list (list (list "poly" "drawing")
			     0.0
			     0.0
			     0.0 
			     ,(TECHgetRuleWith "minEnclosure" "poly" "licon1")
			     ,(TECHgetRuleWith "minEnclosure" "poly" "licon1")
			     ,(TECHgetRuleWith "minEnclosure" "poly" "licon1")
			     )
		       (list (list "licon1" "drawing")
			     ,(TECHgetRuleWith "minWidth" "licon1")
			     ,(TECHgetRuleWith "minSpacing" "licon1")
			     (list (list "npc" "drawing")
				   ,(TECHgetRuleWith "minEnclosure" "npc" "licon1")
				   )
			     )
		       (list (list "li1" "drawing")
			     ,(TECHgetRuleWith "minEnclosure" "li1" "licon1")
			     ,(TECHgetRuleWith "minEnclosure" "li1" "licon1")
			     ,(TECHgetRuleWith "minEnclosure" "li1" "licon1")
			     ,(TECHgetRuleWith "minEnclosure" "li1" "mcon")
			     ,(TECHgetRuleWith "minEnclosure" "li1" "mcon")
			     ,(TECHgetRuleWith "minEnclosure" "li1" "mcon")
			     )
		       (list (list "mcon" "drawing")
			     ,(TECHgetRuleWith "minWidth" "mcon")
			     ,(TECHgetRuleWith "minSpacing" "mcon")
			     )
		       (list (list "met1" "drawing")
			     ,(TECHgetRuleWith "minEnclosure" "met1" "mcon")
			     ,(TECHgetRuleWith "minEnclosure" "met1" "mcon")
			     ,(TECHgetRuleWith "minEnclosure" "met1" "mcon")
			     0.0
			     0.0
			     0.0
			     )
		       ))
(setq PYM2params (list (list (list "poly" "drawing")
			     0.0
			     0.0
			     0.0 
			     ,(TECHgetRuleWith "minEnclosure" "poly" "licon1")
			     ,(TECHgetRuleWith "minEnclosure" "poly" "licon1")
			     ,(TECHgetRuleWith "minEnclosure" "poly" "licon1")
			     )
		       (list (list "licon1" "drawing")
			     ,(TECHgetRuleWith "minWidth" "licon1")
			     ,(TECHgetRuleWith "minSpacing" "licon1")
			     (list (list "npc" "drawing")
				   ,(TECHgetRuleWith "minEnclosure" "npc" "licon1")
				   )
			     )
		       (list (list "li1" "drawing")
			     ,(TECHgetRuleWith "minEnclosure" "li1" "licon1")
			     ,(TECHgetRuleWith "minEnclosure" "li1" "licon1")
			     ,(TECHgetRuleWith "minEnclosure" "li1" "licon1")
			     ,(TECHgetRuleWith "minEnclosure" "li1" "mcon")
			     ,(TECHgetRuleWith "minEnclosure" "li1" "mcon")
			     ,(TECHgetRuleWith "minEnclosure" "li1" "mcon")
			     )
		       (list (list "mcon" "drawing")
			     ,(TECHgetRuleWith "minWidth" "mcon")
			     ,(TECHgetRuleWith "minSpacing" "mcon")
			     )
		       (list (list "met1" "drawing")
			     ,(TECHgetRuleWith "minEnclosure" "met1" "mcon")
			     ,(TECHgetRuleWith "minEnclosure" "met1" "mcon")
			     ,(TECHgetRuleWith "minEnclosure" "met1" "mcon")
			     ,(TECHgetRuleWith "minEnclosure" "met1" "via")
			     ,(TECHgetRuleWith "minEnclosure" "met1" "via")
			     ,(TECHgetRuleWith "minEnclosure" "met1" "via")
			     )
		       (list (list "via" "drawing")
			     ,(TECHgetRuleWith "minWidth" "via")
			     ,(TECHgetRuleWith "minSpacing" "via")
			     )
		       (list (list "met2" "drawing")
			     ,(TECHgetRuleWith "minEnclosure" "met2" "via")
			     ,(TECHgetRuleWith "minEnclosure" "met2" "via")
			     ,(TECHgetRuleWith "minEnclosure" "met2" "via")
			     0.0
			     0.0
			     0.0
			     )
		       ))
(setq PYM1ButtingParams (list (list (list "poly" "drawing")
			     0.0
			     0.0
			     0.0 
			     ,(TECHgetRuleWith "minEnclosure" "poly" "licon1")
			     ,(TECHgetRuleWith "minEnclosure" "poly" "licon1")
			     (times 0.5 ,(TECHgetRuleWith "minSpacing" "mcon"))
			     )
		       (list (list "licon1" "drawing")
			     ,(TECHgetRuleWith "minWidth" "licon1")
			     ,(TECHgetRuleWith "minSpacing" "licon1")
			     (list (list "npc" "drawing")
				   ,(TECHgetRuleWith "minEnclosure" "npc" "licon1")
				   )
			     )
		       (list (list "li1" "drawing")
			     ,(TECHgetRuleWith "minEnclosure" "li1" "licon1")
			     ,(TECHgetRuleWith "minEnclosure" "li1" "licon1")
			     (times 0.5 ,(TECHgetRuleWith "minSpacing" "mcon"))
			     ,(TECHgetRuleWith "minEnclosure" "li1" "mcon")
			     ,(TECHgetRuleWith "minEnclosure" "li1" "mcon")
			     (times 0.5 ,(TECHgetRuleWith "minSpacing" "mcon"))
			     )
		       (list (list "mcon" "drawing")
			     ,(TECHgetRuleWith "minWidth" "mcon")
			     ,(TECHgetRuleWith "minSpacing" "mcon")
			     )
		       (list (list "met1" "drawing")
			     ,(TECHgetRuleWith "minEnclosure" "met1" "mcon")
			     ,(TECHgetRuleWith "minEnclosure" "met1" "mcon")
			     (times 0.5 ,(TECHgetRuleWith "minSpacing" "mcon"))
			     0.0
			     0.0
			     0.0
			     )
		       ))

(setq PYM2ButtingParams (list (list (list "poly" "drawing")
			     0.0
			     0.0
			     0.0 
			     ,(TECHgetRuleWith "minEnclosure" "poly" "licon1")
			     ,(TECHgetRuleWith "minEnclosure" "poly" "licon1")
			     (times 0.5 ,(TECHgetRuleWith "minSpacing" "mcon"))
			     )
		       (list (list "licon1" "drawing")
			     ,(TECHgetRuleWith "minWidth" "licon1")
			     ,(TECHgetRuleWith "minSpacing" "licon1")
			     (list (list "npc" "drawing")
				   ,(TECHgetRuleWith "minEnclosure" "npc" "licon1")
				   )
			     )
		       (list (list "li1" "drawing")
			     ,(TECHgetRuleWith "minEnclosure" "li1" "licon1")
			     ,(TECHgetRuleWith "minEnclosure" "li1" "licon1")
			     (times 0.5 ,(TECHgetRuleWith "minSpacing" "mcon"))
			     ,(TECHgetRuleWith "minEnclosure" "li1" "mcon")
			     ,(TECHgetRuleWith "minEnclosure" "li1" "mcon")
			     (times 0.5 ,(TECHgetRuleWith "minSpacing" "mcon"))
			     )
		       (list (list "mcon" "drawing")
			     ,(TECHgetRuleWith "minWidth" "mcon")
			     ,(TECHgetRuleWith "minSpacing" "mcon")
			     )
		       (list (list "met1" "drawing")
			     ,(TECHgetRuleWith "minEnclosure" "met1" "mcon")
			     ,(TECHgetRuleWith "minEnclosure" "met1" "mcon")
			     (times 0.5 ,(TECHgetRuleWith "minSpacing" "mcon"))
			     ,(TECHgetRuleWith "minEnclosure" "met1" "via")
			     ,(TECHgetRuleWith "minEnclosure" "met1" "via")
			     (times 0.5 (plus 
					 ,(TECHgetRuleWith "minSpacing" "mcon")
					 (difference ,(TECHgetRuleWith "minWidth" "mcon") ,(TECHgetRuleWith "minWidth" "via"))))
			     )
		       (list (list "via" "drawing")
			     ,(TECHgetRuleWith "minWidth" "via")
			     ,(TECHgetRuleWith "minSpacing" "via")
			     )
		       (list (list "met2" "drawing")
			     ,(TECHgetRuleWith "minEnclosure" "met2" "via")
			     ,(TECHgetRuleWith "minEnclosure" "met2" "via")
			     (times 0.5 (plus 
					 ,(TECHgetRuleWith "minSpacing" "mcon")
					 (difference ,(TECHgetRuleWith "minWidth" "mcon") ,(TECHgetRuleWith "minWidth" "via"))))
			     0.0
			     0.0
			     0.0
			     )
		       ))


 (tcDeclareDevice
  "symbolic" "simpleContactClass" "TPM1sd_varactor"
  (
   (layerparams   `((list ',TPM1params)))
   )
  (
   (w    (TECHgetRuleWith "minWidth" "licon1"))
   (l    (plus (times 2.0 (TECHgetRuleWith "minEnclosure"
						      "tap" "licon1"))
			  (TECHgetRuleWith "minWidth" "licon1")))
   (inWell t)
   )
  )
 (tcDeclareDevice
  "symbolic" "simpleContactClass" "TPM2sd_varactor"
  (
   (layerparams   `((list ',TPM2params)))
   )
  (
   (w    (TECHgetRuleWith "minWidth" "licon1"))
   (l    (plus (times 2.0 (TECHgetRuleWith "minEnclosure"
						      "tap" "licon1"))
			  (TECHgetRuleWith "minWidth" "licon1")))
   (inWell t)
   )
  )
 (tcDeclareDevice
  "symbolic" "simpleContactClass" "PYM1_varactor"
  (
   (layerparams   `((list ',PYM1params)))
   )
  (
   (w    (plus (times 2 (TECHgetRuleWith "minEnclosure" "poly" "licon1"))
	       (TECHgetRuleWith "minWidth" "licon1")))
   (l    (plus (times 2 (TECHgetRuleWith "minEnclosure" "poly" "licon1"))
	       (TECHgetRuleWith "minWidth" "licon1")))
   (center t)
   )
  )
 (tcDeclareDevice
  "symbolic" "simpleContactClass" "PYM2_varactor"
  (
   (layerparams   `((list ',PYM2params)))
   )
  (
   (w    (plus (times 2 (TECHgetRuleWith "minEnclosure" "poly" "licon1"))
	       (TECHgetRuleWith "minWidth" "licon1")))
   (l    (plus (times 2 (TECHgetRuleWith "minEnclosure" "poly" "licon1"))
	       (TECHgetRuleWith "minWidth" "licon1")))
   (center t)
   )
  )
 (tcDeclareDevice
  "symbolic" "simpleContactClass" "PYM1butt_varactor"
  (
   (layerparams   `((list ',PYM1ButtingParams)))
   )
  (
   (w    (plus (times 2 (TECHgetRuleWith "minEnclosure" "poly" "licon1"))
	       (TECHgetRuleWith "minWidth" "licon1")))
   (l    (plus ,(TECHgetRuleWith "minSpacing" "mcon")
	       (TECHgetRuleWith "minWidth" "licon1")))
   (center t)
   )
  )

 (tcDeclareDevice
  "symbolic" "simpleContactClass" "PYM2butt_varactor"
  (
   (layerparams   `((list ',PYM2ButtingParams)))
   )
  (
   (w    (plus (times 2 (TECHgetRuleWith "minEnclosure" "poly" "licon1"))
	       (TECHgetRuleWith "minWidth" "licon1")))
   (l    (plus ,(TECHgetRuleWith "minSpacing" "mcon")
	       (TECHgetRuleWith "minWidth" "licon1")))
   (center t)
   )
  )

(tcDeclareDevice "symbolic" "varactorClass" "varactor"
  ;; Class parameters
  ((tapLayer         (list "tap" "drawing"))
   (gateLayer        (list "poly" "drawing"))
   (wellLayer        (list "nwell" "drawing"))
   (tapExt           (TECHgetRule "varac_4"))
   (wellEncPoly      (TECHgetRule "varac_5"))
   (wellEncTap       (TECHgetRuleWith "minEnclosure" "nwell" "tap"))
   (labelWidth       0.15)
   (implantLayer      (list "nsdm" "drawing"))
   (tapImpEnc        (TECHgetRule     "nsd_5a"))
   (contactGateSpace (TECHgetRule "varac_4"))
   (topMetal         (list "met2" "drawing"))
   (topMetalGateDist (times 2 (TECHgetRuleWith "minSpacing" "met2")))
  )
  ;; Formal parameters
  ((gateContact     "PYM2_varactor")
   (contacts        "TPM2sd_varactor")
   (gateExt         (TECHgetRuleWith "minExtension" "poly" "diff"))
   (m               1)
   (l               (TECHgetRule "varac_1"))
   (w               (TECHgetRule "varac_2"))
   (doubleGateContacts t)
  )
)

(tcDeclareDevice "symbolic" "varactorClass" "varactor2"
  ;; Class parameters
  ((tapLayer         (list "tap" "drawing"))
   (gateLayer        (list "poly" "drawing"))
   (wellLayer        (list "nwell" "drawing"))
   (tapExt           (TECHgetRule "varac_4"))
   (wellEncPoly      (TECHgetRule "varac_5"))
   (wellEncTap       (TECHgetRuleWith "minEnclosure" "nwell" "tap"))
   (labelWidth       0.15)
   (implantLayer      (list "nsdm" "drawing"))
   (tapImpEnc        (TECHgetRule     "nsd_5a"))
   (contactGateSpace (TECHgetRule "varac_4"))
   (topMetal         (list "met2" "drawing"))
   (topMetalGateDist (times 2 (TECHgetRuleWith "minSpacing" "met2")))
   (varChannelImp    (list "hvtp" "drawing"))
   (varChannelImpEnc (TECHgetRule "varac_8"))
  )
  ;; Formal parameters
  ((gateContact     "PYM2_varactor")
   (contacts        "TPM2sd_varactor")
   (gateExt         (TECHgetRuleWith "minExtension" "poly" "diff"))
   (m               1)
   (l               (TECHgetRule "varac_1"))
   (w               (TECHgetRule "varac_2"))
   (doubleGateContacts t)
  )
)

;; these get used by the cdf functions for the transistor pcells
;; If a source or drain contact is added, the properties
;; must be defined or initialize devices will crash opus
(tfcDefineDeviceProp
 ;;(viewName  deviceName   propName      propValue)
 
 ("symbolic" "PYM2_varactor"   "description" "gate contact to met2")
 ("symbolic" "PYM2_varactor"   "varactor"       t)
 ("symbolic" "PYM2_varactor"   "gate"         t)

 ("symbolic" "PYM1_varactor"   "description" "gate contact to met1")
 ("symbolic" "PYM1_varactor"   "varactor"       t)
 ("symbolic" "PYM1_varactor"   "gate"         t)

 ("symbolic" "PYM1butt_varactor"   "description" "butting gate contact to met1")
 ("symbolic" "PYM1butt_varactor"   "varactor"     t)
 ("symbolic" "PYM1butt_varactor"   "gate"         t)

 ("symbolic" "PYM2butt_varactor"   "description" "butting gate contact to met2")
 ("symbolic" "PYM2butt_varactor"   "varactor"     t)
 ("symbolic" "PYM2butt_varactor"   "gate"         t)
 
 ("symbolic" "TPM2sd_varactor"   "description" "contact to met2")
 ("symbolic" "TPM2sd_varactor"   "varactor"       t)
 ("symbolic" "TPM2sd_varactor"   "gate"           nil)
 
 ("symbolic" "TPM1sd_varactor"   "description" "contact to met1")
 ("symbolic" "TPM1sd_varactor"   "varactor"       t)
 ("symbolic" "TPM1sd_varactor"   "gate"           nil)

 ("symbolic" "DFTPM1s2"  "description" "double strapped to met1")
 ("symbolic" "DFTPM1s2"  "strapped"     t)
 ("symbolic" "DFTPM1s2"  "double"       t)
 
 ("symbolic" "DFTPL1s2"  "description" "double strapped to li1")
 ("symbolic" "DFTPL1s2"  "strapped"     t)
 ("symbolic" "DFTPL1s2"  "double"       t)
 
 ("symbolic" "DFTPM1s"   "description" "single strapped to met1")
 ("symbolic" "DFTPM1s"   "strapped"     t)
  
 ("symbolic" "DFTPM1sw"  "description" "single strapped to met1-wide")
 ("symbolic" "DFTPM1sw"  "strapped"     t)
 
 ("symbolic" "DFTPL1s"   "description" "single strapped to li1")
 ("symbolic" "DFTPL1s"   "strapped"     t)
  
 ("symbolic" "DFTPL1sw"  "description" "single strapped to li1-wide")
 ("symbolic" "DFTPL1sw"  "strapped"     t)
 
 ("symbolic" "DFM1sd"    "description" "single nonStrap to met1")
 
 ("symbolic" "DFM1sd2"   "description" "double nonStrap to met1")
 ("symbolic" "DFM1sd2"   "double"       t)
 
 ("symbolic" "DFL1sd"    "description" "single nonStrap to li1")
 
 ("symbolic" "DFL1sdf"    "description" "single nonStrap to li1, flush")
 
 ("symbolic" "DFL1sd2"   "description" "double nonStrap to li1")
 ("symbolic" "DFL1sd2"   "double"       t)
 
 ("symbolic" "TPM1s"     "description" "single tap to met1")
 ("symbolic" "TPM1s"     "tapOnly"      t)
 
 ("symbolic" "TPL1s"     "description" "single tap to li1")
 ("symbolic" "TPL1s"     "tapOnly"      t)
 
 ("symbolic" "hvDFL1sd"    "description" "hv single nonStrap to li1")  ;;;???

 ("symbolic" "hvDFTPL1s"   "description" "hv single strapped to li1")
 ("symbolic" "hvDFTPL1s"   "strapped"     t)
  
 ("symbolic" "hvDFL1sd2"   "description" "hv double nonStrap to li1")
 ("symbolic" "hvDFL1sd2"   "double"       t)
 
 ("symbolic" "hvDFTPL1s2"   "description" "hv double strapped to li1")
 ("symbolic" "hvDFTPL1s2"   "strapped"     t)
 ("symbolic" "hvDFTPL1s2"   "double"       t)
  
 ("symbolic" "hvDFTPM1s"   "description" "hv single strapped to met1")
 ("symbolic" "hvDFTPM1s"   "strapped"     t)
 
 ("symbolic" "hvDFM1sd"    "description" "hv single nonStrap to met1")

 ("symbolic" "hvDFM1sd2"   "description" "hv double nonStrap to met1")
 ("symbolic" "hvDFM1sd2"   "double"       t)
 
 ("symbolic" "hvDFTPM1s2"   "description" "hv double strapped to met1")
 ("symbolic" "hvDFTPM1s2"   "strapped"     t)
 ("symbolic" "hvDFTPM1s2"   "double"       t)

) ; end tfcDefineDeviceProp

(tcSetDeviceProp "symbolic" "hvDFTPL1s"    list("res" (TECHgetRule "rcl1p") ))
(tcSetDeviceProp "symbolic" "hvDFL1sd2"    list("res" (TECHgetRule "rcl1p") )) 
(tcSetDeviceProp "symbolic" "hvDFTPM1s"    list("res" (TECHgetRule "rcp") ))
(tcSetDeviceProp "symbolic" "hvDFM1sd2"    list("res" (TECHgetRule "rcp") ))

(tcDeclareDevice
 "symbolic" "esdFetClass" "pEsdFet"
 ;; Class parameters
 ((diffLayer            "diff")
  (gateLayer            "poly")
  (pgateLayer           (list "poly" "gate"))
  (wellLayer             "nwell")
  (diffImplant           "psdm")
  (diffImpEnc            (TECHgetRule "psd_5a"))
  (tapLayer             "tap")
  (tapImplant           "nsdm")
  (tapImpEnc             (TECHgetRule "nsd_5a"))
  (idLayer               (list "areaid" "esd"))
  (hvLayer               "hvi") ;; High Voltage Diffusion Layer(diff.hv)
  (drnInterconnect     `('("licon1" ,(TECHgetRuleWith  "minWidth" "licon1") 
			   ,(TECHgetRuleWith  "minSpacing" "licon1") 
                           ,(TECHgetRule "esd_dIntconn_cc_a") "li1" ,(TECHgetRule "esd_dIntconn_w") 
                           ,(TECHgetRuleWith  "minSpacing" "li1") ,(TECHgetRule "esd_dIntconn_minBevEdg_a"))
			 ;;'("contactLayerName" contactLayerWidth contactLayerSpace 
			 ;; contactColumnsNum "upperMetLayerName" metLayerWidth metLayerSpace metLayerBevelEdge)
			 '("mcon" ,(TECHgetRuleWith  "minWidth" "mcon") 
			   ,(TECHgetRuleWith  "minSpacing" "mcon") 
                           ,(TECHgetRule "esd_dIntconn_cc_b") "met1" ,(TECHgetRule "esd_dIntconn_minW") 
                           ,(TECHgetRule "esd_dIntconn_minS") ,(TECHgetRule "esd_dIntconn_minBevEdg_b"))))
  (srcInterconnect     `('("licon1" ,(TECHgetRuleWith  "minWidth" "licon1") 
			   ,(TECHgetRuleWith  "minSpacing" "licon1") 
                           ,(TECHgetRule "esd_sIntconn_cc_a") "li1" ,(TECHgetRule "esd_sIntconn_w") 
                           ,(TECHgetRuleWith  "minSpacing" "li1") ,(TECHgetRule "esd_sIntconn_minBevEdg_a"))
			 ;;'("contactLayerName" contactLayerWidth contactLayerSpace 
			 ;; contactColumnsNum "upperMetLayerName" metLayerWidth metLayerSpace metLayerBevelEdge)
			 '("mcon" ,(TECHgetRuleWith  "minWidth" "mcon") 
			   ,(TECHgetRuleWith  "minSpacing" "mcon") 
                           ,(TECHgetRule "esd_sIntconn_cc_b") "met1" ,(TECHgetRule "esd_sIntconn_minW") 
                           ,(TECHgetRule "esd_sIntconn_minS") ,(TECHgetRule "esd_sIntconn_minBevEdg_b"))))
  (diffContact0Yenc      (TECHgetRule "esd_diffCon0Yenc"))
  (diffContact0Xenc      (TECHgetRule "esd_diffCon0Xenc"))
  (flareInDiff           (TECHgetRule "esd_flareInDiff"))
  (flareOutDiff          (TECHgetRule "esd_flareOutDiff"))
  (flareExt              (TECHgetRule "esd_flareExt"))
  (InnerRingInterconnectHoriz `('("licon1" ,(TECHgetRuleWith  "minWidth" "licon1") 
				  ,(TECHgetRuleWith  "minSpacing" "licon1") 
				  ,(TECHgetRule "esd_InnRingIntconn_cc_a") "li1" 
				  ,(TECHgetRuleWith  "minEnclosure" "li1" "mcon")
				  ,(TECHgetRule "esd_InnRingIntconn_innerminBevEdg_a") ,(TECHgetRule "esd_InnRingIntconn_outerminBevEdg_a"))
				;;'("contactLayerName" contactLayerWidth contactLayerSpace 
				;; contactColumnsNum "upperMetLayerName" metContactEnc innerMetBevelEdge outerMetBevelEdge)
				'("mcon" ,(TECHgetRuleWith  "minWidth" "mcon") 
				  ,(TECHgetRuleWith  "minSpacing" "mcon") ,(TECHgetRule "esd_InnRingIntconn_cc_b") "met1" 
				  ,(TECHgetRule "esd_InnRingIntconn_minEnc")
				  ,(TECHgetRule "esd_InnRingIntconn_innerminBevEdg_b") ,(TECHgetRule "esd_InnRingIntconn_outerminBevEdg_b"))))
  (InnerRingInterconnectVert  `('("licon1" ,(TECHgetRuleWith  "minWidth" "licon1") 
				  ,(TECHgetRuleWith  "minSpacing" "licon1") 
				  ,(TECHgetRule "esd_InnRingIntconn_cc_c") "li1" 
				  ,(TECHgetRuleWith  "minEnclosure" "li1" "mcon")
				  ,(TECHgetRule "esd_InnRingIntconn_innerminBevEdg_c") ,(TECHgetRule "esd_InnRingIntconn_outerminBevEdg_c"))
				;;'("contactLayerName" contactLayerWidth contactLayerSpace 
				;; contactColumnsNum "upperMetLayerName" metContactEnc innerMetBevelEdge outerMetBevelEdge)
				'("mcon" ,(TECHgetRuleWith  "minWidth" "mcon") 
				  ,(TECHgetRuleWith  "minSpacing" "mcon") ,(TECHgetRule "esd_InnRingIntconn_cc_d") "met1" 
				  ,(TECHgetRule "esd_InnRingIntconn_minEnc")
				  ,(TECHgetRule "esd_InnRingIntconn_innerminBevEdg_d") ,(TECHgetRule "esd_InnRingIntconn_outerminBevEdg_d"))))
  (OuterRingInterconnect `('("licon1" ,(TECHgetRuleWith  "minWidth" "licon1") 
			     ,(TECHgetRuleWith  "minSpacing" "licon1") ,(TECHgetRule "esd_OutRingIntconn_cc_a") "li1" 
			     ,(TECHgetRuleWith  "minEnclosure" "li1" "mcon") 
                             ,(TECHgetRule "esd_OutRingIntconn_innerminBevEdg_a") ,(TECHgetRule "esd_OutRingIntconn_outerminBevEdg_a"))
			   ;;'("contactLayerName" contactLayerWidth contactLayerSpace 
			   ;; contactColumnsNum "upperMetLayerName" metContactEnc innerMetBevelEdge outerMetBevelEdge)
			   '("mcon" ,(TECHgetRuleWith  "minWidth" "mcon") 
			     ,(TECHgetRuleWith  "minSpacing" "mcon") ,(TECHgetRule "esd_OutRingIntconn_cc_b") "met1" 
			     ,(TECHgetRule "esd_OutRingIntconn_minEnc")
                             ,(TECHgetRule "esd_OutRingIntconn_innerminBevEdg_b") ,(TECHgetRule "esd_OutRingIntconn_outerminBevEdg_b"))))
  (OuterInnerRingSpace   (TECHgetRule "esd_outerInnerRingSpace"))
  (fetDiffInnerRingSpace (TECHgetRule "esd_fetDiffInnRingSpace"))
  (hvWellDiffTapEnc      (TECHgetRule "esd_hvWellTapEnc"))
  (hvLayerDiffTapEnc     (TECHgetRule "esd_HVIdifftapEnc"))
  (mosType              "pmos")
  (minInnerRingFetExtraRightSpace (TECHgetRule "esd_minExtraSpace_Right"))
  (minInnerRingFetExtraLeftSpace  (TECHgetRule "esd_minExtraSpace_Left"))
  (minInnerRingFetExtraTopSpace   (TECHgetRule "esd_minExtraSpace_Top"))
  (minInnerRingFetExtraBotSpace   (TECHgetRule "esd_minExtraSpace_Bottom"))
  (buttingTapWidth     (TECHgetRule "esd_fetDiffInnRingSpace"))
  (minimumM            (TECHgetRule "esd_minM"))
  (srcGateContactSpaceMin (TECHgetRule "esd_srcGateContactSpaceMin"))
  (srcGateContactSpaceMax (TECHgetRule "esd_srcGateContactSpaceMax"))
)
 ;; Formal parameters
 (
  (buttingTap           t)
  (w                  14.5)  
  (l                  0.55)  
  (m                    10)  
  (innerRingFetExtraRightSpace (TECHgetRule "esd_minExtraSpace_Right"))
  (innerRingFetExtraLeftSpace  (TECHgetRule "esd_minExtraSpace_Left"))
  (innerRingFetExtraTopSpace   (TECHgetRule "esd_minExtraSpace_Top"))
  (innerRingFetExtraBotSpace   (TECHgetRule "esd_minExtraSpace_Bottom"))
  (rings              "Both")
  (ringsMet1Off       "FALSE")
  (hvMode             "TRUE")
  (userOuterRingWidth (plus (times (TECHgetRuleWith  "minWidth" "licon1") 3)
				 (times 2 (TECHgetRuleWith  "minSpacing" "licon1")) 
				 (times 2.0 (TECHgetRuleWith  "minEnclosure" "li1" "mcon"))))
  (hspiceModel        "phvesd")
  (hspiceModelChoices (list "phvesd"))
  (srcGateContactSpace (TECHgetRule "esd_srcGateContactSpaceMin"))
  ;(drnGateContactSpace (TECHgetRule "esd_drnGateContactSpaceMin"))
  (drnGateContactSpaceParams (list (list (TECHgetRule "esd_drnGateContactSpace_1") (TECHgetRule "esd_drnGateContactSpace_1a") (TECHgetRule "esd_drnGateContactSpace_1b") "1.3, total width >= 116um")
				   (list (TECHgetRule "esd_drnGateContactSpace_2") (TECHgetRule "esd_drnGateContactSpace_2a") (TECHgetRule "esd_drnGateContactSpace_2b") "2.3, total width >= 116um")
				   (list (TECHgetRule "esd_drnGateContactSpace_3") (TECHgetRule "esd_drnGateContactSpace_3a") (TECHgetRule "esd_drnGateContactSpace_3b") "2.7, total width >= 116um")
				   (list (TECHgetRule "esd_drnGateContactSpace_4") (TECHgetRule "esd_drnGateContactSpace_4a") (TECHgetRule "esd_drnGateContactSpace_4b") "0.5, total width >= 400um")))
  (drnGateContactSpaceValue (list (TECHgetRule "esd_drnGateContactSpace_1") (TECHgetRule "esd_drnGateContactSpace_1a") (TECHgetRule "esd_drnGateContactSpace_1b") "1.3, total width >= 116um"))
  )
 )

(tfcDefineDeviceProp
 ;;(viewName  deviceName   propName      propValue)
 ("symbolic" "pEsdFet" "discreteWLs" t)  ;;Declares that the pEsdFet is a discrete device
) 

(tcDeclareDevice
 "symbolic" "esdCascodeFetClass" "pEsdCascodeFet"
 ;; Class parameters
 ((diffLayer            "diff")
  (gateLayer            "poly")
  (pgateLayer           (list "poly" "gate"))
  (wellLayer             "nwell")
  (diffImplant           "psdm")
  (diffImpEnc            (TECHgetRule "psd_5a"))
  (tapLayer             "tap")
  (tapImplant           "nsdm")
  (tapImpEnc             (TECHgetRule "nsd_5a"))
  (idLayer               (list "areaid" "esd"))
  (hvLayer               "hvi") ;; High Voltage Diffusion Layer(diff.hv)
  (drnInterconnect     `('("licon1" ,(TECHgetRuleWith  "minWidth" "licon1") 
			   ,(TECHgetRuleWith  "minSpacing" "licon1") 
                           ,(TECHgetRule "esd_dIntconn_cc_a") "li1" ,(TECHgetRule "esd_dIntconn_w") 
                           ,(TECHgetRuleWith  "minSpacing" "li1") ,(TECHgetRule "esd_dIntconn_minBevEdg_a"))
			 ;;'("contactLayerName" contactLayerWidth contactLayerSpace 
			 ;; contactColumnsNum "upperMetLayerName" metLayerWidth metLayerSpace metLayerBevelEdge)
			 '("mcon" ,(TECHgetRuleWith  "minWidth" "mcon") 
			   ,(TECHgetRuleWith  "minSpacing" "mcon") 
                           ,(TECHgetRule "esd_dIntconn_cc_b") "met1" ,(TECHgetRule "esd_dIntconn_minW") 
                           ,(TECHgetRule "esd_dIntconn_minS") ,(TECHgetRule "esd_dIntconn_minBevEdg_b"))))
  (srcInterconnect     `('("licon1" ,(TECHgetRuleWith  "minWidth" "licon1") 
			   ,(TECHgetRuleWith  "minSpacing" "licon1") 
                           ,(TECHgetRule "esd_sIntconn_cc_a") "li1" ,(TECHgetRule "esd_sIntconn_w") 
                           ,(TECHgetRuleWith  "minSpacing" "li1") ,(TECHgetRule "esd_sdIntconn_minBevEdg_a"))
			 ;;'("contactLayerName" contactLayerWidth contactLayerSpace 
			 ;; contactColumnsNum "upperMetLayerName" metLayerWidth metLayerSpace metLayerBevelEdge)
			 '("mcon" ,(TECHgetRuleWith  "minWidth" "mcon") 
			   ,(TECHgetRuleWith  "minSpacing" "mcon") 
                           ,(TECHgetRule "esd_sIntconn_cc_b") "met1" ,(TECHgetRule "esd_sIntconn_minW") 
                           ,(TECHgetRule "esd_sIntconn_minS") ,(TECHgetRule "esd_sIntconn_minBevEdg_b"))))
  (diffContact0Yenc      (TECHgetRule "esd_diffCon0Yenc"))
  (diffContact0Xenc      (TECHgetRule "esd_diffCon0Xenc"))
  (flareInDiff           (TECHgetRule "esd_flareInDiff"))
  (flareOutDiff          (TECHgetRule "esd_flareOutDiff"))
  (flareExt              (TECHgetRule "esd_flareExt"))
  (InnerRingInterconnectHoriz `('("licon1" ,(TECHgetRuleWith  "minWidth" "licon1") 
			     ,(TECHgetRuleWith  "minSpacing" "licon1") 
                             ,(TECHgetRule "esd_InnRingIntconn_cc_a") "li1" 
			     ,(TECHgetRuleWith  "minEnclosure" "li1" "mcon")
                             ,(TECHgetRule "esd_InnRingIntconn_innerminBevEdg_a") ,(TECHgetRule "esd_InnRingIntconn_outerminBevEdg_a"))
			   ;;'("contactLayerName" contactLayerWidth contactLayerSpace 
			   ;; contactColumnsNum "upperMetLayerName" metContactEnc innerMetBevelEdge outerMetBevelEdge)
			   '("mcon" ,(TECHgetRuleWith  "minWidth" "mcon") 
			     ,(TECHgetRuleWith  "minSpacing" "mcon") ,(TECHgetRule "esd_InnRingIntconn_cc_b") "met1" 
			     ,(TECHgetRule "esd_InnRingIntconn_minEnc")
                             ,(TECHgetRule "esd_InnRingIntconn_innerminBevEdg_b") ,(TECHgetRule "esd_InnRingIntconn_outerminBevEdg_b"))))
  (InnerRingInterconnectVert `('("licon1" ,(TECHgetRuleWith  "minWidth" "licon1") 
			     ,(TECHgetRuleWith  "minSpacing" "licon1") 
                             ,(TECHgetRule "esd_InnRingIntconn_cc_c") "li1" 
			     ,(TECHgetRuleWith  "minEnclosure" "li1" "mcon")
                             ,(TECHgetRule "esd_InnRingIntconn_innerminBevEdg_c") ,(TECHgetRule "esd_InnRingIntconn_outerminBevEdg_c"))
			   ;;'("contactLayerName" contactLayerWidth contactLayerSpace 
			   ;; contactColumnsNum "upperMetLayerName" metContactEnc innerMetBevelEdge outerMetBevelEdge)
			   '("mcon" ,(TECHgetRuleWith  "minWidth" "mcon") 
			     ,(TECHgetRuleWith  "minSpacing" "mcon") ,(TECHgetRule "esd_InnRingIntconn_cc_d") "met1" 
			     ,(TECHgetRule "esd_InnRingIntconn_minEnc")
                             ,(TECHgetRule "esd_InnRingIntconn_innerminBevEdg_d") ,(TECHgetRule "esd_InnRingIntconn_outerminBevEdg_d"))))
  (OuterRingInterconnect `('("licon1" ,(TECHgetRuleWith  "minWidth" "licon1") 
			     ,(TECHgetRuleWith  "minSpacing" "licon1") ,(TECHgetRule "esd_OutRingIntconn_cc_a") "li1" 
			     ,(TECHgetRuleWith  "minEnclosure" "li1" "mcon") 
                             ,(TECHgetRule "esd_OutRingIntconn_innerminBevEdg_a") ,(TECHgetRule "esd_OutRingIntconn_outerminBevEdg_a"))
			   ;;'("contactLayerName" contactLayerWidth contactLayerSpace 
			   ;; contactColumnsNum "upperMetLayerName" metContactEnc innerMetBevelEdge outerMetBevelEdge)
			   '("mcon" ,(TECHgetRuleWith  "minWidth" "mcon") 
			     ,(TECHgetRuleWith  "minSpacing" "mcon") ,(TECHgetRule "esd_OutRingIntconn_cc_b") "met1" 
			     ,(TECHgetRule "esd_OutRingIntconn_minEnc")
                             ,(TECHgetRule "esd_OutRingIntconn_innerminBevEdg_b") ,(TECHgetRule "esd_OutRingIntconn_outerminBevEdg_b"))))
  (OuterInnerRingSpace   (TECHgetRule "esd_outerInnerRingSpace"))
  (fetDiffInnerRingSpace (TECHgetRule "esd_fetDiffInnRingSpace"))
  (hvWellDiffTapEnc      (TECHgetRule "esd_hvWellTapEnc"))
  (hvLayerDiffTapEnc     (TECHgetRule "esd_HVIdifftapEnc"))
  (mosType              "pmos")
  (singleFlare          "TRUE")
  (sharedCascodeDiffWidth      (TECHgetRuleWith "minSpacing" "poly"))
  (minInnerRingFetExtraRightSpace (TECHgetRule "esd_minExtraSpace_Right"))
  (minInnerRingFetExtraLeftSpace  (TECHgetRule "esd_minExtraSpace_Left"))
  (minInnerRingFetExtraTopSpace   (TECHgetRule "esd_minExtraSpace_Top"))
  (minInnerRingFetExtraBotSpace   (TECHgetRule "esd_minExtraSpace_Bottom"))
  (srcGateContactSpace (TECHgetRule "esd_srcGateContactSpaceMin"))
  (buttingTapWidth     (TECHgetRule "esd_fetDiffInnRingSpace"))
  (minimumM            (TECHgetRule "esd_minM"))
)
 ;; Formal parameters
 (
  (buttingTap           t)
  (w                  14.5)  
  (l                  0.55)  
  (m                    10)  
  (innerRingFetExtraRightSpace 0)
  (innerRingFetExtraLeftSpace 0)
  (innerRingFetExtraTopSpace  1.0)
  (innerRingFetExtraBotSpace  1.0)
  (rings              "Both")
  (ringsMet1Off       "FALSE")
  (hvMode             "TRUE")
  (userOuterRingWidth (plus (times (TECHgetRuleWith  "minWidth" "licon1") 3)
				 (times 2 (TECHgetRuleWith  "minSpacing" "licon1")) 
				 (times 2.0 (TECHgetRuleWith  "minEnclosure" "li1" "mcon"))))
  (hspiceModel        "phvesd")
  (hspiceModelChoices (list "phvesd"))
  ;(drnGateContactSpace (TECHgetRule "esd_drnGateContactSpaceMin"))
  (drnGateContactSpaceParams (list (list (TECHgetRule "esd_drnGateContactSpace_1") (TECHgetRule "esd_drnGateContactSpace_1a") (TECHgetRule "esd_drnGateContactSpace_1b") "1.3, total width >= 116um")
				   (list (TECHgetRule "esd_drnGateContactSpace_2") (TECHgetRule "esd_drnGateContactSpace_2a") (TECHgetRule "esd_drnGateContactSpace_2b") "2.3, total width >= 116um")
				   (list (TECHgetRule "esd_drnGateContactSpace_3") (TECHgetRule "esd_drnGateContactSpace_3a") (TECHgetRule "esd_drnGateContactSpace_3b") "2.7, total width >= 116um")
				   (list (TECHgetRule "esd_drnGateContactSpace_4") (TECHgetRule "esd_drnGateContactSpace_4a") (TECHgetRule "esd_drnGateContactSpace_4b") "0.5, total width >= 400um")))
  (drnGateContactSpaceValue (list (TECHgetRule "esd_drnGateContactSpace_1") (TECHgetRule "esd_drnGateContactSpace_1a") (TECHgetRule "esd_drnGateContactSpace_1b") "1.3, total width >= 116um"))
  )
 )
(tfcDefineDeviceProp
 ;;(viewName  deviceName   propName      propValue)
 ("symbolic" "pEsdCascodeFet" "discreteWLs" t)  ;;Declares that the pEsdCascodeFet is a discrete device
)
 
;; PnR li1 to met1 contact
(tcDeclareDevice
           "symbolic" "syEnhContact" "L1M1_PR"
           ;; Class Parameters
           (
            (layer1         "li1")
            (layer2         "met1")
            (viaLayer      "mcon")
            (via1Width      (TECHgetRuleWith "minWidth"        "mcon"))
            (via1Space      (TECHgetRuleWith "minSpacing"      "mcon"))
            (layer1EncVia1  (TECHgetRuleWith "minEnclosure"    "li1" "mcon"))
            (layer2XEncVia1 (TECHgetRuleWith "minEnclosure"    "met1" "mcon"))
            (layer2YEncVia1 (TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
            (halfgrid       (quotient (TECHgetLayerProp "li1"  'snapGrid) 2.0))
            )
           ;; Formal Parameters
           (
            (row            1)
            (column         1)
            (xPitch         (plus (TECHgetRuleWith "minWidth"   "mcon")
                                  (TECHgetRuleWith "minSpacing" "mcon")))
            (yPitch         (plus (TECHgetRuleWith "minWidth"   "mcon")
                                  (TECHgetRuleWith "minSpacing" "mcon")))
            (w                    (TECHgetRuleWith "minWidth"   "mcon"))
            (l                    (TECHgetRuleWith "minWidth"   "mcon"))
            )
           )

          (tcSetDeviceProp "symbolic" "L1M1_PR"
                           list("res" (TECHgetRule "rcm1l1") ))

          ;; PnR met1 to met2 contact
          (tcDeclareDevice
           "symbolic" "syEnhContact" "M1M2_PR"
           ;; Class Parameters
           (
            (layer1         "met1")
            (layer2         "met2")
            (viaLayer       "via")
            (via1Width      (TECHgetRuleWith "minWidth"        "via"))
            (via1Space      (TECHgetRuleWith "minSpacing"      "via"))
            (layer1XEncVia1 (TECHgetRuleWith "minEnclosure"    "met1" "via"))
            (layer1YEncVia1 (TECHgetRuleWith "minEnclosureAny" "met1" "via"))
            (layer2XEncVia1 (TECHgetRuleWith "minEnclosureAny" "met2" "via"))
            (layer2YEncVia1 (TECHgetRuleWith "minEnclosure"    "met2" "via"))
            (halfgrid       (quotient (TECHgetLayerProp "met1" 'snapGrid) 2.0))
            )
           ;; Formal Parameters
           (
            (row            1)
            (column         1)
            (xPitch         (plus (TECHgetRuleWith "minWidth"   "via")
                                  (TECHgetRuleWith "minSpacing" "via")))
            (yPitch         (plus (TECHgetRuleWith "minWidth"   "via")
                                  (TECHgetRuleWith "minSpacing" "via")))
            (w                    (TECHgetRuleWith "minWidth"   "via"))
            (l                    (TECHgetRuleWith "minWidth"   "via"))
            )
           )

          (tcSetDeviceProp "symbolic" "M1M2_PR"
                           list("res" (TECHgetRule "rcvia") ))

 (symContactDevice
  ;; layer1 = top routing layer; layer2 = bottom routing layer
  ;; ( name     viaLayer   viaPurpose
  ;;     layer1   purpose1   [ implantLpp1 ]
  ;;     layer2   purpose2   [ implantLpp2 ]
  ;;     viaWidth viaLength
  ;;     [ (rows cols xPitch yPitch xBias yBias) ]
  ;;     encLayer1 encLayer2 [ l_legalRegion ]
  ;; )

  ( "TPL1_C"    "licon1" "drawing"   "li1" "drawing"   "tap" "drawing"
    (TECHgetRuleWith "minWidth" "licon1") (TECHgetRuleWith "minWidth" "licon1")
    ( 1 1 0 0 center center )
    (TECHgetRuleWith "minEnclosure" "li1" "licon1")
    (TECHgetRuleWith "minEnclosure" "tap" "licon1")
    _NA_
  )

  ( "PYL1_C"    "licon1" "drawing"     "poly"  "drawing"   "li1" "drawing" 
	("npc" "drawing" ((TECHgetRuleWith "minEnclosure" "npc" "licon1") - 
	(TECHgetRuleWith "minEnclosure" "poly" "licon1")))
    (TECHgetRuleWith "minWidth"     "licon1")  (TECHgetRuleWith   "minWidth" "licon1")
    ( 1 1 0 0 center center )
    (TECHgetRuleWith "minEnclosure" "poly"  "licon1")
    (TECHgetRuleWith "minEnclosure" "li1"  "licon1")
    _NA_
  )

  ( "L1M1_C"  "mcon" "drawing"      "met1"  "drawing"  "li1"   "drawing"
    (TECHgetRuleWith "minWidth"     "mcon") (TECHgetRuleWith   "minWidth" "mcon")
    ( 1 1 0 0 center center )
    (TECHgetRuleWith "minEnclosure" "met1"  "mcon")
    (TECHgetRuleWith "minEnclosure" "li1"   "mcon")
    _NA_
  )

( "M1M2_C"    "via" "drawing"     "met2"  "drawing"   "met1" "drawing"
    (TECHgetRuleWith "minWidth"     "via")  (TECHgetRuleWith   "minWidth" "via")
    ( 1 1 0 0 center center )
    (TECHgetRuleWith "minEnclosure" "met2"  "via")
    (TECHgetRuleWith "minEnclosure" "met1"  "via")
    _NA_
  )
  )

(tcSetDeviceProp  "symbolic" "TPL1_C"
                  list("res" (TECHgetRule "rcl1p") ))
(tcSetDeviceProp  "symbolic" "PYL1_C"
                  list("res" (TECHgetRule "rcl1gp") ))
(tcSetDeviceProp "symbolic" "L1M1_C" 
		 list("res" (TECHgetRule "rcm1l1") ))
(tcSetDeviceProp  "symbolic" "M1M2_C" 
		  list("res" (TECHgetRule "rcvia") ))
 ;; ----------------------------------------------------------------------

) ; end devices

(lxRules

(let

(
;;; ------------------------------------------------------------------------
;;; Varibales used in gate_con MPP Template
;;; ------------------------------------------------------------------------
npcWidth
polyWidth
licon1Width
npcEnc
liEnc
PYL1_offSet
m1Width
mconWidth
m1mconAnyEnc
m1mconEnc
L1M1Width
viaWidth
m2viaAnyEnc
m2viaEnc
L1M2Width
via2Width		
m2via2Enc		
m3via2AnyEnc
m3via2Enc		
M2M3Width	  
tapWidth
psdmWidth
psdmEnc
taplicon1Enc
nsdmEnc
nsdmWidth
nwellEnc
)

(setq licon1Width		(TECHgetRuleWith "minWidth" "licon1"))
(setq npcEnc		    (TECHgetRuleWith "minEnclosure" "npc" "licon1"))
(setq npcWidth      (licon1Width + 2*npcEnc))
(setq liEnc		      (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
(setq PYL1Width     (licon1Width + 2*liEnc))
(setq PYL1_offSet   (npcEnc - liEnc))

(setq m1Width		    (TECHgetRuleWith "minWidth" "met1"))
(setq mconWidth		  (TECHgetRuleWith "minWidth" "mcon"))
(setq m1mconAnyEnc	(TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
(setq m1mconEnc		  (TECHgetRuleWith "minEnclosure" "met1" "mcon"))
(setq L1M1Width	    (mconWidth + 2*m1mconAnyEnc))

(setq viaWidth		  (TECHgetRuleWith "minWidth" "via"))
(setq m2viaAnyEnc		(TECHgetRuleWith "minEnclosureAny" "met2" "via"))
(setq m2viaEnc		  (TECHgetRuleWith "minEnclosure" "met2" "via"))
(setq L1M2Width	    (viaWidth + 2*m2viaAnyEnc))

(setq via2Width		  (TECHgetRuleWith "minWidth" "via2"))
(setq m2via2Enc		  (TECHgetRuleWith "minEnclosure" "met2" "via2"))
(setq m3via2AnyEnc	(TECHgetRuleWith "minEnclosureAny" "met3" "via2"))
(setq m3via2Enc		  (TECHgetRuleWith "minEnclosure" "met3" "via2"))
(setq M2M3Width	    (via2Width + 2*m2via2Enc))
(setq M2M3_offSet   (m2via2Enc - m3via2Enc))
(setq M2M3via2Enc   (max (TECHgetRuleWith "minEnclosure" "met3" "via2") (TECHgetRuleWith "minEnclosure" "met2" "via2")))


(setq tapWidth		  (TECHgetRuleWith "minWidth" "tap"))
(setq psdmWidth		  (TECHgetRuleWith "minWidth" "psdm"))
(setq psdmEnc       (TECHgetRule "psd_5b"))
(setq taplicon1Enc  (TECHgetRuleWith "minEnclosure" "tap" "licon1"))

(setq nsdmEnc       (TECHgetRule "nsd_5b"))
(setq nsdmWidth		  (TECHgetRuleWith "minWidth" "nsdm"))
(setq nwellEnc      (TECHgetRuleWith "minEnclosure" "nwell" "tap"))

(eval
 
 `(lxMPPTemplates
   	
	; ------------------------------------
	; Defining template for pydi_mpp
	; ------------------------------------
	
	(PYL1_MPP
		; Master path args
		(("poly" "drawing")	,PYL1Width	t	"flush" 0.000 0.000 "center" 0.000 nil)
		;offset subpath args
		nil
		;Enclosure subpath args
		((("li1" "drawing") ,liEnc t 0.000 0.00	nil)
		(("npc" "drawing") ,-PYL1_offSet t ,PYL1_offSet ,PYL1_offSet nil)
     )
		;Sub rectangle args
		((("licon1" "drawing")	nil nil t 0.000 "center" nil ,-npcEnc ,-npcEnc "minimum" nil ,npcEnc	,npcEnc)
     )
	 ); End of pyli_mpp template

   (PYM1_MPP
		; Master path args
		(("poly" "drawing")	,PYL1Width	t	"flush" 0.000 0.000 "center" 0.000 nil)
		;offset subpath args
		nil
		;Enclosure subpath args
		((("li1" "drawing") ,liEnc t 0.000 0.00	nil)
		(("npc" "drawing") ,-PYL1_offSet t ,PYL1_offSet ,PYL1_offSet nil)
		(("met1" "drawing") ,PYL1_offSet t 0.00 0.00	nil)
     )
		;Sub rectangle args
		((("licon1" "drawing")	nil nil t 0.000 "center" nil ,-npcEnc ,-npcEnc "minimum" nil ,npcEnc	,npcEnc)
		 (("mcon" "drawing")	  nil nil t 0.000 "center" nil ,-m1mconEnc ,-m1mconEnc "minimum" nil ,m1mconEnc	,m1mconEnc)
     )
	 ); End of PYM1

   (L1M1_MPP
		; Master path args
		(("met1" "drawing")	,L1M1Width	t	"flush" 0.000 0.000 "center" 0.000 nil)
		;offset subpath args
		nil
		;Enclosure subpath args
		((("li1" "drawing") nil t 0.00 0.00	nil)
     )
		;Sub rectangle args
		((("mcon" "drawing")	nil nil t 0.000 "center" nil ,-m1mconEnc ,-m1mconEnc "minimum" nil ,m1mconEnc	,m1mconEnc)
     )
	 ); End of L1M1
   
   (L1M2_MPP
		; Master path args
		(("met2" "drawing")	,L1M2Width	t	"flush" 0.000 0.000 "center" 0.000 nil)
		;offset subpath args
		nil
		;Enclosure subpath args
		((("li1" "drawing") nil t 0.00 0.00	nil)
		 (("met1" "drawing") nil t 0.00 0.00	nil)
     )
		;Sub rectangle args
		((("mcon" "drawing")	nil nil t 0.000 "center" nil ,-m1mconEnc ,-m1mconEnc "minimum" nil ,m1mconEnc	,m1mconEnc)
		 (("via" "drawing")	nil nil t 0.000 "center" nil ,-m2viaEnc ,-m2viaEnc "minimum" nil ,m2viaEnc	,m2viaEnc)
     )
	 ); End of L1M2

   (M1M2_MPP
		; Master path args
		(("met2" "drawing")	,L1M2Width	t	"flush" 0.000 0.000 "center" 0.000 nil)
		;offset subpath args
		nil
		;Enclosure subpath args
		((("met1" "drawing") nil t 0.00 0.00	nil)
     )
		;Sub rectangle args
		 ((("via" "drawing")	nil nil t 0.000 "center" nil ,-m2viaEnc ,-m2viaEnc "minimum" nil ,m2viaEnc	,m2viaEnc)
     )
	 ); End of M1M2

   (M2M3_MPP
		; Master path args
		(("met2" "drawing")	,M2M3Width	t	"flush" 0.000 0.000 "center" 0.000 nil)
		;offset subpath args
		nil
		;Enclosure subpath args
		((("met3" "drawing") ,M2M3_offSet t 0.00 0.00	nil)
     )
		;Sub rectangle args
		 ((("via2" "drawing")	nil nil t 0.000 "center" nil ,-M2M3via2Enc ,-M2M3via2Enc "minimum" nil ,M2M3via2Enc	,M2M3via2Enc)
     )
	 ); End of M2M3

   (PTPL1_MPP
		; Master path args
		(("tap" "drawing")	,licon1Width	t	"flush" 0.000 0.000 "center" 0.000 nil)
		;offset subpath args
		nil
		;Enclosure subpath args
		((("li1" "drawing") nil t 0.00 0.00	nil)
		 (("psdm" "drawing")  ,-psdmEnc t ,psdmEnc ,psdmEnc	nil)
     )
		;Sub rectangle args
		 ((("licon1" "drawing")	nil nil t 0.000 "center" nil ,-taplicon1Enc ,-taplicon1Enc "minimum" nil ,taplicon1Enc	,taplicon1Enc)
     )
	 ); End of PTPL1

  (PTPM1_MPP
		; Master path args
		(("tap" "drawing")	,licon1Width	t	"flush" 0.000 0.000 "center" 0.000 nil)
		;offset subpath args
		nil
		;Enclosure subpath args
		((("li1" "drawing") nil t 0.00 0.00	nil)
		 (("met1" "drawing") ,-m1mconEnc t 0.00 0.00	nil)
		 (("psdm" "drawing")  ,-psdmEnc t ,psdmEnc ,psdmEnc	nil)
     )
		;Sub rectangle args
		 ((("licon1" "drawing")	nil nil t 0.000 "center" nil ,-taplicon1Enc ,-taplicon1Enc "minimum" nil ,taplicon1Enc	,taplicon1Enc)
		  (("mcon" "drawing")	nil nil t 0.000 "center" nil ,-m1mconEnc ,-m1mconEnc "minimum" nil ,m1mconEnc	,m1mconEnc)
     )
	 ); End of PTPM1

 (NTPL1_MPP
		; Master path args
		(("tap" "drawing")	,licon1Width	t	"flush" 0.000 0.000 "center" 0.000 nil)
		;offset subpath args
		nil
		;Enclosure subpath args
		((("li1" "drawing") nil t 0.00 0.00	nil)
		 (("nsdm" "drawing")  ,-nsdmEnc t ,nsdmEnc ,nsdmEnc	nil)
		 (("nwell" "drawing")  ,-nwellEnc t ,nwellEnc ,nwellEnc	nil)
     )
		;Sub rectangle args
		 ((("licon1" "drawing")	nil nil t 0.000 "center" nil ,-taplicon1Enc ,-taplicon1Enc "minimum" nil ,taplicon1Enc	,taplicon1Enc)
     )
	 ); End of NTPL1

 (NTPM1_MPP
		; Master path args
		(("tap" "drawing")	,licon1Width	t	"flush" 0.000 0.000 "center" 0.000 nil)
		;offset subpath args
		nil
		;Enclosure subpath args
		((("li1" "drawing") nil t 0.00 0.00	nil)
		 (("met1" "drawing") ,-m1mconEnc t 0.00 0.00	nil)
		 (("nsdm" "drawing")  ,-nsdmEnc t ,nsdmEnc ,nsdmEnc	nil)
		 (("nwell" "drawing")  ,-nwellEnc t ,nwellEnc ,nwellEnc	nil)
     )
		;Sub rectangle args
		 ((("licon1" "drawing")	nil nil t 0.000 "center" nil ,-taplicon1Enc ,-taplicon1Enc "minimum" nil ,taplicon1Enc	,taplicon1Enc)
		  (("mcon" "drawing")	nil nil t 0.000 "center" nil ,-m1mconEnc ,-m1mconEnc "minimum" nil ,m1mconEnc	,m1mconEnc)
     )
	 ); End of NTPM1

   );lxMPPTemplates
 );eval
);let
);
(devices

 (tcCreateCDSDeviceClass)
;;;  
;;; $Id: discreteContactRingClass.il,v 1.2 2005/05/19 21:30:44 kmi Exp $ %T%
;;; 
;;; discreteContactRingClass.il
;;; 
;;; Copyright (c) 2005 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Apr 08, 2005
;;; Author: Kresimir Mihic (kmi) @KYCC
;;; 
;;; Description:
;;;   This is a part of the device library.  It will be used to generate
;;; contacts within a ring structure.  All of the parameters are formal
;;; parameters.  It is not intended to be used directly by designers,
;;; but it is intended to be instantiated by other device in the device lib.
;;; The class is to be used in sealRing pcell (because of assumptions made in the class design)
;;; 
;;; Revision History:
;;;   kmi 04/11/05 initial version
;;;   kmi 05/19/05 updating the class for bevel edges
;;; 
;;; 

(putpropqq discreteContactRingClass "$Id: discreteContactRingClass.il,v 1.2 2005/05/19 21:30:44 kmi Exp $ %T%" SCCS)

(tcCreateDeviceClass
 "symbolic" "discreteContactRingClass"
 ;; Class parameters
 ( 
 )
 ;; Formal parameters
 (
  (grid                  (TECHgetProp snapGrid))
  (numRowsInBevel           0) ;; number of rows in beveled edges, if set to 0, the code derives it
  (contact1Layer             (list "hilite" "drawing")); the first contact 
  (contact2Layer            nil); the second contact, drawn by having the contact1 as the reference
  (con2con1EncX             0.0); contact2 enclosure of contact1 in X direction
  (con2con1EncY             0.0); contact2 enclosure of contact1 in X direction
  (contact1Width             0.1); contact1 width (no need for contact2 width as we have enclosures)
  (contact1Length            0.1); contact2 length (no need for contact2 length as we have enclosures)
  (bevelLength              1.0)
  (contact2SpaceY           0.1)
  (contact2SpaceX           0.1)
  (contact2OffsetX          0.0)
  (contact2OffsetY          0.0)
  (contact2Rows             0); number of contact2 rows
  (contact1SpaceY           0.1)
  (contact1SpaceX           0.1)
  (contact1OffsetX          0.0)
  (contact1OffsetY          0.0)
  (contact1Rows             1); number of contact1 rows
  (l                        10.0)
  (w                        10.0)
  )

 ;; s2 is the square root of 2.0
 (setq s2 (sqrt 2.0))

 (setq contact1Rows (max 1 contact1Rows)) 
 (setq contact1PitchY (plus contact1Width contact1SpaceY))
 (setq contact1PitchX (plus contact1Length contact1SpaceX))
 (setq contact2PitchY (plus contact1Width contact2SpaceY))
 (setq contact2PitchX (plus contact1Length contact2SpaceX))
 (setq ringWidth (max 0.0 (difference (times contact1Rows contact1PitchY) contact1SpaceY)
                          (difference (times contact2Rows contact2PitchY) contact2SpaceY)))
 (setq bevelLength (max bevelLength (plus ringWidth contact1SpaceX) (plus ringWidth contact2SpaceX))) 
 (when numRowsInBevel<=0
   (setq numRowsInBevel (max 1 (difference (plus contact1Rows contact2Rows) 1))))

 (setq noRivets (if contact2Rows>0 2 1))

 ;; do not start with contacts on bevelLength as it may make SP error with the
 ;; solid ring on dieSeal. The precise offset value is SP(1-cos45)
 (setq spOffset (times contact1SpaceX (1-1/s2)))
 (setq spOffset (times (ceiling (plus (quotient spOffset grid) 1e-6)) grid))
 (for contactN 1 noRivets 
   (setq contactPitchY (if (equal contactN 1) contact1PitchY contact2PitchY))
   (setq contactPitchX (if (equal contactN 1) contact1PitchX contact2PitchX))
   (setq contactSpaceX (if (equal contactN 1) contact1SpaceX contact2SpaceX))
   (setq contactSpaceY (if (equal contactN 1) contact1SpaceY contact2SpaceY))
   (setq xOffset (if (equal contactN 1) contact1OffsetX contact2OffsetX))
   (setq yOffset (if (equal contactN 1) contact1OffsetY contact2OffsetY))
   (setq numRows (if (equal contactN 1) contact1Rows contact2Rows))

   ;;
   ;; 1.  Draw the contacts along the top and bottom edge
   ;;
   ;; second contacts must be aligned with the first one
   (when (equal contactN 1)
     (setq usedL (difference l (times 2 (plus spOffset bevelLength))))
     (setq numColB (max 1 (fix (plus (quotient (plus usedL contactSpaceX) contactPitchX) 1e-6))))
     (setq contactSideLB (difference (times numColB contactPitchX) contactSpaceX))
     (setq numColOffsetB (quotient (difference usedL contactSideLB) 2))
     (setq numColOffsetB (times (fix (plus (quotient numColOffsetB grid) 1e-6)) grid))
   )
   (setq xOriginB (plus numColOffsetB bevelLength xOffset spOffset))
   (setq yOriginB yOffset)
   (setq yOriginT (difference w yOffset))
   (setq Y0_bottom yOriginB)
   (setq Y0_top yOriginT)
   (for row 1 numRows
      (setq X0 xOriginB)
      (setq Y1_bottom (plus Y0_bottom contact1Width))
      (setq Y1_top (difference Y0_top contact1Width))
      (for col 1 numColB
        (setq X1 (plus X0 contact1Length))
        (when X1<(difference l (plus bevelLength spOffset))
          (dbCreateRect tcCellView contact1Layer
               (list X0:Y0_bottom X1:Y1_bottom))
          (dbCreateRect tcCellView contact1Layer (list X0:Y0_top X1:Y1_top))
          (when contact2Layer 
           (dbCreateRect tcCellView contact2Layer
               (list (difference X0 con2con1EncX):(difference Y0_bottom con2con1EncY)
                     (plus X1 con2con1EncX):(plus Y1_bottom con2con1EncY)))
           (dbCreateRect tcCellView contact2Layer
               (list (difference X0 con2con1EncX):(plus Y0_top con2con1EncY)
                     (plus X1 con2con1EncX):(difference Y1_top con2con1EncY)))
          )
        )
        (setq X0 (plus X0 contactPitchX))
      )
      (setq Y0_bottom (plus Y0_bottom contactPitchY))
      (setq Y0_top (difference Y0_top contactPitchY))
   )

   ;;
   ;; 2.  Draw the contacts along the left & right edge
   ;;
   ;; second contacts must be aligned with the first one
   (when (equal contactN 1)
     (setq usedW (difference w (times 2 (plus spOffset bevelLength))))
     (setq numColS (max 1 (fix (plus (quotient (plus usedW contactSpaceX) contactPitchX) 1e-6))))
     (setq contactSideLS (difference (times numColS contactPitchX) contactSpaceX))
     (setq numColOffsetS (quotient (difference usedW contactSideLS) 2))
     (setq numColOffsetS (times (fix (plus (quotient numColOffsetS grid) 1e-6)) grid))
   )
   (setq xOriginL (plus numColOffsetS bevelLength xOffset spOffset))
   (setq yOriginL yOffset)
   (setq yOriginR (difference l yOffset))

   (setq Y0_left yOriginL)
   (setq Y0_right yOriginR)
   (for row 1 numRows
      (setq X0 xOriginL)
      (setq Y1_left (plus Y0_left contact1Width))
      (setq Y1_right (difference Y0_right contact1Width))
      (for col 1 numColS
        (setq X1 (plus X0 contact1Length))
        (when X1<(difference w (plus spOffset bevelLength))
          (dbCreateRect tcCellView contact1Layer
                        (list Y0_left:X0 Y1_left:X1))
          (dbCreateRect tcCellView contact1Layer
                        (list Y0_right:X0 Y1_right:X1))

         (when contact2Layer
          (dbCreateRect tcCellView contact2Layer
                        (list (difference Y0_left con2con1EncY):(difference X0 con2con1EncX)
                              (plus Y1_left con2con1EncY):(plus X1 con2con1EncX)))
          (dbCreateRect tcCellView contact2Layer
                        (list (plus Y0_right con2con1EncY):(difference X0 con2con1EncX)
                              (difference Y1_right con2con1EncY):(plus X1 con2con1EncX)))
         )
       )

          (setq X0 (plus X0 contactPitchX))
      )
      (setq Y0_left (plus Y0_left contactPitchY))
      (setq Y0_right (difference Y0_right contactPitchY))
   )
   ;;
   ;; 3.  Draw the contacts in bevelled corners
   ;;
   ;; no contact2 in corners
   (when (equal contactN 1)
    (setq bevelSpace (min contactSpaceY contactSpaceX))
    (setq bevelPitch (min contactPitchY contactPitchX))
    (setq usedC (difference bevelLength (plus bevelSpace contact1Length con2con1EncX)))
    (setq numColC (max 1 (fix (plus (quotient (plus usedC bevelSpace) bevelPitch) 1e-6))))
    (setq contactSideC (difference (times numColC bevelPitch) bevelSpace))
    (setq numColOffsetC (difference usedC contactSideC))
    (setq numColOffsetC (times (fix (plus (quotient numColOffsetC grid) 1e-6)) grid))

    (setq bevelWidth (max 0.0 (difference (times numRowsInBevel bevelPitch) bevelSpace)))
    (setq centerOffset (quotient (difference ringWidth bevelWidth) 2) )
    (setq centerOffset  (times (fix (plus (quotient  (times centerOffset s2) grid) 1e-6)) grid))
    (setq yOriginB (plus yOffset centerOffset numColOffsetC bevelSpace contact1Length con2con1EncX))
    (setq yOriginT (difference w (plus yOffset centerOffset numColOffsetC bevelSpace contact1Width con2con1EncX)))
    (setq xOriginR (plus (difference l bevelLength) numColOffsetC bevelSpace con2con1EncX))
    (setq xOriginL (difference bevelLength (plus numColOffsetC bevelSpace con2con1EncX)))
    (setq Y0_bottom yOriginB)
    (setq Y0_top yOriginT)
    (for row 1 numRowsInBevel
      (setq X0_R (difference xOriginR con2con1EncX))
      (setq X0_L (plus xOriginL con2con1EncX))
      (for col 1 numColS
        (setq X1_R (plus X0_R contact1Length))
        (setq X1_L (difference X0_L contact1Length))
        (setq Y1_bottom (plus Y0_bottom contact1Width))
        (setq Y1_top (difference Y0_top contact1Width))
        ;; as  all corners are identical it is enough to check for y1_bottom only
        (when Y1_bottom<(difference bevelLength bevelSpace)
          (dbCreateRect tcCellView contact1Layer (list X0_R:Y0_bottom X1_R:Y1_bottom))
          (dbCreateRect tcCellView contact1Layer (list X0_L:Y0_bottom X1_L:Y1_bottom))
          (dbCreateRect tcCellView contact1Layer (list X0_R:Y0_top X1_R:Y1_top))
          (dbCreateRect tcCellView contact1Layer (list X0_L:Y0_top X1_L:Y1_top))
          (when contact2Layer
           (dbCreateRect tcCellView contact2Layer
               (list (difference X0_R con2con1EncX):(difference Y0_bottom con2con1EncY)
                     (plus X1_R con2con1EncX):(plus Y1_bottom con2con1EncY)))
           (dbCreateRect tcCellView contact2Layer
               (list (plus X0_L con2con1EncX):(difference Y0_bottom con2con1EncY)
                     (difference X1_L con2con1EncX):(plus Y1_bottom con2con1EncY)))
           (dbCreateRect tcCellView contact2Layer
               (list (difference X0_R con2con1EncX):(plus Y0_top con2con1EncY)
                     (plus X1_R con2con1EncX):(difference Y1_top con2con1EncY)))
           (dbCreateRect tcCellView contact2Layer
               (list (plus X0_L con2con1EncX):(plus Y0_top con2con1EncY)
                     (difference X1_L con2con1EncX):(difference Y1_top con2con1EncY)))
          )
         )
        (setq X0_R (plus X0_R bevelPitch))
        (setq X0_L (difference X0_L bevelPitch))
        (setq Y0_bottom (plus Y0_bottom bevelPitch))
        (setq Y0_top (difference Y0_top bevelPitch))
      )
      (setq Y0_bottom (plus yOriginB (times row bevelPitch)))
      (setq Y0_top (difference yOriginT (times row bevelPitch)))
    )
   )
 )
)

;;; 
;;; $Id: dieSealRingClassAdv.il,v 1.6 2009/09/09 19:05:28 lpj Exp $ %T%
;;; 
;;; dieSealRingClassAdv.il
;;; 
;;; Copyright (c) 2005 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Apr 11, 2005
;;; Author: Kresimir Mihic (kmi) @KYCC
;;; 
;;; Description:
;;;   This is the device library code for the die seal ring.  It will put
;;; Nikon Crosses in the four corners, each covered with the pad cut.
;;; It will use the generic ring to draw all of the rings.
;;; 
;;; Revision History:
;;;   kmi 04/11/05 initial version (updated dieSealRingClassAdv)
;;;   kmi 04/20/05 SPR24764
;;;   kmi 05/19/05 updating the class for bevel edges and offset lists
;;;   lpj 06/02/09 added laserTargets
;;;

(putpropqq dieSealRingClassAdv "$Id: dieSealRingClassAdv.il,v 1.6 2009/09/09 19:05:28 lpj Exp $ %T%" SCCS)

(tcCreateDeviceClass
 "symbolic" "dieSealRingClassAdv"
 ;; Class parameters
 (
  ;; due to a Cadence feature, you must have your list quoted similar to below
  ;; each item is a list of '(layer spaceFromOutside layerWidth makePin grid)
  (solidLayerRing '('(("tap" "drawing") 5.0 3.0 nil 0.05)
               '(("met1" "drawing") (1.3 3.4 6.0) 2.5 nil 0.05)
               '(("met2" "drawing") 5.5 4.0 t 0.05)))
  ;; each item is a list of 
  ;; '(contact1Layer1 contact2Layer con2con1EncX con2con1EncY spaceFromOutside contact1Width contact1Length
  ;;   contact1NoRow contact1OffsetX contact1OffsetY contact1SpaceX contact1SpaceY
  ;;   contact2NoRow contact2OffsetX contact2OffsetY contact2SpaceX contact2SpaceY grid)
  ;; spaceFromOutside can be a list or a single value
  (discreteContactRing nil)
  
  (sealringIdLayer (list "y1" "drawing"))
  (sealringIdWidth 0.0)
  (sealringGrid 0.0)
  (genericRingName "")
  (nikonCrossName "")
  (discreteContactRingName "")
  (laserTargetXName "")
  (laserTargetYName "")
  (padLayer (list "y0" "drawing"))
  (padGrid  0.0)
  (padEncNikon 0.0)
  (padEncNikonInside 0.0)
  ;; following 4 are needed to define zones for metal-stress 
  (rdLayer nil)          ;; layer marking dead zone 
  (rcLayer nil)          ;; layer marking critical corner
  (dLayer  nil)          ;; layer marking critical side
  (scaleF  1)            ;; scale factor for the technology
  ;; following 4 parameters are optional - no need to be pass these from device
  (criticalL 5080.0)     ;; determining die length 200 mils on Si (scale factor=1)
  (defRd   0.0)          ;; default rd is 0 mils on si (for scale factor=1) 
  (defRc   152.4)        ;; default rc is 6 mils on si (for scale factor=1)
  (defD    101.6)        ;; default D  is 4 mils on si (for scale factor=1)
 )
 ;; Formal parameters
 (
  (w 0.0)
  (l 0.0)
  (extraCornerCut 0.0)
  (laserTargetsDef "OFF")
  (laserTargetsEn nil)
  (laserTargetsOrient nil)
 )
 (setq extraCornerCut_orig extraCornerCut)
 (setq tg22_5   0.4142)

 (setq dbuperuu tcCellView~>DBUPerUU)
 (setq grid (fix (times dbuperuu sealringGrid)))
 (setq s2 (sqrt 2.0))
 ;; get the input parameters in integers
 (foreach param '(sealringIdWidth padEncNikon padEncNikonInside w l extraCornerCut padGrid)
     (set param (fix (times dbuperuu (eval param))))
     (unless (zerop (mod (eval param) grid))
	 (set param (xtimes (xquotient (xplus (eval param) grid) grid) grid))
     )
 )

 (setq net (dbMakeNet tcCellView "ppd"))
 (setq minSealRingIdWidth 0)

 ;; open the generic ring and do sanity checks on it
 (setq ringId (dbOpenCellView tcCellView~>lib genericRingName "symbolic" nil "rn"))
 (unless ringId
     (error "dieSealRingClassAdv:  Cannot find/open generic ring %s\n" genericRingName)
 )
 (unless ringId~>isParamCell
     (error "dieSealRingClassAdv:  Ring %s is not a pcell\n" genericRingName)
 )

 ;; open the generic contact ring and do sanity checks on it
 (when (discreteContactRingName != "")
     (setq contactRingId (dbOpenCellView tcCellView~>lib discreteContactRingName "symbolic" nil "rn"))
     (unless contactRingId
	 (error "dieSealRingClassAdv:  Cannot find/open generic contact ring %s\n" discreteContactRingName)
     )
     (unless contactRingId~>isParamCell
	 (error "dieSealRingClassAdv:  Rivet ring %s is not a pcell\n" discreteContactRingName)
     )
 )
 (when (and discreteContactRing !contactRingId) (error "dieSealRingClassAdv:  Rivet ring class not defined\n"))


 ;; open the nikon cross and do sanity checks on it
 (setq nikonId (dbOpenCellView tcCellView~>lib nikonCrossName "symbolic" nil "rn"))
 (unless nikonId
     (error "dieSealRingClassAdv:  Cannot find/open nikon cross %s\n" nikonCrossName)
 )
 (unless nikonId~>isParamCell
     (error "dieSealRingClassAdv:  Nikon cross %s is not a pcell\n" nikonCrossName)
 )

 ;; grow the width and length by 2 * sealring width so that the user can
 ;; enter the size of the die
 (foreach layer solidLayerRing
     (setq thisLpp (car layer))
     (setq ringWidth (fix (times dbuperuu (caddr layer))))
     (setq makePin (nth 3 layer))
     (setq layGrid (fix (times dbuperuu (nth 4 layer))))
     (setq spacingList (cadr layer))
     (when !(listp spacingList) (setq spacingList (list spacingList))) 
     (foreach SP spacingList
       (setq spacing (fix (times dbuperuu SP)))
       (setq intRingLayers (cons (list thisLpp spacing ringWidth makePin layGrid) intRingLayers))

     ;; make sure that the sealring ID layer will enclose this layer
     (when (lessp minSealRingIdWidth (xplus spacing ringWidth))
	 (setq minSealRingIdWidth (xplus spacing ringWidth)))
     )
 )

 (setq sealringIdWidth (max sealringIdWidth minSealRingIdWidth))
 (setq w (xplus w (xtimes 2 sealringIdWidth)))
 (setq l (xplus l (xtimes 2 sealringIdWidth)))


 ;; Create Metal_Stress zones

 (setq len (quotient l dbuperuu))
 (setq wid (quotient w dbuperuu))
 (setq smalldie nil)


 (if l > w then
     (setq ar (quotient len wid))
     (if len < (criticalL/scaleF) then
	 (setq smalldie t))
  else
     (setq ar (quotient wid len))
     (if wid < (criticalL/scaleF) then
	 (setq smalldie t))
 )

 (if smalldie then
     rd = defRd/scaleF
     rc = defRc/scaleF
     d  = defD/scaleF
  else
     rd = (6.43-(1.28*ar)+(0.69*ar*ar))*25.4/scaleF
     rc = (11.25+(3.47*ar))*25.4/scaleF
     d  = (-1.31+(3.87*ar))*25.4/scaleF
 )

 ;; Create deadzone
 (if rdLayer && (rd > 0) then     
     (dbCreateEllipse tcCellView rdLayer (list -rd:-rd rd:rd))
     (dbCreateEllipse tcCellView rdLayer (list -rd:(wid-rd) rd:(wid+rd)))
     (dbCreateEllipse tcCellView rdLayer (list (len-rd):-rd (len+rd):rd))
     (dbCreateEllipse tcCellView rdLayer (list (len-rd):(wid-rd) (len+rd):(wid+rd))) 
 )

 ;; Create critical corner
 (if rcLayer then
     (dbCreateEllipse tcCellView rcLayer (list -rc:-rc rc:rc))
     (dbCreateEllipse tcCellView rcLayer (list -rc:(wid-rc) rc:(wid+rc)))
     (dbCreateEllipse tcCellView rcLayer (list (len-rc):-rc (len+rc):rc))
     (dbCreateEllipse tcCellView rcLayer (list (len-rc):(wid-rc) (len+rc):(wid+rc)))
 )

 ;; Create critical side
 (if dLayer then
     (dbCreateRect tcCellView dLayer (list 0:0 d:wid))
     (dbCreateRect tcCellView dLayer (list 0:0 len:d))
     (dbCreateRect tcCellView dLayer (list 0:(wid-d) len:wid))
     (dbCreateRect tcCellView dLayer (list (len-d):0 len:wid))
 )
 
 ;; create the nikon cross and pad opening in the LL corner
 (setq dbid (dbCreateParamInst tcCellView nikonId "llNikon" (quotient padEncNikon dbuperuu):(quotient padEncNikon dbuperuu) "R0" 1 nil))
 (setq theMaster dbid~>master)
 (setq cutPoints nil)
 (foreach point theMaster~>outlinePoints
     (setq cutPoints (cons (plus padEncNikon (fix (times dbuperuu (car point)))):(plus padEncNikon (fix (times dbuperuu (cadr point))))
			   cutPoints))
 )
 ;; calculate the corner cut necessary to satisfy the pad enclosure of
 ;; the nikon cross
 (when (zerop padEncNikonInside) (setq padEncNikonInside padEncNikon))
 (setq cornerCut (fix (plus (times 2.0 padEncNikon) (times s2 padEncNikonInside) (times dbuperuu (car (nth 3 theMaster~>outlinePoints))) (times dbuperuu (car (nth 2 theMaster~>outlinePoints))))))

 ;; snap the cornerCut to grid
 (unless (zerop (mod cornerCut padGrid))
     (setq cornerCut (xtimes (xquotient (xplus cornerCut padGrid) padGrid) padGrid))
 )

 ;; Bevels are not creted when the bevel length in a corner is less than 
 ;; ringWidth-ringWidth*(sqr(2)-1)     (see ringClass.il)
 ;; so we might have sealRing with 90 degrees corners. In order to avoid this, bevelAdd is calculated .
 (setq bevelAdd 0)
 (foreach layer intRingLayers
     (setq spacing (cadr layer))
     (setq bevelLength (plus cornerCut -spacing (fix (times spacing (difference s2 1.0)))))
     (setq minBevelRequired (ceiling (times (caddr layer) 1.0)))
     (setq bevelAjdust (difference minBevelRequired bevelLength))
     (if (and (greaterp bevelAjdust 0) (leqp bevelAdd bevelAjdust)) then
         (setq bevelAdd bevelAjdust)
     )
 )
 ;; bevelAdd should be snaped to grid otherwise there may exist
 ;; a space between padRing and triangular pad in corners. 
 ;; RingClass snaps bevel values so we must do the same here before
 ;; building pad corners and calling the class.
 ;;
 ;; Snap it up to a grid : 
 ;; The procedure (xtimes (xquotient (xplus ... used throughout this code
 ;; will round up a number to the grid ( example: 20 will become 25) what must be prevented
 ;; ( example: 20 must stay 20, and 21 should be snapped to 25) 
 ;; The following code does it. 
 ;; Converting padGrid to a float number
 (setq padGridFloat (times padGrid 1.0))
 ;; snap up to a grid 
 (setq bevelAdd (times (ceiling (quotient bevelAdd padGridFloat)) padGrid))

 (setq extraCornerCut (plus extraCornerCut bevelAdd))

 ;; divide the cut points by the dbuperuu
 (setq realCutPoints nil)
 (foreach point cutPoints
     (setq realCutPoints (cons (quotient (car point) dbuperuu):(quotient (cadr point) dbuperuu)
			       realCutPoints)
     )
 )
 (setq realCutPoints (reverse realCutPoints))
 (setq padLayerId_1 (dbCreatePolygon tcCellView padLayer
		      (cons 0.0:0.0
			(append realCutPoints
				(list
				 (car realCutPoints)
				 0.0:0.0
				 (quotient (plus cornerCut extraCornerCut) dbuperuu):0.0
				 0.0:(quotient (plus cornerCut extraCornerCut) dbuperuu))))))

  

 ;; create the nikon cross and pad opening in the LR corner
 (setq dbid (dbCreateParamInst tcCellView nikonId "lrNikon" (quotient (difference l padEncNikon) dbuperuu):(quotient padEncNikon dbuperuu) "MY" 1 nil))
 (setq theMaster dbid~>master)
 (setq cutPoints nil)
 (foreach point theMaster~>outlinePoints
     (setq cutPoints (cons (difference l padEncNikon (fix (times dbuperuu (car point)))):(plus padEncNikon (fix (times dbuperuu (cadr point))))
			   cutPoints))
 )

 ;; divide the cut points by the dbuperuu
 (setq realCutPoints nil)
 (foreach point cutPoints
     (setq realCutPoints (cons (quotient (car point) dbuperuu):(quotient (cadr point) dbuperuu)
			       realCutPoints)
     )
 )
 (setq realCutPoints (reverse realCutPoints))
 (setq padLayerId_2 (dbCreatePolygon tcCellView padLayer
		      (cons (quotient l dbuperuu):0.0
			(append realCutPoints
				(list 
				 (car realCutPoints)
				 (quotient l dbuperuu):0.0
				 (quotient (difference l cornerCut extraCornerCut) dbuperuu):0.0
				 (quotient l dbuperuu):(quotient (plus cornerCut extraCornerCut) dbuperuu))))))

 ;; create the nikon cross and pad opening in the UR corner
 (setq dbid (dbCreateParamInst tcCellView nikonId "urNikon" (quotient (difference l padEncNikon) dbuperuu):(quotient (difference w padEncNikon) dbuperuu) "R180" 1 nil))
 (setq theMaster dbid~>master)
 (setq cutPoints nil)
 (foreach point theMaster~>outlinePoints
     (setq cutPoints (cons (difference l padEncNikon (fix (times dbuperuu (car point)))):(difference w padEncNikon (fix (times dbuperuu (cadr point))))
			   cutPoints))
 )
 ;; divide the cut points by the dbuperuu
 (setq realCutPoints nil)
 (foreach point cutPoints
     (setq realCutPoints (cons (quotient (car point) dbuperuu):(quotient (cadr point) dbuperuu)
			       realCutPoints)
     )
 )
 (setq realCutPoints (reverse realCutPoints))
 (setq padLayerId_3 (dbCreatePolygon tcCellView padLayer
		      (cons (quotient l dbuperuu):(quotient w dbuperuu)
			(append realCutPoints
				(list
				 (car realCutPoints)
				 (quotient l dbuperuu):(quotient w dbuperuu)
				 (quotient (difference l cornerCut extraCornerCut) dbuperuu):(quotient w dbuperuu)
				 (quotient l dbuperuu):(quotient (difference w cornerCut extraCornerCut) dbuperuu))))))


 ;; create the nikon cross and pad opening in the UL corner
 (setq dbid (dbCreateParamInst tcCellView nikonId "ulNikon" (quotient padEncNikon dbuperuu):(quotient (difference w padEncNikon) dbuperuu) "MX" 1 nil))
 (setq theMaster dbid~>master)
 (setq cutPoints nil)
 (foreach point theMaster~>outlinePoints
     (setq cutPoints (cons (plus padEncNikon (fix (times (car point) dbuperuu))):(difference w padEncNikon (fix (times dbuperuu (cadr point))))
			   cutPoints))
 )

 ;; divide the cut points by the dbuperuu
 (setq realCutPoints nil)
 (foreach point cutPoints
     (setq realCutPoints (cons (quotient (car point) dbuperuu):(quotient (cadr point) dbuperuu)
			       realCutPoints)
     )
 )
 (setq realCutPoints (reverse realCutPoints))
 (setq padLayerId_4 (dbCreatePolygon tcCellView padLayer
		      (cons 0.0:(quotient w dbuperuu)
			(append realCutPoints
				(list
				 (car realCutPoints)
				 0.0:(quotient w dbuperuu)
				 (quotient (plus cornerCut extraCornerCut) dbuperuu):(quotient w dbuperuu)
				 0.0:(quotient (difference w cornerCut extraCornerCut) dbuperuu))))))

 ;; Create laser targets
 (if (and (nequal laserTargetsDef "ON") (nequal laserTargetsDef "OFF")) then
     (error "dieSealRingClassAdv: Invalid value for laserTargets\n")
 )
 (if (and laserTargetsEn (equal laserTargetsDef "ON"))  then

     ;; open the laser targets and do sanity checks on them
     (setq laserTargetIdX (dbOpenCellView tcCellView~>lib laserTargetXName "symbolic" nil "rn"))
     (setq laserTargetIdY (dbOpenCellView tcCellView~>lib laserTargetYName "symbolic" nil "rn"))
     (unless laserTargetIdX
         (error "dieSealRingClassAdv:  Cannot find/open laser target %s\n" laserTargetXName)
     )
     (unless laserTargetIdX~>isParamCell
         (error "dieSealRingClassAdv:  Laser target %s is not a pcell\n" laserTargetXName)
     )
     (unless laserTargetIdY
         (error "dieSealRingClassAdv:  Cannot find/open laser target %s\n" laserTargetYName)
     )
     (unless laserTargetIdY~>isParamCell
         (error "dieSealRingClassAdv:  Laser target %s is not a pcell\n" laserTargetYName)
     )

     ;; Get the maximum ring width for laser target offset 
     (setq maxRingSpace 0.000)
     (foreach layer solidLayerRing
         (setq ringWidth (caddr layer))
         (setq spaceFromEdge (cadr layer))
         (setq ringSpace (times (plus ringWidth spaceFromEdge) dbuperuu))
         (if ringSpace > maxRingSpace then
             (setq maxRingSpace ringSpace)
         )
     )

     ;; total offset is the extra space needed as a result of the cornerCut, extraCornerCut, and ringOffset
     (setq totalOffset (quotient (plus cornerCut extraCornerCut (times s2 maxRingSpace)) 2.000))
     (setq totalOffset (quotient (times (ceiling (quotient totalOffset padGridFloat)) padGrid) dbuperuu))

     (setq ltBboxX laserTargetIdX~>bBox)
     (setq ltWidthX  (nth 1 (nth 1 ltBboxX))-(nth 1 (nth 0 ltBboxX)))
     (setq ltHeightX (nth 0 (nth 1 ltBboxX))-(nth 0 (nth 0 ltBboxX)))
     (setq ltBboxY laserTargetIdY~>bBox)
     (setq ltWidthY  (nth 1 (nth 1 ltBboxY))-(nth 1 (nth 0 ltBboxY)))
     (setq ltHeightY (nth 0 (nth 1 ltBboxY))-(nth 0 (nth 0 ltBboxY)))

     (if (equal laserTargetsOrient "R0") then
       (dbCreateParamInst tcCellView laserTargetIdX "lazX_SW" totalOffset:totalOffset "R0" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdY "lazY_SW" (totalOffset+ltWidthX):totalOffset "R0" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdX "lazX_NW" totalOffset:(wid-totalOffset-ltHeightX) "R0" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdY "lazY_NW" (totalOffset+ltWidthX):(wid-totalOffset-ltHeightY) "R0" 1 nil) 
       (dbCreateParamInst tcCellView laserTargetIdX "lazX_NE" (len-totalOffset):(wid-totalOffset) "R180" 1 nil)
     )
     (if (equal laserTargetsOrient "R90") then
       (dbCreateParamInst tcCellView laserTargetIdX "lazX_NW" totalOffset:(wid-totalOffset-ltHeightX) "R0" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdY "lazY_NW" (totalOffset+ltWidthX):(wid-totalOffset-ltHeightY) "R0" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdX "lazX_NE" (len-totalOffset):(wid-totalOffset) "R180" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdY "lazY_NE" (len-(totalOffset+ltWidthX)):(wid-totalOffset) "R180" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdX "lazX_SE" (len-totalOffset):(totalOffset+ltHeightX) "R180" 1 nil)
     )
     (if (equal laserTargetsOrient "R180") then
       (dbCreateParamInst tcCellView laserTargetIdX "lazX_NE" (len-totalOffset):(wid-totalOffset) "R180" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdY "lazY_NE" (len-(totalOffset+ltWidthX)):(wid-totalOffset) "R180" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdX "lazX_SE" (len-totalOffset):(totalOffset+ltHeightX) "R180" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdY "lazY_SE" (len-(totalOffset+ltWidthX)):(totalOffset+ltHeightY) "R180" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdX "lazX_SW" totalOffset:totalOffset "R0" 1 nil)
     )
     (if (equal laserTargetsOrient "R270") then
       (dbCreateParamInst tcCellView laserTargetIdX "lazX_SE" (len-totalOffset):(totalOffset+ltHeightX) "R180" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdY "lazY_SE" (len-(totalOffset+ltWidthX)):(totalOffset+ltHeightY) "R180" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdX "lazX_SW" totalOffset:totalOffset "R0" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdY "lazY_SW" (totalOffset+ltWidthX):totalOffset "R0" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdX "lazX_NW" totalOffset:(wid-totalOffset-ltHeightX) "R0" 1 nil)
     )
     (if (equal laserTargetsOrient "MX") then
       (dbCreateParamInst tcCellView laserTargetIdX "lazX_NE" (len-totalOffset):(wid-totalOffset) "R180" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdY "lazY_NE" (len-(totalOffset+ltWidthX)):(wid-totalOffset) "R180" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdX "lazX_SE" (len-totalOffset):(totalOffset+ltHeightX) "R180" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdY "lazY_SE" (len-(totalOffset+ltWidthX)):(totalOffset+ltHeightY) "R180" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdX "lazX_NW" totalOffset:(wid-totalOffset-ltHeightX) "R0" 1 nil)
     )
     (if (equal laserTargetsOrient "MXR90") then
       (dbCreateParamInst tcCellView laserTargetIdX "lazX_SE" (len-totalOffset):(totalOffset+ltHeightX) "R180" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdY "lazY_SE" (len-(totalOffset+ltWidthX)):(totalOffset+ltHeightY) "R180" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdX "lazX_SW" totalOffset:totalOffset "R0" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdY "lazY_SW" (totalOffset+ltWidthX):totalOffset "R0" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdX "lazX_NE" (len-totalOffset):(wid-totalOffset) "R180" 1 nil)
     )
     (if (equal laserTargetsOrient "MY") then
       (dbCreateParamInst tcCellView laserTargetIdX "lazX_SW" totalOffset:totalOffset "R0" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdY "lazY_SW" (totalOffset+ltWidthX):totalOffset "R0" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdX "lazX_NW" totalOffset:(wid-totalOffset-ltHeightX) "R0" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdY "lazY_NW" (totalOffset+ltWidthX):(wid-totalOffset-ltHeightY) "R0" 1 nil) 
       (dbCreateParamInst tcCellView laserTargetIdX "lazX_SE" (len-totalOffset):(totalOffset+ltHeightX) "R180" 1 nil)
     )
     (if (equal laserTargetsOrient "MYR90") then
       (dbCreateParamInst tcCellView laserTargetIdX "lazX_NW" totalOffset:(wid-totalOffset-ltHeightX) "R0" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdY "lazY_NW" (totalOffset+ltWidthX):(wid-totalOffset-ltHeightY) "R0" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdX "lazX_NE" (len-totalOffset):(wid-totalOffset) "R180" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdY "lazY_NE" (len-(totalOffset+ltWidthX)):(wid-totalOffset) "R180" 1 nil)
       (dbCreateParamInst tcCellView laserTargetIdX "lazX_SW" totalOffset:totalOffset "R0" 1 nil)
     )

     (dbClose laserTargetIdX)
     (dbClose laserTargetIdY)
 )

 ;; loop through all of the ring layers and draw them


 (setq ringCount 0)
 (foreach layer intRingLayers

     (setq spacing (cadr layer))
     (setq ringWidth (caddr layer))
     (setq grid (nth 4 layer))

      ;; calculate the extra offset required because of the bevelled corners
      (setq extraOffset (fix (times spacing (difference s2 1.0))))
      (setq bevelLength (plus cornerCut -spacing extraOffset))

      (setq dbid
	   (dbCreateParamInst tcCellView ringId (sprintf nil "ring%d" ringCount)
			      0.0:0.0 "R0" 1
			      (list
			       (list "w" "int" (fix (difference w (times 2 spacing))))
			       (list "l" "int" (fix (difference l (times 2 spacing))))
			       (list "xOffset" "int" spacing)
			       (list "yOffset" "int" spacing)
			       (list "ringLayer" "list" nil)
			       (list "ringWidth" "int" ringWidth)
			       (list "additionalWidthInBevel" "int" 0)
			       (list "llBevelLength" "int" (plus extraCornerCut bevelLength))
			       (list "ulBevelLength" "int" (plus extraCornerCut bevelLength))
			       (list "lrBevelLength" "int" (plus extraCornerCut bevelLength))
			       (list "urBevelLength" "int" (plus extraCornerCut bevelLength))
			       (list "bevelTheOutside" "boolean" t)
			       (list "grid" "int" grid)
 			       (list "breakupPolygons" "boolean" "TRUE")
			      )
	   )
     )

     (setq theMaster dbid~>master)
     (setq dbid1 (dbCreatePolygon tcCellView (car layer) theMaster~>ringPoints1))
     (setq dbid2 (dbCreatePolygon tcCellView (car layer) theMaster~>ringPoints2))
     (setq dbid3 (dbCreatePolygon tcCellView (car layer) theMaster~>ringPoints3))
     (setq dbid4 (dbCreatePolygon tcCellView (car layer) theMaster~>ringPoints4))
     (dbAddFigToNet dbid1 net)
     (dbAddFigToNet dbid2 net)
     (dbAddFigToNet dbid3 net)
     (dbAddFigToNet dbid4 net)

     (when (nth 3 layer)
	 (setq pinid (dbCreatePin net dbid1))
	 pinid~>accessDir = (list "top" "bottom" "left" "right")
	 (setq pinid (dbCreatePin net dbid2))
	 pinid~>accessDir = (list "top" "bottom" "left" "right")
	 (setq pinid (dbCreatePin net dbid3))
	 pinid~>accessDir = (list "top" "bottom" "left" "right")
	 (setq pinid (dbCreatePin net dbid4))
	 pinid~>accessDir = (list "top" "bottom" "left" "right")
     )


     (setq ringCount (plus ringCount 1))
 )

 (when (listp discreteContactRing)
  (setq ringCount 0)
  (foreach layer discreteContactRing
     (setq contact1Layer (nth 0 layer))
     (setq contact2Layer (nth 1 layer))
     (setq con2con1EncX  (nth 2 layer))
     (setq con2con1EncY  (nth 3 layer))
     (setq spacingList     (nth 4 layer))
     (setq contact1Width  (nth 5 layer))
     (setq contact1Length (nth 6 layer))
     (setq contact1Rows  (nth 7 layer))
     (setq contact1OffsetX (nth 8 layer))
     (setq contact1OffsetY (nth 9 layer))
     (setq contact1SpaceX  (nth 10 layer))
     (setq contact1SpaceY  (nth 11 layer))
     (setq contact2Rows    (nth 12 layer))
     (setq contact2OffsetX (nth 13 layer))
     (setq contact2OffsetY (nth 14 layer))
     (setq contact2SpaceX  (nth 15 layer))
     (setq contact2SpaceY  (nth 16 layer))
     (setq grid (nth 17 layer))
     (if (nth 19 layer)
       (setq numRowsInBevel (nth 19 layer))
       (setq numRowsInBevel (nth 18 layer))
     )
     ;; calculate the extra offset required because of the bevelled corners
     (when !(listp spacingList) (setq spacingList (list spacingList))) 
     (foreach spacing spacingList
      (setq extraOffset (fix (times (times spacing dbuperuu)  (tg22_5-1))))
;      (setq bevelLength (plus cornerCut bevelAdd extraOffset -(times contact1Width/2 dbuperuu)))
      (setq bevelLength (plus cornerCut bevelAdd extraOffset))
      (setq bevelLength (quotient bevelLength dbuperuu))
      (setq bevelLength (times (fix (plus (quotient bevelLength grid) 1e-6)) grid))
      (setq dbid
           (dbCreateParamInst tcCellView contactRingId (sprintf nil "contact%d" ringCount)
                              spacing:spacing "R0" 1
                              (list
			       (list "w" "float" (difference wid (times 2 spacing)))
			       (list "l" "float" (difference len (times 2 spacing)))
			       (list "bevelLength" "float" (plus extraCornerCut_orig bevelLength))
                               (list "contact1Layer" "list" contact1Layer)
                               (list "contact2Layer" "list" contact2Layer)
                               (list "con2con1EncX"   "float" con2con1EncX)
                               (list "con2con1EncY"   "float" con2con1EncY)
                               (list "contact1Width"  "float" contact1Width)
                               (list "contact1Length" "float" contact1Length)
                               (list "contact1Rows"  "int" contact1Rows)
                               (list "contact1OffsetX" "float" contact1OffsetX)
                               (list "contact1OffsetY" "float" contact1OffsetY)
                               (list "contact1SpaceY"  "float" contact1SpaceY)
                               (list "contact1SpaceX"  "float" contact1SpaceX)
                               (list "contact2Rows"    "int" contact2Rows)
                               (list "contact2OffsetX" "float" contact2OffsetX)
                               (list "contact2OffsetY" "float" contact2OffsetY)
                               (list "contact2SpaceY"  "float" contact2SpaceY)
                               (list "contact2SpaceX"  "float" contact2SpaceX)
                               (list "grid" "float" grid)
                               (list "numRowsInBevel"  "int" numRowsInBevel)
                              )
           )
     )
     (setq ringCount (plus ringCount 1))
 )))

 ;; create the sealring identification layer around the die seal ring
 (setq dbid (dbCreateParamInst tcCellView ringId "sealid" 0.0:0.0 "R0" 1
			       (list
				(list "w" "int" w)
				(list "l" "int" l)
				(list "xOffset" "int" 0)
				(list "yOffset" "int" 0)
				(list "ringLayer" "list" nil)
				(list "ringWidth" "int" sealringIdWidth)
				(list "additionalWidthInBevel" "int" 0)
				(list "llBevelLength" "int" (plus cornerCut extraCornerCut))
				(list "ulBevelLength" "int" (plus cornerCut extraCornerCut))
				(list "lrBevelLength" "int" (plus cornerCut extraCornerCut))
				(list "urBevelLength" "int" (plus cornerCut extraCornerCut))
				(list "bevelTheOutside" "boolean" "FALSE")
				(list "grid" "int" (fix (times dbuperuu sealringGrid)))
				(list "breakupPolygons" "boolean" "TRUE")
			       )
	    )
 )
 (when sealringIdLayer
     (setq theMaster dbid~>master)
     (dbCreatePolygon tcCellView sealringIdLayer theMaster~>ringPoints1)
     (dbCreatePolygon tcCellView sealringIdLayer theMaster~>ringPoints2)
     (dbCreatePolygon tcCellView sealringIdLayer theMaster~>ringPoints3)
     (dbCreatePolygon tcCellView sealringIdLayer theMaster~>ringPoints4)
 )

 (dbClose ringId)
 (dbClose nikonId)
 
)
;;; 
;;; $Id: ringClass.il,v 1.2 2002/05/13 05:18:18 lpn Exp $ %T%
;;; 
;;; ringClass.il
;;; 
;;; Copyright (c) 1997 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Feb 18, 1997
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This is the device library code for a generic ring.  Many devices
;;; in the device library use a ring type of structure.  Using this device,
;;; a lot of code will not have to be rewritten.
;;;   All of the parameters are formal parameters.  This ring is not meant
;;; to be placed by designers, but by other devices in the device library.
;;; 
;;; Revision History:
;;;   gtc 04/22/97  Giving sensible default parameter values
;;;   gtc 07/25/97  Adding option to break into 4 polygons to work around
;;;                 a vampire drc bug
;;;   lpn 04/02/2002 Added the bevelTheOutsideNoInside switch to have bevel on the 
;;;                  outside and no bevel inside.
;;; 

(putpropqq ringClass "$Id: ringClass.il,v 1.2 2002/05/13 05:18:18 lpn Exp $ %T%" SCCS)

(tcCreateDeviceClass
 "symbolic" "ringClass"
 ;; Class parameters
 (
 )
 ;; Formal parameters
 (
  (w                      50.0)
  (l                      50.0)
  (xOffset                0.0)
  (yOffset                0.0)
  (ringLayer              (list "hilite" "drawing"))
  (ringWidth              4.0)
  (additionalWidthInBevel 0.0)
  (llBevelLength          0.0)
  (ulBevelLength          0.0)
  (lrBevelLength          0.0)
  (urBevelLength          0.0)
  (bevelTheOutside        "FALSE")
  (bevelTheOutsideNoInside "FALSE")
  (grid                   0.05)
  (breakupPolygons        "FALSE")
 )

 ;; in some situations, it is desirable to bevel the inside of the corners,
 ;; but not the outside.  If so, "bevelTheOutside" should be false/nil
 (when (equal bevelTheOutside "FALSE")
     (setq bevelTheOutside nil)
 )

 ;; in some situations, it is desirable to bevel the inside of the corners,
 ;; but not the outside.  If so, "bevelTheOutside" should be false/nil
 (when (equal bevelTheOutsideNoInside "FALSE")
     (setq bevelTheOutsideNoInside nil)
 )

 ;; in some situations, vampire cannot handle the complex geometries that
 ;; this pcell can  spit out.  Therefore, we must breakup this one polygon
 ;; into four polygons that still make up the same shape.  This seems to
 ;; appease the current vampire bug
 (when (equal breakupPolygons "FALSE")
     (setq breakupPolygons nil)
 )

 ;; there is a big load of geometry/math behind this equation, but it
 ;; all boils down to the following equation.  (See the design document
 ;; for the geometry/math.)  The "bevelInsideOffset" is necessary to
 ;; maintain the minimum width throughout the bevel.  bevelInsideOffset is:
 ;;    o how much higher point 1 is wrt point 9  (points are in figure below)
 ;;    o how much further to the right point 2 is wrt point 10
 (setq s2 (sqrt 2.0))
 (setq bevelInsideOffset
       (quotient (plus (times ringWidth (difference s2 1.0))
		       (times s2 additionalWidthInBevel))
		 grid))


 ;; now use a "ceiling" function to snap it up to the next grid.
 ;; this assumes that the grid is < 1.0
 (setq fixedBev (fix (plus 1e-6 bevelInsideOffset)))
 (cond ((lessp (difference bevelInsideOffset fixedBev) 1e-6)
	(setq bevelInsideOffset (times grid fixedBev))
       )
     (t
      (setq bevelInsideOffset (times grid (plus 1.0 fixedBev)))
     )
 )


 ;; "cannotBevelLength" is the point at which the inside bevel will be
 ;; pinched off.  We do not allow bevels to occur when the bevel length
 ;; in a corner is less than this value
 (setq cannotBevelLength (difference ringWidth bevelInsideOffset))


 ;; determine whether it should bevel in each corner
 (cond ((setq llBevel (greaterp llBevelLength cannotBevelLength))
	(setq arraySize 4)
       )
     (t (setq arraySize 2))
 )

 (cond ((setq lrBevel (greaterp lrBevelLength cannotBevelLength))
	(setq arraySize (plus arraySize 4))
       )
     (t (setq arraySize (plus arraySize 2)))
 )

 (cond ((setq urBevel (greaterp urBevelLength cannotBevelLength))
	(setq arraySize (plus arraySize 4))
       )
     (t (setq arraySize (plus arraySize 2)))
 )

 (cond ((setq ulBevel (greaterp ulBevelLength cannotBevelLength))
	(setq arraySize (plus arraySize 4))
       )
     (t (setq arraySize (plus arraySize 2)))
 )

 ;;     15_____________________________14
 ;;      /                              ;;     /    _______________________     ;;    /    /7                     6\     ;; 16/    /                         \    \13
 ;;  |    /8                         5\    |
 ;;  |   |                             |   |
 ;;  |   |                             |   |
 ;;  |   |                             |   |
 ;;  |   |1                           4|   |
 ;;  | /  \                           /    |
 ;;  9\    \                         /    /12
 ;;    \    \2_____________________3/    /
 ;;     \                               /
 ;;    10\_____________________________/11
 ;;
 ;; There is a point at each vertex of the ring that will be used to create
 ;; the ring.  The list of points that will be used to create the ring is:
 ;; (1, 8, 7, 6, 5, 4, 3, 2, 1, 9, 10, 11, 12, 13, 14, 15, 16, 9, 1)
 ;; If they opt to create the ring in four sections, the sections will be:
 ;; section 1:  (1, 2, 3, 11, 10, 9)
 ;; section 2:  (3, 4, 5, 13, 12, 11)
 ;; section 3:  (5, 6, 7, 15, 14, 13)
 ;; section 4:  (7, 8, 1, 9, 16, 15)
 ;;
 ;; This will have the cut in the ring between points 1 and 9.
 ;; Whenever there is not going to be a bevel in a corner, the points
 ;; will be merged in that corner.  For example, if there was not a
 ;; bevel in the LL (lower left) corner, points 1 & 2 will become one point,
 ;; and points 9 and 10 will become one point.
 ;;
 ;; The order in which it calculates the points and puts them in the array is:
 ;; 
 ;; time   --->
 ;;index  corner
 ;;              [0]                             1
 ;;              [1]        UL                8
 ;;              [2]        UL             7
 ;;              [3]      UR            6  |
 ;;              [4]      UR         5     |
 ;;     /\       [5]    LR        4        |
 ;;     |        [6]    LR     3  |        |
 ;;     |        [7]  LL    2     |        |
 ;; insideIndex  [8]  LL 1        |        |
 ;; outsideIndex [9]  LL 9        |        |
 ;;     |        [10] LL   10     |        |
 ;;     |        [11]   LR    11  |        |
 ;;     \/       [12]   LR       12        |
 ;;              [13]     UR        13     |
 ;;              [14]     UR           14  |
 ;;              [15]       UL            15
 ;;              [16]       UL               16
 ;;              [17]                            9
 ;;              [18]                            1
 ;;
 ;; For each non-bevelled corner, the two entries for that corner in the
 ;; first half of the array will be merged, and the two entries for that
 ;; corner in the second half of the array will be merged.  For example,
 ;; if the UR (upper right) corner was not bevelled, array entries number
 ;; 3 and 4 will be merged, and entries 13 and 14 will be merged.

 ;; the insideIndex will start in the middle and count down to 0
 (setq insideIndex (xquotient arraySize 2))

 ;; the outsideIndex will start in the middle +1 and count up to arraySize
 (setq outsideIndex (plus insideIndex 1))
 (setq arraySize (plus arraySize 3))  ;; to handle a cut in the ring

 ;; Initialize the ring points
 (declare theRingPoints[arraySize])
 (setq theOutsideX xOffset)
 (setq theOutsideY yOffset)

 ;; Start with the lower left corner
 (cond ((null llBevel)  ;; no bevel in the ll corner
	(setq theInsideX (plus theOutsideX ringWidth))
	(setq theInsideY (plus theOutsideY ringWidth))

	(setq beginningInsidePoint theInsideX:theInsideY)
	(setq beginningOutsidePoint theOutsideX:theOutsideY)

	;; add the inside points to the beginning of the ring points,
	;; and the outside points to the end of the ring points
	theRingPoints[insideIndex] = beginningInsidePoint
	theRingPoints[outsideIndex] = beginningOutsidePoint
	(setq insideIndex (difference insideIndex 1))
	(setq outsideIndex (plus outsideIndex 1))
       )

     (t ;; there is a bevel in the ll corner
      (setq theOutsideY (plus theOutsideY llBevelLength))
      (setq theInsideY (plus theOutsideY bevelInsideOffset))
     
      (setq theInsideX (plus theOutsideX ringWidth))

      (setq beginningInsidePoint theInsideX:theInsideY)
      (setq beginningOutsidePoint theOutsideX:theOutsideY)
 
      (cond (bevelTheOutsideNoInside
	     (setq theInsideY1 (plus yOffset ringWidth))
	     (setq beginningInsidePoint1 theInsideX:theInsideY1)
	     theRingPoints[insideIndex] = beginningInsidePoint1
	    )
	  (t
	   theRingPoints[insideIndex] = beginningInsidePoint
	  )
      )	  
      
      (setq insideIndex (difference insideIndex 1))
      (when bevelTheOutside
	  theRingPoints[outsideIndex] = beginningOutsidePoint
	  (setq outsideIndex (plus outsideIndex 1))
      )

      (setq theOutsideX (plus theOutsideX llBevelLength))
      (setq theOutsideY yOffset)
      (setq theInsideX (plus theOutsideX bevelInsideOffset))
      (setq theInsideY (plus theOutsideY ringWidth))
 

      (cond (bevelTheOutsideNoInside
	     theRingPoints[insideIndex] = beginningInsidePoint1
	    )
	  (t
	   theRingPoints[insideIndex] = theInsideX:theInsideY
	  )
      )
      
      (setq insideIndex (difference insideIndex 1))
      (cond (bevelTheOutside
	     theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	    )
	  (t
	   theRingPoints[outsideIndex] = xOffset:theOutsideY
	   beginningOutsidePoint = theRingPoints[outsideIndex]
	  )
      )
      (setq outsideIndex (plus outsideIndex 1))

     ) ;; done with the LL bevelled case
 ) ;; done with the LL corner

 (cond ((null lrBevel) ;; no bevel in the lr corner
	(setq theOutsideX (plus xOffset l))
	(setq theInsideX (difference theOutsideX ringWidth))

	theRingPoints[insideIndex] = theInsideX:theInsideY
	theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	(setq insideIndex (difference insideIndex 1))
	(setq outsideIndex (plus outsideIndex 1))
       )

     (t ;; there is a bevel in the lr corner
      (setq theOutsideX (plus xOffset l -lrBevelLength))
      (setq theInsideX (difference theOutsideX bevelInsideOffset))
      (cond (bevelTheOutsideNoInside
	     (setq theInsideX1 (plus xOffset l -ringWidth))
	     theRingPoints[insideIndex] = theInsideX1:theInsideY
	    )
	  (t
	   theRingPoints[insideIndex] = theInsideX:theInsideY
	  )
      )
      (setq insideIndex (difference insideIndex 1))
      (when bevelTheOutside
	  theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	  (setq outsideIndex (plus outsideIndex 1))
      )

      (setq theOutsideX (plus theOutsideX lrBevelLength))
      (setq theOutsideY (plus theOutsideY lrBevelLength))
      

      (cond (bevelTheOutsideNoInside
	     theRingPoints[insideIndex] = theInsideX1:theInsideY
	    )
	  (t
	   (setq theInsideX (difference theOutsideX ringWidth))
	   (setq theInsideY (plus theOutsideY bevelInsideOffset))
	   theRingPoints[insideIndex] = theInsideX:theInsideY
	  )
      )
      
      (setq insideIndex (difference insideIndex 1))
      (cond (bevelTheOutside
	     theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	    )
	  (t
	   theRingPoints[outsideIndex] = theOutsideX:yOffset
	  )
      )
      (setq outsideIndex (plus outsideIndex 1))
     ) ;; done with the LR bevelled case
 ) ;; done with the LR corner

 (cond ((null urBevel) ;; no bevel in the UR corner
	(setq theOutsideY (plus yOffset w))
	(setq theInsideY (difference theOutsideY ringWidth))

	theRingPoints[insideIndex] = theInsideX:theInsideY
	theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	(setq insideIndex (difference insideIndex 1))
	(setq outsideIndex (plus outsideIndex 1))
       )

     (t ;; there is a bevel in the UR corner
      (setq theOutsideY (plus yOffset w -urBevelLength))
      (setq theInsideY (difference theOutsideY bevelInsideOffset))
      (cond (bevelTheOutsideNoInside   
	     (setq theInsideY1 (plus yOffset w -ringWidth))
	     theRingPoints[insideIndex] = theInsideX1:theInsideY1
	    )
	  (t
	   theRingPoints[insideIndex] = theInsideX:theInsideY
	  )
      )
      (setq insideIndex (difference insideIndex 1))
      (when bevelTheOutside
	  theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	  (setq outsideIndex (plus outsideIndex 1))
      )
      
      (setq theOutsideY (plus yOffset w))
      (setq theOutsideX (difference theOutsideX urBevelLength))
      
      (cond (bevelTheOutsideNoInside
	     theRingPoints[insideIndex] = theInsideX1:theInsideY1
	    )
	  (t
	   (setq theInsideX (difference theOutsideX bevelInsideOffset))
	   (setq theInsideY (difference theOutsideY ringWidth))
	   theRingPoints[insideIndex] = theInsideX:theInsideY
	  )
      )
    
      (setq insideIndex (difference insideIndex 1))
      (cond (bevelTheOutside
	     theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	    )
	  (t
	   theRingPoints[outsideIndex] = (plus xOffset l):theOutsideY
	  )
      )
      (setq outsideIndex (plus outsideIndex 1))
     ) ;; done with the UR bevelled case
 ) ;; done with the UR corner

 (cond ((null ulBevel) ;; no bevel in the UL corner
	(setq theOutsideX xOffset)
	(setq theInsideX (plus theOutsideX ringWidth))

	theRingPoints[insideIndex] = theInsideX:theInsideY
	theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	(setq insideIndex (difference insideIndex 1))
	(setq outsideIndex (plus outsideIndex 1))
       )

     (t ;; there is a bevel in the UL corner
      (setq theOutsideX (plus xOffset ulBevelLength))
      (setq theInsideX (plus theOutsideX bevelInsideOffset))
      (cond (bevelTheOutsideNoInside
	     (setq theInsideX1 (plus xOffset ringWidth))
	     theRingPoints[insideIndex] = theInsideX1:theInsideY1
	    )
	  (t
	   theRingPoints[insideIndex] = theInsideX:theInsideY
	  )
      )      
      (setq insideIndex (difference insideIndex 1))
      (when bevelTheOutside
	  theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	  (setq outsideIndex (plus outsideIndex 1))
      )

      (setq theOutsideX xOffset)
      (setq theOutsideY (difference theOutsideY ulBevelLength))
     

      (cond (bevelTheOutsideNoInside
	     theRingPoints[insideIndex] = theInsideX1:theInsideY1
	    )
	  (t
	   (setq theInsideX (plus theOutsideX ringWidth))
	   (setq theInsideY (difference theOutsideY bevelInsideOffset))
	   theRingPoints[insideIndex] = theInsideX:theInsideY
	  )
      )
          
      (setq insideIndex (difference insideIndex 1))
      (cond (bevelTheOutside
	     theRingPoints[outsideIndex] = theOutsideX:theOutsideY
	    )
	  (t
	   theRingPoints[outsideIndex] = theOutsideX:(plus yOffset w)
	  )
      )
      (setq outsideIndex (plus outsideIndex 1))
     ) ;; done with the UL bevelled case
 ) ;; done with the UL corner

 
 (cond (bevelTheOutsideNoInside
	theRingPoints[insideIndex] = beginningInsidePoint1
	theRingPoints[outsideIndex] = beginningOutsidePoint
	(setq outsideIndex (plus outsideIndex 1))
	theRingPoints[outsideIndex] = beginningInsidePoint1
       )
     (t
      theRingPoints[insideIndex] = beginningInsidePoint
      theRingPoints[outsideIndex] = beginningOutsidePoint
      (setq outsideIndex (plus outsideIndex 1))
      theRingPoints[outsideIndex] = beginningInsidePoint
     )
 )


 (cond (breakupPolygons ; create four polygons for the ring shape

	     ;; the insideIndex will start in the middle and count down to 0
	     (setq insideIndex (xquotient (difference arraySize 3) 2))

	     ;; the outsideIndex will start in the middle +1 and count up
	     (setq outsideIndex (plus insideIndex 1))


	(cond (bevelTheOutside
	       ;; LL corner is 6 points if LL is bevelled, 4 points if not
	       (cond (llBevel
		      (setq ringList1 (list theRingPoints[insideIndex]
					    theRingPoints[insideIndex - 1]
					    theRingPoints[insideIndex - 2]
					    theRingPoints[outsideIndex + 2]
					    theRingPoints[outsideIndex + 1]
					    theRingPoints[outsideIndex]))
		      (setq insideIndex (difference insideIndex 2))
		      (setq outsideIndex (plus outsideIndex 2))
		     )
		   (t
		    (setq ringList1 (list theRingPoints[insideIndex]
					  theRingPoints[insideIndex - 1]
					  theRingPoints[outsideIndex + 1]
					  theRingPoints[outsideIndex]))
		    (setq insideIndex (difference insideIndex 1))
		    (setq outsideIndex (plus outsideIndex 1))
		   )
	       )

	       ;; LR corner is 6 points if LR is bevelled, 4 points if not
	       (cond (lrBevel
		      (setq ringList2 (list theRingPoints[insideIndex]
					    theRingPoints[insideIndex - 1]
					    theRingPoints[insideIndex - 2]
					    theRingPoints[outsideIndex + 2]
					    theRingPoints[outsideIndex + 1]
					    theRingPoints[outsideIndex]))
		      (setq insideIndex (difference insideIndex 2))
		      (setq outsideIndex (plus outsideIndex 2))
		     )
		   (t
		    (setq ringList2 (list theRingPoints[insideIndex]
					  theRingPoints[insideIndex - 1]
					  theRingPoints[outsideIndex + 1]
					  theRingPoints[outsideIndex]))
		    (setq insideIndex (difference insideIndex 1))
		    (setq outsideIndex (plus outsideIndex 1))
		   )
	       )

	       ;; UR corner is 6 points if UR is bevelled, 4 points if not
	       (cond (urBevel
		      (setq ringList3 (list theRingPoints[insideIndex]
					    theRingPoints[insideIndex - 1]
					    theRingPoints[insideIndex - 2]
					    theRingPoints[outsideIndex + 2]
					    theRingPoints[outsideIndex + 1]
					    theRingPoints[outsideIndex]))
		      (setq insideIndex (difference insideIndex 2))
		      (setq outsideIndex (plus outsideIndex 2))
		     )
		   (t
		    (setq ringList3 (list theRingPoints[insideIndex]
					  theRingPoints[insideIndex - 1]
					  theRingPoints[outsideIndex + 1]
					  theRingPoints[outsideIndex]))
		    (setq insideIndex (difference insideIndex 1))
		    (setq outsideIndex (plus outsideIndex 1))
		   )
	       )

	       ;; UL corner is 6 points if UL is bevelled, 4 points if not
	       (cond (ulBevel
		      (setq ringList4 (list theRingPoints[insideIndex]
					    theRingPoints[insideIndex - 1]
					    theRingPoints[insideIndex - 2]
					    theRingPoints[outsideIndex + 2]
					    theRingPoints[outsideIndex + 1]
					    theRingPoints[outsideIndex]))
		      (setq insideIndex (difference insideIndex 2))
		      (setq outsideIndex (plus outsideIndex 2))
		     )
		   (t
		    (setq ringList4 (list theRingPoints[insideIndex]
					  theRingPoints[insideIndex - 1]
					  theRingPoints[outsideIndex + 1]
					  theRingPoints[outsideIndex]))
		    (setq insideIndex (difference insideIndex 1))
		    (setq outsideIndex (plus outsideIndex 1))
		   )
	       )

	     ;;***** no bevel in the outside corners case
	      )
	    (t ; the outside corners are not bevelled

	     ;; LL corner is 5 points if the LL is bevelled, 4 points if not
	     (cond (llBevel
		    (setq ringList1 (list theRingPoints[insideIndex]
					  theRingPoints[insideIndex - 1]
					  theRingPoints[insideIndex - 2]
					  theRingPoints[outsideIndex + 1]
					  theRingPoints[outsideIndex]))
		    (setq insideIndex (difference insideIndex 2))
		    (setq outsideIndex (plus outsideIndex 1))
		   )
		 (t
		  (setq ringList1 (list theRingPoints[insideIndex]
					theRingPoints[insideIndex - 1]
					theRingPoints[outsideIndex + 1]
					theRingPoints[outsideIndex]))
		  (setq insideIndex (difference insideIndex 1))
		  (setq outsideIndex (plus outsideIndex 1))
		 )
	     )

	     ;; LR corner is 5 points if the LR is bevelled, 4 points if not
	     (cond (lrBevel
		    (setq ringList2 (list theRingPoints[insideIndex]
					  theRingPoints[insideIndex - 1]
					  theRingPoints[insideIndex - 2]
					  theRingPoints[outsideIndex + 1]
					  theRingPoints[outsideIndex]))
		    (setq insideIndex (difference insideIndex 2))
		    (setq outsideIndex (plus outsideIndex 1))
		   )
		 (t
		  (setq ringList2 (list theRingPoints[insideIndex]
					theRingPoints[insideIndex - 1]
					theRingPoints[outsideIndex + 1]
					theRingPoints[outsideIndex]))
		  (setq insideIndex (difference insideIndex 1))
		  (setq outsideIndex (plus outsideIndex 1))
		 )
	     )

	     ;; UR corner is 5 points if the UR is bevelled, 4 points if not
	     (cond (urBevel
		    (setq ringList3 (list theRingPoints[insideIndex]
					  theRingPoints[insideIndex - 1]
					  theRingPoints[insideIndex - 2]
					  theRingPoints[outsideIndex + 1]
					  theRingPoints[outsideIndex]))
		    (setq insideIndex (difference insideIndex 2))
		    (setq outsideIndex (plus outsideIndex 1))
		   )
		 (t
		  (setq ringList3 (list theRingPoints[insideIndex]
					theRingPoints[insideIndex - 1]
					theRingPoints[outsideIndex + 1]
					theRingPoints[outsideIndex]))
		  (setq insideIndex (difference insideIndex 1))
		  (setq outsideIndex (plus outsideIndex 1))
		 )
	     )

	     ;; UL corner is 5 points if the UL is bevelled, 4 points if not
	     (cond (ulBevel
		    (setq ringList4 (list theRingPoints[insideIndex]
					  theRingPoints[insideIndex - 1]
					  theRingPoints[insideIndex - 2]
					  theRingPoints[outsideIndex + 1]
					  theRingPoints[outsideIndex]))
		    (setq insideIndex (difference insideIndex 2))
		    (setq outsideIndex (plus outsideIndex 1))
		   )
		 (t
		  (setq ringList4 (list theRingPoints[insideIndex]
					theRingPoints[insideIndex - 1]
					theRingPoints[outsideIndex + 1]
					theRingPoints[outsideIndex]))
		  (setq insideIndex (difference insideIndex 1))
		  (setq outsideIndex (plus outsideIndex 1))
		 )
	     )
	    )
	)

	(when ringLayer
	    (setq net (dbMakeNet tcCellView "ppd"))
	    (dbCreateTerm net "" "inputOutput")
	    (setq dbid (dbCreatePolygon tcCellView ringLayer ringList1))
	    (dbAddFigToNet dbid net)
	    (setq dbid (dbCreatePolygon tcCellView ringLayer ringList2))
	    (dbAddFigToNet dbid net)
	    (setq dbid (dbCreatePolygon tcCellView ringLayer ringList3))
	    (dbAddFigToNet dbid net)
	    (setq dbid (dbCreatePolygon tcCellView ringLayer ringList4))
	    (dbAddFigToNet dbid net)
	)

	(dbCreateProp tcCellView "ringPoints1" "list" ringList1)
	(dbCreateProp tcCellView "ringPoints2" "list" ringList2)
	(dbCreateProp tcCellView "ringPoints3" "list" ringList3)
	(dbCreateProp tcCellView "ringPoints4" "list" ringList4)

       )

     (t ; create one complex polygon for the ring
      (setq ringList nil)
      (for i 1 outsideIndex
	   (setq ringList (cons theRingPoints[outsideIndex - i] ringList))
      )

      (when ringLayer
	  (setq net (dbMakeNet tcCellView "ppd"))
	  (dbCreateTerm net "" "inputOutput")
	  (setq dbid (dbCreatePolygon tcCellView ringLayer ringList))
	  (dbAddFigToNet dbid net)
      )

      (dbCreateProp tcCellView "ringPoints" "list" ringList)
     )
 )

)
;;; 
;;; 
;;; ringClass.il
;;; 
;;; Copyright (c) 1997 by Cypress Semiconductor
;;; 
;;; Date  : 08/10/04 
;;; Author: agktmp1 @ INDC
;;; 
;;; Description:
;;;   This is the device library code for a generic ring.  Many devices
;;; in the device library use a ring type of structure.  Using this device,
;;; a lot of code will not have to be rewritten.
;;;   All of the parameters are formal parameters.  This ring is not meant
;;; to be placed by designers, but by other devices in the device library.
;;;
;;;   This class is the enhanced version of ringClass. It has
;;; four extra boolean type user parameter to selectively draw
;;; the sides of the ring. It adjusts the sides in a rectangular
;;; shape to avoid min width errors when sides are drawn selectively.
;;; 
;;; Revision History:
;;;   agktmp1 10/08/04  Initial version: copied and upgraded ringClass.il
;;;  kmi 10/19/04 replacing hard coded grid value with (TECHgetProp snapGrid)
;;; 

(tcCreateDeviceClass
 "symbolic" "enhRingClass"
 ;; Class parameters
 (
 )
 ;; Formal parameters
 (
  (w                      5.0)
  (l                      5.0)
  (xOffset                0.0)
  (yOffset                0.0)
  (ringLayer              (list "y3" "drawing"))
  (ringWidth              1.0)
  (additionalWidthInBevel 0.0)
  (llBevelLength          0.0)
  (ulBevelLength          0.0)
  (lrBevelLength          0.0)
  (urBevelLength          0.0)
  (bevelTheOutside         "FALSE")
  (bevelTheOutsideNoInside "FALSE")
  (skipLeftSide			"FALSE")
  (skipRightSide			"FALSE")
  (skipTopSide				"FALSE")
  (skipBottomSide 		    "FALSE")
  (grid     (TECHgetProp snapGrid))
  (breakupPolygons        "FALSE")
 )

 ;; in some situations, it is desirable to bevel the inside of the 
 ;; corners, but not the outside.  If so, "bevelTheOutside" should 
 ;; be false/nil
(when (equal bevelTheOutside "FALSE")
 (setq bevelTheOutside nil)
)

;; selectively draw sides
(if (or (equal skipLeftSide "FALSE") (null skipLeftSide)) then
 (setq drawLeftSide t)
 else
 (setq drawLeftSide nil)
)

(if (or (equal skipRightSide "FALSE") (null skipRightSide)) then
 (setq drawRightSide t)
 else
 (setq drawRightSide nil)
)

(if (or (equal skipTopSide "FALSE") (null skipTopSide)) then
 (setq drawTopSide t)
 else
 (setq drawTopSide nil)
)

(if (or (equal skipBottomSide "FALSE") (null skipBottomSide)) then
 (setq drawBottomSide t)
 else
 (setq drawBottomSide nil)
)

(if (or (equal skipLeftSide "TRUE")
     (equal skipRightSide "TRUE")
     (equal skipTopSide "TRUE")
     (equal skipBottomSide "TRUE")
    ) then
 (setq selectiveDrawing t)
 else
 (setq selectiveDrawing nil)
)


;; in some situations, it is desirable to bevel the inside of the 
;; corners, but not the outside.  If so, "bevelTheOutside" should 
;; be false/nil
(when (equal bevelTheOutsideNoInside "FALSE")
 (setq bevelTheOutsideNoInside nil)
)

;; in some situations, vampire cannot handle the complex geometries 
;; that this pcell can  spit out.  Therefore, we must breakup this 
;; one polygon into four polygons that still make up the same shape.  
;; This seems to appease the current vampire bug

(if (or (equal breakupPolygons "FALSE") (null breakupPolygons)) then
 (setq breakupPolygons nil)
 else 
 (setq breakupPolygons t)
)

;; there is a big load of geometry/math behind this equation, but it
;; all boils down to the following equation.  (See the design 
                                               ;; document for the geometry/math.)  The "bevelInsideOffset" is 
;; necessary to maintain the minimum width throughout the bevel. 
;; bevelInsideOffset is:
;;    o how much higher point 1 is wrt point 9  
;;      (points are in figure below)
;;    o how much further to the right point 2 is wrt point 10
(setq s2 (sqrt 2.0))
(setq bevelInsideOffset
 (quotient (plus (times ringWidth (difference s2 1.0))
            (times s2 additionalWidthInBevel)
           )
  grid)
)


;; now use a "ceiling" function to snap it up to the next grid.
;; this assumes that the grid is < 1.0
(setq fixedBev (fix (plus 1e-6 bevelInsideOffset)))
(cond ((lessp (difference bevelInsideOffset fixedBev) 1e-6)
       (setq bevelInsideOffset (times grid fixedBev))
      )
 (t
  (setq bevelInsideOffset (times grid (plus 1.0 fixedBev)))
 )
)


;; "cannotBevelLength" is the point at which the inside bevel will be
;; pinched off.  We do not allow bevels to occur when the bevel length
;; in a corner is less than this value
(setq cannotBevelLength (difference ringWidth bevelInsideOffset))


;; determine whether it should bevel in each corner
(cond ((setq llBevel (greaterp llBevelLength cannotBevelLength))
       (setq arraySize 4)
      )
 (t (setq arraySize 2))
)

(cond ((setq lrBevel (greaterp lrBevelLength cannotBevelLength))
       (setq arraySize (plus arraySize 4))
      )
 (t (setq arraySize (plus arraySize 2)))
)

(cond ((setq urBevel (greaterp urBevelLength cannotBevelLength))
       (setq arraySize (plus arraySize 4))
      )
 (t (setq arraySize (plus arraySize 2)))
)

(cond ((setq ulBevel (greaterp ulBevelLength cannotBevelLength))
       (setq arraySize (plus arraySize 4))
      )
 (t (setq arraySize (plus arraySize 2)))
)

;;     15_____________________________14
;;      /                              ;;     /    _______________________     ;;    /    /7                     6\     ;; 16/    /                         \    \13
 ;;  |    /8                         5\    |
 ;;  |   |                             |   |
 ;;  |   |                             |   |
 ;;  |   |                             |   |
 ;;  |   |1                           4|   |
 ;;  | /  \                           /    |
 ;;  9\    \                         /    /12
 ;;    \    \2_____________________3/    /
 ;;     \                               /
 ;;    10\_____________________________/11
 ;;
 ;; There is a point at each vertex of the ring that will be used to create
 ;; the ring.  The list of points that will be used to create the ring is:
 ;; (1, 8, 7, 6, 5, 4, 3, 2, 1, 9, 10, 11, 12, 13, 14, 15, 16, 9, 1)
 ;; If they opt to create the ring in four sections, the sections will be:
 ;; section 1:  (1, 2, 3, 11, 10, 9)
 ;; section 2:  (3, 4, 5, 13, 12, 11)
 ;; section 3:  (5, 6, 7, 15, 14, 13)
 ;; section 4:  (7, 8, 1, 9, 16, 15)
 ;;
 ;; This will have the cut in the ring between points 1 and 9.
 ;; Whenever there is not going to be a bevel in a corner, the points
 ;; will be merged in that corner.  For example, if there was not a
 ;; bevel in the LL (lower left) corner, points 1 & 2 will become one point,
 ;; and points 9 and 10 will become one point.
 ;;
 ;; The order in which it calculates the points and puts them in the array is:
 ;; 
 ;; time   --->
 ;;index  corner
 ;;              [0]                             1
 ;;              [1]        UL                8
 ;;              [2]        UL             7
 ;;              [3]      UR            6  |
 ;;              [4]      UR         5     |
 ;;     /\       [5]    LR        4        |
 ;;     |        [6]    LR     3  |        |
 ;;     |        [7]  LL    2     |        |
 ;; insideIndex  [8]  LL 1        |        |
 ;; outsideIndex [9]  LL 9        |        |
 ;;     |        [10] LL   10     |        |
 ;;     |        [11]   LR    11  |        |
 ;;     \/       [12]   LR       12        |
 ;;              [13]     UR        13     |
 ;;              [14]     UR           14  |
 ;;              [15]       UL            15
 ;;              [16]       UL               16
 ;;              [17]                            9
 ;;              [18]                            1
 ;;
 ;; For each non-bevelled corner, the two entries for that corner in the
 ;; first half of the array will be merged, and the two entries for that
 ;; corner in the second half of the array will be merged.  For example,
 ;; if the UR (upper right) corner was not bevelled, array entries number
 ;; 3 and 4 will be merged, and entries 13 and 14 will be merged.

;; the insideIndex will start in the middle and count down to 0
(setq insideIndex (xquotient arraySize 2))

;; the outsideIndex will start in the middle +1 and count up to arraySize
(setq outsideIndex (plus insideIndex 1))
 (setq arraySize (plus arraySize 3))  ;; to handle a cut in the ring

;; Initialize the ring points
(declare theRingPoints[arraySize])
(setq theOutsideX xOffset)
(setq theOutsideY yOffset)

 ;; Start with the lower left corner
 (cond 
  ((null llBevel)  ;; no bevel in the ll corner
   (setq theInsideX (plus theOutsideX ringWidth))
   (setq theInsideY (plus theOutsideY ringWidth))

   (setq beginningInsidePoint theInsideX:theInsideY)
   (setq beginningOutsidePoint theOutsideX:theOutsideY)

   ;; add the inside points to the beginning of the ring points,
   ;; and the outside points to the end of the ring points
   theRingPoints[insideIndex] = beginningInsidePoint
   theRingPoints[outsideIndex] = beginningOutsidePoint
   (setq insideIndex (difference insideIndex 1))
   (setq outsideIndex (plus outsideIndex 1))
  )

  (t ;; there is a bevel in the ll corner
   (setq theOutsideY (plus theOutsideY llBevelLength))
   (setq theInsideY (plus theOutsideY bevelInsideOffset))

   (setq theInsideX (plus theOutsideX ringWidth))

   (setq beginningInsidePoint theInsideX:theInsideY)
   (setq beginningOutsidePoint theOutsideX:theOutsideY)

   (cond (bevelTheOutsideNoInside
          (setq theInsideY1 (plus yOffset ringWidth))
          (setq beginningInsidePoint1 theInsideX:theInsideY1)
          theRingPoints[insideIndex] = beginningInsidePoint1
         )
    (t
     theRingPoints[insideIndex] = beginningInsidePoint
    )
   )	  

   (setq insideIndex (difference insideIndex 1))
   (when bevelTheOutside
    theRingPoints[outsideIndex] = beginningOutsidePoint
    (setq outsideIndex (plus outsideIndex 1))
   )

(setq theOutsideX (plus theOutsideX llBevelLength))
(setq theOutsideY yOffset)
(setq theInsideX (plus theOutsideX bevelInsideOffset))
(setq theInsideY (plus theOutsideY ringWidth))


 (cond (bevelTheOutsideNoInside
        theRingPoints[insideIndex] = beginningInsidePoint1
       )
  (t
   theRingPoints[insideIndex] = theInsideX:theInsideY
  )
 )

(setq insideIndex (difference insideIndex 1))
 (cond (bevelTheOutside
        theRingPoints[outsideIndex] = theOutsideX:theOutsideY
       )
  (t
   theRingPoints[outsideIndex] = xOffset:theOutsideY
   beginningOutsidePoint = theRingPoints[outsideIndex]
  )
 )
(setq outsideIndex (plus outsideIndex 1))

 ) ;; done with the LL bevelled case
 ) ;; done with the LL corner

 (cond 
  ((null lrBevel) ;; no bevel in the lr corner
   (setq theOutsideX (plus xOffset l))
   (setq theInsideX (difference theOutsideX ringWidth))

   theRingPoints[insideIndex] = theInsideX:theInsideY
   theRingPoints[outsideIndex] = theOutsideX:theOutsideY
   (setq insideIndex (difference insideIndex 1))
   (setq outsideIndex (plus outsideIndex 1))
  )

  (t ;; there is a bevel in the lr corner
   (setq theOutsideX (plus xOffset l -lrBevelLength))
   (setq theInsideX (difference theOutsideX bevelInsideOffset))
   (cond (bevelTheOutsideNoInside
          (setq theInsideX1 (plus xOffset l -ringWidth))
          theRingPoints[insideIndex] = theInsideX1:theInsideY
         )
    (t
     theRingPoints[insideIndex] = theInsideX:theInsideY
    )
   )
   (setq insideIndex (difference insideIndex 1))
   (when bevelTheOutside
    theRingPoints[outsideIndex] = theOutsideX:theOutsideY
    (setq outsideIndex (plus outsideIndex 1))
   )

   (setq theOutsideX (plus theOutsideX lrBevelLength))
   (setq theOutsideY (plus theOutsideY lrBevelLength))


   (cond (bevelTheOutsideNoInside
          theRingPoints[insideIndex] = theInsideX1:theInsideY
         )
    (t
     (setq theInsideX (difference theOutsideX ringWidth))
     (setq theInsideY (plus theOutsideY bevelInsideOffset))
     theRingPoints[insideIndex] = theInsideX:theInsideY
    )
   )

(setq insideIndex (difference insideIndex 1))
 (cond (bevelTheOutside
        theRingPoints[outsideIndex] = theOutsideX:theOutsideY
       )
  (t
   theRingPoints[outsideIndex] = theOutsideX:yOffset
  )
 )
(setq outsideIndex (plus outsideIndex 1))
 ) ;; done with the LR bevelled case
 ) ;; done with the LR corner

 (cond 
  ((null urBevel) ;; no bevel in the UR corner
   (setq theOutsideY (plus yOffset w))
   (setq theInsideY (difference theOutsideY ringWidth))

   theRingPoints[insideIndex] = theInsideX:theInsideY
   theRingPoints[outsideIndex] = theOutsideX:theOutsideY
   (setq insideIndex (difference insideIndex 1))
   (setq outsideIndex (plus outsideIndex 1))
  )

  (t ;; there is a bevel in the UR corner
   (setq theOutsideY (plus yOffset w -urBevelLength))
   (setq theInsideY (difference theOutsideY bevelInsideOffset))
   (cond (bevelTheOutsideNoInside   
          (setq theInsideY1 (plus yOffset w -ringWidth))
          theRingPoints[insideIndex] = theInsideX1:theInsideY1
         )
    (t
     theRingPoints[insideIndex] = theInsideX:theInsideY
    )
   )
   (setq insideIndex (difference insideIndex 1))
   (when bevelTheOutside
    theRingPoints[outsideIndex] = theOutsideX:theOutsideY
    (setq outsideIndex (plus outsideIndex 1))
   )

   (setq theOutsideY (plus yOffset w))
   (setq theOutsideX (difference theOutsideX urBevelLength))

   (cond (bevelTheOutsideNoInside
          theRingPoints[insideIndex] = theInsideX1:theInsideY1
         )
    (t
     (setq theInsideX (difference theOutsideX bevelInsideOffset))
     (setq theInsideY (difference theOutsideY ringWidth))
     theRingPoints[insideIndex] = theInsideX:theInsideY
    )
   )

(setq insideIndex (difference insideIndex 1))
 (cond (bevelTheOutside
        theRingPoints[outsideIndex] = theOutsideX:theOutsideY
       )
  (t
   theRingPoints[outsideIndex] = (plus xOffset l):theOutsideY
  )
 )
(setq outsideIndex (plus outsideIndex 1))
 ) ;; done with the UR bevelled case
 ) ;; done with the UR corner

(cond ((null ulBevel) ;; no bevel in the UL corner
       (setq theOutsideX xOffset)
       (setq theInsideX (plus theOutsideX ringWidth))

       theRingPoints[insideIndex] = theInsideX:theInsideY
       theRingPoints[outsideIndex] = theOutsideX:theOutsideY
       (setq insideIndex (difference insideIndex 1))
       (setq outsideIndex (plus outsideIndex 1))
      )

 (t ;; there is a bevel in the UL corner
  (setq theOutsideX (plus xOffset ulBevelLength))
  (setq theInsideX (plus theOutsideX bevelInsideOffset))
  (cond (bevelTheOutsideNoInside
         (setq theInsideX1 (plus xOffset ringWidth))
         theRingPoints[insideIndex] = theInsideX1:theInsideY1
        )
   (t
    theRingPoints[insideIndex] = theInsideX:theInsideY
   )
  )      
  (setq insideIndex (difference insideIndex 1))
  (when bevelTheOutside
   theRingPoints[outsideIndex] = theOutsideX:theOutsideY
   (setq outsideIndex (plus outsideIndex 1))
  )

  (setq theOutsideX xOffset)
  (setq theOutsideY (difference theOutsideY ulBevelLength))

  (cond (bevelTheOutsideNoInside
         theRingPoints[insideIndex] = theInsideX1:theInsideY1
        )
   (t
    (setq theInsideX (plus theOutsideX ringWidth))
    (setq theInsideY (difference theOutsideY bevelInsideOffset))
    theRingPoints[insideIndex] = theInsideX:theInsideY
   )
  )

(setq insideIndex (difference insideIndex 1))
 (cond (bevelTheOutside
        theRingPoints[outsideIndex] = theOutsideX:theOutsideY
       )
  (t
   theRingPoints[outsideIndex] = theOutsideX:(plus yOffset w)
  )
 )
(setq outsideIndex (plus outsideIndex 1))
 ) ;; done with the UL bevelled case
 ) ;; done with the UL corner


 (cond (bevelTheOutsideNoInside
        theRingPoints[insideIndex] = beginningInsidePoint1
        theRingPoints[outsideIndex] = beginningOutsidePoint
        (setq outsideIndex (plus outsideIndex 1))
        theRingPoints[outsideIndex] = beginningInsidePoint1
       )
  (t
   theRingPoints[insideIndex] = beginningInsidePoint
   theRingPoints[outsideIndex] = beginningOutsidePoint
   (setq outsideIndex (plus outsideIndex 1))
   theRingPoints[outsideIndex] = beginningInsidePoint
  )
 )


 (cond (breakupPolygons ; create four polygons for the ring shape

        ;; the insideIndex will start in the middle and count down to 0
        (setq insideIndex (xquotient (difference arraySize 3) 2))

        ;; the outsideIndex will start in the middle +1 and count up
        (setq outsideIndex (plus insideIndex 1))

        (cond (bevelTheOutside
               ;; LL corner is 6 points if LL is bevelled, 4 points if not
               (cond 
                (llBevel
                 (setq ringList1 (list theRingPoints[insideIndex]
                                  theRingPoints[insideIndex - 1]
                                  theRingPoints[insideIndex - 2]
                                  theRingPoints[outsideIndex + 2]
                                  theRingPoints[outsideIndex + 1]
                                  theRingPoints[outsideIndex]))
                 (setq insideIndex (difference insideIndex 2))
                 (setq outsideIndex (plus outsideIndex 2))
                )
                (t
                 (setq ringList1 (list theRingPoints[insideIndex]
                                  theRingPoints[insideIndex - 1]
                                  theRingPoints[outsideIndex + 1]
                                  theRingPoints[outsideIndex]))
                 (setq insideIndex (difference insideIndex 1))
                 (setq outsideIndex (plus outsideIndex 1))
                )
               )

               ;; LR corner is 6 points if LR is bevelled, 4 points if not
               (cond 
                (lrBevel
                 (setq ringList2 (list theRingPoints[insideIndex]
                                  theRingPoints[insideIndex - 1]
                                  theRingPoints[insideIndex - 2]
                                  theRingPoints[outsideIndex + 2]
                                  theRingPoints[outsideIndex + 1]
                                  theRingPoints[outsideIndex]))
                 (setq insideIndex (difference insideIndex 2))
                 (setq outsideIndex (plus outsideIndex 2))
                )
                (t
                 (setq ringList2 (list theRingPoints[insideIndex]
                                  theRingPoints[insideIndex - 1]
                                  theRingPoints[outsideIndex + 1]
                                  theRingPoints[outsideIndex]))
                 (setq insideIndex (difference insideIndex 1))
                 (setq outsideIndex (plus outsideIndex 1))
                )
               )

               ;; UR corner is 6 points if UR is bevelled, 4 points if not
               (cond 
                (urBevel
                 (setq ringList3 (list theRingPoints[insideIndex]
                                  theRingPoints[insideIndex - 1]
                                  theRingPoints[insideIndex - 2]
                                  theRingPoints[outsideIndex + 2]
                                  theRingPoints[outsideIndex + 1]
                                  theRingPoints[outsideIndex]))
                 (setq insideIndex (difference insideIndex 2))
                 (setq outsideIndex (plus outsideIndex 2))
                )
                (t
                 (setq ringList3 (list theRingPoints[insideIndex]
                                  theRingPoints[insideIndex - 1]
                                  theRingPoints[outsideIndex + 1]
                                  theRingPoints[outsideIndex])
                 )
                 (setq insideIndex (difference insideIndex 1))
                 (setq outsideIndex (plus outsideIndex 1))
                )
               )

               ;; UL corner is 6 points if UL is bevelled, 4 points if not
               (cond 
                (ulBevel
                 (setq ringList4 (list theRingPoints[insideIndex]
                                  theRingPoints[insideIndex - 1]
                                  theRingPoints[insideIndex - 2]
                                  theRingPoints[outsideIndex + 2]
                                  theRingPoints[outsideIndex + 1]
                                  theRingPoints[outsideIndex]))
                 (setq insideIndex (difference insideIndex 2))
                 (setq outsideIndex (plus outsideIndex 2))
                )
                (t
                 (setq ringList4 (list theRingPoints[insideIndex]
                                  theRingPoints[insideIndex - 1]
                                  theRingPoints[outsideIndex + 1]
                                  theRingPoints[outsideIndex])
                 )
                 (setq insideIndex (difference insideIndex 1))
                 (setq outsideIndex (plus outsideIndex 1))
                )
               )

               ;;***** no bevel in the outside corners case
               )
               (t ; the outside corners are not bevelled

                ;; LL corner is 5 points if the LL is bevelled, 4 points if not
                (cond (llBevel
                       (setq ringList1 (list theRingPoints[insideIndex]
                                        theRingPoints[insideIndex - 1]
                                        theRingPoints[insideIndex - 2]
                                        theRingPoints[outsideIndex + 1]
                                        theRingPoints[outsideIndex]))
                       (setq insideIndex (difference insideIndex 2))
                       (setq outsideIndex (plus outsideIndex 1))
                      )
                 (t
                  ;; when sides are to be drawn selectively adjust the trapezoid
                  ;; shape to rectangular to avoid min width error at the sharp
                  ;; corners
                  (if selectiveDrawing then
                   (setq urX (plus (car theRingPoints[insideIndex - 1])
                              ringWidth
                             )
                   )
                   (setq urY (cadr theRingPoints[insideIndex - 1]))
                   (setq urPoint (list urX urY))
                   (setq llX (car theRingPoints[outsideIndex]))
                   (setq llY (cadr theRingPoints[outsideIndex]))
                   (setq llPoint (list llX llY))
                   (setq ringList1 (list llPoint urPoint))
                   (setq insideIndex (difference insideIndex 1))
                   (setq outsideIndex (plus outsideIndex 1))
                   else
                   (setq ringList1 (list theRingPoints[insideIndex]
                                    theRingPoints[insideIndex - 1]
                                    theRingPoints[outsideIndex + 1]
                                    theRingPoints[outsideIndex])
                   )
                   (setq insideIndex (difference insideIndex 1))
                   (setq outsideIndex (plus outsideIndex 1))
                  )
                  )
                  )

                  ;; LR corner is 5 points if the LR is bevelled, 4 points if not
                  (cond (lrBevel
                         (setq ringList2 (list theRingPoints[insideIndex]
                                          theRingPoints[insideIndex - 1]
                                          theRingPoints[insideIndex - 2]
                                          theRingPoints[outsideIndex + 1]
                                          theRingPoints[outsideIndex]))
                         (setq insideIndex (difference insideIndex 2))
                         (setq outsideIndex (plus outsideIndex 1))
                        )
                   (t
                    ;; when sides are to be drawn selectively adjust the trapezoid
                    ;; shape to rectangular to avoid min width error at the sharp
                    ;; corners
                    (if selectiveDrawing then
                     (setq urX (car theRingPoints[outsideIndex + 1]))
                     (setq urY (cadr theRingPoints[outsideIndex + 1]))
                     (setq urPoint (list urX urY))
                     (setq llX (car theRingPoints[insideIndex]))
                     (setq llY (difference (cadr theRingPoints[insideIndex])
                                ringWidth
                               )
                     )
                     (setq llPoint (list llX llY))
                     (setq ringList2 (list llPoint urPoint))
                     (setq insideIndex (difference insideIndex 1))
                     (setq outsideIndex (plus outsideIndex 1))
                     else
                     (setq ringList2 (list theRingPoints[insideIndex]
                                      theRingPoints[insideIndex - 1]
                                      theRingPoints[outsideIndex + 1]
                                      theRingPoints[outsideIndex]))
                     (setq insideIndex (difference insideIndex 1))
                     (setq outsideIndex (plus outsideIndex 1))
                    )
                    )
                    )

                    ;; UR corner is 5 points if the UR is bevelled, 4 points if not
                    (cond (urBevel
                           (setq ringList3 (list theRingPoints[insideIndex]
                                            theRingPoints[insideIndex - 1]
                                            theRingPoints[insideIndex - 2]
                                            theRingPoints[outsideIndex + 1]
                                            theRingPoints[outsideIndex]))
                           (setq insideIndex (difference insideIndex 2))
                           (setq outsideIndex (plus outsideIndex 1))
                          )
                     (t
                      ;; when sides are to be drawn selectively adjust the trapezoid
                      ;; shape to rectangular to avoid min width error at the sharp
                      ;; corners
                      (if selectiveDrawing then
                       (setq urX (car theRingPoints[outsideIndex]))
                       (setq urY (cadr theRingPoints[outsideIndex]))
                       (setq urPoint (list urX urY))
                       (setq llX (difference (car theRingPoints[insideIndex - 1])
                                  ringWidth
                                 )
                       )
                       (setq llY (cadr theRingPoints[insideIndex - 1]))
                       (setq llPoint (list llX llY))
                       (setq ringList3 (list llPoint urPoint))
                       (setq insideIndex (difference insideIndex 1))
                       (setq outsideIndex (plus outsideIndex 1))
                       else
                       (setq ringList3 (list theRingPoints[insideIndex]
                                        theRingPoints[insideIndex - 1]
                                        theRingPoints[outsideIndex + 1]
                                        theRingPoints[outsideIndex]))
                       (setq insideIndex (difference insideIndex 1))
                       (setq outsideIndex (plus outsideIndex 1))
                      )
                      )
                      )

                      ;; UL corner is 5 points if the UL is bevelled, 4 points if not
                      (cond (ulBevel
                             (setq ringList4 (list theRingPoints[insideIndex]
                                              theRingPoints[insideIndex - 1]
                                              theRingPoints[insideIndex - 2]
                                              theRingPoints[outsideIndex + 1]
                                              theRingPoints[outsideIndex]))
                             (setq insideIndex (difference insideIndex 2))
                             (setq outsideIndex (plus outsideIndex 1))
                            )
                       (t
                        ;; when sides are to be drawn selectively adjust the trapezoid
                        ;; shape to rectangular to avoid min width error at the sharp
                        ;; corners
                        (if selectiveDrawing then
                         (setq urX (car theRingPoints[insideIndex]))
                         (setq urY (plus (cadr theRingPoints[insideIndex])
                                    ringWidth
                                   )
                         )

                         (setq urPoint (list urX urY))
                         (setq llX (car theRingPoints[outsideIndex + 1]))
                         (setq llY (cadr theRingPoints[outsideIndex + 1]))
                         (setq llPoint (list llX llY))
                         (setq ringList4 (list llPoint urPoint))
                         (setq insideIndex (difference insideIndex 1))
                         (setq outsideIndex (plus outsideIndex 1))
                         else
                         (setq ringList4 (list theRingPoints[insideIndex]
                                          theRingPoints[insideIndex - 1]
                                          theRingPoints[outsideIndex + 1]
                                          theRingPoints[outsideIndex]))
                         (setq insideIndex (difference insideIndex 1))
                         (setq outsideIndex (plus outsideIndex 1))
                        )
                        )
                        )
                        )
                        )

                        (when ringLayer
                         (setq net (dbMakeNet tcCellView "ppd"))
                         (dbCreateTerm net "" "inputOutput")
                         ;; when sides are to be drawn selectively create each side
                         ;; separately as rectangle, otherwise as polygon
                         (if selectiveDrawing then
                          (when drawBottomSide
                           (setq dbid (dbCreateRect tcCellView ringLayer ringList1))
                           (dbAddFigToNet dbid net)
                          )
                          (when drawRightSide
                           (setq dbid (dbCreateRect tcCellView ringLayer ringList2))
                           (dbAddFigToNet dbid net)
                          )
                          (when drawTopSide
                           (setq dbid (dbCreateRect tcCellView ringLayer ringList3))
                           (dbAddFigToNet dbid net)
                          )
                          (when drawLeftSide
                           (setq dbid (dbCreateRect tcCellView ringLayer ringList4))
                           (dbAddFigToNet dbid net)
                          )
                          else
                          (when drawBottomSide
                           (setq dbid (dbCreatePolygon tcCellView ringLayer ringList1))
                           (dbAddFigToNet dbid net)
                          )
(when drawRightSide
 (setq dbid (dbCreatePolygon tcCellView ringLayer ringList2))
 (dbAddFigToNet dbid net)
)
(when drawTopSide
 (setq dbid (dbCreatePolygon tcCellView ringLayer ringList3))
 (dbAddFigToNet dbid net)
)
(when drawLeftSide
 (setq dbid (dbCreatePolygon tcCellView ringLayer ringList4))
 (dbAddFigToNet dbid net)
)
)
)

(dbCreateProp tcCellView "ringPoints1" "list" ringList1)
(dbCreateProp tcCellView "ringPoints2" "list" ringList2)
(dbCreateProp tcCellView "ringPoints3" "list" ringList3)
(dbCreateProp tcCellView "ringPoints4" "list" ringList4)
)

(t ; create one complex polygon for the ring
 (setq ringList nil)
 (for i 1 outsideIndex
  (setq ringList (cons theRingPoints[outsideIndex - i] ringList))
 )

 (when ringLayer
  (setq net (dbMakeNet tcCellView "ppd"))
  (dbCreateTerm net "" "inputOutput")
  (setq dbid (dbCreatePolygon tcCellView ringLayer ringList))
  (dbAddFigToNet dbid net)
 )

 (dbCreateProp tcCellView "ringPoints" "list" ringList)
)
)
)

;;; 
;;; $Id: rivetRingMirrorClass.il,v 1.3 2003/09/29 19:14:16 kmi Exp $
;;; 
;;; rivetRingMirrorClass.il
;;; 
;;; Copyright (c) 1997 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Dec 29, 2000
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This is a part of the device library.  It will be used to generate
;;; rivets within a ring structure.  All of the parameters are formal
;;; parameters.  It is not intended to be used directly by designers,
;;; but it is intended to be instantiated by other device in the device lib.
;;;
;;;   This is a majorly hacked version of rivetRingClass.il in order to
;;; mirror the contacts.  The formal parameters are deliberately kept the
;;; same as rivetRingClass.il, even though some do not work here. These are:
;;;
;;;   llBevelLength, ulBevelLength, lrBevelLength, urBevelLength -
;;;     There is no bevel support for contacts in the corners.  It takes
;;;     the max of these as a uniform corner exclusion region.
;;;
;;;
;;;   autoIncreaseBevelWidth - completely ignored
;;;
;;;   This code does assume that there is some decent substance to the ring.
;;; It may not work as expected if there is only enough room for one or two
;;; rivets along an edge.  Three or more rivets should be no problem.
;;; 
;;; Revision History:
;;;   gtc 12/29/00  Copied and majorly hacked from rivetRingClass.il
;;;   ymx 08/01/02  Added widthEqLength for rect. rivets 
;;;   kmi 09/15/03  Adding rivet2Layer 
;;; 

(putpropqq rivetRingMirrorClass "$Id: rivetRingMirrorClass.il,v 1.3 2003/09/29 19:14:16 kmi Exp $" SCCS)

(tcCreateDeviceClass
 "symbolic" "rivetRingMirrorClass"
 ;; Class parameters
 (
  (widthEqLength          t)
 )
 ;; Formal parameters
 (
  (w                      50.0) ; size in Y direction
  (l                      50.0) ; size in X direction
  (xOffset                0.0)
  (yOffset                0.0)
  (rivetLayer             (list "y3" "drawing"))
  (rivet2Layer            nil)
  (rivetLayer2            nil) ; completely ignored
  (ringWidth              6.0)
  (rivetWidth             0.6) ; width of rivets (y-dir)
  (rivetLength            1.0) ; length of rivet (x-dir)
  (rivetSpace             0.8)
  (rivet2Width            0.0) ; width of rivets2 (y-dir)
  (rivet2Length           0.0) ; length of rivet2 (x-dir)
  (rivet2Space            0.0)
  (rivet2EncByRivet1L              0.0) ; rivet2 enclosure by rivet1 (X)
  (rivet2EncByRivet1W              0.0) ; rivet2 enclosure by rivet1 (Y)
  (llBevelLength          10.0) ; the max of the 4 bevels is used for all
  (ulBevelLength          10.0) ; 4 of the corners as a cornerExcludeWidth
  (lrBevelLength          10.0)
  (urBevelLength          10.0)
  (autoIncreaseBevelWidth "FALSE") ; completely ignored
  (grid                   0.05)
 )

 (when widthEqLength
    (setq rivetLength rivetWidth)
 )

 (setq cornerExcludeWidth
       (max 0.0 llBevelLength ulBevelLength lrBevelLength urBevelLength))

 (setq rivetPitchY (plus rivetWidth rivetSpace))  ;pitch in Y-dir
 (setq rivetPitchX (plus rivetLength rivetSpace)) ;pitch in X-dir

 ;; set rivet2 params
 (when rivet2Layer
    (setq rivet2PitchL (plus rivet2Length rivet2Space)) ;pitch in X-dir
    (setq rivet2ActiveL (difference rivetLength (times 2 rivet2EncByRivet1L)))
    (setq numCol2 (fix (plus (quotient (plus rivet2ActiveL rivet2Space) rivet2PitchL) 1e-6)))
    (setq rivet1RealL (difference (times numCol2 rivet2PitchL) rivet2Space))
    (setq rivet2OffsetL (quotient (difference rivet2ActiveL rivet1RealL) 2))
    (setq rivet2OffsetL (times (fix (plus (quotient rivet2OffsetL grid) 1e-6)) grid))
 )

 ;; find out how many column can fit within the "ringWidth"
 (setq numCols (fix (plus (quotient (plus ringWidth rivetSpace) rivetPitchY) 1e-5)))

 ;; It will draw the rivets in 2 big steps:
 ;;   1.  Draw the rivets along the top and bottom edges
 ;;   2.  Draw the rivets along the left and right edges
 ;;

 ;; 1.  Draw the rivets along the top and bottom edges
 ;;
 ;; First, determine how many rivets can fit along these edges.  Due to the
 ;; processing order, it must do the condition of the even # of rivets first,
 ;; and then for the odd # of rivets.
 ;;
 ;; if the # of rivets is even
 ;;   We need to make sure that we can perfectly mirror the rivets
 ;;   if total width is an even grid multiple
 ;;     rivet space must also be an even grid multiple
 ;;     else if rivet space is an odd grid multiple
 ;;       we would like to get away with increasing the center width by 1 grid,
 ;;       but that may make it too large to fit within the working width.
 ;;       if there is enough room to add 1 grid to center rivet space
 ;;         add 1 grid to center rivet space
 ;;       else
 ;;         decrement the rivet count by 1 (to an odd number)
 ;;         (It will do the sanity checks when the rivet count is odd)
 ;;       end if
 ;;     end else if
 ;;   else if total width is an odd grid multiple
 ;;     rivet space must also be odd
 ;;     else if rivet space is even
 ;;       if there is enough room to add 1 grid to center rivet space
 ;;         add 1 grid to center rivet space
 ;;       else
 ;;         decrement the rivet count by 1 (to an odd number)
 ;;         (It will do the sanity checks when the rivet count is odd)
 ;;       end if
 ;;     end else if
 ;;   end else if
 ;; end if
 ;;
 ;; if # of rivets is odd
 ;;   We need to make sure that we can perfectly center the center rivet.
 ;;   if total width is an even grid multiple then
 ;;     rivet width must also be even grid multiple
 ;;     else if rivet width is odd grid multiple
 ;;       decrement the rivet count by 1 (to an even number)
 ;;       if rivet space is odd multiple of grid
 ;;         add 1 grid to the middle rivet space only
 ;;       end if
 ;;     end else if
 ;;   else if total width is odd
 ;;     rivet width must be an odd grid
 ;;     else if rivet width is even
 ;;       decrement the rivet count by 1 (to an even number)
 ;;       if rivet space is an even multiple of grid
 ;;         add 1 grid to the middle rivet space only
 ;;       end if
 ;;     end else if
 ;;   end else if
 ;; end if
 ;;
 ;; This will result in some conditions where there is a spacing between
 ;; two rivets that is 1 grid larger than minimum and what is used
 ;; everywhere else.
 ;;

 (setq rivetWidthGrids (fix (plus 0.999 (quotient rivetWidth grid))))
 (setq rivetSpaceGrids (fix (plus 0.999 (quotient rivetSpace grid))))

 ;; Also be careful when you get close to the far left/right edge so that
 ;; it will not create a spacing error or a rectangular rivet if two instances
 ;; are shared left-right.
 ;;
 (cond
     ((lessp cornerExcludeWidth (quotient rivetSpace 2.0))
      (setq xWorkingWidth (difference l rivetSpace))
      ;; if the rivet space is an odd multiple of the snap grid, knock
      ;; off one more grid width to preserve the evenness/oddness of the
      ;; xWorkingWidth number of grids
      (when (oddp rivetSpaceGrids)
	  (setq xWorkingWidth (difference xWorkingWidth grid))
      )
     )
     (t
      (setq xWorkingWidth (difference l (times 2 cornerExcludeWidth)))
     )
 )

 (setq xWorkingGrids (fix (plus 0.999 (quotient xWorkingWidth grid))))

 ;; get the maximum number of rivets we could fit in
 (setq numRivets (fix (plus 1e-5 (quotient (plus xWorkingWidth rivetSpace)
					   (plus rivetLength rivetSpace)))))

 ;; deltaWidth is the amount of extra width if there are numRivets placed
 (setq deltaWidth (difference xWorkingWidth
			      (plus
			       (times numRivets rivetLength)
			       (times (difference numRivets 1) rivetSpace))))

 ;; in some cases, the center space may be increased by 1 grid, but start
 ;; it out with the rivetSpace
 (setq centerSpace rivetSpace)

 ;; must do when an even number of rivets first because in some conditions
 ;; it will decrement to an odd number of rivets requiring the odd massaging
 ;; to be done
 (when (evenp numRivets)
     (cond
	 ;; if the total working width is an even number of grids
	 ((evenp xWorkingGrids)
	  ;; when rivet space is an even number of grids, we are OK.
	  ;; when rivet space is an odd number of grids, we must massage
	  (when (oddp rivetSpaceGrids)
	      (cond
		  ;; if there is enough room to increase the center space
		  ;; by 1 grid
		  ((geqp deltaWidth grid)
		   (setq centerSpace (plus centerSpace grid))
		  )
		  ;; otherwise, decrement the number of rivets by 1 to an
		  ;; odd number, and let it do the odd processing on it
		  (t
		   (setq numRivets (difference numRivets 1))
		  )
	      )
	  )
	 )
	 ;; else the total working width is an odd number of grids
	 (t
	  ;; when rivet space is an odd number of grids, we are OK.
	  ;; when rivet space is an even number of grids, we must massage
	  (when (evenp rivetSpaceGrids)
	      (cond
		  ;; if there is enough room to increase the center space
		  ;; by 1 grid
		  ((geqp deltaWidth grid)
		   (setq centerSpace (plus centerSpace grid))
		  )
		  ;; otherwise, decrement the number of rivets by 1 to an
		  ;; odd number, and let it do the odd processing on it
		  (t
		   (setq numRivets (difference numRivets 1))
		  )
	      )
	  )
	 )
     ) ; end cond if working width is even or odd number of grids
 ) ; end when there are an even number of rivets

 ;; must keep this after the condition when there are an even number of rivets
 (when (oddp numRivets)
     (cond
	 ;; when the total working width is an even grid multiple
	 ((evenp xWorkingGrids)
	  ;; when rivet width is an even number of grids, we are OK.
	  ;; when rivet width is an odd number of grids, we must massage
	  (when (oddp rivetWidthGrids)
	      ;; decrement the rivet count by 1 (to an even number)
	      (setq numRivets (difference numRivets 1))
	      ;; if the rivet space is an even number of grids, we are OK.
	      ;; if the rivet space is an odd number of grids, we must massage
	      (when (oddp rivetSpaceGrids)
		  ;; add 1 grid to the center space only
		  (setq centerSpace (plus centerSpace grid))
	      )
	  )
	 )
	 ;; else the total working width is an odd grid multiple
	 (t
	  ;; when rivet width is an odd number of grids, we are OK.
	  ;; when rivet width is an even number of grids, we must massage
	  (when (evenp rivetWidthGrids)
	      ;; decrement the rivet count by 1 (to an even number)
	      (setq numRivets (difference numRivets 1))
	      ;; if the rivet space is an odd number of grids, we are OK.
	      ;; if the rivet space is an even number of grids, we must massage
	      (when (evenp rivetSpaceGrids)
		  ;; add 1 grid to the center space only
		  (setq centerSpace (plus centerSpace grid))
	      )
	  )
	 )
     ) ; end cond if working width is even or odd number of grids
 ) ; end when there are an odd number of rivets

 ;; now we have got these rivets prepared so that they can be shared & mirrored
 ;; but we need to work out the initial locations.  We will draw from left to
 ;; right with the special centerSpace at the center rivet
 (setq xOrigin
       (difference (plus xOffset (quotient l 2.0))
		   (quotient (plus (times numRivets rivetLength)
				   (times (difference numRivets 2) rivetSpace)
				   centerSpace
			     )
			     2.0)
       )
 )

 (when (or (equal numRivets 0) (equal numCols 0))
    (error nil "riverRingMirrorClass: number of viaCons less than zero")
 )
 (when (and rivet2Layer (equal numCol2 0))
    (error nil "riverRingMirrorClass: number of viaCons less than zero")
 )

 ;; now we are in business to start drawing some rivets (top, bottom).
 (for row 1 numRivets
      (setq yOriginBot yOffset)
      (setq yOriginTop (plus yOffset w))

      (for col 1 numCols
	   ;; first create the rivet on the bottom
	   (dbCreateRect tcCellView rivetLayer
			 (list xOrigin:yOriginBot
			      (plus xOrigin rivetLength):
			      (plus yOriginBot rivetWidth)))
	   ;; second create the rivet on the top
	   (dbCreateRect tcCellView rivetLayer
			 (list xOrigin:yOriginTop
			      (plus xOrigin rivetLength):
			      (difference yOriginTop rivetWidth)))
           ;; create rivet2 within rivet (along the rivet lenght)
           (when rivet2Layer
             (setq yOriginBot2 (plus yOriginBot rivet2EncByRivet1W))
             (setq yOriginTop2 (difference yOriginTop rivet2EncByRivet1W))
             (setq xOrigin2    (plus xOrigin rivet2EncByRivet1L rivet2OffsetL))
             (for col2 1 numCol2
	        (dbCreateRect tcCellView rivet2Layer
			 (list xOrigin2:yOriginBot2
			      (plus xOrigin2 rivet2Length):
			      (plus yOriginBot2 rivet2Width)))
	        (dbCreateRect tcCellView rivet2Layer
			 (list xOrigin2:yOriginTop2
			      (plus xOrigin2 rivet2Length):
			      (difference yOriginTop2 rivet2Width)))
	        (setq xOrigin2 (plus xOrigin2 rivet2PitchL))
             )
           )
        
	   ;; adjust the yOrigins
	   (setq yOriginBot (plus yOriginBot rivetPitchY))
	   (setq yOriginTop (difference yOriginTop rivetPitchY))
      )

      ;; adjust the xOrigin
      (cond
	  ;; if this is between the center rivets, the center space may be
	  ;; slightly larger than the regular minimum space in order to
	  ;; better support mirroring and sharing
	  ((and (evenp numRivets)
		(lessp (abs (difference row (quotient numRivets 2.0)))
		       1e-5))
	   (setq xOrigin (plus xOrigin rivetLength centerSpace))
	  )
	  (t
	   (setq xOrigin (plus xOrigin rivetPitchX))
	  )
      )
 )

 ;; 2.  Draw the rivets along the left and right edges
 ;;
 ;; A lot of this is very similar to how it is drawn for the top and bottom

 ;; Be careful when you get close to the far top/bottom edge so that
 ;; it will not create a spacing error or a rectangular rivet with the
 ;; rivets created along the top and bottom edges
 ;;
 (cond
     ((lessp cornerExcludeWidth (times numCols rivetPitchY))
      (setq yWorkingWidth (difference w (times 2 numCols rivetPitchY)))
     )
     (t
      (setq yWorkingWidth (difference w (times 2 cornerExcludeWidth)))
     )
 )
 (setq yWorkingGrids (fix (plus 0.999 (quotient yWorkingWidth grid))))

 ;; get the maximum number of rivets we could fit in
 (setq numRivets (fix (plus 1e-5 (quotient (plus yWorkingWidth rivetSpace)
					   (plus rivetLength rivetSpace)))))

 ;; deltaWidth is the amount of extra width if there are numRivets placed
 (setq deltaWidth (difference yWorkingWidth
			      (plus
			       (times numRivets rivetLength)
			       (times (difference numRivets 1) rivetSpace))))

 ;; in some cases, the center space may be increased by 1 grid, but start
 ;; it out with the rivetSpace
 (setq centerSpace rivetSpace)

 ;; must do when an even number of rivets first because in some conditions
 ;; it will decrement to an odd number of rivets requiring the odd massaging
 ;; to be done
 (when (evenp numRivets)
     (cond
	 ;; if the total working width is an even number of grids
	 ((evenp yWorkingGrids)
	  ;; when rivet space is an even number of grids, we are OK.
	  ;; when rivet space is an odd number of grids, we must massage
	  (when (oddp rivetSpaceGrids)
	      (cond
		  ;; if there is enough room to increase the center space
		  ;; by 1 grid
		  ((geqp deltaWidth grid)
		   (setq centerSpace (plus centerSpace grid))
		  )
		  ;; otherwise, decrement the number of rivets by 1 to an
		  ;; odd number, and let it do the odd processing on it
		  (t
		   (setq numRivets (difference numRivets 1))
		  )
	      )
	  )
	 )
	 ;; else the total working width is an odd number of grids
	 (t
	  ;; when rivet space is an odd number of grids, we are OK.
	  ;; when rivet space is an even number of grids, we must massage
	  (when (evenp rivetSpaceGrids)
	      (cond
		  ;; if there is enough room to increase the center space
		  ;; by 1 grid
		  ((geqp deltaWidth grid)
		   (setq centerSpace (plus centerSpace grid))
		  )
		  ;; otherwise, decrement the number of rivets by 1 to an
		  ;; odd number, and let it do the odd processing on it
		  (t
		   (setq numRivets (difference numRivets 1))
		  )
	      )
	  )
	 )
     ) ; end cond if working width is even or odd number of grids
 ) ; end when there are an even number of rivets

 ;; must keep this after the condition when there are an even number of rivets
 (when (oddp numRivets)
     (cond
	 ;; when the total working width is an even grid multiple
	 ((evenp yWorkingGrids)
	  ;; when rivet width is an even number of grids, we are OK.
	  ;; when rivet width is an odd number of grids, we must massage
	  (when (oddp rivetWidthGrids)
	      ;; decrement the rivet count by 1 (to an even number)
	      (setq numRivets (difference numRivets 1))
	      ;; if the rivet space is an even number of grids, we are OK.
	      ;; if the rivet space is an odd number of grids, we must massage
	      (when (oddp rivetSpaceGrids)
		  ;; add 1 grid to the center space only
		  (setq centerSpace (plus centerSpace grid))
	      )
	  )
	 )
	 ;; else the total working width is an odd grid multiple
	 (t
	  ;; when rivet width is an odd number of grids, we are OK.
	  ;; when rivet width is an even number of grids, we must massage
	  (when (evenp rivetWidthGrids)
	      ;; decrement the rivet count by 1 (to an even number)
	      (setq numRivets (difference numRivets 1))
	      ;; if the rivet space is an odd number of grids, we are OK.
	      ;; if the rivet space is an even number of grids, we must massage
	      (when (evenp rivetSpaceGrids)
		  ;; add 1 grid to the center space only
		  (setq centerSpace (plus centerSpace grid))
	      )
	  )
	 )
     ) ; end cond if working width is even or odd number of grids
 ) ; end when there are an odd number of rivets

 ;; now we have got these rivets prepared so that they can be shared & mirrored
 ;; but we need to work out the initial locations.  We will draw from bottom to
 ;; top with the special centerSpace at the center rivet
 (setq yOrigin
       (difference (plus yOffset (quotient w 2.0))
		   (quotient (plus (times numRivets rivetLength)
				   (times (difference numRivets 2) rivetSpace)
				   centerSpace
			     )
			     2.0)
       )
 )

 ;; now we are in business to start drawing some rivets.
 (for row 1 numRivets
      (setq xOriginLeft xOffset)
      (setq xOriginRight (plus xOffset l))

      (for col 1 numCols
	   ;; first create the rivet on the left
	   (dbCreateRect tcCellView rivetLayer
			 (list xOriginLeft:yOrigin
			      (plus xOriginLeft rivetWidth):
			      (plus yOrigin rivetLength)))
	   ;; second create the rivet on the right
	   (dbCreateRect tcCellView rivetLayer
			 (list xOriginRight:yOrigin
			      (difference xOriginRight rivetWidth):
			      (plus yOrigin rivetLength)))
           ;; create rivet2 within rivet (along the rivet lenght)
           (when rivet2Layer
             (setq xOriginLeft2 (plus xOriginLeft rivet2EncByRivet1W))
             (setq xOriginRight2 (difference xOriginRight rivet2EncByRivet1W))
             (setq yOrigin2    (plus yOrigin rivet2EncByRivet1L rivet2OffsetL))
             (for col2 1 numCol2
	       (dbCreateRect tcCellView rivet2Layer
			 (list xOriginLeft2:yOrigin2
			      (plus xOriginLeft2 rivet2Width):
			      (plus yOrigin2 rivet2Length)))
	       (dbCreateRect tcCellView rivet2Layer
			 (list xOriginRight2:yOrigin2
			      (difference xOriginRight2 rivet2Width):
			      (plus yOrigin2 rivet2Length)))
                (setq yOrigin2 (plus yOrigin2 rivet2PitchL))
             )
           )

	   ;; adjust the xOrigins
	   (setq xOriginLeft (plus xOriginLeft rivetPitchY))
	   (setq xOriginRight (difference xOriginRight rivetPitchY))
      )

      ;; adjust the yOrigin
      (cond
	  ;; if this is between the center rivets, the center space may be
	  ;; slightly larger than the regular minimum space in order to
	  ;; better support mirroring and sharing
	  ((and (evenp numRivets)
		(lessp (abs (difference row (quotient numRivets 2.0)))
		       1e-5))
	   (setq yOrigin (plus yOrigin rivetLength centerSpace))
	  )
	  (t
	   (setq yOrigin (plus yOrigin rivetPitchX))
	  )
      )
 )
)
;;; 
;;; 
;;; enhRivetRingMirrorClass.il
;;; 
;;; Copyright (c) 1997 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Aug 10, 2004 
;;; Author: agktmp1 @ INDC
;;; 
;;; Description:
;;;   This is a part of the device library.  It will be used to generate
;;; rivets within a ring structure.  All of the parameters are formal
;;; parameters.  It is not intended to be used directly by designers,
;;; but it is intended to be instantiated by other device in the device lib.
;;;
;;;   This is a majorly hacked version of rivetRingClass.il in order to
;;; mirror the contacts.  The formal parameters are deliberately kept the
;;; same as rivetRingClass.il, even though some do not work here. These are:
;;;
;;;   llBevelLength, ulBevelLength, lrBevelLength, urBevelLength -
;;;     There is no bevel support for contacts in the corners.  It takes
;;;     the max of these as a uniform corner exclusion region.
;;;
;;;
;;;   autoIncreaseBevelWidth - completely ignored
;;;
;;;   This code does assume that there is some decent substance to the ring.
;;; It may not work as expected if there is only enough room for one or two
;;; rivets along an edge.  Three or more rivets should be no problem.
;;; 
;;; It has four extra boolean type user parameter to selectively
;;;  draw the sides of the rivet ring.

;;; Revision History:
;;;  agktmp1 10/08/04  Initial version: copied & upgraded  rivetRingMirrorClass
;;;                     It has four extra boolean type user parameter to 
;;;                     selectively  draw the sides of the rivet ring.
;;;  kmi 10/19/04 replacing hard coded grid value with (TECHgetProp snapGrid)
;;;


(tcCreateDeviceClass
 "symbolic" "enhRivetRingMirrorClass"
 ;; Class parameters
 (
  (widthEqLength          t)
 )
 ;; Formal parameters
 (
  (w                      5.0) ; size in Y direction
  (l                      5.0) ; size in X direction
  (xOffset                0.0)
  (yOffset                0.0)
  (rivetLayer             (list "y3" "drawing"))
  (rivet2Layer            nil)
  (rivetLayer2            nil) ; completely ignored
  (ringWidth              1.0)
  (rivetWidth             1.0) ; width of rivets (y-dir)
  (rivetLength            0.25); length of rivet (x-dir)
  (rivetSpace             0.5)
  (rivet2Width            0.0) ; width of rivets2 (y-dir)
  (rivet2Length           0.0) ; length of rivet2 (x-dir)
  (rivet2Space            0.0)
  (rivet2EncByRivet1L              0.0) ; rivet2 enclosure by 
  ; rivet1 (X)
  (rivet2EncByRivet1W              0.0) ; rivet2 enclosure by 
  ; rivet1 (Y)
  (llBevelLength          1.0) ; the max of the 4 bevels is used 
  ; for all
  (ulBevelLength          1.0) ; 4 of the corners as a 
; cornerExcludeWidth
(lrBevelLength          1.0)
(urBevelLength          1.0)
 (autoIncreaseBevelWidth "FALSE") ; completely ignored
 (skipTop                "FALSE")
 (skipBottom             "FALSE")
 (skipLeft               "FALSE")
(skipRight              "FALSE")
(grid     (TECHgetProp snapGrid))
 )

 ;; place the rivets selectively when it's required
(if (or (equal skipTop "FALSE") (null skipTop)) then
 (setq drawTop t)
 else
 (setq drawTop nil)
)

(if (or (equal skipBottom "FALSE") (null skipBottom)) then
 (setq drawBottom t)
 else
 (setq drawBottom nil)
)

(if (or (equal skipLeft "FALSE") (null skipLeft)) then
 (setq drawLeft t)
 else
 (setq drawLeft nil)
)

(if (or (equal skipRight "FALSE") (null skipRight)) then
 (setq drawRight t)
 else
 (setq drawRight nil)
)

(when widthEqLength
 (setq rivetLength rivetWidth)
)

(setq cornerExcludeWidth
 (max 0.0 llBevelLength ulBevelLength 
  lrBevelLength urBevelLength
 )
)

(setq rivetPitchY (plus rivetWidth rivetSpace))  ;pitch in Y-dir
(setq rivetPitchX (plus rivetLength rivetSpace)) ;pitch in X-dir

;; set rivet2 params
(when rivet2Layer
 (setq rivet2PitchL (plus rivet2Length rivet2Space)) ;pitch in X-dir
 (setq rivet2ActiveL (difference rivetLength 
                      (times 2 rivet2EncByRivet1L)
                     )
 )
 (setq numCol2 (fix (plus 
                     (quotient (plus rivet2ActiveL rivet2Space)
                      rivet2PitchL
                     ) 1e-6
                    )
               )
 )
 (setq rivet1RealL (difference (times numCol2 rivet2PitchL)
                    rivet2Space
                   )
 )
 (setq rivet2OffsetL (quotient 
                      (difference rivet2ActiveL rivet1RealL) 2
                     )
 )
 (setq rivet2OffsetL (times (fix 
                             (plus 
                              (quotient rivet2OffsetL grid) 1e-6
                             )
                            ) grid
                     )
 )
 )

 ;; find out how many column can fit within the "ringWidth"
 (setq numCols (fix (plus (quotient 
                           (plus ringWidth rivetSpace) rivetPitchY
                          ) 1e-5
                    )
               )
 )

 ;; It will draw the rivets in 2 big steps:
 ;;   1.  Draw the rivets along the top and bottom edges
 ;;   2.  Draw the rivets along the left and right edges
 ;;

 ;; 1.  Draw the rivets along the top and bottom edges
 ;;
 ;; First, determine how many rivets can fit along these edges.  Due 
 ;; to the processing order, it must do the condition of the even 
 ;; # of rivets first, and then for the odd # of rivets.
 ;;
 ;; if the # of rivets is even
 ;;   We need to make sure that we can perfectly mirror the rivets
 ;;   if total width is an even grid multiple
 ;;     rivet space must also be an even grid multiple
 ;;     else if rivet space is an odd grid multiple
 ;;       we would like to get away with increasing the center 
 ;;       width by 1 grid, but that may make it too large to fit
 ;;       within the working width.
 ;;       if there is enough room to add 1 grid to center rivet space
 ;;         add 1 grid to center rivet space
 ;;       else
 ;;         decrement the rivet count by 1 (to an odd number)
 ;;         (It will do the sanity checks when the rivet count is odd)
 ;;       end if
 ;;     end else if
 ;;   else if total width is an odd grid multiple
 ;;     rivet space must also be odd
 ;;     else if rivet space is even
 ;;       if there is enough room to add 1 grid to center rivet space
 ;;         add 1 grid to center rivet space
 ;;       else
 ;;         decrement the rivet count by 1 (to an odd number)
 ;;         (It will do the sanity checks when the rivet count is odd)
 ;;       end if
 ;;     end else if
 ;;   end else if
 ;; end if
 ;;
 ;; if # of rivets is odd
 ;;   We need to make sure that we can perfectly center the center 
 ;;   rivet.
 ;;   if total width is an even grid multiple then
 ;;     rivet width must also be even grid multiple
 ;;     else if rivet width is odd grid multiple
 ;;       decrement the rivet count by 1 (to an even number)
 ;;       if rivet space is odd multiple of grid
 ;;         add 1 grid to the middle rivet space only
 ;;       end if
 ;;     end else if
 ;;   else if total width is odd
 ;;     rivet width must be an odd grid
 ;;     else if rivet width is even
 ;;       decrement the rivet count by 1 (to an even number)
 ;;       if rivet space is an even multiple of grid
 ;;         add 1 grid to the middle rivet space only
 ;;       end if
 ;;     end else if
 ;;   end else if
 ;; end if
 ;;
 ;; This will result in some conditions where there is a spacing 
 ;; between two rivets that is 1 grid larger than minimum and what 
 ;; is used everywhere else.
 ;;

(setq rivetWidthGrids (fix (plus 0.999 (quotient rivetWidth grid))))
(setq rivetSpaceGrids (fix (plus 0.999 (quotient rivetSpace grid))))

 ;; Also be careful when you get close to the far left/right edge so
 ;; that it will not create a spacing error or a rectangular rivet if 
 ;; two instances are shared left-right.
 ;;
(cond
 ((lessp cornerExcludeWidth (quotient rivetSpace 2.0))
  (setq xWorkingWidth (difference l rivetSpace))
  ;; if the rivet space is an odd multiple of the snap grid, knock
  ;; off one more grid width to preserve the evenness/oddness 
  ;; of the xWorkingWidth number of grids
  (when (oddp rivetSpaceGrids)
   (setq xWorkingWidth (difference xWorkingWidth grid))
  )
 )
 (t
  (setq xWorkingWidth (difference l (times 2 cornerExcludeWidth)))
 )
)

(setq xWorkingGrids (fix (plus 0.999 (quotient xWorkingWidth grid))))

 ;; get the maximum number of rivets we could fit in
 (setq numRivets (fix (plus 1e-5 
                       (quotient 
                        (plus xWorkingWidth rivetSpace)
                        (plus rivetLength rivetSpace)
                       )
                      )
                 )
 )

 ;; deltaWidth is the amount of extra width if there are numRivets 
 ;; placed
 (setq deltaWidth (difference xWorkingWidth
                   (plus
                    (times numRivets rivetLength)
                    (times (difference numRivets 1) rivetSpace)
                   )
                  )
 )

 ;; in some cases, the center space may be increased by 1 grid, but 
;; start it out with the rivetSpace
(setq centerSpace rivetSpace)

 ;; must do when an even number of rivets first because in some 
 ;; conditions it will decrement to an odd number of rivets requiring
;; the odd massaging to be done
(when (evenp numRivets)
 (cond
  ;; if the total working width is an even number of grids
  ((evenp xWorkingGrids)
   ;; when rivet space is an even number of grids, we are OK.
   ;; when rivet space is an odd number of grids, we must massage
   (when (oddp rivetSpaceGrids)
    (cond
     ;; if there is enough room to increase the center space
     ;; by 1 grid
     ((geqp deltaWidth grid)
      (setq centerSpace (plus centerSpace grid))
     )
     ;; otherwise, decrement the number of rivets by 1 to an
     ;; odd number, and let it do the odd processing on it
     (t
      (setq numRivets (difference numRivets 1))
     )
    )
   )
  )
  ;; else the total working width is an odd number of grids
  (t
   ;; when rivet space is an odd number of grids, we are OK.
   ;; when rivet space is an even number of grids, we must massage
   (when (evenp rivetSpaceGrids)
    (cond
     ;; if there is enough room to increase the center space
     ;; by 1 grid
     ((geqp deltaWidth grid)
      (setq centerSpace (plus centerSpace grid))
     )
     ;; otherwise, decrement the number of rivets by 1 to an
     ;; odd number, and let it do the odd processing on it
     (t
      (setq numRivets (difference numRivets 1))
     )
    )
   )
  )
  ) ; end cond if working width is even or odd number of grids
  ) ; end when there are an even number of rivets

  ;; must keep this after the condition when there are an even number 
;; of rivets
(when (oddp numRivets)
 (cond
  ;; when the total working width is an even grid multiple
  ((evenp xWorkingGrids)
   ;; when rivet width is an even number of grids, we are OK.
   ;; when rivet width is an odd number of grids, we must massage
   (when (oddp rivetWidthGrids)
    ;; decrement the rivet count by 1 (to an even number)
    (setq numRivets (difference numRivets 1))
    ;; if the rivet space is an even number of grids, we are OK.
    ;; if the rivet space is an odd number of grids, we must 
    ;; massage
    (when (oddp rivetSpaceGrids)
     ;; add 1 grid to the center space only
     (setq centerSpace (plus centerSpace grid))
    )
   )
  )
  ;; else the total working width is an odd grid multiple
  (t
   ;; when rivet width is an odd number of grids, we are OK.
   ;; when rivet width is an even number of grids, we must massage
   (when (evenp rivetWidthGrids)
    ;; decrement the rivet count by 1 (to an even number)
    (setq numRivets (difference numRivets 1))
    ;; if the rivet space is an odd number of grids, we are OK.
    ;; if the rivet space is an even number of grids, we must massage
    (when (evenp rivetSpaceGrids)
     ;; add 1 grid to the center space only
     (setq centerSpace (plus centerSpace grid))
    )
   )
  )
  ) ; end cond if working width is even or odd number of grids
  ) ; end when there are an odd number of rivets

  ;; now we have got these rivets prepared so that they can be shared & 
  ;; mirrored but we need to work out the initial locations. We will 
  ;; draw from left to right with the special centerSpace at the center
  ;; rivet
(setq xOrigin
 (difference (plus xOffset (quotient l 2.0))
  (quotient (plus (times numRivets rivetLength)
             (times (difference numRivets 2) rivetSpace)
             centerSpace
            )
   2.0)
 )
)

(when (or (equal numRivets 0) (equal numCols 0))
 (error (sprintf nil 
         "riverRingMirrorClass: number of viaCons less than zero"
        )
 )
)
(when (and rivet2Layer (equal numCol2 0))
 (error (sprintf nil
         "riverRingMirrorClass: number of viaCons less than zero"
        )
 )
)

;; now we are in business to start drawing some rivets (top, bottom).
(for row 1 numRivets
 (setq yOriginBot yOffset)
 (setq yOriginTop (plus yOffset w))

 (for col 1 numCols
  ;; first create the rivet on the bottom

  ;; draw when it's required else skip
  (when drawBottom 
   (dbCreateRect tcCellView rivetLayer
    (list xOrigin:yOriginBot
     (plus xOrigin rivetLength):
     (plus yOriginBot rivetWidth)
    )
   )
  )
  ;; second create the rivet on the top

  ;; draw when it's required else skip
  (when drawTop
   (dbCreateRect tcCellView rivetLayer
    (list xOrigin:yOriginTop
     (plus xOrigin rivetLength):
     (difference yOriginTop rivetWidth)
    )
   )
  )

  ;; create rivet2 within rivet (along the rivet lenght)
(when rivet2Layer
 (setq yOriginBot2 (plus yOriginBot rivet2EncByRivet1W))
 (setq yOriginTop2 
  (difference yOriginTop rivet2EncByRivet1W)
 )
 (setq xOrigin2 (plus xOrigin rivet2EncByRivet1L 
                 rivet2OffsetL
                )
 )
 (for col2 1 numCol2

  ;; draw when it's required else skip
  (when drawBottom
   (dbCreateRect tcCellView rivet2Layer
    (list xOrigin2:yOriginBot2
     (plus xOrigin2 rivet2Length):
     (plus yOriginBot2 rivet2Width)
    )
   )
  )

  ;; draw when it's required else skip
  (when drawTop
   (dbCreateRect tcCellView rivet2Layer
    (list xOrigin2:yOriginTop2
     (plus xOrigin2 rivet2Length):
     (difference yOriginTop2 rivet2Width)
    )
   )
  )
  (setq xOrigin2 (plus xOrigin2 rivet2PitchL))
 )
 )

;; adjust the yOrigins
(setq yOriginBot (plus yOriginBot rivetPitchY))
(setq yOriginTop (difference yOriginTop rivetPitchY))
 )

 ;; adjust the xOrigin
 (cond
  ;; if this is between the center rivets, the center space may be
  ;; slightly larger than the regular minimum space in order to
  ;; better support mirroring and sharing
  ((and (evenp numRivets)
    (lessp (abs (difference row (quotient numRivets 2.0))) 1e-5)
   )
   (setq xOrigin (plus xOrigin rivetLength centerSpace))
  )
  (t
   (setq xOrigin (plus xOrigin rivetPitchX))
  )
 )
 )

 ;; 2.  Draw the rivets along the left and right edges
 ;;
 ;; A lot of this is very similar to how it is drawn for the top and 
 ;; bottom 
 ;; Be careful when you get close to the far top/bottom edge so that
 ;; it will not create a spacing error or a rectangular rivet with the
 ;; rivets created along the top and bottom edges
 ;;
(cond
 ((lessp cornerExcludeWidth (times numCols rivetPitchY))
  (setq yWorkingWidth (difference w (times 2 numCols rivetPitchY)))
 )
 (t
  (setq yWorkingWidth (difference w (times 2 cornerExcludeWidth)))
 )
)
(setq yWorkingGrids (fix (plus 0.999 (quotient yWorkingWidth grid))))

 ;; get the maximum number of rivets we could fit in
(setq numRivets (fix (plus 1e-5 (quotient 
                                 (plus yWorkingWidth rivetSpace)
                                 (plus rivetLength rivetSpace)
                                )
                     )
                )
)

;; deltaWidth is the amount of extra width if there are numRivets 
;; placed
(setq deltaWidth (difference yWorkingWidth
                  (plus
                   (times numRivets rivetLength)
                   (times (difference numRivets 1) rivetSpace)
                  )
                 )
)

;; in some cases, the center space may be increased by 1 grid, but 
;; start it out with the rivetSpace
(setq centerSpace rivetSpace)

 ;; must do when an even number of rivets first because in some 
 ;; conditions it will decrement to an odd number of rivets requiring 
;; the odd massaging to be done
(when (evenp numRivets)
 (cond
  ;; if the total working width is an even number of grids
  ((evenp yWorkingGrids)
   ;; when rivet space is an even number of grids, we are OK.
   ;; when rivet space is an odd number of grids, we must massage
   (when (oddp rivetSpaceGrids)
    (cond
     ;; if there is enough room to increase the center space
     ;; by 1 grid
     ((geqp deltaWidth grid)
      (setq centerSpace (plus centerSpace grid))
     )
     ;; otherwise, decrement the number of rivets by 1 to an
     ;; odd number, and let it do the odd processing on it
     (t
      (setq numRivets (difference numRivets 1))
     )
    )
   )
  )
  ;; else the total working width is an odd number of grids
  (t
   ;; when rivet space is an odd number of grids, we are OK.
   ;; when rivet space is an even number of grids, we must massage
   (when (evenp rivetSpaceGrids)
    (cond
     ;; if there is enough room to increase the center space
     ;; by 1 grid
     ((geqp deltaWidth grid)
      (setq centerSpace (plus centerSpace grid))
     )
     ;; otherwise, decrement the number of rivets by 1 to an
     ;; odd number, and let it do the odd processing on it
     (t
      (setq numRivets (difference numRivets 1))
     )
    )
   )
  )
  ) ; end cond if working width is even or odd number of grids
  ) ; end when there are an even number of rivets

  ;; must keep this after the condition when there are an even number
;; of rivets
(when (oddp numRivets)
 (cond
  ;; when the total working width is an even grid multiple
  ((evenp yWorkingGrids)
   ;; when rivet width is an even number of grids, we are OK.
   ;; when rivet width is an odd number of grids, we must massage
   (when (oddp rivetWidthGrids)
    ;; decrement the rivet count by 1 (to an even number)
    (setq numRivets (difference numRivets 1))
    ;; if the rivet space is an even number of grids, we are OK.
    ;; if the rivet space is an odd number of grids, we must massage
    (when (oddp rivetSpaceGrids)
     ;; add 1 grid to the center space only
     (setq centerSpace (plus centerSpace grid))
    )
   )
  )
  ;; else the total working width is an odd grid multiple
  (t
   ;; when rivet width is an odd number of grids, we are OK.
   ;; when rivet width is an even number of grids, we must massage
   (when (evenp rivetWidthGrids)
    ;; decrement the rivet count by 1 (to an even number)
    (setq numRivets (difference numRivets 1))
    ;; if the rivet space is an odd number of grids, we are OK.
    ;; if the rivet space is an even number of grids, we must massage
    (when (evenp rivetSpaceGrids)
     ;; add 1 grid to the center space only
     (setq centerSpace (plus centerSpace grid))
    )
   )
  )
  ) ; end cond if working width is even or odd number of grids
  ) ; end when there are an odd number of rivets

  ;; now we have got these rivets prepared so that they can be shared
  ;; & mirrored but we need to work out the initial locations.We will
  ;; draw from bottom to top with the special centerSpace at the center 
  ;; rivet
(setq yOrigin
 (difference (plus yOffset (quotient w 2.0))
  (quotient (plus (times numRivets rivetLength)
             (times (difference numRivets 2) rivetSpace)
             centerSpace
            )
   2.0)
 )
)

;; now we are in business to start drawing some rivets.
(for row 1 numRivets
 (setq xOriginLeft xOffset)
 (setq xOriginRight (plus xOffset l))

 (for col 1 numCols
  ;; first create the rivet on the left

  ;; draw when it's required else skip
  (when drawLeft 
   (dbCreateRect tcCellView rivetLayer
    (list xOriginLeft:yOrigin
     (plus xOriginLeft rivetWidth):
     (plus yOrigin rivetLength)
    )
   )
  )

  ;; second create the rivet on the right

  ;; draw when it's required else skip
  (when drawRight 
   (dbCreateRect tcCellView rivetLayer
    (list xOriginRight:yOrigin
     (difference xOriginRight rivetWidth):
     (plus yOrigin rivetLength)
    )
   )
  )

  ; create rivet2 within rivet (along the rivet lenght)
(when rivet2Layer
 (setq xOriginLeft2 (plus xOriginLeft rivet2EncByRivet1W))
 (setq xOriginRight2 (difference xOriginRight rivet2EncByRivet1W))
 (setq yOrigin2 (plus yOrigin rivet2EncByRivet1L rivet2OffsetL))
 (for col2 1 numCol2

  ;; draw when it's required else skip
  (when drawLeft
   (dbCreateRect tcCellView rivet2Layer
    (list xOriginLeft2:yOrigin2
     (plus xOriginLeft2 rivet2Width):
     (plus yOrigin2 rivet2Length)
    )
   )
  )

  ;; draw when it's required else skip
  (when drawRight 
   (dbCreateRect tcCellView rivet2Layer
    (list xOriginRight2:yOrigin2
     (difference xOriginRight2 rivet2Width):
     (plus yOrigin2 rivet2Length)
    )
   )
  )
  (setq yOrigin2 (plus yOrigin2 rivet2PitchL))
 )
 )

;; adjust the xOrigins
(setq xOriginLeft (plus xOriginLeft rivetPitchY))
(setq xOriginRight (difference xOriginRight rivetPitchY))
 )

 ;; adjust the yOrigin
 (cond
  ;; if this is between the center rivets, the center space may be
  ;; slightly larger than the regular minimum space in order to
  ;; better support mirroring and sharing
  ((and (evenp numRivets)
    (lessp (abs (difference row (quotient numRivets 2.0))) 1e-5)
   )
   (setq yOrigin (plus yOrigin rivetLength centerSpace))
  )
  (t
   (setq yOrigin (plus yOrigin rivetPitchX))
  )
 )
 )
 )

;;; 
;;; $Id: rivetRingClass.il,v 1.4 2004/10/23 01:53:52 kmi Exp $ %T%
;;; 
;;; rivetRingClass.il
;;; 
;;; Copyright (c) 1997 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Feb 20, 1997
;;; Author: Gordon Carskadon/CAD (gtc) @ CSDC
;;; 
;;; Description:
;;;   This is a part of the device library.  It will be used to generate
;;; rivets within a ring structure.  All of the parameters are formal
;;; parameters.  It is not intended to be used directly by designers,
;;; but it is intended to be instantiated by other device in the device lib.
;;; 
;;; Revision History:
;;;   gtc 04/17/97  added an optional "rivetLayer2" that it can alternate
;;;                 placing rivets in
;;;   gtc 04/22/97  adding sensible default parameter values
;;;   lpn 01/28/04  Updated the class to draw different spacing in X and y direction
;;;                 and also updated the corner sections to meet c8 diesealr in TCS 790
;;;   kmi 10/19/04 replacing hard coded grid value with (TECHgetProp snapGrid)
;;;

(putpropqq rivetRingClass "$Id: rivetRingClass.il,v 1.4 2004/10/23 01:53:52 kmi Exp $ %T%" SCCS)

(tcCreateDeviceClass
 "symbolic" "rivetRingClass"
 ;; Class parameters
 ( 
 )
 ;; Formal parameters
 (
  (w                      50.0)
  (l                      50.0)
  (xOffset                 0.0)
  (yOffset                 0.0)
  (rivetLayer             (list "hilite" "drawing"))
  (rivetLayer2             nil)
  (ringWidth               6.0)
  (rivetWidth              0.6)
  (rivetSpace              0.8)  ;; Y direction
  (rivetSpaceX	           0.0)  ;; X direction
  (llBevelLength          10.0)
  (ulBevelLength          10.0)
  (lrBevelLength          10.0)
  (urBevelLength          10.0)
  (autoIncreaseBevelWidth "FALSE")
  (grid     (TECHgetProp snapGrid))
  (lessConNearbevel    "FALSE")
  (numColsLess               0) ;; control number of cols in 45 degree corners Default should be zero	
  (updatedClass        "FALSE") ;; to control new options  
  (altCorCon           "FALSE") ;; alternate the contacts in the 45 degree corner region for the updatedClass 
 )

 ;; s2 is the square root of 2.0
 (setq s2 (sqrt 2.0))
 
 (declare thisLayer[2])
 thisLayer[0] = rivetLayer
 thisLayer[1] = (or rivetLayer2 rivetLayer)
 (setq contactNum 0)
 
 (setq rivetSpaceY rivetSpace)
 (when (equal rivetSpaceX 0.0)
     (setq rivetSpaceX rivetSpace)
 )


 (setq rivetPitchY (plus rivetWidth rivetSpaceY))
 (setq rivetPitchX (plus rivetWidth rivetSpaceX))
 (setq rivetPitchX_orig  rivetPitchX)
 (setq rivetPitchY_orig  rivetPitchY)
 (setq rivetPitchMax (max rivetPitchY rivetPitchX))	
 (setq rivetPitchMin (min rivetPitchY rivetPitchX))

 (if (rivetPitchY > rivetPitchX) then	
     (setq rivetPitchOffset (difference  rivetPitchY rivetPitchX))
  else	
     (setq rivetPitchOffset (difference  rivetPitchX rivetPitchY))
 )
 
 
 (setq rivetPitchOffsetHalf (quotient rivetPitchOffset 2))
 
 ;; find out how many column can fit within the "ringWidth"
 
(setq numCols (fix (plus (quotient (plus ringWidth rivetSpaceX) rivetPitchX) 1e-5)))
 
 ;; the rivets it places will be along the outside edge of the ring.
 ;; find out how much of the ring width it will actually use to place
 ;; numCols of rivets
 (setq usedRingWidth (difference (times numCols rivetPitchX) rivetSpaceX))
 
 ;; it might need to increase the ringWidth in the corners in order to
 ;; fit in a rivet.  Only do this when "autoIncreaseBevelWith" is true.
 ;; It will also determine how many columns of rivets can be placed
 ;; horizontally or vertically in the bevelled corners.
 (cond ((and (equal autoIncreaseBevelWidth "TRUE")
	     (lessp ringWidth (times s2 rivetWidth)))
	(setq additionalBevelWidth
	      (quotient (plus rivetWidth
			      (times (difference 1 s2) usedRingWidth))
			s2))
	(setq numColsInBevel numCols)
       )
     (t
      (setq additionalBevelWidth 0.0)
      (setq numColsInBevel
	    (fix (plus 1e-5 (quotient (difference (plus rivetSpaceX (times s2 ringWidth))
						  rivetWidth)
				      rivetPitchX))))
     )
 )

 ;; create a property of how much additional width is placed in the bevels
 (dbCreateProp tcCellView "additionalBevelWidth" "float" additionalBevelWidth)
 
 ;; determine what the minimum bevel cut length is in order to contain a
 ;; rivet in the bevelled corner
 (setq minBevelCutForRivet (difference (times 2.0 rivetPitchX) 1e-5))
 
 ;; the bevelInsideOffset is necessary to maintain a constant width
 ;; throughout the corner
 (setq bevelInsideOffset
       (quotient (plus (times ringWidth (difference s2 1.0))
		       (times s2 additionalBevelWidth))
		 grid))
 
 ;; now use a "ceiling" function to snap it up to the next grid.
 ;; this assumes that the grid is < 1.0
 (setq fixedBev (fix (plus 0.999 bevelInsideOffset)))
 (setq bevelInsideOffset (times grid fixedBev))
 
 ;; "cannotBevelLength" is the point at which the inside bevel will be
 ;; pinched off.  We do not allow bevels to occur when the bevel length
 ;; in a corner is less than this value
 (setq cannotBevelLength (difference ringWidth bevelInsideOffset))
 
 ;; determine whether it should bevel in each corner
 (setq llBevel (greaterp llBevelLength cannotBevelLength))
 (setq lrBevel (greaterp lrBevelLength cannotBevelLength))
 (setq urBevel (greaterp urBevelLength cannotBevelLength))
 (setq ulBevel (greaterp ulBevelLength cannotBevelLength))
 
 ;; It will draw the rivets in 8 steps:
 ;;   1.  Draw the rivets along the bottom edge
 ;;   2.  Draw the rivets in the lower right corner
 ;;   3.  Draw the rivets along the right edge
 ;;   4.  Draw the rivets in the upper right corner
 ;;   5.  Draw the rivets along the top edge
 ;;   6.  Draw the rivets in the upper left corner
 ;;   7.  Draw the rivets along the left edge
 ;;   8.  Draw the rivets in the lower left corner
 
 ;;
 ;; Prepare to draw the rivets along the bottom edge.  See if there is a
 ;; bevel in the lower left corner, and set the xOrigin and yOrigin
 ;; of the rivets accordingly.  As it is looping around, it will use the
 ;; following variables:
 ;;
 ;; xOrigin     is the x origin of the rivets
 ;; xLoopOrigin is the x origin of the rivets as it is looping through rows
 ;; xStop       when it is looping through columns, do not place a column
 ;;             beyond this x stopping point
 ;; yOrigin     is the y origin of the rivets
 ;; yLoopOrigin is the y origin of the rivets as it is looping through columns
 ;; yStop       when it is looping through rows, do not place a row
 ;;             beyond this y stopping point
 ;;
 ;; prepare origins for the row of rivets on the bottom
 (cond  (llBevel
	 (setq xOrigin (plus xOffset llBevelLength))
	 (setq yOrigin yOffset)
	)
     (t
      (setq xOrigin xOffset)
      (setq yOrigin yOffset)
     )
 )
 
 ;; make sure that there will not be a spacing error between the rivets
 ;; along the left edge and the rivets along the bottom edge.  If necessary,
 ;; increase the x origin of the rivets along the bottom edge.
 (when (lessp llBevelLength (plus usedRingWidth rivetSpaceX))
     (setq xOrigin (plus xOffset (max (plus usedRingWidth rivetSpaceX)
				      rivetPitchX)))
 

)

 ;; set the stopping condition for the row of rivets on the bottom
 (cond (lrBevel
	(setq xStop (plus xOffset l -lrBevelLength -rivetWidth))
       )
     (t
      (setq xStop (plus xOffset l -rivetWidth))
     )
 )

 (when (equal lessConNearbevel "TRUE")
     (setq xStop (plus xStop -rivetPitchX))
 )
 ;;
 ;; 1.  Draw the rivets along the bottom edge
 ;;
 (setq tempContactNum contactNum)
 (setq yLoopOrigin yOrigin)
 (for col 1 numCols
      (setq contactNum (mod (plus tempContactNum 1) 2))
      (setq tempContactNum contactNum)
      (setq xLoopOrigin xOrigin)
      
      (when (equal lessConNearbevel "TRUE")
	  (setq xLoopOrigin (plus xOrigin rivetPitchY))
	  
      )
      (while (xLoopOrigin < xStop)
	  (dbCreateRect tcCellView thisLayer[contactNum]
			(list xLoopOrigin:yLoopOrigin
			      (plus xLoopOrigin rivetWidth):
			      (plus yLoopOrigin rivetWidth)))
	  (setq contactNum (mod (plus contactNum 1) 2))
	  (setq xLoopOrigin (plus xLoopOrigin rivetPitchY))
      )
      (setq yLoopOrigin (plus yLoopOrigin rivetPitchX))
 )
(when (equal lessConNearbevel "TRUE")
    (setq xLoopOrigin (plus xLoopOrigin rivetPitchX))
)


;; this is to aviod update to algo draw correctly in 45 degree

(when (equal updatedClass "TRUE")
    (setq rivetPitchX  rivetPitchMax )
    (setq rivetPitchY  rivetPitchMax )
    thisLayer[0] = rivetLayer  
    thisLayer[1] = rivetLayer2
    (setq rivetPitchOffsetHalf  0.0 )        ;; rivetPitchX = rivetPitchY
    (setq rivetPitchOffset      0.0 )        ;; rivetPitchX = rivetPitchY
)

(setq numColsLR        (plus numCols -numColsLess))
(setq numColsInBevelLR (plus numColsInBevel -numColsLess))

;;
;; 2.  Draw the rivets in the lower right corner
;;
(cond ((and lrBevel (greaterp lrBevelLength minBevelCutForRivet))
       
       ;; In centering the rivets in a bevelled corner, the following
       ;; variables will be used:
       ;;
       ;; slackFromLastRun - how much space there is between the last rivet
	;;    in the last run and the beginning of the bevel in this corner.
	;; delta - non-zero only when the next run of rivets must be pushed
	;;    out to prevent them from overlapping the last run of rivets.
	;;    This is how much extra space there is in the corner.
	;; totalSlack - the total amount of slack that will be used to
	;;    center the rivets in the corner.
	;; extraOffset - half of totalSlack nicely snapped to the grid
	;; theStartRow - what row to start drawing the rivets.  This will
	;;    usually be 1.  It will be > 1 when the corner is being pinched
	;;    when the next run of rivets is going to be pushed out to prevent
	;;    them from overlapping the last run of rivets.
	;;
	
	(setq slackFromLastRun (plus xOffset l -lrBevelLength -xLoopOrigin rivetSpaceX))

	;; see if it needs to massage the y origin.  This is a condition when
	;; the y origin of the rivets along the right edge must be pushed
	;; up to prevent them from overlapping the rivets along the bottom edge
	(cond ((lessp lrBevelLength (plus usedRingWidth rivetSpaceX))
	       (setq delta (min (plus -lrBevelLength usedRingWidth rivetSpaceX)
				rivetPitchX))
	       (setq theStartRow (difference 1 (fix (plus 1e-5 (quotient (plus usedRingWidth rivetSpaceX -lrBevelLength) rivetPitchX)))))
	      )
	    (t	    
	     (setq delta 0.0)
	     (setq theStartRow 1)
	    )
	)
	;; calculate the total slack space available to use to center the
	;; rivets in the corner
	(setq totalSlack (difference
			  (plus lrBevelLength delta slackFromLastRun)
			  (times rivetPitchX (fix (plus 1e-5 (quotient (plus lrBevelLength delta slackFromLastRun) rivetPitchX))))))
	;; half of the totalSlack will be on each side of the corner rivets
	(setq halfTotalSlack (times 0.5 totalSlack))
	
	;; snap the slack offset to the grid
	(setq fixedHalfSlack (fix (plus 0.999 (quotient halfTotalSlack grid))))
	(setq extraOffset (times fixedHalfSlack grid))
	;; set the x and y origins for beginning the corner rivet fill

	(setq xOrigin
	      (plus xOffset l -rivetPitchX -rivetWidth -extraOffset delta rivetPitchOffsetHalf))
	(setq yOrigin
	      (plus yOffset lrBevelLength -rivetPitchY -extraOffset delta -rivetPitchOffsetHalf))	

	;; set the stopping condition
	(setq xStop (plus xOffset l -lrBevelLength rivetSpaceX
			  -slackFromLastRun -1e-5))
	(setq col 1)
	
	;; loop through all of the columns in this corner
	(while (xOrigin >= xStop)
	    
	    ;; set the stopping row based on what column it is currently
	    ;; looped at, and the number of columns it can fit in the bevel
	    (setq stopRow (min col numColsInBevelLR))
	    
	    ;; set the starting row.  Usually this is 1, but there are
	    ;; curcumstances where it is not.
	    (cond ((and (greaterp numColsInBevelLR numColsLR)
			(col >= numColsLR))
		   ;; this is to fill in a few rivets in the inside bevel
		   ;; cut in the upper side of the lower right corner
		   (setq startRow stopRow - numColsInBevelLR + 1)
		  )
		(t
		 (setq startRow theStartRow)
		)
	    )
	    ;; loop through all of the rows in this corner creating a rivet
	    (for row startRow stopRow
		 (setq yLoopOrigin
		       (plus yOrigin
			     (times (difference row 1) -rivetPitchY)))
		 (dbCreateRect tcCellView thisLayer[contactNum]
			       (list xOrigin:yLoopOrigin
				     (plus xOrigin rivetWidth):
				     (plus yLoopOrigin rivetWidth)))
		 (setq contactNum (mod (plus contactNum 1) 2))

		 (when (and (equal updatedClass "TRUE") (equal altCorCon "TRUE"))
		     (dbCreateRect tcCellView thisLayer[contactNum]		
				   (list xOrigin:yLoopOrigin
					 (plus xOrigin rivetWidth):(plus yLoopOrigin rivetWidth)))
		     (setq contactNum (mod (plus contactNum 1) 2))
		 ) 
		 
	    )
	   (setq yOrigin (difference yOrigin rivetPitchOffset))

	    (setq col (plus col 1))
	    (when (greaterp col numColsInBevelLR)
		(setq yOrigin  (difference yOrigin rivetPitchY))		
	    )
	    (setq xOrigin (difference xOrigin rivetPitchX))
	)
	
	;; this is to fill in a few rivets in the inside bevel cut in the
	;; left side of the lower right corner
	(when (and (greaterp numColsInBevelLR numColsLR)
		   (greaterp lrBevelLength ringWidth))
	    (setq yStop (plus yOffset usedRingWidth rivetSpaceY))
	    (setq yLoopOrigin yOrigin)
	    (while (xOrigin >=
			    (plus xOffset l -lrBevelLength -bevelInsideOffset))
		(while (yLoopOrigin > yStop)
		    (dbCreateRect tcCellView thisLayer[contactNum]
				  (list xOrigin:yLoopOrigin
					(plus xOrigin rivetWidth):(plus yLoopOrigin rivetWidth)))
		    (setq contactNum (mod (plus contactNum 1) 2))		
		  
		    
		    (setq yLoopOrigin (difference yLoopOrigin rivetPitchY))
		)
		(setq yOrigin (difference yOrigin rivetPitchY))
		(setq yLoopOrigin yOrigin)
		(setq xOrigin (difference xOrigin rivetPitchX))
	    )
	)
	
	;; prepare origins for the row of rivets on the right
	(setq xOrigin (plus xOffset l -usedRingWidth))
	(setq yOrigin (plus yOffset lrBevelLength))
       )
     (lrBevel
      ;; prepare origins for the row of rivets on the right
      (setq xOrigin (plus xOffset l -usedRingWidth))
      (setq yOrigin (plus yOffset lrBevelLength))
     )
     (t
      ;; prepare origins for the row of rivets on the right
      (setq xOrigin (plus xOffset l -usedRingWidth))
      (setq yOrigin (plus yOffset usedRingWidth rivetSpaceY))
     )
 )
 
 (when (lessp lrBevelLength (plus usedRingWidth rivetSpaceY))
     (setq yOrigin (plus yOffset usedRingWidth rivetSpaceY))
 )
 
 ;; set the stopping condition for the row of rivets on the right
 (cond (urBevel
	(setq yStop (plus yOffset w -urBevelLength -rivetWidth))
       )
     (t
      (setq yStop (plus yOffset w -rivetWidth))
     )
 )

 (when (equal lessConNearbevel "TRUE")
     (setq yStop (plus yStop -rivetPitchY))
 )

(when  (equal updatedClass "TRUE") 
    (setq rivetPitchX  rivetPitchX_orig )
    (setq rivetPitchY  rivetPitchY_orig )
    thisLayer[0] = rivetLayer
     thisLayer[1] = (or rivetLayer2 rivetLayer)
)
;;
;; 3.  Draw the rivets along the right edge
;;
(setq xLoopOrigin xOrigin)
 (for col 1 numCols
      (setq contactNum (mod (plus tempContactNum 1) 2))
      (setq tempContactNum contactNum)
      (setq yLoopOrigin yOrigin)
      
      (when (equal lessConNearbevel "TRUE")
	  (setq yLoopOrigin (plus yOrigin rivetPitchY))
      )
      (while (yLoopOrigin < yStop)
	  (dbCreateRect tcCellView thisLayer[contactNum]
			(list xLoopOrigin:yLoopOrigin
			      (plus xLoopOrigin rivetWidth):
			      (plus yLoopOrigin rivetWidth)))
	  (setq contactNum (mod (plus contactNum 1) 2))
	  (setq yLoopOrigin (plus yLoopOrigin rivetPitchY))
      )
      (setq xLoopOrigin (plus xLoopOrigin rivetPitchX))
 )

(when (equal lessConNearbevel "TRUE")
    (setq yLoopOrigin (plus yLoopOrigin rivetPitchY))
)

(when  (equal updatedClass "TRUE") 
    (setq rivetPitchX  rivetPitchMax )
    (setq rivetPitchY  rivetPitchMax )
    thisLayer[0] = rivetLayer
    thisLayer[1] = rivetLayer2
    (setq rivetPitchOffsetHalf  0.0 )        ;; rivetPitchX = rivetPitchY
    (setq rivetPitchOffset  0.0  )           ;; rivetPitchX = rivetPitchY
)

(setq numColsUR        (plus numCols -numColsLess))
(setq numColsInBevelUR (plus numColsInBevel -numColsLess))
;;
;; 4.  Draw the rivets in the upper right corner
;;
(cond ((and urBevel (greaterp urBevelLength minBevelCutForRivet))
       
       (setq slackFromLastRun (plus yOffset w -urBevelLength
				    -yLoopOrigin rivetSpaceY))

       ;; see if it needs to massage the x origin.  This is a condition when
       ;; the x origin of the rivets along the top edge must be pushed
       ;; to the left to prevent them from overlapping the rivets along
       ;; the right edge.
       (cond ((lessp urBevelLength (plus usedRingWidth rivetSpaceX))
	      (setq delta (min (plus -urBevelLength usedRingWidth rivetSpaceX)
			       rivetPitchX))
	      (setq theStartRow (difference 1 (fix (plus 1e-5 (quotient (plus usedRingWidth rivetSpaceX -urBevelLength) rivetPitchX)))))
	     )
	   (t
	     (setq delta 0.0)
	     (setq theStartRow 1)
	   )
       )
       
       ;; calculate the total slack space available to use to center the
       ;; rivets in the corner
	(setq totalSlack (difference
			  (plus urBevelLength delta)
			  (times rivetPitchX (fix (plus 1e-5 (quotient (plus urBevelLength delta) rivetPitchX))))))
	(cond ((greaterp (plus totalSlack slackFromLastRun 1e-5) rivetPitchX)
	       (setq totalSlack (plus -rivetPitchX totalSlack slackFromLastRun))
	      )
	    (t
	     (setq totalSlack (plus totalSlack slackFromLastRun))
	    )
	)
	
	;; half of the totalSlack will be on each side of the corner rivets
	(setq halfTotalSlack (times 0.5 totalSlack))
	
	;; snap the offset to the grid
	(setq fixedHalfSlack (fix (plus 0.999 (quotient halfTotalSlack grid))))
	(setq extraOffset (times fixedHalfSlack grid))
	
	
	
	;; set the x and y origins for beginning the corner rivet fill
	(setq xOrigin (plus xOffset l -rivetWidth -rivetPitchX -extraOffset slackFromLastRun
			    rivetPitchOffsetHalf ))
	(setq yOrigin (plus yLoopOrigin extraOffset rivetPitchOffsetHalf))
	
	;; depending upon how much slack there was from the run on the right
	;; edge and on how much extra offset there is to center the upper
	;; right corner rivets, it might not can place the first column
	;; of extra rivets in the lower side inside bevel cut
	(cond ((greaterp 0.0 (plus slackFromLastRun -extraOffset))
	       (setq drawExtraInsideColumn t)
	      )
	    (t (setq drawExtraInsideColumn nil))
	)

	;; set the stopping condition
	(setq xStop (min (plus xOffset l -urBevelLength rivetSpaceX -1e-5)
			 (plus xOffset l -usedRingWidth -1e-5)))
	(setq col 1)
	
	

	;; loop through all of the columns
	(while (xOrigin >= xStop)
	    
	    ;; set the stopping row
	    (setq stopRow (min col numColsInBevelUR))
	    
	    ;; set the starting row
	    (cond ((and (greaterp numColsInBevelUR numColsUR)
			(col >= numColsUR))
		   (cond (drawExtraInsideColumn
			  ;; this is to fill in a few rivets in the inside
			  ;; bevel cut in the lower side of the upper right
			  ;; corner
			  (setq startRow stopRow - numColsInBevelUR + 1)
			 )
		       (t (setq drawExtraInsideColumn t))
		   )
		  )
		(t
		 (setq startRow theStartRow)
		)
	    )
	    
	    ;; loop through all of the rows while drawing rivets
	    (for row startRow stopRow
		 (setq yLoopOrigin
		       (plus yOrigin
			     (times (difference row 1) rivetPitchY)))
		 (dbCreateRect tcCellView thisLayer[contactNum]
			       (list xOrigin:yLoopOrigin
				     (plus xOrigin rivetWidth):
				     (plus yLoopOrigin rivetWidth)))
		 (setq contactNum (mod (plus contactNum 1) 2))
	 
		 (when (and (equal updatedClass "TRUE") (equal altCorCon "TRUE"))		

		     (dbCreateRect tcCellView thisLayer[contactNum]
				   (list xOrigin:yLoopOrigin
					 (plus xOrigin rivetWidth):
				     (plus yLoopOrigin rivetWidth)))
		     (setq contactNum (mod (plus contactNum 1) 2))	 
		 )
	    )
	    (setq yOrigin (plus yOrigin rivetPitchOffset))
	    

	    (setq col (plus col 1))
	    (when (greaterp col numColsInBevelUR)
		(setq yOrigin (plus yOrigin rivetPitchY))
	    )
	    (setq xOrigin (difference xOrigin rivetPitchX))
	)
	
	(when (col <= numColsInBevelUR)
	    (setq yOrigin (plus yOrigin (times startRow rivetPitchY)))
	)
	
	;; this is to fill in a few rivets in the inside bevel cut in the
	;; left side of the upper right corner
	(when (and (greaterp numColsInBevelUR numColsUR)
		   (greaterp urBevelLength ringWidth))
	    (setq yStop (plus yOffset w -usedRingWidth -rivetPitchY))
	    (setq yLoopOrigin yOrigin)
	    (while (xOrigin >= (plus xOffset l -urBevelLength -bevelInsideOffset))
		(while (yLoopOrigin <= yStop)
		    (dbCreateRect tcCellView thisLayer[contactNum]
				  (list xOrigin:yLoopOrigin
					(plus xOrigin rivetWidth):(plus yLoopOrigin rivetWidth)))
		    (setq contactNum (mod (plus contactNum 1) 2))
		    (setq yLoopOrigin (plus yLoopOrigin rivetPitchY))
		)
		(setq yOrigin (plus yOrigin rivetPitchY))
		(setq yLoopOrigin yOrigin)
		(setq xOrigin (difference xOrigin rivetPitchX))
	    )
	)
	
	;; prepare origins for the row of rivets on the top
	(setq xOrigin (plus xOffset l -urBevelLength -rivetWidth))
	(setq yOrigin (plus yOffset w -usedRingWidth))
      )
    (lrBevel
     ;; prepare origins for the row of rivets on the top
     (setq xOrigin (plus xOffset l -urBevelLength -rivetWidth))
     (setq yOrigin (plus yOffset w -usedRingWidth))
    )
     (t
      ;; prepare origins for the row of rivets on the top
      (setq xOrigin (plus xOffset l -usedRingWidth -rivetSpaceX))
      (setq yOrigin (plus yOffset w -usedRingWidth))
     )
)

;; if necessary, adjust the starting condition for the row of rivets on top
;; to make sure that the rivets along the top edge to not overlap the rivets
;; along the right edge
(when (greaterp xOrigin (plus xOffset l -usedRingWidth -rivetPitchX))
    (setq xOrigin (plus xOffset l -usedRingWidth -rivetPitchX))
)

;; set the stopping condition for the row of rivets on the top
(cond (ulBevel
       (setq xStop (plus xOffset ulBevelLength -1e-5))
       )
    (t
     (setq xStop (plus xOffset -1e-5))
    )
)

(when (equal lessConNearbevel "TRUE")
    (setq xStop (plus xStop rivetPitchX))
)
(when  (equal updatedClass "TRUE") 
    (setq rivetPitchX  rivetPitchX_orig )
    (setq rivetPitchY  rivetPitchY_orig )
    thisLayer[0] = rivetLayer
     thisLayer[1] = (or rivetLayer2 rivetLayer)
)
;;
;; 5.  Draw the rivets along the top edge
;;
(setq yLoopOrigin yOrigin)
(for col 1 numCols
      (setq contactNum (mod (plus tempContactNum 1) 2))
      (setq tempContactNum contactNum)
      (setq xLoopOrigin xOrigin)
 
      (when (equal lessConNearbevel "TRUE")
	  (setq xLoopOrigin (plus xOrigin -rivetPitchX))
      )

      (while (xLoopOrigin > xStop)
	  (dbCreateRect tcCellView thisLayer[contactNum]
			(list xLoopOrigin:yLoopOrigin
			      (plus xLoopOrigin rivetWidth):
			      (plus yLoopOrigin rivetWidth)))
	  (setq contactNum (mod (plus contactNum 1) 2))
	  (setq xLoopOrigin (difference xLoopOrigin rivetPitchY))
       )
      (setq yLoopOrigin (plus yLoopOrigin rivetPitchX))
)

(when (equal lessConNearbevel "TRUE")
    (setq xLoopOrigin (plus xLoopOrigin -rivetPitchX))
)

(when  (equal updatedClass "TRUE") 
    (setq rivetPitchX  rivetPitchMax )
    (setq rivetPitchY  rivetPitchMax )
    thisLayer[0] = rivetLayer
    thisLayer[1] = rivetLayer2
    (setq rivetPitchOffsetHalf  0.0 )        ;; rivetPitchX = rivetPitchY
    (setq rivetPitchOffset  0.0  )           ;; rivetPitchX = rivetPitchY
)

(setq numColsUL        (plus numCols -numColsLess))
(setq numColsInBevelUL (plus numColsInBevel -numColsLess))

;;
;; 6.  Draw the rivets in the upper left corner
;;
(cond ((and ulBevel (greaterp ulBevelLength minBevelCutForRivet))
       
       (setq slackFromLastRun (plus xLoopOrigin rivetPitchX -xOffset -ulBevelLength))
       
       ;; see if it needs to massage the y origin.  This is a condition when
       ;; the y origin of the rivets along the left edge must be pushed down
       ;; to prevent them from overlapping the rivets along the top edge.
       ;;
       (cond ((lessp ulBevelLength (plus usedRingWidth rivetSpaceX))
	      (setq delta (min (plus -ulBevelLength usedRingWidth rivetSpaceX)
			       rivetPitchX))
	       (setq theStartRow (difference 1 (fix (plus 1e-5 (quotient (plus usedRingWidth rivetSpaceX -ulBevelLength) rivetPitchX)))))
	     )
	   (t
	     (setq delta 0.0)
	     (setq theStartRow 1)
	   )
       )
       
       ;; calculate the total slack space available to use to center the
       ;; rivets in the corner
       (setq totalSlack (difference
			  (plus ulBevelLength delta slackFromLastRun)
			  (times rivetPitchX (fix (plus 1e-5 (quotient (plus ulBevelLength delta slackFromLastRun) rivetPitchX))))))
       
       ;; half of the totalSlack will be on each side of the corner rivets
       (setq halfTotalSlack (times 0.5 totalSlack))
       
       ;; snap the offset to the grid
       (setq fixedHalfSlack (fix (plus 0.999 (quotient halfTotalSlack grid))))
       (setq extraOffset (times fixedHalfSlack grid))

       ;; set the x and y origins for beginning the corner rivet fill
       
       
       (setq xOrigin (plus xOffset rivetPitchX extraOffset -delta -rivetPitchOffsetHalf))
       (setq yOrigin (plus yOffset w -ulBevelLength rivetSpaceY extraOffset -delta rivetPitchOffsetHalf))
       
       ;; set the stopping condition
       (setq xStop (difference (plus xOffset ulBevelLength slackFromLastRun 1e-5)
			       rivetPitchX))
       (setq col 1)
       

       ;; loop through all of the columns
       (while (xOrigin <= xStop)
	   
	   ;; set the stopping row
	   (setq stopRow (min col numColsInBevelUL))
	   
	   ;; set the starting row
	   (cond ((and (greaterp numColsInBevelUL numColsUL)
		       (col >= numColsUL))
		  ;; this is to fill in a few rivets in the inside bevel
		  ;; cut in the lower side of the upper left corner
		  (setq startRow stopRow - numColsInBevelUL + 1)
		 )
	       (t
		 (setq startRow theStartRow)
	       )
	   )
	   
	   ;; loop through all the rows while creating rivets
	   (for row startRow stopRow
		 (setq yLoopOrigin
		       (plus yOrigin
			     (times (difference row 1) rivetPitchY)))
		 (dbCreateRect tcCellView thisLayer[contactNum]
			       (list xOrigin:yLoopOrigin
				     (plus xOrigin rivetWidth):
				     (plus yLoopOrigin rivetWidth)))
		 (setq contactNum (mod (plus contactNum 1) 2))

		 (when (and (equal updatedClass "TRUE") (equal altCorCon "TRUE"))
		     
		     (dbCreateRect tcCellView thisLayer[contactNum]
				   (list xOrigin:yLoopOrigin
					 (plus xOrigin rivetWidth):
					 (plus yLoopOrigin rivetWidth)))
		     (setq contactNum (mod (plus contactNum 1) 2))
		 )
	   )
	   (setq col (plus col 1))
	   (setq yOrigin 	(plus yOrigin rivetPitchOffset)) 

	   (when (greaterp col numColsInBevelUL)
	       (setq yOrigin (plus yOrigin rivetPitchY))
	   )
	   (setq xOrigin (plus xOrigin rivetPitchX))
       )
       
       ;; this is to fill in a few rivets in the inside bevel cut in the
	;; right side of the upper left corner
       (when (and (greaterp numColsInBevelUL numColsUL)
		  (greaterp ulBevelLength ringWidth))
	   (setq yStop (plus yOffset w -usedRingWidth -rivetPitchY))
	   (setq yLoopOrigin yOrigin)
	   (while (xOrigin <= (plus xOffset ulBevelLength bevelInsideOffset))
	       (while (yLoopOrigin <= yStop)
		    (dbCreateRect tcCellView thisLayer[contactNum]
				  (list xOrigin:yLoopOrigin
					(plus xOrigin rivetWidth):(plus yLoopOrigin rivetWidth)))
		    (setq contactNum (mod (plus contactNum 1) 2))
		    (setq yLoopOrigin (plus yLoopOrigin rivetPitchY))
	       )
	       (setq yOrigin (plus yOrigin rivetPitchY))
	       (setq yLoopOrigin yOrigin)
	       (setq xOrigin (plus xOrigin rivetPitchX))
	   )
       )

       ;; prepare origins for the row of rivets on the left
       (setq xOrigin xOffset)
       (setq yOrigin (plus yOffset w -ulBevelLength -rivetWidth))
       
       )
    (ulBevel
     ;; prepare origins for the row of rivets on the left
     (setq xOrigin xOffset)
     (setq yOrigin (plus yOffset w -ulBevelLength -rivetWidth))
    )
    (t
     ;; prepare origins for the row of rivets on the left
     (setq xOrigin xOffset)
     (setq yOrigin (plus yOffset w -usedRingWidth -rivetPitchY))
    )
)

;; make sure that the rivets along the left edge do not overlap the
;; rivets along the top edge/upper left corner
(when (greaterp yOrigin (plus yOffset w -usedRingWidth -rivetPitchY))
    (setq yOrigin (plus yOffset w -usedRingWidth -rivetPitchY))
)

;; set the stopping condition for the row of rivets on the left
(cond (llBevel
	(setq yStop (plus yOffset llBevelLength))
      )
    (t
     (setq yStop yOffset)
    )
)

(when (equal lessConNearbevel "TRUE")
     (setq yStop (plus yStop rivetPitchY))
)
(when  (equal updatedClass "TRUE") 
    (setq rivetPitchX  rivetPitchX_orig )
    (setq rivetPitchY  rivetPitchY_orig )
    thisLayer[0] = rivetLayer
    thisLayer[1] = (or rivetLayer2 rivetLayer)
)

;;
;; 7.  Draw the rivets along the left edge
;;
(setq xLoopOrigin xOrigin)
(for col 1 numCols
     (setq contactNum (mod (plus tempContactNum 1) 2))
     (setq tempContactNum contactNum)
     (setq yLoopOrigin yOrigin)
     
     (when (equal lessConNearbevel "TRUE")
	 (setq yLoopOrigin (plus yOrigin -rivetPitchY))
     )
      (while (yLoopOrigin > yStop)
	  (dbCreateRect tcCellView thisLayer[contactNum]
			(list xLoopOrigin:yLoopOrigin
			      (plus xLoopOrigin rivetWidth):
			      (plus yLoopOrigin rivetWidth)))
	  (setq contactNum (mod (plus contactNum 1) 2))
	  (setq yLoopOrigin (difference yLoopOrigin rivetPitchY))
      )
      (setq xLoopOrigin (plus xLoopOrigin rivetPitchX))
)

(when (equal lessConNearbevel "TRUE")
    (setq yLoopOrigin (plus yLoopOrigin -rivetPitchY))
)
(when  (equal updatedClass "TRUE") 
    (setq rivetPitchX  rivetPitchMax )
    (setq rivetPitchY  rivetPitchMax )
    thisLayer[0] =   rivetLayer
    thisLayer[1] =  rivetLayer2
    (setq rivetPitchOffsetHalf  0.0 )        ;; rivetPitchX = rivetPitchY
    (setq rivetPitchOffset  0.0  )           ;; rivetPitchX = rivetPitchY
)

(setq numColsLL        (plus numCols -numColsLess))
(setq numColsInBevelLL (plus numColsInBevel -numColsLess))
;;
;; 8.  Draw the rivets in the lower left corner
;;
(cond ((and llBevel (greaterp llBevelLength minBevelCutForRivet))
       
       (setq slackFromLastRun (plus yLoopOrigin rivetPitchX
				    -yOffset -llBevelLength))

       ;; see if it needs to massage the x origin.  This is a condition when
       ;; the x origin of the rivets along the bottom edge must be pushed
       ;; to the right to prevent them from overlapping the rivets along
       ;; the top edge.
       (cond ((lessp llBevelLength (plus usedRingWidth rivetSpaceX))
	      (setq delta (min (plus -llBevelLength usedRingWidth rivetSpaceX)
			       rivetPitchX))
	      (setq theStartRow (difference 1 (fix (plus 1e-5 (quotient (plus usedRingWidth rivetSpaceX -llBevelLength) rivetPitchX)))))
	      )
	   (t
	    (setq delta 0.0)
	    (setq theStartRow 1)
	   )
       )

       ;; calculate the total slack space available to use to center the
       ;; rivets in the corner
       (setq totalSlack (difference
			 (plus llBevelLength delta)
			 (times rivetPitchX (fix (plus 1e-5 (quotient (plus llBevelLength delta) rivetPitchX))))))
       (cond ((greaterp (plus totalSlack slackFromLastRun 1e-5) rivetPitchX)
	       (setq totalSlack (plus -rivetPitchX totalSlack slackFromLastRun))
	     )
	   (t
	    (setq totalSlack (plus totalSlack slackFromLastRun))
	   )
	)
       
       ;; half of the totalSlack will be on each side of the corner rivets
       (setq halfTotalSlack (times 0.5 totalSlack))
       
       ;; snap the offset to the grid
       (setq fixedHalfSlack (fix (plus 0.999 (quotient halfTotalSlack grid))))
       (setq extraOffset (times fixedHalfSlack grid))
       
       
       ;; set the x and y origins for beginning the corner rivet fill
       (setq xOrigin (plus xOffset rivetPitchX -slackFromLastRun extraOffset))
       (setq yOrigin (plus yLoopOrigin -extraOffset))
       
       ;; depending upon how much slack there was from the run on the left
       ;; edge and on how much extra offset there is to center the lower
       ;; left rivets, it might not can place the first column of extra
       ;; rivets in the upper side inside bevel cut
       (cond ((greaterp 0.0 (plus slackFromLastRun -extraOffset))
	      (setq drawExtraInsideColumn t)
	     )
	   (t (setq drawExtraInsideColumn nil))
	)
       
       ;; set the stopping condition
       (setq xStop (max (plus xOffset llBevelLength 1e-5 -rivetPitchX)
			(plus xOffset usedRingWidth 1e-5 -rivetWidth)))
       (setq col 1)
       

       
       ;; loop through the columns
       (while (xOrigin <= xStop)
	   
	   ;; set the stopping row
	   (setq stopRow (min col numColsInBevelLL))
	   
	   ;; set the starting row
	   (cond ((and (greaterp numColsInBevelLL numColsLL)
		       (col >= numColsLL))
		  (cond (drawExtraInsideColumn
			 ;; this is to fill in a few rivets in the inside
			 ;; bevel cut in the top side of the lower left corner
			 (setq startRow stopRow - numColsInBevelLL + 1)
			 )
		      (t (setq drawExtraInsideColumn t))
		  )
		 )
	       (t
		 (setq startRow theStartRow)
	       )
	   )
	   
	   ;; loop through all the rows while drawing the rivets
	   (for row startRow stopRow
		(setq yLoopOrigin
		      (plus yOrigin
			     (times (difference row 1) -rivetPitchY)))
		
		(dbCreateRect tcCellView thisLayer[contactNum]
			      (list xOrigin:yLoopOrigin
				    (plus xOrigin rivetWidth):
				     (plus yLoopOrigin rivetWidth)))
		(setq contactNum (mod (plus contactNum 1) 2))

		(when (and (equal updatedClass "TRUE") (equal altCorCon "TRUE"))
	
		    (dbCreateRect tcCellView thisLayer[contactNum]
				  (list xOrigin:yLoopOrigin
					(plus xOrigin rivetWidth):
					(plus yLoopOrigin rivetWidth)))
		    (setq contactNum (mod (plus contactNum 1) 2))
		)
	   )
	   (setq col (plus col 1))
	   (setq yOrigin (difference yOrigin rivetPitchOffset))
	   (when (greaterp col numColsInBevelLL)
	       (setq yOrigin (difference yOrigin rivetPitchY))
	   )
	   (setq xOrigin (plus xOrigin rivetPitchX))
       )
       
	(when (col <= numColsInBevelLL)
	    (setq yOrigin (plus yOrigin (times -startRow rivetPitchY)))
	)
	
	;; this is to fill in a few rivets in the inside bevel cut in the
	;; right side of the lower left corner
	(when (and (greaterp numColsInBevelLL numColsLL)
		   (greaterp llBevelLength ringWidth))
	    (setq yStop (plus yOffset usedRingWidth rivetSpaceY))
	    (setq yLoopOrigin yOrigin)
	    (while (xOrigin <= (plus xOffset llBevelLength bevelInsideOffset))
		(while (yLoopOrigin > yStop)
		    (dbCreateRect tcCellView thisLayer[contactNum]
				  (list xOrigin:yLoopOrigin
					(plus xOrigin rivetWidth):(plus yLoopOrigin rivetWidth)))
		    (setq contactNum (mod (plus contactNum 1) 2))
		    (setq yLoopOrigin (difference yLoopOrigin rivetPitchY))
		)
		(setq yOrigin (difference yOrigin rivetPitchY))
		(setq yLoopOrigin yOrigin)
		(setq xOrigin (plus xOrigin rivetPitchX))
	    )
	)
       )
 )
)

;;; 
;;; $Id: shortClass.il,v 1.1 1998/02/10 13:22:25 gtc Exp $ %T%
;;; 
;;; shortClass.il
;;; 
;;; Copyright (c) 1996 by Cypress Semiconductor
;;; Cypress Southeast Design Center (CSDC)
;;; 
;;; Date  : Nov 19, 1996
;;; Author: Sanjay Rekhi/Senior CAD (syr) @ CSDC
;;; 
;;; Description:
;;;   The short class is used to define the short devices for the
;;;   metal1, metal2 and metal3 layers.
;;;
;;; Revision History:
;;; 
;;; 

(putpropqq shortClass "$Id: shortClass.il,v 1.1 1998/02/10 13:22:25 gtc Exp $ %T%" SCCS)

(tcCreateDeviceClass
 "symbolic" "shortClass"
 ;;; Class Parameters
 (
  (shortOnLayer  "marker")  ;;; Provides the layer which will be shorted.
  (minPinWidth   0.0)       ;;; minimum width of the pin.
  (shortLayer    (list "short" "drawing")) ;;; The short recognition layer
  (minShortWidth 0.0)       ;;; minimum width of the short idLayer
  ;;; This width should be as small as possible. The region under the short
  ;;; is not included for the calculation of the parasitics.
 )

 ;;; Formal Parameters
 (
  (w  0.0)     ;;; width of the short device
  (l  0.0)     ;;; length of the short device
 )

 ;;; make the nets and the terminals for the two nets of the device.
 (setq net0 (dbMakeNet tcCellView "m0"))  ;;; same as schematic symbol
 (dbCreateTerm net0 "m0" "inputOutput")   ;;; same as schematic symbol
 (setq net1 (dbMakeNet tcCellView "m1"))  ;;; same as schematic symbol
 (dbCreateTerm net1 "m1" "inputOutput")   ;;; same as schematic symbol

 ;;; make a bogus net for the body of the shortOnLayer.
 (setq netB (dbMakeNet tcCellView "ppd"))
 
 ;;; Ensure that shortOnLayer is a list parameter.
 (when (stringp shortOnLayer)
     (setq shortOnLayer (list shortOnLayer "drawing"))
 )

 ;;; Draw the shortOnLayer rectangle
 (setq dbid (dbCreateRect tcCellView shortOnLayer 
			  (list 0.0:0.0 l:w))
 )
 ;;; Add the shortOnLayer to the bogus net.
 (dbAddFigToNet dbid netB)

 ;;; Create the two pins for the geometry
 (setq dbid (dbCreateRect tcCellView shortOnLayer 
			  (list (minus minPinWidth):0.0 0.0:w))
 )
 (setq pinid (dbCreatePin net0 dbid))
 pinid~>accessDir = (list "top" "bottom" "left")
 
 (setq dbid (dbCreateRect tcCellView shortOnLayer 
			  (list l:0.0 (plus l minPinWidth):w))
 )
 (dbCreatePin net1 dbid)
 pinid~>accessDir = (list "top" "bottom" "right")

 ;;; Create the short layer in the center of the shortOnLayer rectangle
 (setq x1Coord (quotient (difference l minShortWidth) 2.0))
 (setq dbid (dbCreateRect tcCellView shortLayer (list x1Coord:0.0
						      (plus x1Coord minShortWidth):w))
 )

 ;;; Create the recognition textLayer based on the class parameters
 ;;; These could be fixed or class parameters, class parameters will give us
 ;;; the flexbility to control them in future (if required).
 ;;; If the textValue is not defined, we create that based on the specified
 ;;; shortOnLayer.
;; (when (or (null textValue) (equal textValue ""))
;;     (setq textValue (strcat "short" (car shortOnLayer)))
;; )
 ;;;; draw the label
;; (setq labelId (dbCreateLabel tcCellView textLayer
;;			      (quotient l 2.0):(quotient w 2.0)
;;			      textValue "centerCenter" "R90" "stick" textWidth))
)
       
(tfcDefineDeviceClassProp
;;(viewName       devClassName  propName          propValue)
 (symbolic        shortClass    function          "transistor")
)

;;; 
;;; $Id: laserTargetClass.il,v 1.1 2009/09/09 19:07:14 lpj Exp $ %T%
;;; 
;;; laserTargetClass.il
;;; 
;;; Copyright (c) 2009 by Cypress Semiconductor
;;; Cypress Kentucky Design Center (KYCC)
;;; 
;;; Date  : Jun 12, 2009
;;; Author: Joe Lanford/CAD (lpj) @ KYCC
;;; 
;;; Description:
;;;   This is the source code for the laser targets.  The parameters for
;;; this pcell are all set by the technology.  This will be used by the
;;; die seal ring.
;;; 
;;; Revision History:
;;;   lpj 06/12/09  initial version
;;; 

(putpropqq laserTargetClass "$Id: laserTargetClass.il,v 1.1 2009/09/09 19:07:14 lpj Exp $ %T%" SCCS)

(tcCreateDeviceClass
 "symbolic" "laserTargetClass"
 ;; Class parameters
 (
   (metList nil)
   (metSpacings nil)
 )
 ;; Formal parameters
 (
   (orientation nil)
 )
 
 (setq topMetMinSpace (nth 0 (last metSpacings)))
 (setq length (topMetMinSpace*2)+48.000)
 (dbCreateRect tcCellView list("areaid" "moduleCut")  list( 0.000:0.000 length:length))
 (dbCreateRect tcCellView list("areaid" "frame")      list( 0.000:0.000 length:length))
 (dbCreateRect tcCellView list("cpdm"   "mask")       list( 0.000:0.000 length:length))
 (dbCreateRect tcCellView list("cp1m"   "waffleDrop") list( 0.000:0.000 length:length))
 (dbCreateRect tcCellView list("pad"    "drawing")    list( 0.000:0.000 length:length))
 (setq i 0)
 (foreach metLayer metList
   (setq minEncl (nth i metSpacings))
   (setq metLayerNum (atoi (nth 0 (parseString metLayer "met"))))
   (setq cmmLayerNum (difference metLayerNum 1))
   (sprintf cmmLayerNum "%d" cmmLayerNum)
   (if (greaterp (atoi cmmLayerNum) 0) then
     (dbCreateRect tcCellView list((strcat "cmm" cmmLayerNum) "waffleDrop") list( 0.000:0.000 length:length))
   )
   (if (equal orientation "x") then
     (dbCreateRect tcCellView list(metLayer "drawing") list(list((length/2)-5 minEncl) list((length/2)+5 (difference length minEncl))))
   )
   (if (equal orientation "y") then
     (dbCreateRect tcCellView list(metLayer "drawing") list(list(minEncl (length/2)-5) list((difference length minEncl) (length/2)+5)))
   )
   (setq i i+1)
 )
) ; end tcCreateDeviceClass

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;    Generic classes
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(tcDeclareDevice
 "symbolic" "discreteContactRingClass" "discreteContactRing"
 ;; Class Parameters
 (
 )
 ;; Formal Parameters
 (
 )
)

;; met4Short element
(tcDeclareDevice
 "symbolic" "shortClass" "M4short"
 ;; Class Parameters
 (
  (shortOnLayer    (list "met4" "drawing"))
  (shortLayer 	    (list "met4" "short"))
  (minPinWidth     (TECHgetRuleWith "minWidth" "met4"))
  (minShortWidth   (times 2.0 (TECHgetLayerProp "met4" 'snapGrid)))
  )
 ;; Formal Parameters
 (
  (w 		    (TECHgetRuleWith "minWidth" "met4"))
  (l 		    (TECHgetRuleWith "minSpacing" "met4"))
  )
 ) ; end met4short
(tcDeclareDevice
 "symbolic" "shortClass" "M5short"
 ;; Class Parameters
 (
  (shortOnLayer    (list "met5" "drawing"))
  (shortLayer 	    (list "met5" "short"))
  (minPinWidth     (TECHgetRuleWith "minWidth" "met5"))
  (minShortWidth   (times 2.0 (TECHgetLayerProp "met5" 'snapGrid)))
  )
 ;; Formal Parameters
 (
  (w 		    (TECHgetRuleWith "minWidth" "met5"))
  (l 		    (TECHgetRuleWith "minSpacing" "met5"))
  )
 ) ; end met5sho

;; met2 to met3 (rcInterCon)
(tcDeclareDevice
 "symbolic" "rcInterConClass" "M2M3"
 ;; Class Parameters
 ( 
  (layer1 	    "met2")
  (layer2 	    "met3")
  (viaLayer  	    "via2")
  (layer1XEnc      (TECHgetRuleWith "minEnclosure" "met2" "via2"))
  (layer1YEnc      (TECHgetRuleWith "minEnclosureAdj" "met2" "via2")) 
  (layer2XEnc      (TECHgetRuleWith "minEnclosure" "met3" "via2"))
  (layer2YEnc      (TECHgetRuleWith "minEnclosure" "met3" "via2"))
  )
 ;; Formal Parameters
 ( 
  (row 	    1)
  (column 	    1)
  (w   	    (TECHgetRuleWith "minWidth" "via2"))
  (l   	    (TECHgetRuleWith "minWidth" "via2"))
  (xPitch 	    (plus (TECHgetRuleWith "minSpacing" "via2")
			  (TECHgetRuleWith "minWidth"   "via2")))
  (yPitch 	    (plus (TECHgetRuleWith "minSpacing" "via2")
			  (TECHgetRuleWith "minWidth"   "via2")))
  )
 ) ;;; end met2 to met3

(tcSetDeviceProp "symbolic" "M2M3" 
		 list("res" (TECHgetRule "rcvia2") ))

;; we need to tell placeBus that this isn't the right contact to use
(tfcDefineDeviceProp
 ;;(viewName  deviceName   propName      propValue)
 ("symbolic" "M2M3"   "PBUSignore"     t)
 )

;; met3 to met4 (rcInterCon)
(tcDeclareDevice
 "symbolic" "rcInterConClass" "M3M4"
 ;; Class Parameters
 ( 
  (layer1 	    "met3")
  (layer2 	    "met4")
  (viaLayer  	    "via3")
  (layer1XEnc      (TECHgetRuleWith "minEnclosure" "met3" "via3"))
  (layer1YEnc      (TECHgetRuleWith "minEnclosureAdj" "met3" "via3")) 
  (layer2XEnc      (TECHgetRuleWith "minEnclosure" "met4" "via3"))
  (layer2YEnc      (TECHgetRuleWith "minEnclosure" "met4" "via3"))
  )
 ;; Formal Parameters
 ( 
  (row 	    1)
  (column 	    1)
  (w   	    (TECHgetRuleWith "minWidth" "via3"))
  (l   	    (TECHgetRuleWith "minWidth" "via3"))
  (xPitch 	    (plus (TECHgetRuleWith "minSpacing" "via3")
			  (TECHgetRuleWith "minWidth"   "via3")))
  (yPitch 	    (plus (TECHgetRuleWith "minSpacing" "via3")
			  (TECHgetRuleWith "minWidth"   "via3")))
  )
 ) ;;; end met4 to met4

(tcSetDeviceProp "symbolic" "M3M4" 
		 list("res" (TECHgetRule "rcvia3") ))

;; we need to tell placeBus that this isn't the right contact to use
(tfcDefineDeviceProp
 ;;(viewName  deviceName   propName      propValue)
 ("symbolic" "M3M4"   "PBUSignore"     t)
 )
(tcDeclareDevice
 "symbolic" "rcInterConClass" "M4M5"
 ;; Class Parameters
 ( 
  (layer1 	    "met4")
  (layer2 	    "met5")
  (viaLayer  	    "via4")
  (layer1XEnc      (TECHgetRuleWith "minEnclosure" "met4" "via4"))
  (layer1YEnc      (TECHgetRuleWith "minEnclosure" "met4" "via4")) 
  (layer2XEnc      (TECHgetRuleWith "minEnclosure" "met5" "via4"))
  (layer2YEnc      (TECHgetRuleWith "minEnclosure" "met5" "via4"))
  )
 ;; Formal Parameters
 ( 
  (row 	    1)
  (column 	    1)
  (w   	    (TECHgetRuleWith "minWidth" "via4"))
  (l   	    (TECHgetRuleWith "minWidth" "via4"))
  (xPitch 	    (plus (TECHgetRuleWith "minSpacing" "via4")
			  (TECHgetRuleWith "minWidth"   "via4")))
  (yPitch 	    (plus (TECHgetRuleWith "minSpacing" "via4")
			  (TECHgetRuleWith "minWidth"   "via4")))
  )
 ) ;;; end met4 to met5

(tcSetDeviceProp "symbolic" "M3M4" 
		 list("res" (TECHgetRule "rcvia4") ))

;; we need to tell placeBus that this isn't the right contact to use
(tfcDefineDeviceProp
 ;;(viewName  deviceName   propName      propValue)
 ("symbolic" "M3M4"   "PBUSignore"     t)
 )

;; met2 to met3 sqare (rcInterCon)
(tcDeclareDevice
 "symbolic" "rcInterConClass" "M2M3sq"
 ;; Class Parameters
 ( 
  (layer1 	    "met2")
  (layer2 	    "met3")
  (viaLayer  	    "via2")
  (encByLayer1     (TECHgetRuleWith "minEnclosure" "met2" "via2"))
  (layer2XEnc      (TECHgetRuleWith "minEnclosure" "met3" "via2"))
  (layer2YEnc      (TECHgetRuleWith "minEnclosure" "met3" "via2"))
  )
 ;; Formal Parameters
 ( 
  (row 	    1)
  (column 	    1)
  (w   	    (TECHgetRuleWith "minWidth" "via2"))
  (l   	    (TECHgetRuleWith "minWidth" "via2"))
  (xPitch 	    (plus (TECHgetRuleWith "minSpacing" "via2")
			  (TECHgetRuleWith "minWidth"   "via2")))
  (yPitch 	    (plus (TECHgetRuleWith "minSpacing" "via2")
			  (TECHgetRuleWith "minWidth"   "via2")))
  )
 ) ; end met2 to met3 square

(tcSetDeviceProp "symbolic" "M2M3sq" 
		 list("res" (TECHgetRule "rcvia2") ))	  

;; met3 to met4 sqare (rcInterCon)
(tcDeclareDevice
 "symbolic" "rcInterConClass" "M3M4sq"
 ;; Class Parameters
 ( 
  (layer1 	    "met3")
  (layer2 	    "met4")
  (viaLayer  	    "via3")
  (encByLayer1     (TECHgetRuleWith "minEnclosure" "met3" "via3"))
  (layer2XEnc      (TECHgetRuleWith "minEnclosure" "met4" "via3"))
  (layer2YEnc      (TECHgetRuleWith "minEnclosure" "met4" "via3"))
  )
 ;; Formal Parameters
 ( 
  (row 	    1)
  (column 	    1)
  (w   	    (TECHgetRuleWith "minWidth" "via3"))
  (l   	    (TECHgetRuleWith "minWidth" "via3"))
  (xPitch 	    (plus (TECHgetRuleWith "minSpacing" "via3")
			  (TECHgetRuleWith "minWidth"   "via3")))
  (yPitch 	    (plus (TECHgetRuleWith "minSpacing" "via3")
			  (TECHgetRuleWith "minWidth"   "via3")))
  )
 ) ; end met3 to met4 square

(tcSetDeviceProp "symbolic" "M3M4sq" 
		 list("res" (TECHgetRule "rcvia3") ))	  
(tcDeclareDevice
 "symbolic" "rcInterConClass" "M4M5sq"
 ;; Class Parameters
 ( 
  (layer1 	    "met4")
  (layer2 	    "met5")
  (viaLayer  	    "via4")
  (encByLayer1     (TECHgetRuleWith "minEnclosure" "met4" "via4"))
  (layer2XEnc      (TECHgetRuleWith "minEnclosure" "met5" "via4"))
  (layer2YEnc      (TECHgetRuleWith "minEnclosure" "met5" "via4"))
  )
 ;; Formal Parameters
 ( 
  (row 	    1)
  (column 	    1)
  (w   	    (TECHgetRuleWith "minWidth" "via4"))
  (l   	    (TECHgetRuleWith "minWidth" "via4"))
  (xPitch 	    (plus (TECHgetRuleWith "minSpacing" "via4")
			  (TECHgetRuleWith "minWidth"   "via4")))
  (yPitch 	    (plus (TECHgetRuleWith "minSpacing" "via4")
			  (TECHgetRuleWith "minWidth"   "via4")))
  )
 ) ; end met4 to met5 square

(tcSetDeviceProp "symbolic" "M4M5sq" 
		 list("res" (TECHgetRule "rcvia4") ))	  


;; PnR met2 to met3 contact
(tcDeclareDevice 
 "symbolic" "syEnhContact" "M2M3_PR"
 ;; Class Parameters
 ( 
  (layer1 	    "met2")
  (layer2 	    "met3")
  (viaLayer 	    "via2")
  (via1Width 	    (TECHgetRuleWith "minWidth"        "via2"))
  (via1Space 	    (TECHgetRuleWith "minSpacing"      "via2"))
  (layer1XEncVia1 (TECHgetRuleWith "minEnclosure"    "met2" "via2"))
  (layer1YEncVia1 (TECHgetRuleWith "minEnclosureAdj" "met2" "via2"))
  (layer2XEncVia1 (TECHgetRuleWith "minEnclosure"    "met3" "via2"))
  (layer2YEncVia1 (TECHgetRuleWith "minEnclosure"    "met3" "via2"))
  (halfgrid 	    (quotient (TECHgetLayerProp "met2" 'snapGrid) 2.0))
  )
 ;; Formal Parameters
 ( 
  (row 	    1)   (column 	    1)
  (xPitch 	    (plus (TECHgetRuleWith "minWidth"   "via2")
			  (TECHgetRuleWith "minSpacing" "via2")))
  (yPitch 	    (plus (TECHgetRuleWith "minWidth"   "via2")
			  (TECHgetRuleWith "minSpacing" "via2")))
  (w  		  (TECHgetRuleWith "minWidth" "via2"))
  (l  		  (TECHgetRuleWith "minWidth" "via2"))
  )
 )

(tcSetDeviceProp "symbolic" "M2M3_PR" 
		 list("res" (TECHgetRule "rcvia2") ))

;; PnR met3 to met4 contact
(tcDeclareDevice 
 "symbolic" "syEnhContact" "M3M4_PR"
 ;; Class Parameters
 ( 
  (layer1 	    "met3")
  (layer2 	    "met4")
  (viaLayer 	    "via3")
  (via1Width 	    (TECHgetRuleWith "minWidth"        "via3"))
  (via1Space 	    (TECHgetRuleWith "minSpacing"      "via3"))
  (layer1XEncVia1 (TECHgetRuleWith "minEnclosureAdj"    "met3" "via3"))
  (layer1YEncVia1 (TECHgetRuleWith "minEnclosure"       "met3" "via3"))
  (layer2XEncVia1 (TECHgetRuleWith "minEnclosure"    "met4" "via3"))
  (layer2YEncVia1 (TECHgetRuleWith "minEnclosure"    "met4" "via3"))
  (halfgrid 	    (quotient (TECHgetLayerProp "met3" 'snapGrid) 2.0))
  )
 ;; Formal Parameters
 ( 
  (row 	    1)   (column 	    1)
  (xPitch 	    (plus (TECHgetRuleWith "minWidth"   "via3")
			  (TECHgetRuleWith "minSpacing" "via3")))
  (yPitch 	    (plus (TECHgetRuleWith "minWidth"   "via3")
			  (TECHgetRuleWith "minSpacing" "via3")))
  (w  		  (TECHgetRuleWith "minWidth" "via3"))
  (l  		  (TECHgetRuleWith "minWidth" "via3"))
  )
 )

(tcSetDeviceProp "symbolic" "M3M4_PR" 
		 list("res" (TECHgetRule "rcvia3") ))

(tcDeclareDevice 
 "symbolic" "syEnhContact" "M4M5_PR"
 ;; Class Parameters
 ( 
  (layer1 	    "met4")
  (layer2 	    "met5")
  (viaLayer 	    "via4")
  (via1Width 	    (TECHgetRuleWith "minWidth"        "via4"))
  (via1Space 	    (TECHgetRuleWith "minSpacing"      "via4"))
  (layer1EncVia1  (TECHgetRuleWith "minEnclosure"    "met4" "via4"))
  (layer2XEncVia1 (TECHgetRuleWith "minEnclosure"    "met5" "via4"))
  (layer2YEncVia1 (TECHgetRuleWith "minEnclosure"    "met5" "via4"))
  (halfgrid 	    (quotient (TECHgetLayerProp "met3" 'snapGrid) 2.0))
  )
 ;; Formal Parameters
 ( 
  (row 	    1)   (column 	    1)
  (xPitch 	    (plus (TECHgetRuleWith "minWidth"   "via4")
			  (TECHgetRuleWith "minSpacing" "via4")))
  (yPitch 	    (plus (TECHgetRuleWith "minWidth"   "via4")
			  (TECHgetRuleWith "minSpacing" "via4")))
  (w  		  (TECHgetRuleWith "minWidth" "via4"))
  (l  		  (TECHgetRuleWith "minWidth" "via4"))
  )
 )

(tcSetDeviceProp "symbolic" "M4M5_PR" 
		 list("res" (TECHgetRule "rcvia4") ))

(symContactDevice
 ( "M2M3_C"    "via2" "drawing"   "met3" "drawing"   "met2" "drawing"
   (TECHgetRuleWith "minWidth" "via2") (TECHgetRuleWith "minWidth" "via2")
   ( 1 1 0 0 center center )
   (TECHgetRuleWith "minEnclosure" "met3" "via2")
   (TECHgetRuleWith "minEnclosureAdj" "met2" "via2")
   _NA_
   )
 ) ; end symcontactdevice

(tcSetDeviceProp "symbolic" "M2M3_C" list("res" (TECHgetRule "rcvia2") ))

(symContactDevice
 ( "M3M4_C"    "via3" "drawing"   "met4" "drawing"   "met3" "drawing"
   (TECHgetRuleWith "minWidth" "via3") (TECHgetRuleWith "minWidth" "via3")
   ( 1 1 0 0 center center )
   (TECHgetRuleWith "minEnclosure" "met4" "via3")
   (TECHgetRuleWith "minEnclosureAdj" "met3" "via3")
   _NA_
   )
 ) ; end symcontactdevice

(tcSetDeviceProp "symbolic" "M3M4_C" list("res" (TECHgetRule "rcvia3") ))

(symContactDevice
 ( "M4M5_C"    "via4" "drawing"   "met5" "drawing"   "met4" "drawing"
   (TECHgetRuleWith "minWidth" "via4") (TECHgetRuleWith "minWidth" "via4")
   ( 1 1 0 0 center center )
   (TECHgetRuleWith "minEnclosure" "met5" "via4")
   (TECHgetRuleWith "minEnclosure" "met4" "via4")
   _NA_
   )
 ) ; end symcontactdevice

(tcSetDeviceProp "symbolic" "M4M5_C" list("res" (TECHgetRule "rcvia4") ))

	  ;;; define ruleVia contacts
(eval
 `(ruleContactDevice
   ("ruleVia" 
    (met1 drawing ,(list 
		    (difference (quotient (TECHgetRuleWith "minWidth" "via") -2.0)
				(TECHgetRuleWith "minEnclosure" "met1" "via"))
		    (difference (quotient (TECHgetRuleWith "minWidth" "via") -2.0)
				(TECHgetRuleWith "minEnclosure" "met1" "via"))
	       (plus (quotient (TECHgetRuleWith "minWidth" "via") 2.0)
		     (TECHgetRuleWith "minEnclosure" "met1" "via"))
	       (plus (quotient (TECHgetRuleWith "minWidth" "via") 2.0)
		     (TECHgetRuleWith "minEnclosure" "met1" "via"))))
    (via drawing  ,(list 
		    (quotient (TECHgetRuleWith "minWidth" "via") -2.0)
		    (quotient (TECHgetRuleWith "minWidth" "via") -2.0)
		    (quotient (TECHgetRuleWith "minWidth" "via") 2.0)
		    (quotient (TECHgetRuleWith "minWidth" "via") 2.0)))
    (met2 drawing ,(list 
		    (difference (quotient (TECHgetRuleWith "minWidth" "via") -2.0)
			   (TECHgetRuleWith "minEnclosure" "met2" "via"))
		    (difference (quotient (TECHgetRuleWith "minWidth" "via") -2.0)
				(TECHgetRuleWith "minEnclosure" "met2" "via"))
		    (plus (quotient (TECHgetRuleWith "minWidth" "via") 2.0)
			  (TECHgetRuleWith "minEnclosure" "met2" "via"))
		    (plus (quotient (TECHgetRuleWith "minWidth" "via") 2.0)
			  (TECHgetRuleWith "minEnclosure" "met2" "via")))) 
    )
   ("ruleVia1" 
    (met1 drawing ,(list 
		    (difference (quotient (TECHgetRuleWith "minWidth" "via") -2.0)
				(TECHgetRuleWith "minEnclosure" "met1" "via"))
		    (difference (quotient (TECHgetRuleWith "minWidth" "via") -2.0)
				(TECHgetRuleWith "minEnclosure" "met1" "via"))
		    (plus (quotient (TECHgetRuleWith "minWidth" "via") 2.0)
			  (TECHgetRuleWith "minEnclosure" "met1" "via"))
		    (plus (quotient (TECHgetRuleWith "minWidth" "via") 2.0)
			  (TECHgetRuleWith "minEnclosure" "met1" "via"))))
    (via drawing  ,(list 
		    (quotient (TECHgetRuleWith "minWidth" "via") -2.0)
		    (quotient (TECHgetRuleWith "minWidth" "via") -2.0)
		    (quotient (TECHgetRuleWith "minWidth" "via") 2.0)
		    (quotient (TECHgetRuleWith "minWidth" "via") 2.0)))
    (met2 drawing ,(list 
		    (difference (quotient (TECHgetRuleWith "minWidth" "via") -2.0)
				(TECHgetRuleWith "minEnclosure" "met2" "via"))
		    (difference (quotient (TECHgetRuleWith "minWidth" "via") -2.0)
				(TECHgetRuleWith "minEnclosure" "met2" "via"))
		    (plus (quotient (TECHgetRuleWith "minWidth" "via") 2.0)
			  (TECHgetRuleWith "minEnclosure" "met2" "via"))
		    (plus (quotient (TECHgetRuleWith "minWidth" "via") 2.0)
			  (TECHgetRuleWith "minEnclosure" "met2" "via")))) 
    )
   ("ruleVia2" 
    (met2 drawing ,(list 
		    (difference (quotient (TECHgetRuleWith "minWidth" "via2") -2.0)
				(TECHgetRuleWith "minEnclosure" "met2" "via2"))
		    (difference (quotient (TECHgetRuleWith "minWidth" "via2") -2.0)
				(TECHgetRuleWith "minEnclosure" "met2" "via2"))
		    (plus (quotient (TECHgetRuleWith "minWidth" "via2") 2.0)
			  (TECHgetRuleWith "minEnclosure" "met2" "via2"))
		    (plus (quotient (TECHgetRuleWith "minWidth" "via2") 2.0)
		     (TECHgetRuleWith "minEnclosure" "met2" "via2"))))
    (via2 drawing  ,(list 
		     (quotient (TECHgetRuleWith "minWidth" "via2") -2.0)
		     (quotient (TECHgetRuleWith "minWidth" "via2") -2.0)
		     (quotient (TECHgetRuleWith "minWidth" "via2") 2.0)
		     (quotient (TECHgetRuleWith "minWidth" "via2") 2.0)))
    (met3 drawing ,(list 
		    (difference (quotient (TECHgetRuleWith "minWidth" "via2") -2.0)
				(TECHgetRuleWith "minEnclosure" "met3" "via2"))
		    (difference (quotient (TECHgetRuleWith "minWidth" "via2") -2.0)
				(TECHgetRuleWith "minEnclosure" "met3" "via2"))
		    (plus (quotient (TECHgetRuleWith "minWidth" "via2") 2.0)
			  (TECHgetRuleWith "minEnclosure" "met3" "via2"))
		    (plus (quotient (TECHgetRuleWith "minWidth" "via2") 2.0)
			  (TECHgetRuleWith "minEnclosure" "met3" "via2")))) 
    )
   ("ruleVia3" 
    (met3 drawing ,(list 
		    (difference (quotient (TECHgetRuleWith "minWidth" "via3") -2.0)
				(TECHgetRuleWith "minEnclosure" "met3" "via3"))
		    (difference (quotient (TECHgetRuleWith "minWidth" "via3") -2.0)
				(TECHgetRuleWith "minEnclosure" "met3" "via3"))
		    (plus (quotient (TECHgetRuleWith "minWidth" "via3") 2.0)
			  (TECHgetRuleWith "minEnclosure" "met3" "via3"))
		    (plus (quotient (TECHgetRuleWith "minWidth" "via3") 2.0)
		     (TECHgetRuleWith "minEnclosure" "met3" "via3"))))
    (via3 drawing  ,(list 
		     (quotient (TECHgetRuleWith "minWidth" "via3") -2.0)
		     (quotient (TECHgetRuleWith "minWidth" "via3") -2.0)
		     (quotient (TECHgetRuleWith "minWidth" "via3") 2.0)
		     (quotient (TECHgetRuleWith "minWidth" "via3") 2.0)))
    (met4 drawing ,(list 
		    (difference (quotient (TECHgetRuleWith "minWidth" "via3") -2.0)
				(TECHgetRuleWith "minEnclosure" "met4" "via3"))
		    (difference (quotient (TECHgetRuleWith "minWidth" "via3") -2.0)
				(TECHgetRuleWith "minEnclosure" "met4" "via3"))
		    (plus (quotient (TECHgetRuleWith "minWidth" "via3") 2.0)
			  (TECHgetRuleWith "minEnclosure" "met4" "via3"))
		    (plus (quotient (TECHgetRuleWith "minWidth" "via3") 2.0)
			  (TECHgetRuleWith "minEnclosure" "met4" "via3")))) 
    )
    ("ruleVia4" 
    (met4 drawing ,(list 
		    (difference (quotient (TECHgetRuleWith "minWidth" "via4") -2.0)
				(TECHgetRuleWith "minEnclosure" "met4" "via4"))
		    (difference (quotient (TECHgetRuleWith "minWidth" "via4") -2.0)
				(TECHgetRuleWith "minEnclosure" "met4" "via4"))
		    (plus (quotient (TECHgetRuleWith "minWidth" "via4") 2.0)
			  (TECHgetRuleWith "minEnclosure" "met4" "via4"))
		    (plus (quotient (TECHgetRuleWith "minWidth" "via4") 2.0)
		     (TECHgetRuleWith "minEnclosure" "met4" "via4"))))
    (via4 drawing  ,(list 
		     (quotient (TECHgetRuleWith "minWidth" "via4") -2.0)
		     (quotient (TECHgetRuleWith "minWidth" "via4") -2.0)
		     (quotient (TECHgetRuleWith "minWidth" "via4") 2.0)
		     (quotient (TECHgetRuleWith "minWidth" "via4") 2.0)))
    (met5 drawing ,(list 
		    (difference (quotient (TECHgetRuleWith "minWidth" "via4") -2.0)
				(TECHgetRuleWith "minEnclosure" "met5" "via4"))
		    (difference (quotient (TECHgetRuleWith "minWidth" "via4") -2.0)
				(TECHgetRuleWith "minEnclosure" "met5" "via4"))
		    (plus (quotient (TECHgetRuleWith "minWidth" "via4") 2.0)
			  (TECHgetRuleWith "minEnclosure" "met5" "via4"))
		    (plus (quotient (TECHgetRuleWith "minWidth" "via4") 2.0)
			  (TECHgetRuleWith "minEnclosure" "met5" "via4")))) 
    )
   ) ; end rule contact device
 ) ; end eval	     

(tcSetDeviceProp "symbolic" "ruleVia"  list("res" (TECHgetRule "rcvia" )))
(tcSetDeviceProp "symbolic" "ruleVia1" list("res" (TECHgetRule "rcvia" )))
(tcSetDeviceProp "symbolic" "ruleVia2" list("res" (TECHgetRule "rcvia2")))
(tcSetDeviceProp "symbolic" "ruleVia3" list("res" (TECHgetRule "rcvia3")))
(tcSetDeviceProp "symbolic" "ruleVia4" list("res" (TECHgetRule "rcvia4")))

(symPinDevice
 ;; (  name       mask?
 ;;    layer1     purpose1      w1
 ;;  [ layer2     purpose2      w2 ]
 ;; )
 (  "PY_T"        t
    "poly"        "drawing"      (TECHgetRuleWith "minWidth" "poly" )
    _NA_          _NA_           _NA_
    _NA_
    )
 (  "L1_T"        t
    "li1"         "drawing"      (TECHgetRuleWith "minWidth" "li1" )
     _NA_          _NA_           _NA_
     _NA_
     )
 (  "M1_T"        t
    "met1"        "drawing"      (TECHgetRuleWith "minWidth" "met1" )
    _NA_          _NA_           _NA_
    _NA_
    )
 (  "M2_T"        t
    "met2"        "drawing"      (TECHgetRuleWith "minWidth" "met2" )
    _NA_          _NA_           _NA_
    _NA_
    )
 (  "M1M2_T"      t
    "met1"        "drawing"      (TECHgetRuleWith "minWidth" "met1" )
    "met2"        "drawing"      (TECHgetRuleWith "minWidth" "met2" )
    _NA_
    )
 (  "M3_T"        t 
    "met3"        "drawing"      (TECHgetRuleWith "minWidth" "met3" ) 
    _NA_          _NA_           _NA_
    _NA_
    )
 (  "M2M3_T"      t
    "met2"        "drawing"      (TECHgetRuleWith "minWidth" "met2" )
    "met3"        "drawing"      (TECHgetRuleWith "minWidth" "met3" ) 
    _NA_
    )
 (  "M4_T"        t 
    "met4"        "drawing"      (TECHgetRuleWith "minWidth" "met4" ) 
    _NA_          _NA_           _NA_
    _NA_
    )
 (  "M3M4_T"      t
    "met3"        "drawing"      (TECHgetRuleWith "minWidth" "met3" )
    "met4"        "drawing"      (TECHgetRuleWith "minWidth" "met4" ) 
    _NA_
    )
 (  "M5_T"        t 
    "met5"        "drawing"      (TECHgetRuleWith "minWidth" "met5" ) 
    _NA_          _NA_           _NA_
    _NA_
    )
 (  "M4M5_T"      t
    "met4"        "drawing"      (TECHgetRuleWith "minWidth" "met4" )
    "met5"        "drawing"      (TECHgetRuleWith "minWidth" "met5" ) 
    _NA_
    )
 ) ; end symPinDevice


;; metop device
(tcDeclareDevice
 "symbolic" "metopClass" "M3metop"
 ;; class parameters
 (
  (optionOnLayer   '(nil
		     '("met3" "option1")
		     '("met3" "option2")
		     '("met3" "option3")
		     '("met3" "option4")
		     '("met3" "option5")
		     '("met3" "option6")
		     '("met3" "option7")
		     '("met3" "option8")))
  (pinLayer 	    '("met3" "drawing"))
  (minPinWidth       (TECHgetRuleWith "minWidth" "met3"))
  )
 ;; formal parameters
 (
  (metopNumber     8)
  (w 		    (TECHgetRuleWith "minWidth" "met3"))
  (l 		    (TECHgetRuleWith "minWidth" "met3"))
  )
 )
 
 ;; met2 to met3 for fuse (rcInterCon)
 ;; the fuseClass is so finicky that we need
 ;; to make a completely square contact with the
 ;; same enclosures of met2 and met3 to get it to
;; come out right.
(tcDeclareDevice
 "symbolic" "rcInterConClass" "FUSE_M3M4"
 ;; Class Parameters
 ( 
  (layer1 	    "met3")
  (layer2 	    "met4")
  (viaLayer  	    "via3")
  (layer1YEnc      (quotient (difference 
			      (TECHgetRuleWith "minWidth" (list "met4" "fuse"))
			      (TECHgetRuleWith "minWidth" "via3")
			      )
			     2.0))
  (layer1XEnc      (quotient (difference (TECHgetRuleWith "minWidth" (list "met4" "fuse"))
					 (TECHgetRuleWith "minWidth" "via3")
					 )
			     2.0))
  (layer2YEnc      (quotient (difference (TECHgetRuleWith "minWidth" (list "met4" "fuse"))
					 (TECHgetRuleWith "minWidth" "via3")
					  )
			     2.0))
  (layer2XEnc      (quotient (difference 
			      (TECHgetRuleWith "minWidth" (list "met4" "fuse"))
			      (TECHgetRuleWith "minWidth" "via3")
			      )
			     2.0))
  )
  ;; Formal Parameters
 ( 
  (row 	    1)
  (column 	    1)
  (w   	    (TECHgetRuleWith "minWidth" "via3"))
  (l   	    (TECHgetRuleWith "minWidth" "via3"))
  (xPitch 	    (plus (TECHgetRuleWith "minSpacing" "via3")
			  (TECHgetRuleWith "minWidth"   "via3")))
  (yPitch 	    (plus (TECHgetRuleWith "minSpacing" "via3")
			  (TECHgetRuleWith "minWidth"   "via3")))
  )
 )
;; we need to tell placeBus that this isn't the right contact to use
(tfcDefineDeviceProp
 ;;(viewName  deviceName   propName      propValue)
 ("symbolic" "FUSE_M3M4"   "PBUSignore"     t)
 )

 ;; met4 fuse element
(tcDeclareDevice
 "symbolic" "fuseShieldClass" "M4fuse"
 ;; class parameters
 (
  (fuseOnLayer     (list "met4" "drawing"))
  (fuseLayer 	    (list "met4" "fuse"))
  (contactName     "FUSE_M3M4")
  (pinLayer 	    (list "met4" "drawing"))
  (targWidth       (TECHgetRule "centerwidth"))
  (shieldLength    (TECHgetRuleWith "shieldLength" (list "met4" "fuse")))
  (shieldWidth     (TECHgetRuleWith "shieldWidth" (list "met4" "fuse")))
  )
 ;; formal parameters
 (
  (loShieldOffset      2.2)
  (lowerShield         "FALSE")
  (upShieldOffset      2.2)
  (upperShield         "FALSE")
  (rw 		    (TECHgetRuleWith "minWidth" (list "met4" "fuse")))
  (rl 		    (TECHgetRuleWith "minLength" (list "met4" "fuse")))
  )
 )

(let
    (cpmmOffset)
  (setq cpmmOffset   (TECHgetNikonOffset "cpmm"))
(tcDeclareDevice
 "symbolic" "nikonCrossClass" "nikon"
 ;; Class Parameters
 (
  (legWidth 	    (TECHgetNikonRule featureSize))
  (legLength 	    (quotient (difference 
			       (TECHgetNikonRule totalWidth)
			       (times 2.0 (TECHgetNikonRule reverseFeatureSize))
			       (TECHgetNikonRule featureSize))
			      2.0))
  (width 	    (TECHgetNikonRule reverseFeatureSize))
  (cutOffset 	    (TECHgetNikonRule cutOffset))
   (theLayers 	    `(
		      '(("cfom"   "mask") ,(TECHgetNikonRule (TECHgetRule "cfom_nikon_1")))
		      '(("cdnm"   "mask") ,(TECHgetNikonRule (TECHgetRule "cdnm_nikon_1")))
		      '(("cnwm"   "mask") ,(TECHgetNikonRule (TECHgetRule "cnwm_nikon_1")))
		      '(("clvtnm" "mask") ,(TECHgetNikonRule (TECHgetRule "clvtnm_nikon_1")))
                      '(("chvtpm" "mask") ,(TECHgetNikonRule (TECHgetRule "chvtpm_nikon_1")))
                      '(("ctunm"  "mask") ,(TECHgetNikonRule (TECHgetRule "ctunm_nikon_1")))
                      '(("conom"  "mask") ,(TECHgetNikonRule (TECHgetRule "conom_nikon_1")))
                      '(("clvom"  "mask") ,(TECHgetNikonRule (TECHgetRule "clvom_nikon_1")))
		      '(("cp1m"   "mask") ,(TECHgetNikonRule (TECHgetRule "cp1m_nikon_1")))
		      '(("cntm"   "mask") ,(TECHgetNikonRule (TECHgetRule "cntm_nikon_1")))
                      '(("chvntm" "mask") ,(TECHgetNikonRule (TECHgetRule "chvntm_nikon_1")))
                      '(("cldntm" "mask") ,(TECHgetNikonRule (TECHgetRule "cldntm_nikon_1")))
		      '(("cnpc"   "mask") ,(TECHgetNikonRule (TECHgetRule "cnpc_nikon_1")))
		      '(("cnsdm"  "mask") ,(TECHgetNikonRule (TECHgetRule "cnsdm_nikon_1")))
		      '(("cpsdm"  "mask") ,(TECHgetNikonRule (TECHgetRule "cpsdm_nikon_1")))
		      '(("clicm1" "mask") ,(TECHgetNikonRule (TECHgetRule "clicm1_nikon_1")))
		      '(("cli1m"  "mask") ,(TECHgetNikonRule (TECHgetRule "cli1m_nikon_1")))
		      '(("cctm1"  "mask") ,(TECHgetNikonRule (TECHgetRule "cctm1_nikon_1")))
		      '(("cmm1"   "mask") ,(TECHgetNikonRule (TECHgetRule "cmm1_nikon_1")))
		      '(("cviam"  "mask") ,(TECHgetNikonRule (TECHgetRule "cviam_nikon_1")))
		      '(("cmm2"   "mask") ,(TECHgetNikonRule (TECHgetRule "cmm2_nikon_1")))
		      '(("cviam2" "mask") ,(TECHgetNikonRule (TECHgetRule "cviam2_nikon_1")))
		      '(("cmm3"   "mask") ,(TECHgetNikonRule (TECHgetRule "cmm3_nikon_1")))
		      '(("cviam3" "mask") ,(TECHgetNikonRule (TECHgetRule "cviam3_nikon_1")))
		      '(("cmm4"   "mask") ,(TECHgetNikonRule (TECHgetRule "cmm4_nikon_1")))
		      '(("cviam4" "mask") ,(TECHgetNikonRule (TECHgetRule "cviam4_nikon_1")))
		      '(("cmm5"   "mask") ,(TECHgetNikonRule (TECHgetRule "cmm5_nikon_1")))
          '(("cnsm"   "mask") ,(TECHgetNikonRule (TECHgetRule "cnsm_nikon_1")))
		      '(("cpdm"   "mask") ,(TECHgetNikonRule (TECHgetRule "cpdm_nikon_1")))
		      '(("cpmm"   "mask") ,(TECHgetNikonRule (TECHgetRule "cpmm_nikon_1")) ,cpmmOffset)
          '(("cpmm"   "maskDrop") ,(TECHgetNikonRule (TECHgetRule "cpmmDrop_nikon_1")) ,cpmmOffset)
		      '(("chvnvtm"   "mask") ,(TECHgetNikonRule (TECHgetRule "chvnvtm_nikon_1")))
		      ))
   )
 ;; Formal Parameters
 (
  )
 ) 
);;let
;; Declare the laser target in x direction
(tcDeclareDevice
  "symbolic" "laserTargetClass" "lazX_dieSealRing"
  ;; Class Parameters
  ( 
    (metList (nth 0 (TECHgetMetViaLists)))
    (metSpacings ((lambda (x) (setq meList nil) (foreach met x (setq meList (cons (TECHgetRuleWith "minSpacing" met) meList))) (reverse meList) ) (nth 0 (TECHgetMetViaLists))))
  )
  ;; Formal Parameters
  ( 
    (orientation "x")
  )
 )

;; Declare the laser target in y direction
(tcDeclareDevice
  "symbolic" "laserTargetClass" "lazY_dieSealRing"
  ;; Class Parameters
  ( 
    (metList (nth 0 (TECHgetMetViaLists)))
    (metSpacings ((lambda (x) (setq meList nil) (foreach met x (setq meList (cons (TECHgetRuleWith "minSpacing" met) meList))) (reverse meList) ) (nth 0 (TECHgetMetViaLists))))
  )
  ;; Formal Parameters
  ( 
    (orientation "y")
  )
 )

(tcDeclareDevice
 "symbolic" "dieSealRingClassAdv" "advSeal_6um"
 (
  ;; (ringLayers '('(("layer1" "purpose") spaceFromEdge width isPin grid)
  ;;            ...'(("layerN" "purpose") spaceFromEdge width isPin grid)))
  ;;  aka              layer    purpose   scribe/offset width isPin grid
  ;; These numbers are derived from spec 01-70001
  ;; note: psdm is included for drc clean without writing an exception
  ;;  and because it has been generated in the ring for all the other flows
  ;;  automatically.  Subtracted psdm enclosure of tap from tap offset, and 
  ;;  added twice the enclosure to tap width
  (solidLayerRing '('(("nsm"    "drawing")   0.000   3.000  nil  0.005)
		    '(("areaid" "drawing")   0.000   6.000  nil  0.005)
		    
		    ))

  ;; '(contact1Layer1 contact2Layer con2con1EncX con2con1EncY spaceFromOutside contact1Width contact1Length
  ;;   contact1NoRow contact1OffsetX contact1OffsetY contact1SpaceX contact1SpaceY
  ;;   contact2NoRow contact2OffsetX contact2OffsetY contact2SpaceX contact2SpaceY grid ringWidth noBevelContacts(num/zero))
  ;; number of  contacts in bevel can be forced. if number is set to zero, the class will derive it.
  
  (discreteContactRingName "discreteContactRing")
  
  (sealringIdLayer (list "areaid" "seal"))
  (sealringGrid    (TECHgetLayerProp (list "areaid" "seal") 'snapGrid))
  (genericRingName "genIntDLring")
  (nikonCrossName  "nikon")
  (laserTargetXName "lazX_dieSealRing")
  (laserTargetYName "lazY_dieSealRing")
  (padLayer        (list "cpdm" "mask"))
  ;;   (padGrid         (TECHgetLayerProp (list "cpdm" "drawing") 'snapGrid))
  (padGrid         0.005)
  (padEncNikon     (TECHgetNikonRule offsetRsa))
  (rdLayer         (list "areaid" "deadZon"))    ;; dead zone layer
  (rcLayer         (list "areaid" "critCorner")) ;; critical corner layer
  (dLayer          (list "areaid" "critSid"))    ;; critical side layer
  (scaleF  1.0)            ;; scale factor for the technology
  )
 (
  (w          250.0)
  (l          250.0)
       ;;; extarCornerCut shoul ideally be zero but it was failing stress.12
  (extraCornerCut 0.25)
  (laserTargetsDef "ON")
  (laserTargetsEn t)
  (laserTargetsOrient "R0")
  )
 )




(tcDeclareDevice
 "symbolic" "dieSealRingClassAdv" "advancedSeal"
 (
  ;; (ringLayers '('(("layer1" "purpose") spaceFromEdge width isPin grid)
  ;;            ...'(("layerN" "purpose") spaceFromEdge width isPin grid)))
  ;;  aka              layer    purpose   scribe/offset width isPin grid
  ;; These numbers are derived from spec 01-70001
  ;; note: psdm is included for drc clean without writing an exception
  ;;  and because it has been generated in the ring for all the other flows
  ;;  automatically.  Subtracted psdm enclosure of tap from tap offset, and 
  ;;  added twice the enclosure to tap width
  (solidLayerRing '('(("tap"    "drawing")   7.140   7.720  nil  0.005)
		    '(("psdm"   "drawing")   7.000   8.000  nil  0.005)
		    '(("licon1" "drawing")   7.275   0.170  nil  0.005)
		    '(("licon1" "drawing")   9.095   0.170  nil  0.005)
		    '(("licon1" "drawing")   10.915  0.170  nil  0.005)
		    '(("licon1" "drawing")   12.735  0.170  nil  0.005)
		    '(("licon1" "drawing")   14.555  0.170  nil  0.005)
		    '(("li1"    "drawing")   7.000   8.000  nil  0.005)
		    '(("mcon"   "drawing")   7.690   0.170  nil  0.005)
		    '(("mcon"   "drawing")   9.840   0.170  nil  0.005)
		    '(("mcon"   "drawing")   11.990  0.170  nil  0.005)
		    '(("mcon"   "drawing")   14.140  0.170  nil  0.005)
		    '(("met1"   "drawing")   7.000   8.000  nil  0.005)
		    '(("via"    "drawing")   7.200   0.200  nil  0.005)
		    '(("via"    "drawing")   9.050   0.200  nil  0.005)
		    '(("via"    "drawing")   10.900  0.200  nil  0.005)
		    '(("via"    "drawing")   12.750  0.200  nil  0.005)
		    '(("via"    "drawing")   14.600  0.200  nil  0.005)
		    '(("met2"   "drawing")   7.000   8.000  nil  0.005)
		    '(("via2"   "drawing")   7.200   0.200  nil  0.005)
		    '(("via2"   "drawing")   9.050   0.200  nil  0.005)
		    '(("via2"   "drawing")   10.900  0.200  nil  0.005)
		    '(("via2"   "drawing")   12.750  0.200  nil  0.005)
		    '(("via2"   "drawing")   14.600  0.200  nil  0.005)
		    '(("met3"   "drawing")   7.000   8.000  nil  0.005)
		    '(("via3"   "drawing")   7.200   0.200  nil  0.005)
		    '(("via3"   "drawing")   9.050   0.200  nil  0.005)
		    '(("via3"   "drawing")   10.900  0.200  nil  0.005)
		    '(("via3"   "drawing")   12.750  0.200  nil  0.005)
		    '(("via3"   "drawing")   14.600  0.200  nil  0.005)
		    '(("met4"   "drawing")   7.000   8.000  nil  0.005)
		    '(("via4"   "drawing")   7.400   0.800  nil  0.005)
		    '(("via4"   "drawing")   9.000   0.800  nil  0.005)
		    '(("via4"   "drawing")   10.620  0.800  nil  0.005)
		    '(("via4"   "drawing")   12.220  0.800  nil  0.005)
		    '(("via4"   "drawing")   13.830  0.800  nil  0.005)
		    '(("met5"   "drawing")   7.000   8.000  nil  0.005)
		    '(("nsm"    "drawing")   0.000   4.000  nil  0.005)
		    '(("areaid" "seal")      0.000  15.000  nil  0.005)
		    ))

  ;; '(contact1Layer1 contact2Layer con2con1EncX con2con1EncY spaceFromOutside contact1Width contact1Length
  ;;   contact1NoRow contact1OffsetX contact1OffsetY contact1SpaceX contact1SpaceY
  ;;   contact2NoRow contact2OffsetX contact2OffsetY contact2SpaceX contact2SpaceY grid ringWidth noBevelContacts(num/zero))
  ;; number of  contacts in bevel can be forced. if number is set to zero, the class will derive it.
  (discreteContactRing '(
	'(("licon1" "drawing")  nil  0.0  0.0  7.6400 0.170 0.170 2 0.000 0.000 0.550 0.560 2 0.365  0.365  0.550 0.560 0.005 1.990 1)
	'(("licon1" "drawing")  nil  0.0  0.0  9.4550 0.170 0.170 2 0.000 0.000 0.550 0.560 2 0.365  0.365  0.550 0.560 0.005 1.990 1)
	'(("licon1" "drawing")  nil  0.0  0.0  11.275 0.170 0.170 2 0.000 0.000 0.550 0.560 2 0.365  0.365  0.550 0.560 0.005 1.990 1)
	'(("licon1" "drawing")  nil  0.0  0.0  13.095 0.170 0.170 2 0.000 0.000 0.550 0.560 2 0.365  0.365  0.550 0.560 0.005 1.990 1)
	'(("mcon"   "drawing")  nil  0.0  0.0  8.1200 0.170 0.170 2 0.000 0.000 0.690 0.690 2 0.430  0.430  0.690 0.690 0.005 2.320 1)
	'(("mcon"   "drawing")  nil  0.0  0.0  10.270 0.170 0.170 2 0.000 0.000 0.690 0.690 2 0.430  0.430  0.690 0.690 0.005 2.320 1)
	'(("mcon"   "drawing")  nil  0.0  0.0  12.420 0.170 0.170 2 0.000 0.000 0.690 0.690 2 0.430  0.430  0.690 0.690 0.005 2.320 1)
	'(("via"    "drawing")  nil  0.0  0.0  7.610  0.150 0.150 2 0.000 0.000 0.570 0.570 2 0.360  0.360  0.570 0.570 0.005 2.000 1)
	'(("via"    "drawing")  nil  0.0  0.0  9.460  0.150 0.150 2 0.000 0.000 0.570 0.570 2 0.360  0.360  0.570 0.570 0.005 2.000 1)
	'(("via"    "drawing")  nil  0.0  0.0  11.310 0.150 0.150 2 0.000 0.000 0.570 0.570 2 0.360  0.360  0.570 0.570 0.005 2.000 1)
	'(("via"    "drawing")  nil  0.0  0.0  13.160 0.150 0.150 2 0.000 0.000 0.570 0.570 2 0.360  0.360  0.570 0.570 0.005 2.000 1)


;	'(("via2"   "drawing")  nil  0.0  0.0  7.600  0.200 0.200 2 0.000 0.000 0.570 0.570 2 0.360  0.360  0.570 0.570 0.005 2.050 1)
;	'(("via2"   "drawing")  nil  0.0  0.0  9.450  0.200 0.200 2 0.000 0.000 0.570 0.570 2 0.360  0.360  0.570 0.570 0.005 2.050 1)
;	'(("via2"   "drawing")  nil  0.0  0.0  11.300 0.200 0.200 2 0.000 0.000 0.570 0.570 2 0.360  0.360  0.570 0.570 0.005 2.050 1)
;	'(("via2"   "drawing")  nil  0.0  0.0  13.150 0.200 0.200 2 0.000 0.000 0.570 0.570 2 0.360  0.360  0.570 0.570 0.005 2.050 1)

	'(("via2"   "drawing")  nil  0.0  0.0  7.600  0.200 0.200 2 0.000 0.000 0.500 0.500 2 0.350  0.350  0.500 0.500 0.005 2.050 1)
	'(("via2"   "drawing")  nil  0.0  0.0  9.450  0.200 0.200 2 0.000 0.000 0.500 0.500 2 0.350  0.350  0.500 0.500 0.005 2.050 1)
	'(("via2"   "drawing")  nil  0.0  0.0  11.300 0.200 0.200 2 0.000 0.000 0.500 0.500 2 0.350  0.350  0.500 0.500 0.005 2.050 1)
	'(("via2"   "drawing")  nil  0.0  0.0  13.150 0.200 0.200 2 0.000 0.000 0.500 0.500 2 0.350  0.350  0.500 0.500 0.005 2.050 1)

	'(("via3"   "drawing")  nil  0.0  0.0  7.600  0.200 0.200 2 0.000 0.000 0.500 0.500 2 0.350  0.350  0.500 0.500 0.005 2.050 1)
	'(("via3"   "drawing")  nil  0.0  0.0  9.450  0.200 0.200 2 0.000 0.000 0.500 0.500 2 0.350  0.350  0.500 0.500 0.005 2.050 1)
	'(("via3"   "drawing")  nil  0.0  0.0  11.300 0.200 0.200 2 0.000 0.000 0.500 0.500 2 0.350  0.350  0.500 0.500 0.005 2.050 1)
	'(("via3"   "drawing")  nil  0.0  0.0  13.150 0.200 0.200 2 0.000 0.000 0.500 0.500 2 0.350  0.350  0.500 0.500 0.005 2.050 1)
	 ))
  (discreteContactRingName "discreteContactRing")
  
  (sealringIdLayer (list "areaid" "seal"))
  (sealringGrid    (TECHgetLayerProp (list "areaid" "seal") 'snapGrid))
  (genericRingName "genIntDLring")
  (nikonCrossName  "nikon")
  (laserTargetXName "lazX_dieSealRing")
  (laserTargetYName "lazY_dieSealRing")
  (padLayer        (list "cpdm" "mask"))
  ;;   (padGrid         (TECHgetLayerProp (list "cpdm" "drawing") 'snapGrid))
  (padGrid         0.005)
  (padEncNikon     (TECHgetNikonRule offsetRsa))
  (rdLayer         (list "areaid" "deadZon"))    ;; dead zone layer
  (rcLayer         (list "areaid" "critCorner")) ;; critical corner layer
  (dLayer          (list "areaid" "critSid"))    ;; critical side layer
  (scaleF  1.0)            ;; scale factor for the technology
  )
 (
  (w          250.0)
  (l          250.0)
       ;;; extarCornerCut shoul ideally be zero but it was failing stress.12
  (extraCornerCut 0.25)
  (laserTargetsDef "ON")
  (laserTargetsEn t)
  (laserTargetsOrient "R0")
  )
 )

 ;; variables for padPL
 (setq w1 (TECHgetRuleWith "minWidth" "via3"))
 (setq w2 (TECHgetRuleWith "minWidth" "via4"))
 (setq s1 (TECHgetRuleWith "minSpacing" "via3"))
 (setq s2 (TECHgetRuleWith "minSpacing" "via4"))
 (setq grid  (TECHgetProp snapGrid))

 (tcDeclareDevice
  "symbolic" "pluggedPadClass" "padPLstg"
  (
   (padLayer               (list "pad" "drawing"))
   (topLayer               (list "met5" "drawing"))

   ;; (viaLayers '('(("layer1" "purpose") spacing width grid)
   ;;           ...'(("layerN" "purpose") spacing width grid)))
   (viaLayer              `( '("via4"   ,s2 ,w2 ,grid)))
   (botLayer              '( '("met4"  "drawing")))

   (bevelCutLength         (TECHgetRule "pad_12"))
   (maxBevelCutLength      (TECHgetRule "pad_13"))
   (topLayerEncPad         (TECHgetRule "pad_4" ))
   (botLayerSpacePad       (TECHgetRule "pad_5" ))

   (botLayerInsideEncVia  (max (TECHgetRuleWith "minEnclosure" "met4" "via4")
                               (TECHgetRuleWith "minEnclosure" "met5" "via4")
                          )
   )
   (botLayerOutsideEncVia (max (TECHgetRuleWith "minEnclosure" "met4" "via4")
                               (TECHgetRuleWith "minEnclosure" "met5" "via4")
                          )
   )
   (genericRingName        "genDLring")
   (rivetedRingName        "genRivetDLring")
   (padGrid                (TECHgetLayerProp "pad" 'snapGrid))
   (topLayerGrid           (TECHgetLayerProp "met5" 'snapGrid))
   (padType                "staggered")
   (padCenter              (list "padCenter" "drawing"))
   (padCenterWidth         0.2)
  )
  (
   (w                      (TECHgetRule "pad_5_1"))
   (l                      (TECHgetRule "pad_4_1"))
   (shrinkPercent          0.0)
   (plasticPackage         "TRUE")
   (centerPad              t)
  )
 )

 (tcDeclareDevice
  "symbolic" "pluggedPadClass" "padPLfp"
  (
   (padLayer               (list "pad" "drawing"))
   (topLayer               (list "met5" "drawing"))

   ;; (viaLayers '('(("layer1" "purpose") spacing width grid)
   ;;           ...'(("layerN" "purpose") spacing width grid)))
   (viaLayer              `( '("via4"   ,s2 ,w2 ,grid)))
   (botLayer              '( '("met4"  "drawing")))

   (bevelCutLength         (TECHgetRule "pad_12"))
   (maxBevelCutLength      (TECHgetRule "pad_13"))
   (topLayerEncPad         (TECHgetRule "pad_4" ))
   (botLayerSpacePad       (TECHgetRule "pad_5" ))

   (botLayerInsideEncVia  (max (TECHgetRuleWith "minEnclosure" "met4" "via4")
                               (TECHgetRuleWith "minEnclosure" "met5" "via4")
                          )
   )
   (botLayerOutsideEncVia (max (TECHgetRuleWith "minEnclosure" "met4" "via4")
                               (TECHgetRuleWith "minEnclosure" "met5" "via4")
                          )
   )
   (genericRingName        "genDLring")
   (rivetedRingName        "genRivetDLring")
   (padGrid                (TECHgetLayerProp "pad" 'snapGrid))
   (topLayerGrid           (TECHgetLayerProp "met5" 'snapGrid)) 
   (padType                "finePitch")
   (padCenter              (list "padCenter" "drawing"))
   (padCenterWidth         0.2)
  )
  (
   (w                      (TECHgetRule "pad_3_1"))
   (l                      (TECHgetRule "pad_2_1"))
   (shrinkPercent          0.0)
   (plasticPackage         "TRUE")
   (centerPad            t)
  )
 )

 (tcDeclareDevice
  "symbolic" "pluggedPadClass" "padPLhp"
  (
    (padLayer               (list "pad" "drawing"))
    (topLayer               (list "met5" "drawing"))

   ;; (viaLayers '('(("layer1" "purpose") spacing width grid)
   ;;           ...'(("layerN" "purpose") spacing width grid)))
   (viaLayer              `( '("via4"   ,s2 ,w2 ,grid)))
   (botLayer              '( '("met4"  "drawing")))

   (bevelCutLength         (TECHgetRule "pad_12"))
   (maxBevelCutLength      (TECHgetRule "pad_13"))
   (topLayerEncPad         (TECHgetRule "pad_4" ))
   (botLayerSpacePad       (TECHgetRule "pad_5" ))

   (botLayerInsideEncVia  (max (TECHgetRuleWith "minEnclosure" "met4" "via4")
                               (TECHgetRuleWith "minEnclosure" "met5" "via4")
                          )
   )
   (botLayerOutsideEncVia (max (TECHgetRuleWith "minEnclosure" "met4" "via4")
                               (TECHgetRuleWith "minEnclosure" "met5" "via4")
                          )
   )
   (genericRingName        "genDLring")
   (rivetedRingName        "genRivetDLring")
   (padGrid                (TECHgetLayerProp "pad" 'snapGrid))
   (topLayerGrid           (TECHgetLayerProp "met5" 'snapGrid))
   (padType                "highParallel")
   (padCenter              (list "padCenter" "drawing"))
   (padCenterWidth         0.2)
  )
  (
   (w                      (TECHgetRule "pad_6_1"))
   (l                      (TECHgetRule "pad_6_1"))
   (shrinkPercent          0.0)
   (plasticPackage         "TRUE")
   (centerPad            t)
  )
 )

(tcDeclareDevice
  "symbolic" "pluggedPadClass" "padPLwlbi"
  (
   (padLayer               (list "pad" "drawing"))
   (topLayer               (list "met5" "drawing"))

   ;; (viaLayers '('(("layer1" "purpose") spacing width grid)
   ;;           ...'(("layerN" "purpose") spacing width grid)))
   (viaLayer              `( '("via4"   ,s2 ,w2 ,grid)))
   (botLayer              '( '("met4"  "drawing")))

   (bevelCutLength         (TECHgetRule "pad_12"))
   (maxBevelCutLength      (TECHgetRule "pad_13"))
   (topLayerEncPad         (TECHgetRule "pad_4" ))
   (botLayerSpacePad       (TECHgetRule "pad_5" ))

   (botLayerInsideEncVia  (max (TECHgetRuleWith "minEnclosure" "met4" "via4")
                               (TECHgetRuleWith "minEnclosure" "met5" "via4")
                          )
   )
   (botLayerOutsideEncVia (max (TECHgetRuleWith "minEnclosure" "met4" "via4")
                               (TECHgetRuleWith "minEnclosure" "met5" "via4")
                          )
   )
   (genericRingName        "genDLring")
   (rivetedRingName        "genRivetDLring")
   (padGrid                (TECHgetLayerProp "pad" 'snapGrid))
   (topLayerGrid           (TECHgetLayerProp "met5" 'snapGrid))
   (padType                "waferLevelBurnIn")
   (padCenter              (list "padCenter" "drawing"))
   (padCenterWidth         0.2)
  )
  (
   (w                      (TECHgetRule "pad_8_1"))
   (l                      (TECHgetRule "pad_7_1"))
   (shrinkPercent          0.0)
   (plasticPackage         "TRUE")
   (centerPad            t)
  )
 )
 
 ;; Declare the anchor
 (tcDeclareDevice
  "symbolic" "anchorClass" "anchor"
  ;; class parameters
  (
   (anchorLayers        (list "poly" "li1" "met1" "met2" "met3" "met4"))
   (anchorContacts      `((list "licon1" ,(TECHgetRuleWith "minWidth" "licon1") 
				"npc" ,(TECHgetRuleWith "minEnclosure" "npc" "licon1"))
			  (list "mcon"   ,(TECHgetRuleWith "minWidth" "mcon"))
			  (list "via"    ,(TECHgetRuleWith "minWidth" "via"))
			  (list "via2"    ,(TECHgetRuleWith "minWidth" "via2"))
			  (list "via3"    ,(TECHgetRuleWith "minWidth" "via3"))
			  ))
   (anchorWidth         (TECHgetRule "stress_8_14_3_5") + 2.0*grid)
   (anchorSpace         (TECHgetRule "stress_8_14_3_6"))
   (viaPitch            (TECHgetRule "stress_8_14_3_7") * 2.3)
   (contactPitch        (TECHgetRule "stress_8_14_3_8") * 2.3)
   (grid                (TECHgetProp snapGrid))
  )
  ;; formal parameters
  (
   (fullAnchor      t)
   (horizOr45       t)
   (anchorLengthX   20.0)
   (anchorLengthY   20.0)
   (anchorLengthZ   (TECHgetRule "stress_8_14_3_5"))
   (numAnchors      1)
  )
 ) ; tcDeclareDevice

 (tcDeclareDevice
  "symbolic" "enhStrap3PolImpClass" "hvDFTPM1s2enh"
  ;; Class Parameters
  ( 
   (wellLayer        "nwell")
   (diffLayer        "diff")
   (tapLayer         "tap")
   (via1Layer        "licon1")
   (layer2 	     "li1")
   (via2Layer        "mcon")
   (layer3           "met1")
   (tapImplant       (list "psdm" "nsdm"))
   (tapImpEnc        (list (TECHgetRule "psd_5b") (TECHgetRule "nsd_5b")))
   (diffImplant      (list "nsdm" "psdm"))
   (diffImpEnc       (list (TECHgetRule "nsd_5a") (TECHgetRule "psd_5a")))
   (diffXEncVia1In   (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
   (diffXEncVia1Out  (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))
   (diffYEncVia1     (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
   (tapXEncVia1      (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (tapYEncVia1      (TECHgetRuleWith "minEnclosureAny" "tap" "licon1"))
   (tapMinNarExt     (TECHgetRule "difftap_7"))
   (layer2XEncVia1   0.0)
   (layer2YEncVia1   (TECHgetRuleWith "minEnclosure" "li1" "licon1"))
   (layer2XEncVia2   (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (layer2YEncVia2   (TECHgetRuleWith "minEnclosure" "li1" "mcon"))
   (layer3XEncVia2   (TECHgetRuleWith "minEnclosureAny" "met1" "mcon"))
   (layer3YEncVia2   (TECHgetRuleWith "minEnclosure" "met1" "mcon"))
   (wellLayerDiffEnc (TECHgetRuleWith "minEnclosure" "nwell" "diff"))
   (wellLayerTapEnc  (TECHgetRuleWith "minEnclosure" "nwell" "tap"))
   (diffSourceWidth  (TECHgetRuleWith "minGateSpacing" "poly" "tap"))
   (tapWidthBetween  (TECHgetRuleWith "minWidthInside" "tap" "hvi"))
   (wellWidth        (TECHgetRuleWith "minWidth"     "nwell"))
   (via1Width        (TECHgetRuleWith "minWidth"     "licon1"))
   (via1Length       (TECHgetRuleWith "minWidth"     "licon1"))
   (via1Space        (TECHgetRuleWith "minSpacing"   "licon1"))
   (via2Width        (TECHgetRuleWith "minWidth"     "mcon"))
   (via2Length       (TECHgetRuleWith "minWidth"     "mcon"))
   (via2Space        (TECHgetRuleWith "minSpacing"   "mcon"))
   )
  ;; Formal Parameters
  ( 
   (tranWidthL      (max (plus (times 2 (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
			       (TECHgetRuleWith "minWidth" "licon1"))
			 (TECHgetRuleWith "minWidthDiff" "hvi")
			 ))
   (tranWidthR      (max (plus (times 2 (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1"))
			       (TECHgetRuleWith "minWidth" "licon1"))
			 (TECHgetRuleWith "minWidthDiff" "hvi")
			 ))
   (extraDiffL       (max 0.0
			  (difference (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1")
				      (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))))
   (extraDiffR       (max 0.0
			  (difference (TECHgetRuleWith "minEnclosureAdj" "diff" "licon1")
				      (TECHgetRuleWith "minGateSpacing" "poly" "licon1"))))
   (extraTapL        0.0)
   (extraTapR        0.0)
   (implant          t)
   (inWell           "FALSE")
   (noLayer3         "FALSE")
   )
  )
 (tcSetDeviceProp "symbolic" "hvDFTPM1s2enh" 
		  list("res" (TECHgetRule "rcp") ))

;;
;; Declare the rivetted bus
;; (tcDeclareDevice
;;  "symbolic" "rivetClass" "rivet"
;;  ;; class parameters
;;  (
;;   (rivetLayers         (list "met1" "met2" "met3"))
;;   (metExt              (TECHgetRule "stress_8_13_2_4"))  ; Extension of the met2 beyond met1
;;; met3 beyond met2 etc...
;;   (rivetContacts       `((list "via"
;;				,(TECHgetRuleWith "minWidth" "via")
;;				,(TECHgetRuleWith "minSpacing" "via")
;;				,(TECHgetRuleWith "minEnclosure" "met1" "via"))
;;			  (list "via2"
;;				,(TECHgetRuleWith "minWidth" "via2")
;;				,(TECHgetRuleWith "minSpacing" "via2")
;;				,(TECHgetRuleWith "minEnclosure" "met2" "via2"))
;;			  ))
;;   (grid                (TECHgetProp snapGrid))
;;
;;   ;; All the following class parameters deal with the slot
;;   ;; generation on a rivetted bus. Since there is no obvious way
;;   ;; to organise them, they are listed one after the other
;;   ;; Refer Spec. 01-70001 for details of the rules.
;;   (minRivetWidth       (TECHgetRule "stress_8_13_2_5" ))
;;   (minSlotWidth        (TECHgetRule "stress_8_13_2_7" ))
;;   (minSlotLength       (TECHgetRule "stress_8_13_2_8" ))
;;   (minBusLength        (TECHgetRule "stress_8_13_2_8x"))
;;   (maxSlotLength       (TECHgetRule "stress_8_13_2_10"))
;;   (minSlotLengthP      (TECHgetRule "stress_8_13_2_9" ))
;;   (maxSlotSpacingH     (TECHgetRule "stress_8_13_2_11"))
;;   (maxSpacingtoEdge    (TECHgetRule "stress_8_13_2_12"))
;;   (maxSlotSpacingV     (TECHgetRule "stress_8_13_2_14"))
;;   (minOverlap          (TECHgetRule "stress_8_13_2_15"))
;;   (slotExt             (TECHgetRule "stress_8_13_2_16"))
;;   (minOverlapP         (TECHgetRule "stress_8_13_2_17"))
;;   (ramTech              t)
;;  )
;;  ;; formal parameters
;;  (
;;   (layerName          "met1")
;;   (multiLayer         t)
;;   (ySlotOffset        0)
;;   (standAlone         t)
;;   (noBent             t)
;;   (rivetLengthZ       100.00)
;;   (rivetLengthY       100.00)
;;   (rivetLengthX       100.00)
;;   (rivetWidth         12.50)
;;  )
;; ) ; tcDeclareDevice 

;;; ;;;Declare the hvpEsdTran device
;;; (tcDeclareDevice "symbolic" "pEsdTranImpClass" "hvpEsdTran"
;;;    ;; class parameters
;;;  (
;;;   (diffLayer           (list "diff"     "drawing"))
;;;   (gateLayer           (list "poly"     "drawing"))
;;;   (rgateLayer          (list "poly"     "gate"))
;;;   (wellLayer           (list "nwell"    "drawing"))
;;;   (tapLayer            (list "tap"      "drawing"))
;;;   (via1Layer           (list "licon1"   "drawing"))
;;;   (layer2              (list "li1"      "drawing"))
;;;   (via2Layer           (list "mcon"     "drawing"))
;;;   (layer3              (list "met1"     "drawing"))
;;;   (idLayer             (list "areaid"   "esd"))
;;;   (maxvLayer           (list "hvi"      "drawing"))
;;;   (diffImplant         (list "psdm"     "drawing"))
;;;   (diffImpEnc          (TECHgetRule     "esd_pc_p_diffImpEnc"))
;;;   (tapWellImplant      (list "nsdm"     "drawing"))
;;;   (tapWellImpEnc       (TECHgetRule     "esd_pc_p_tapWellImpEnc"))
;;;   (tapSubImplant       (list "psdm"     "drawing"))
;;;   (tapSubImpEnc        (TECHgetRule     "esd_pc_p_tapSubImpEnc"))
;;;   (tapWidth            (TECHgetRule     "esd_pc_p_tapWidth"))
;;;   (srcViaGateSpace     (TECHgetRule     "esd_pc_p_srcViaGateSpace"))
;;;   (srcViaTapSpace      (TECHgetRule     "esd_pc_p_srcViaTapSpace"))
;;;   (drnViaGateSpace     (TECHgetRule     "esd_pc_p_drnViaGateSpace"))
;;;   (viaExtDiff          (TECHgetRule     "esd_pc_p_viaExtDiff"))
;;;   (minDiffTapRingSpace (TECHgetRule     "esd_pc_p_minDiffTapRingSpace"))
;;;   (flareYamount        (TECHgetRule     "esd_pc_p_flareYamount_out"))
;;;   (flareYamount_in	(TECHgetRule 	 "esd_pc_p_flareYamount_in"))
;;;   (flareYextension     (TECHgetRule     "esd_pc_p_flareYextension"))
;;;   (via1Width           (TECHgetRule     "esd_pc_p_via1Width"))
;;;   (via1Space           (TECHgetRule     "esd_pc_p_via1Space"))
;;;   (tapEncVia1          (TECHgetRule     "esd_pc_p_tapEncVia1"))
;;;   (wellEncTap          (TECHgetRule     "hdiff_6"))
;;;   (innerRingTapWidth  	(TECHgetRule     "esd_pc_p_innerRingTapWidth"))
;;;   (outerRingTapWidth   (TECHgetRule     "esd_pc_p_outerRingTapWidth"))
;;;   (wellTapSpace        (TECHgetRule     "esd_pc_p_wellTapSpace"))
;;;   (layer2EncVia1       (TECHgetRule     "esd_pc_p_layer2EncVia1"))
;;;   (via2Width           (TECHgetRule     "esd_pc_p_via2Width"))
;;;   (via2Space           (TECHgetRule     "esd_pc_p_via2Space"))
;;;   (via1Via2Space       (TECHgetRule     "esd_pc_p_via1Via2Space"))
;;;   (layer2EncVia2       (TECHgetRule     "esd_pc_p_layer2EncVia2"))
;;;   (layer2Width         (TECHgetRule     "esd_pc_p_layer2Width"))
;;;   (layer3EncVia2       (TECHgetRule     "esd_pc_p_layer3EncVia2"))
;;;   (layer3Width         (TECHgetRule     "esd_pc_p_layer3Width"))
;;;   (innerRingMetalWidth (TECHgetRule     "esd_pc_p_innerRingMetalWidth"))
;;;   (irLayer3EncVia2     (TECHgetRule     "esd_pc_p_irLayer3EncVia2"))
;;;   (orLayer3Width       (TECHgetRule     "esd_pc_p_orLayer3Width"))
;;;   (minW                (TECHgetRule     "esd_pc_p_minW"))
;;;   (maxW                (TECHgetRule     "esd_pc_p_maxW"))
;;;   (minTotalW           (TECHgetRule     "esd_pc_p_minTotalW"))
;;;   (genericRingName     "genDLring")
;;;   (rivetedRingName     "genRivetMirrorDLring")
;;;   (flaredGateName      "flareGate")
;;;   (diffGrid            (TECHgetLayerProp "diff"   'snapGrid))
;;;   (tapGrid             (TECHgetLayerProp "tap"    'snapGrid))
;;;   (wellGrid            (TECHgetLayerProp "nwell"  'snapGrid))
;;;   (polyGrid            (TECHgetLayerProp "poly"   'snapGrid))
;;;   (via1grid            (TECHgetLayerProp "licon1" 'snapGrid))
;;;   (layer2grid          (TECHgetLayerProp "li1"    'snapGrid))
;;;   (via2grid            (TECHgetLayerProp "mcon"   'snapGrid))
;;;   (layer3grid          (TECHgetLayerProp "met1"   'snapGrid))
;;;   (tapEdgesAt45        nil)
;;;   (layer2EdgesAt45     nil)
;;;   (layer3EdgesAt45     t)
;;;   (endTapMetInsideOut  t)
;;;  )
;;;  ;; formal parameters
;;;  (
;;;   ;; There are rigorous constraints on the valid w.  Here
;;;   ;; is how it is calculated:
;;;   ;; (w (plus viaExtDiff viaExtDiff -flareYamount -flareYamount (times 11.0 licon1_pitch) -licon1_space))
;;;   (w                     24.910)
;;;   (l                     (TECHgetRule "hpoly_1"))
;;;   (m                      6)
;;;   (extraLeftSpace         0.000)
;;;   (extraRightSpace        0.000)
;;;   (shrinkPercent          0.000)
;;;   (extraSrcSpace          0.000)
;;;   (extraDrnSpace          0.000)
;;;   (fullyStrap                 t)
;;;   (drnViaYspaceRingViaTop 5.170)
;;;   (drnViaYspaceRingViaBot 5.170)
;;;   (orirLayer3Space     (TECHgetRule	"esd_pc_p_orirLayer3Space"))
;;;  )
;;; ) ;;;tcDeclareDevice hvpEsdTran
;;;
;;;
;;;;;;defining the hvnEsdTran
;;;(tcDeclareDevice "symbolic" "nEsdTranImpClass" "hvnEsdTran"
;;;  ;; class parameters
;;;  (
;;;   (diffLayer           (list "diff"     "drawing"))
;;;   (gateLayer           (list "poly"     "drawing"))
;;;   (rgateLayer          (list "poly"     "gate"))
;;;   (wellLayer           (list "nwell"    "drawing"))
;;;   (tapLayer            (list "tap"      "drawing"))
;;;   (via1Layer           (list "licon1"   "drawing"))
;;;   (layer2              (list "li1"      "drawing"))
;;;   (via2Layer           (list "mcon"     "drawing"))
;;;   (layer3              (list "met1"     "drawing"))
;;;   (idLayer             (list "areaid"   "esd"))
;;;   (maxvLayer           (list "hvi"      "drawing"))
;;;   (hvDiffEnclosure     (TECHgetRule     "hdiff_9"))
;;;   (diffImplant         (list "nsdm"     "drawing"))
;;;   (diffImpEnc          (TECHgetRule     "esd_pc_n_diffImpEnc"))
;;;   (tapWellImplant      (list "nsdm"     "drawing"))
;;;   (tapWellImpEnc       (TECHgetRule     "esd_pc_n_tapWellImpEnc"))
;;;   (tapSubImplant       (list "psdm"     "drawing"))
;;;   (tapSubImpEnc        (TECHgetRule     "esd_pc_n_tapSubImpEnc"))
;;;   (srcViaGateSpace     (TECHgetRule     "esd_pc_n_srcViaGateSpace"))
;;;   (drnViaGateSpace     (TECHgetRule     "esd_pc_n_drnViaGateSpace"))
;;;   (viaExtDiffY         (TECHgetRule     "esd_pc_n_viaExtDiffY"))
;;;   (minDiffTapRingSpace (TECHgetRule     "esd_pc_n_minDiffTapRingSpace"))
;;;   (flareYamount        (TECHgetRule     "esd_pc_n_flareYamount_out"))
;;;   (flareYamount_in	(TECHgetRule 	 "esd_pc_n_flareYamount_in"))
;;;   (flareYextension     (TECHgetRule     "esd_pc_n_flareYextension"))
;;;   (via1Width           (TECHgetRule     "esd_pc_n_via1Width"))
;;;   (via1Space           (TECHgetRule     "esd_pc_n_via1Space"))
;;;   (tapEncVia1          (TECHgetRule     "esd_pc_n_tapEncVia1"))
;;;   (innerRingTapEncVia1 (TECHgetRule     "esd_pc_n_innerRingTapEncVia1"))
;;;   (outerRingTapEncVia1 (TECHgetRule     "esd_pc_n_outerRingTapEncVia1"))
;;;   (wellEncTap          (TECHgetRule     "esd_pc_n_wellEncTap"))
;;;   (ESDnwEncVia1        (TECHgetRule     "esd_pc_n_ESDnwEncVia1"))
;;;   (ESDnwGateSp         (TECHgetRule     "esd_pc_n_ESDnwGateSp"))
;;;   (innerRingTapWidth   (TECHgetRule     "esd_pc_n_innerRingTapWidth"))
;;;   (outerRingTapWidth   (TECHgetRule     "esd_pc_n_outerRingTapWidth"))
;;;   (wellTapSpace        (TECHgetRule     "esd_pc_n_wellTapSpace"))
;;;   (layer2EncVia1       (TECHgetRule     "esd_pc_n_layer2EncVia1"))
;;;   (via2Width           (TECHgetRule     "esd_pc_n_via2Width"))
;;;   (via2Space           (TECHgetRule     "esd_pc_n_via2Space"))
;;;   (via1Via2Space       (TECHgetRule     "esd_pc_n_via1Via2Space"))
;;;   (layer2EncVia2       (TECHgetRule     "esd_pc_n_layer2EncVia2"))
;;;   (layer2Width         (TECHgetRule     "esd_pc_n_layer2Width"))
;;;   (layer3EncVia2       (TECHgetRule     "esd_pc_n_layer3EncVia2"))
;;;   (layer3Width         (TECHgetRule     "esd_pc_n_layer3Width"))
;;;   (innerRingMetalWidth (TECHgetRule     "esd_pc_n_innerRingMetalWidth"))
;;;   (irLayer3EncVia2     (TECHgetRule     "esd_pc_n_irLayer3EncVia2"))
;;;   (orLayer3Width       (TECHgetRule     "esd_pc_n_orLayer3Width"))
;;;   (minW                (TECHgetRule     "esd_pc_n_minW"))
;;;   (maxW                (TECHgetRule     "esd_pc_n_maxW"))
;;;   (minTotalW           (TECHgetRule     "esd_pc_n_minTotalW"))
;;;   (genericRingName     "genDLring")
;;;   (rivetedRingName     "genRivetMirrorDLring")
;;;   (flaredGateName      "flareGate")
;;;   (diffGrid            (TECHgetLayerProp "diff"   'snapGrid))
;;;   (tapGrid             (TECHgetLayerProp "tap"    'snapGrid))
;;;   (wellGrid            (TECHgetLayerProp "nwell"  'snapGrid))
;;;   (polyGrid            (TECHgetLayerProp "poly"   'snapGrid))
;;;   (via1grid            (TECHgetLayerProp "licon1" 'snapGrid))
;;;   (layer2grid          (TECHgetLayerProp "li1"    'snapGrid))
;;;   (via2grid            (TECHgetLayerProp "mcon"   'snapGrid))
;;;   (layer3grid          (TECHgetLayerProp "met1"   'snapGrid))
;;;   (tapEdgesAt45        nil)
;;;   (layer2EdgesAt45     nil)
;;;   (layer3EdgesAt45     t)
;;;  )
;;;  ;; formal parameters
;;;  (
;;;   ;; There are rigorous constraints on the valid w.  Here
;;;   ;; is how it is calculated:
;;;   ;; (w (plus viaExtDiff viaExtDiff -flareYamount -flareYamount (times 11.0 licon1_pitch) -licon1_space))
;;;   (w                     40.310)
;;;   (l                      (TECHgetRule "hpoly_2") )
;;;   (m                     10)
;;;   (extraLeftSpace         0.000)
;;;   (extraRightSpace        0.000)
;;;   (shrinkPercent          0.000)
;;;   (extraSrcSpace          0.000)
;;;   (extraDrnSpace          0.000)
;;;   (fullyStrap                 t)
;;;   (drnViaYspaceRingViaTop 6.240)
;;;   (drnViaYspaceRingViaBot 6.240)
;;;   (orirLayer3Space    	   (TECHgetRule "esd_pc_n_orirLayer3Space"))
;;;   (viaExtDiffX            2.430)
;;;  )
;;;
;;;) ;;;end hvnEsdTran
;;;

 ;; ----------------------------------------------------------------------

  (eval 
   '(errset (progn 
	      (unless (rexMatchp "pipo" (getVersion))
	       (DLcreateCategories techGetCurrentTechFile()~>libName)
	       (DLcreateCDFs techGetCurrentTechFile()~>libName)
              )) t))

) ;; end devices



;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


;;; **********************************************************************
;;;                             Place & Route
;;; **********************************************************************
       (prRules
       
          (prRoutingLayers
           ;; ( layer  preferredDirection )
           (diff      "halfRoute") 
           (tap       "halfRoute") 
           (poly      "halfRoute") 
           (li1       "halfRoute")
           ( met1     "horizontal" )
           ( met2     "vertical" ) 	  
           ( met3     "horizontal" ) 
           ( met4     "vertical" ) 
           ( met5     "horizontal" ) 
           ) ; end prRoutingLayers
       
        (prViaTypes
         ;; the devices listed here must be defined above in the devices section
         ;; ( (device cellViewName) viaType )

	 ( (nDFL1_PR symbolic)      "default" )
	 ( (nTPL1_PR symbolic)      "default" )
	 ( (PYL1_PR  symbolic)      "default" )
         ( (L1M1_PR  symbolic)      "default" )
         ( (M1M2_PR  symbolic)      "default" )
         ( (M2M3_PR  symbolic)      "default" )
	 ( (M3M4_PR  symbolic)      "default" )
	 ( (M4M5_PR  symbolic)      "default" )
         ( (ruleVia  symbolic)      "NDR_dummy")
         ( (ruleVia1 symbolic)      "NDR_1_5")
         ( (ruleVia2 symbolic)      "NDR_1_5")
	 ( (ruleVia3 symbolic)      "NDR_1_5")
	 ( (ruleVia4 symbolic)      "NDR_1_5")
         ) ; end prViaTypes
        
        
        (prStackVias
         ;; ( via via2 via3 ...)
       ;  ( licon1 mcon )
         ( mcon via ) (mcon via2) (mcon via3) (mcon via4)
         ( via via2 ) (via via3) (via via4)
	 ( via2 via3) (via2 via4) 
         ( via3 via4)
         ( met1 met1 )
         ( met2 met2 )
         ( met3 met3 )
	 ( met4 met4 )
	 ( met5 met5 )
         ) ; end prStackVias
        
        
        (prMastersliceLayers
         ;; ( layer1 layer2 layer3 ... )
         ( diff tap poly li1 )
         ) ; end prMastersliceLayers
        
        
        (prViaRules
         ;; ( t_ruleName l_viaNames
         ;;     lt_layer1 t_direction1 (n_minWidth1 n_maxWidth1 n_overhang1)
         ;;     lt_layer2 t_direction2 (g_minWidth2 g_maxWidth2 g_overhang2 g_metalOverhang2)
         ;; ) ...
         
         ) ; end prViaRules
        
        (eval
         `(prGenViaRules
           ;; ( t_ruleName lt_layer
           ;;   ( l_lowerPt l_upperPt g_xPitch g_yPitch g_resistance )
           ;;  lt_layer1 t_dir1 (n_minWidth1 n_maxWidth1 n_overhang1 n_metalOverhang1)
           ;;  lt_layer2 t_dir2 (n_minWidth2 n_maxWidth2 n_overhang2 n_metalOverhang2)
           ;; ) ...
           
            ("viaGenVia" "via"
             ( ,(list (quotient (TECHgetRuleWith "minWidth" "via") -2.0)
       	       (quotient (TECHgetRuleWith "minWidth" "via") -2.0))
       	,(list (quotient (TECHgetRuleWith "minWidth" "via") 2.0)
       	       (quotient (TECHgetRuleWith "minWidth" "via") 2.0))
       	,(plus (TECHgetRuleWith "minWidth" "via")
       	       (TECHgetRuleWith "minSpacing" "via"))
       	,(plus (TECHgetRuleWith "minWidth" "via")
       	       (TECHgetRuleWith "minSpacing" "via"))
       	(TECHgetRule "rcvia")
             )
             "met1" "horizontal"
             (_NA_ _NA_ ,(TECHgetRuleWith "minEnclosure" "met1" "via")
             ,(TECHgetMetalOverhang "met1" "via" 1)
             )
             "met2" "vertical"
             (_NA_ _NA_ ,(TECHgetRuleWith "minEnclosure" "met2" "via")
             ,(TECHgetMetalOverhang "met2" "via" 1)
             )
            )
            ("viaGenVia2" "via2"
             ( ,(list (quotient (TECHgetRuleWith "minWidth" "via2") -2.0)
       	       (quotient (TECHgetRuleWith "minWidth" "via2") -2.0))
       	,(list (quotient (TECHgetRuleWith "minWidth" "via2") 2.0)
       	       (quotient (TECHgetRuleWith "minWidth" "via2") 2.0))
       	,(plus (TECHgetRuleWith "minWidth" "via2")
       	       (TECHgetRuleWith "minSpacing" "via2"))
       	,(plus (TECHgetRuleWith "minWidth" "via2")
       	       (TECHgetRuleWith "minSpacing" "via2"))
       	(TECHgetRule "rcvia2")
             )
             "met2" "vertical" 
             (_NA_ _NA_ ,(TECHgetRuleWith "minEnclosure" "met2" "via2")
             ,(TECHgetMetalOverhang "met2" "via2" 1)
             )
             "met3" "horizontal"
             (_NA_ _NA_ ,(TECHgetRuleWith "minEnclosure" "met3" "via2")
             ,(TECHgetMetalOverhang "met3" "via2" 1)
             )
            )
	    ("viaGenVia3" "via3"
             ( ,(list (quotient (TECHgetRuleWith "minWidth" "via3") -2.0)
       	       (quotient (TECHgetRuleWith "minWidth" "via3") -2.0))
       	,(list (quotient (TECHgetRuleWith "minWidth" "via3") 2.0)
       	       (quotient (TECHgetRuleWith "minWidth" "via3") 2.0))
       	,(plus (TECHgetRuleWith "minWidth" "via3")
       	       (TECHgetRuleWith "minSpacing" "via3"))
       	,(plus (TECHgetRuleWith "minWidth" "via3")
       	       (TECHgetRuleWith "minSpacing" "via3"))
       	(TECHgetRule "rcvia3")
             )
             "met3" "vertical" 
             (_NA_ _NA_ ,(TECHgetRuleWith "minEnclosure" "met3" "via3")
             ,(TECHgetMetalOverhang "met3" "via3" 1)
             )
             "met4" "horizontal"
             (_NA_ _NA_ ,(TECHgetRuleWith "minEnclosure" "met4" "via3")
             ,(TECHgetMetalOverhang "met4" "via3" 1)
             )
            )
        ("viaGenVia4" "via4"
             ( ,(list (quotient (TECHgetRuleWith "minWidth" "via4") -2.0)
       	       (quotient (TECHgetRuleWith "minWidth" "via4") -2.0))
       	,(list (quotient (TECHgetRuleWith "minWidth" "via4") 2.0)
       	       (quotient (TECHgetRuleWith "minWidth" "via4") 2.0))
       	,(plus (TECHgetRuleWith "minWidth"   "via4")
       	       (TECHgetRuleWith "minSpacing" "via4"))
       	,(plus (TECHgetRuleWith "minWidth"   "via4")
       	       (TECHgetRuleWith "minSpacing" "via4"))
       	(TECHgetRule "rcvia4")
             )
             "met4" "vertical" 
             (_NA_ _NA_ ,(TECHgetRuleWith "minEnclosure" "met4" "via4")
             ,(TECHgetMetalOverhang "met4" "via4" 1)
             )
             "met5" "horizontal"
             (_NA_ _NA_ ,(TECHgetRuleWith "minEnclosure" "met5" "via4")
             ,(TECHgetMetalOverhang "met5" "via4" 1)
             )
            )

          ) ; end prGenViaRules
        ) ; end eval around prGenViaRules
        
        
        (prTurnViaRules
         ;; ( t_ruleName lt_viaLayer l_directions ) ...
         ( "met1turn"    "met1"      ("vertical" "horizontal") )
         ( "met2turn"    "met2"      ("vertical" "horizontal") )
         ( "met3turn"    "met3"      ("vertical" "horizontal") )
         ( "met4turn"    "met4"      ("vertical" "horizontal") )
         ( "met5turn"    "met5"      ("vertical" "horizontal") )
       
         
           ) ; end prTurnViaRules
        
         
       (eval
         `(prNonDefaultRules
         ;; This is for the rules for vias that are not of type "default" 
         ;; as defined in the  prViaTypes section
         ;;
         ;; ( t_ruleName
         ;;    ( ( lt_layer g_width g_spacing [g_notch]) ... )
         ;;    ( ( t_viaName [g_resistance] ) ... )
         ;;    [ ( ( lt_layer1 lt_layer2 n_minSpace g_stack) ... )]
         ;;   ...
         ;; )
       
           ( "NDR_1_5"
            ,(TECHgetNDR_prRules 1.5 
                 (list 'met1 (TECHgetRule "m1_3_x") (TECHgetRule "m1_3a"))
                 (list 'met2 (TECHgetRule "m2_3_x") (TECHgetRule "m2_3a"))
                 (list 'met3 (TECHgetRule "m3_3_x") (TECHgetRule "m3_3c"))
		 (list 'met4 (TECHgetRule "m4_1") (TECHgetRule "m4_2"))
		 (list 'met5 (TECHgetRule "m5_1") (TECHgetRule "m5_2"))
       	  )
            ( ruleVia1 ruleVia2 ruleVia3 )
           )
           ( "NDR_2"
            ,(TECHgetNDR_prRules 2 
                 (list 'met1 (TECHgetRule "m1_3_x") (TECHgetRule "m1_3a"))
                 (list 'met2 (TECHgetRule "m2_3_x") (TECHgetRule "m2_3a"))
                 (list 'met3 (TECHgetRule "m3_3_x") (TECHgetRule "m3_3c"))
		 (list 'met4 (TECHgetRule "m4_1") (TECHgetRule "m4_2"))
		 (list 'met5 (TECHgetRule "m5_1") (TECHgetRule "m5_2"))
       	  )
            ( ruleVia1 ruleVia2 ruleVia3 )
           )
           ( "NDR_2_5"
            ,(TECHgetNDR_prRules 2.5 
                 (list 'met1 (TECHgetRule "m1_3_x") (TECHgetRule "m1_3a"))
                 (list 'met2 (TECHgetRule "m2_3_x") (TECHgetRule "m2_3a"))
                 (list 'met3 (TECHgetRule "m3_3_x") (TECHgetRule "m3_3c"))
		 (list 'met4 (TECHgetRule "m4_1") (TECHgetRule "m4_2"))
		 (list 'met5 (TECHgetRule "m5_1") (TECHgetRule "m5_2"))
       	  )
            ( ruleVia1 ruleVia2 ruleVia3 )
           )
           ( "NDR_3"
            ,(TECHgetNDR_prRules 3
                 (list 'met1 (TECHgetRule "m1_3_x") (TECHgetRule "m1_3a"))
                 (list 'met2 (TECHgetRule "m2_3_x") (TECHgetRule "m2_3a"))
                 (list 'met3 (TECHgetRule "m3_3_x") (TECHgetRule "m3_3c"))
		 (list 'met4 (TECHgetRule "m4_1") (TECHgetRule "m4_2"))
		 (list 'met5 (TECHgetRule "m5_1") (TECHgetRule "m5_2"))
       	  )
            ( ruleVia1 ruleVia2 ruleVia3  ruleVia4)
           )
          )
        )
         
        (eval
         `(prRoutingPitch
           ;; ( lt_layer n_pitch ) ...
           ( "met1" ,(TECHgetRoutingPitchL2V "met1" "mcon" "via"))
           ( "met2" ,(TECHgetRoutingPitchL2V "met2" "via" "via2"))
           ( "met3" ,(TECHgetRoutingPitchL2V "met3" "via2" "via3"))
	   ( "met4" ,(TECHgetRoutingPitchL2V "met4" "via3"))
	   ( "met5" ,(TECHgetRoutingPitchL2V "met5" "via4"))

          ) ; end prRoutingPitch
         ) ; end eval
       
       
       
        
        ;; The routing offset is half of the routing pitch
        (prRoutingOffset
         ;; ( lt_layer n_offset ) ...
       
         ;; DEFINED in tech.il
       
         ) ; end prRoutingOffset
        
        
        (prOverlapLayer
         ;; t_layer ...
           (overlap)
         ) ; end prOverlapLayer
        
        ) ; end prRules
;;;       
;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


;;; **********************************************************************
;;;                             controls
;;; **********************************************************************
(controls

 ;; ----------------------------------------------------------------------
 (eval 
  `(techParams 
   
   (TECHtechnology ,(TECHgetProp technology))
   (TECHtdrSpecNum ,(TECHgetProp tdrSpecNum))
   (TECHtdrSpecRev ,(TECHgetProp tdrSpecRev))
   (TECHbondPadStressSpecNum ,(TECHgetProp bondPadStressSpecNum))
   (TECHbondPadStressSpecRev ,(TECHgetProp bondPadStressSpecRev))
   (TECHmiscTdrSpecNum ,(TECHgetProp miscTdrSpecNum))
   (TECHmiscTdrSpecRev ,(TECHgetProp miscTdrSpecRev))
   (TECHcompileTime ,(getCurrentTime))
   (TECHcompileTimeUTC ,(stringToTime (getCurrentTime)))
 
    
    ;; cctRules
    (iccLayers 
     ((("nwell" "drawing") "n_well" "off"
       ,(TECHgetRuleWith "minWidth"   "nwell" )
       ,(TECHgetRuleWith "minSpacing" "nwell" )
       nil nil
       ) 
      (("diff" "drawing") "n_diffusion" "off"
       ,(TECHgetRuleWith "minWidth"   "diff" )
       ,(TECHgetRuleWith "minSpacing" "diff" )
       nil nil
       ) 
      (("tap" "drawing") "n_diffusion" "off"
       ,(TECHgetRuleWith "minWidth"   "tap" )
       ,(TECHgetRuleWith "minSpacing" "tap" )
       nil nil
       ) 
      (("poly" "drawing") "polysilicon" "orthogonal" 
       ,(TECHgetRuleWith "minWidth"   "poly" )
       ,(TECHgetRuleWith "minSpacing" "poly" )
       nil t
       ) 
      (("licon1" "drawing") "cut" "off"
       ,(TECHgetRuleWith "minWidth"   "licon1" )
       ,(TECHgetRuleWith "minSpacing" "licon1" )
       nil t
       ) 
      (("li1" "drawing") "metal" "orthogonal"
       ,(TECHgetRuleWith "minWidth"   "li1" )
       ,(TECHgetRuleWith "minSpacing" "li1" )
       nil t
       ) 
      (("mcon" "drawing") "cut" "off"
       ,(TECHgetRuleWith "minWidth"   "mcon" )
       ,(TECHgetRuleWith "minSpacing" "mcon" )
       nil t
       ) 
      (("met1" "drawing") "metal" "orthogonal"
       ,(TECHgetRuleWith "minWidth"   "met1" )
       ,(TECHgetRuleWith "minSpacing" "met1" )
       nil t
       ) 
      (("via" "drawing") "cut" "off"
       ,(TECHgetRuleWith "minWidth"   "via" )
       ,(TECHgetRuleWith "minSpacing" "via" )
       nil t
       ) 
      (("met2" "drawing") "metal" "orthogonal"
       ,(TECHgetRuleWith "minWidth"   "met2" )
       ,(TECHgetRuleWith "minSpacing" "met2" )
       nil t
       )

      (("via2" "drawing") "cut" "off"
       ,(TECHgetRuleWith "minWidth"   "via2" )
       ,(TECHgetRuleWith "minSpacing" "via2" )
       nil t
       ) 	       

      (("met3" "drawing") "metal" "orthogonal"
       ,(TECHgetRuleWith "minWidth"   "met3" )
       ,(TECHgetRuleWith "minSpacing" "met3" )
       nil t
       )

      (("via3" "drawing") "cut" "off"
       ,(TECHgetRuleWith "minWidth"   "via3" )
       ,(TECHgetRuleWith "minSpacing" "via3" )
       nil t
       ) 	       

      (("met4" "drawing") "metal" "orthogonal"
       ,(TECHgetRuleWith "minWidth"   "met4" )
       ,(TECHgetRuleWith "minSpacing" "met4" )
       nil t
       )
      (("via4" "drawing") "cut" "off"
       ,(TECHgetRuleWith "minWidth"   "via4" )
       ,(TECHgetRuleWith "minSpacing" "via4" )
       nil t
       ) 	       

      (("met5" "drawing") "metal" "orthogonal"
       ,(TECHgetRuleWith "minWidth"   "met5" )
       ,(TECHgetRuleWith "minSpacing" "met5" )
       nil t
       )

      )
     
     ) ; end iccLayers
    
    (iccVias 
     (
      (( ,techGetCurrentTechFile()~>libName "L1M1_C" "symbolic") t)
      (( ,techGetCurrentTechFile()~>libName "M1M2_C" "symbolic") t) 
      (( ,techGetCurrentTechFile()~>libName "PYL1_C" "symbolic") t)
      (( ,techGetCurrentTechFile()~>libName "M2M3_C" "symbolic") t)
      (( ,techGetCurrentTechFile()~>libName "M3M4_C" "symbolic") t)
      (( ,techGetCurrentTechFile()~>libName "M4M5_C" "symbolic") t)
      
      )
     ) ; end iccVias
    
    (iccEquivalentLayers 
     (
      (("diff" "drawing") 
       ("diff" "pin")
       ) 
      (("poly" "drawing") 
       ("poly" "pin")
       ) 
      (("li1" "drawing") 
       ("li1" "pin")
       ) 
      (("met1" "drawing") 
       ("met1" "pin")
       ("met1" "net")
       ) 
      (("met2" "drawing") 
       ("met2" "pin")
       ("met2" "net")
       )
      (("met3" "drawing") 
       ("met3" "pin")
       ("met3" "net")
       )
      (("met4" "drawing") 
       ("met4" "pin")
       ("met4" "net")
       )
      (("met5" "drawing") 
       ("met5" "pin")
       ("met5" "net")
       )
      )
     ) ; end iccEquivalentLayers
    
    (iccBoundaryLayers 
     ((("nwell" "drawing") 
       ("prBoundary" "drawing") 0.0
       ) 
      (("diff" "drawing") 
       ("prBoundary" "drawing") 0.0
       ) 
      (("tap" "drawing") 
       ("prBoundary" "drawing") 0.0
       ) 
      (("poly" "drawing") 
       ("prBoundary" "drawing") 0.0
       ) 
      (("licon1" "drawing") 
       ("prBoundary" "drawing") 0.0
       )
      (("li1" "drawing") 
       ("prBoundary" "drawing") 0.0
       ) 
      (("mcon" "drawing") 
       ("prBoundary" "drawing") 0.0
       ) 
      (("met1" "drawing") 
       ("prBoundary" "drawing") 0.0
       ) 
      (("via" "drawing") 
       ("prBoundary" "drawing") 0.0
       ) 
      (("met2" "drawing") 
       ("prBoundary" "drawing") 0.0
       )
      (("via2" "drawing") 
       ("prBoundary" "drawing") 0.0
       ) 
      (("met3" "drawing") 
       ("prBoundary" "drawing") 0.0
       )
      (("via3" "drawing") 
       ("prBoundary" "drawing") 0.0
       ) 
      (("met4" "drawing") 
       ("prBoundary" "drawing") 0.0
       )
      (("met5" "drawing") 
       ("prBoundary" "drawing") 0.0
       )
      )
      ) ; end iccBoundaryLayers
    
    (iccKeepouts 
     ((nil 
       (("size" 
	 (("target" "drawing") ,(TECHgetRule "mf_m2_1"))
	 "fuseRegion" 
	 "routing" t
	 ) 
	("or" 
	 (("diff" "drawing") ("tap" "drawing"))
	 "tempfom" 
	 "routing" t
	 ) 
	("size" 
	 ("tempfom" 
	  ,(difference (TECHgetRuleWith "minSpacing" "poly" "diff")
		       (TECHgetRuleWith "minSpacing" "poly"))
	  )
	 ("poly" "drawing") 
	 "routing" t
	 ) 
	("c-not" 
	 (("poly" "drawing") "tempfom") 
	 ("poly" "drawing") 
	 "routing" t
	 ) 
	("c-not" 
	 (("poly" "drawing") ("poly" "res")) 
	 ("poly" "drawing") 
	 "routing" t
	 )
	("=>" 
	 ("fuseRegion") 
	 ("poly" "drawing") "routing" t
	 ) 
	("c-not" 
	 (("li1" "drawing") 
	  ("li1" "res")
	  ) 
	 ("li1" "drawing") "routing" t
	 ) 
	("=>" 
	 ("fuseRegion") 
	 ("li1" "drawing") "routing" t
	 ) 
	("c-not" 
	 (("met1" "drawing") 
	  ("met1" "res")
	  ) 
	 ("met1" "drawing") "routing" t
	 ) 
	("c-not" 
	 (("met1" "drawing") 
	  ("met1" "short")
	  ) 
	 ("met1" "drawing") "routing" t
	 )
	("=>" 
	 (("met1" "option1")) 
	 ("met1" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met1" "option2")) 
	 ("met1" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met1" "option3")) 
	 ("met1" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met1" "option4")) 
	 ("met1" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met1" "option5")) 
	 ("met1" "drawing") "routing" t
	 )
	("=>" 
	 (("met1" "option6")) 
	 ("met1" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met1" "option7")) 
	 ("met1" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met1" "option8")) 
	 ("met1" "drawing") "routing" t
	 ) 
	("=>" 
	 ("fuseRegion") 
	 ("met1" "drawing") "routing" t
	 ) 
	("c-not" 
	 (("met2" "drawing") 
	  ("met2" "res")
	  ) 
	 ("met2" "drawing") "routing" t
	 )
	("c-not" 
	 (("met2" "drawing") 
	  ("met2" "short")
	  ) 
	 ("met2" "drawing") "routing" t
	 ) 
	("c-not" 
	 (("met2" "drawing") 
	  ("met2" "fuse")
	  ) 
	 ("met2" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met2" "option1")) 
	 ("met2" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met2" "option2")) 
	 ("met2" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met2" "option3")) 
	 ("met2" "drawing") "routing" t
	 )
	("=>" 
	 (("met2" "option4")) 
	 ("met2" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met2" "option5")) 
	 ("met2" "drawing") "routing" t
	) 
	("=>" 
	 (("met2" "option6")) 
	 ("met2" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met2" "option7")) 
	 ("met2" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met2" "option8")) 
	 ("met2" "drawing") "routing" t
	)
	("=>" 
	 ("fuseRegion") 
	 ("met2" "drawing") "routing" t
	 )
	("c-not" 
	 (("met3" "drawing") 
	  ("met3" "res")
	  ) 
	 ("met3" "drawing") "routing" t
	 )
	("c-not" 
	 (("met3" "drawing") 
	  ("met3" "short")
	  ) 
	 ("met3" "drawing") "routing" t
	 ) 
	("c-not" 
	 (("met3" "drawing") 
	  ("met3" "fuse")
	  ) 
	 ("met3" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met3" "option1")) 
	 ("met3" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met3" "option2")) 
	 ("met3" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met3" "option3")) 
	 ("met3" "drawing") "routing" t
	 )
	("=>" 
	 (("met3" "option4")) 
	 ("met3" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met3" "option5")) 
	 ("met3" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met3" "option6")) 
	 ("met3" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met3" "option7")) 
	 ("met3" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met3" "option8")) 
	 ("met3" "drawing") "routing" t
	 )
	("=>" 
	 ("fuseRegion") 
	 ("met3" "drawing") "routing" t
	 )
	("c-not" 
	 (("met4" "drawing") 
	  ("met4" "res")
	  ) 
	 ("met4" "drawing") "routing" t
	 )
	("c-not" 
	 (("met4" "drawing") 
	  ("met4" "short")
	  ) 
	 ("met4" "drawing") "routing" t
	 ) 
	("c-not" 
	 (("met4" "drawing") 
	  ("met4" "fuse")
	  ) 
	 ("met4" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met4" "option1")) 
	 ("met4" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met4" "option2")) 
	 ("met4" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met4" "option3")) 
	 ("met4" "drawing") "routing" t
	 )
	("=>" 
	 (("met4" "option4")) 
	 ("met4" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met4" "option5")) 
	 ("met4" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met4" "option6")) 
	 ("met4" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met4" "option7")) 
	 ("met4" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met4" "option8")) 
	 ("met4" "drawing") "routing" t
	 )
	("=>" 
	 ("fuseRegion") 
	 ("met4" "drawing") "routing" t
	 )
      	("c-not" 
	 (("met5" "drawing") 
	  ("met5" "res")
	  ) 
	 ("met5" "drawing") "routing" t
	 )
	("c-not" 
	 (("met5" "drawing") 
	  ("met5" "short")
	  ) 
	 ("met5" "drawing") "routing" t
	 ) 
	("c-not" 
	 (("met5" "drawing") 
	  ("met5" "fuse")
	  ) 
	 ("met5" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met5" "option1")) 
	 ("met5" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met5" "option2")) 
	 ("met5" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met5" "option3")) 
	 ("met5" "drawing") "routing" t
	 )
	("=>" 
	 (("met5" "option4")) 
	 ("met5" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met5" "option5")) 
	 ("met5" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met5" "option6")) 
	 ("met5" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met5" "option7")) 
	 ("met5" "drawing") "routing" t
	 ) 
	("=>" 
	 (("met5" "option8")) 
	 ("met5" "drawing") "routing" t
	 )
	("=>" 
	 ("fuseRegion") 
	 ("met5" "drawing") "routing" t
	 )
	);;
       )
      )
     ) ; end iccKeepouts
    
    ) ; end techParams
  ) ; end eval
 
 ) ; end controls

